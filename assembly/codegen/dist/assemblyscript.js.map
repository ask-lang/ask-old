{"version":3,"sources":["webpack://assemblyscript/webpack/universalModuleDefinition","webpack://assemblyscript/./node_modules/long/src/long.js","webpack://assemblyscript/./src/ast.ts","webpack://assemblyscript/./src/builtins.ts","webpack://assemblyscript/./src/common.ts","webpack://assemblyscript/./src/compiler.ts","webpack://assemblyscript/./src/definitions.ts","webpack://assemblyscript/./src/diagnosticMessages.generated.ts","webpack://assemblyscript/./src/diagnostics.ts","webpack://assemblyscript/./src/ext/analyzer.ts","webpack://assemblyscript/./src/ext/collectionutil.ts","webpack://assemblyscript/./src/ext/contract.ts","webpack://assemblyscript/./src/ext/contract/base.ts","webpack://assemblyscript/./src/ext/contract/storage.ts","webpack://assemblyscript/./src/ext/interperter.ts","webpack://assemblyscript/./src/ext/primitiveutil.ts","webpack://assemblyscript/./src/ext/utils.ts","webpack://assemblyscript/./src/extra/ast.ts","webpack://assemblyscript/./src/flow.ts","webpack://assemblyscript/./src/glue/js/index.ts","webpack://assemblyscript/./src/index.ts","webpack://assemblyscript/./src/module.ts","webpack://assemblyscript/./src/parser.ts","webpack://assemblyscript/./src/program.ts","webpack://assemblyscript/./src/resolver.ts","webpack://assemblyscript/./src/tokenizer.ts","webpack://assemblyscript/./src/types.ts","webpack://assemblyscript/./src/util/binary.ts","webpack://assemblyscript/./src/util/collections.ts","webpack://assemblyscript/./src/util/index.ts","webpack://assemblyscript/./src/util/math.ts","webpack://assemblyscript/./src/util/path.ts","webpack://assemblyscript/./src/util/text.ts","webpack://assemblyscript/./src/util/vector.ts","webpack://assemblyscript/./std/assembly/shared/feature.ts","webpack://assemblyscript/./std/assembly/shared/target.ts","webpack://assemblyscript/./std/assembly/shared/typeinfo.ts","webpack://assemblyscript/./src/glue/binaryen.js","webpack://assemblyscript/./src/glue/js/collections.js","webpack://assemblyscript/./src/glue/js/float.js","webpack://assemblyscript/./src/glue/js/i64.js","webpack://assemblyscript/./std/portable/index.js","webpack://assemblyscript/external \"binaryen\"","webpack://assemblyscript/webpack/bootstrap","webpack://assemblyscript/webpack/startup","webpack://assemblyscript/webpack/runtime/global"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__911__","Long","wasm","WebAssembly","Instance","Module","Uint8Array","e","low","high","unsigned","isLong","obj","prototype","__isLong__","Object","defineProperty","value","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","Math","pow","fromString","str","radix","length","Error","RangeError","p","indexOf","substring","radixToPower","result","i","size","min","parseInt","power","mul","add","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","toNumber","toString","isZero","isNegative","eq","radixLong","div","rem1","sub","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","equals","other","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","get_high","b00","divide","divisor","approx","res","div_u","div_s","toUnsigned","shru","shr","shl","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","rem_u","rem_s","mod","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","toSigned","toBytes","toBytesLE","toBytesBE","hi","lo","fromBytes","bytes","fromBytesLE","fromBytesBE","NodeKind","DecoratorKind","LiteralKind","SourceKind","Node","kind","range","name","TypeName","createIdentifierExpression","typeArguments","isNullable","NamedTypeNode","parameters","returnType","explicitThisType","FunctionTypeNode","createSimpleTypeName","extendsType","defaultType","TypeParameterNode","parameterKind","type","initializer","ParameterNode","args","DecoratorNode","fromNode","commentKind","text","CommentNode","isQuoted","IdentifierExpression","elementExpressions","ArrayLiteralExpression","assertionKind","expression","toType","AssertionExpression","operator","left","right","BinaryExpression","CallExpression","declaration","ClassExpression","expressions","CommaExpression","ConstructorExpression","elementExpression","ElementAccessExpression","FalseExpression","FloatLiteralExpression","FunctionExpression","isType","InstanceOfExpression","IntegerLiteralExpression","typeName","NewExpression","NullExpression","names","values","ObjectLiteralExpression","OmittedExpression","ParenthesizedExpression","property","PropertyAccessExpression","pattern","patternFlags","RegexpLiteralExpression","condition","ifThen","ifElse","TernaryExpression","StringLiteralExpression","SuperExpression","ThisExpression","TrueExpression","operand","UnaryPostfixExpression","UnaryPrefixExpression","statements","BlockStatement","label","BreakStatement","decorators","flags","typeParameters","implementsTypes","members","ClassDeclaration","ContinueStatement","statement","DoStatement","EmptyStatement","EnumDeclaration","EnumValueDeclaration","path","isDeclare","ExportStatement","ExportDefaultStatement","externalName","ExportImportStatement","localName","exportedName","ExportMember","ExpressionStatement","ifTrue","ifFalse","IfStatement","declarations","ImportStatement","namespaceName","foreignName","ImportDeclaration","InterfaceDeclaration","FieldDeclaration","incrementor","ForStatement","variable","iterable","ForOfStatement","signature","body","arrowKind","FunctionDeclaration","keyType","valueType","IndexSignatureNode","MethodDeclaration","NamespaceDeclaration","ReturnStatement","cases","SwitchStatement","SwitchCase","ThrowStatement","catchVariable","catchStatements","finallyStatements","TryStatement","TypeDeclaration","VariableStatement","VariableDeclaration","VoidStatement","WhileStatement","literalKind","LITERAL","changetype","FLOAT","INTEGER","STRING","NULL","TRUE","FALSE","node","CALL","PROPERTYACCESS","isAccessOn","THIS","SUPER","TypeNode","super","typeParameterNodes","NAMEDTYPE","namedTypeNode","next","typeArgumentNodes","k","hasGenericComponent","identifier","FUNCTIONTYPE","functionTypeNode","parameterNodes","assert","TYPENAME","TYPEPARAMETER","ParameterKind","PARAMETER","implicitFieldDeclaration","CommonFlags","NONE","flag","nameNode","IDENTIFIER","nameStr","charCodeAt","BUILTIN","CONTRACT","CONSTRUCTOR","DEPLOYER","EXTERNAL","FINAL","GLOBAL","INLINE","LAZY","MESSAGE","OPERATOR","STORAGE","UNMANAGED","UNSAFE","propertyAccessNode","propStr","OPERATOR_BINARY","OPERATOR_PREFIX","OPERATOR_POSTFIX","CUSTOM","decoratorKind","DECORATOR","CommentKind","COMMENT","Expression","LiteralExpression","ARRAY","AssertionKind","ASSERTION","BINARY","numTypeArguments","Range","join","numArguments","CLASS","COMMA","ELEMENTACCESS","FUNCTION","INSTANCEOF","NEW","OBJECT","OMITTED","PARENTHESIZED","REGEXP","TERNARY","UnaryExpression","UNARYPOSTFIX","UNARYPREFIX","Statement","sourceKind","normalizedPath","SOURCE","Array","debugInfoIndex","exportPaths","lineCache","lineColumn","internalPath","mangleInternalPath","pos","lastIndexOf","PATH_DELIMITER","simplePath","source","LIBRARY_SUBST","LIBRARY","LIBRARY_ENTRY","off","end","push","l","r","m","s","unchecked","DeclarationStatement","INDEXSIGNATURE","VariableLikeDeclarationStatement","BLOCK","BREAK","CLASSDECLARATION","indexSignature","CONTINUE","DO","EMPTY","ENUMDECLARATION","ENUMVALUEDECLARATION","EXPORTIMPORT","EXPORTMEMBER","EXPORT","normalizePath","startsWith","resolvePath","LIBRARY_PREFIX","EXPORTDEFAULT","EXPRESSION","parameterIndex","FIELDDECLARATION","FOR","FOROF","ArrowKind","FUNCTIONDECLARATION","IF","IMPORTDECLARATION","IMPORT","INTERFACEDECLARATION","METHODDECLARATION","NAMESPACEDECLARATION","RETURN","SWITCHCASE","SWITCH","THROW","TRY","TYPEDECLARATION","VARIABLEDECLARATION","VARIABLE","VOID","WHILE","len","cur","isTrivialAlphanum","decorator","BuiltinNames","start","started","argumentsLength","setArgumentsLength","abort","trace","seed","isInteger","isFloat","isBoolean","isSigned","isReference","isString","isArray","isArrayLike","isFunction","isDefined","isConstant","isManaged","isVoid","clz","ctz","popcnt","rotl","rotr","abs","copysign","nearest","reinterpret","sqrt","trunc","load","store","atomic_load","atomic_store","atomic_add","atomic_sub","atomic_and","atomic_or","atomic_xor","atomic_xchg","atomic_cmpxchg","atomic_wait","atomic_notify","atomic_fence","sizeof","alignof","offsetof","nameof","lengthof","select","unreachable","call_indirect","instantiate","idof","i8","i16","i32","i64","isize","u8","u16","u32","u64","usize","bool","f32","f64","v128","i32_clz","i64_clz","i32_ctz","i64_ctz","i32_popcnt","i64_popcnt","i32_rotl","i64_rotl","i32_rotr","i64_rotr","f32_abs","f64_abs","f32_max","f64_max","f32_min","f64_min","f32_ceil","f64_ceil","f32_floor","f64_floor","f32_copysign","f64_copysign","f32_nearest","f64_nearest","i32_reinterpret_f32","i64_reinterpret_f64","f32_reinterpret_i32","f64_reinterpret_i64","f32_sqrt","f64_sqrt","f32_trunc","f64_trunc","i32_add","i64_add","f32_add","f64_add","i32_sub","i64_sub","f32_sub","f64_sub","i32_mul","i64_mul","f32_mul","f64_mul","i32_div_s","i32_div_u","i64_div_s","i64_div_u","f32_div","f64_div","i32_load8_s","i32_load8_u","i32_load16_s","i32_load16_u","i32_load","i64_load8_s","i64_load8_u","i64_load16_s","i64_load16_u","i64_load32_s","i64_load32_u","i64_load","f32_load","f64_load","i32_store8","i32_store16","i32_store","i64_store8","i64_store16","i64_store32","i64_store","f32_store","f64_store","i32_atomic_load8_u","i32_atomic_load16_u","i32_atomic_load","i64_atomic_load8_u","i64_atomic_load16_u","i64_atomic_load32_u","i64_atomic_load","i32_atomic_store8","i32_atomic_store16","i32_atomic_store","i64_atomic_store8","i64_atomic_store16","i64_atomic_store32","i64_atomic_store","i32_atomic_rmw8_add_u","i32_atomic_rmw16_add_u","i32_atomic_rmw_add","i64_atomic_rmw8_add_u","i64_atomic_rmw16_add_u","i64_atomic_rmw32_add_u","i64_atomic_rmw_add","i32_atomic_rmw8_sub_u","i32_atomic_rmw16_sub_u","i32_atomic_rmw_sub","i64_atomic_rmw8_sub_u","i64_atomic_rmw16_sub_u","i64_atomic_rmw32_sub_u","i64_atomic_rmw_sub","i32_atomic_rmw8_and_u","i32_atomic_rmw16_and_u","i32_atomic_rmw_and","i64_atomic_rmw8_and_u","i64_atomic_rmw16_and_u","i64_atomic_rmw32_and_u","i64_atomic_rmw_and","i32_atomic_rmw8_or_u","i32_atomic_rmw16_or_u","i32_atomic_rmw_or","i64_atomic_rmw8_or_u","i64_atomic_rmw16_or_u","i64_atomic_rmw32_or_u","i64_atomic_rmw_or","i32_atomic_rmw8_xor_u","i32_atomic_rmw16_xor_u","i32_atomic_rmw_xor","i64_atomic_rmw8_xor_u","i64_atomic_rmw16_xor_u","i64_atomic_rmw32_xor_u","i64_atomic_rmw_xor","i32_atomic_rmw8_xchg_u","i32_atomic_rmw16_xchg_u","i32_atomic_rmw_xchg","i64_atomic_rmw8_xchg_u","i64_atomic_rmw16_xchg_u","i64_atomic_rmw32_xchg_u","i64_atomic_rmw_xchg","i32_atomic_rmw8_cmpxchg_u","i32_atomic_rmw16_cmpxchg_u","i32_atomic_rmw_cmpxchg","i64_atomic_rmw8_cmpxchg_u","i64_atomic_rmw16_cmpxchg_u","i64_atomic_rmw32_cmpxchg_u","i64_atomic_rmw_cmpxchg","i32_wait","i64_wait","v128_splat","v128_extract_lane","v128_replace_lane","v128_shuffle","v128_swizzle","v128_load_splat","v128_load_ext","v128_load","v128_store","v128_add","v128_sub","v128_mul","v128_div","v128_neg","v128_add_saturate","v128_sub_saturate","v128_shl","v128_shr","v128_and","v128_or","v128_xor","v128_andnot","v128_not","v128_bitselect","v128_any_true","v128_all_true","v128_bitmask","v128_min","v128_max","v128_pmin","v128_pmax","v128_dot","v128_avgr","v128_abs","v128_sqrt","v128_ceil","v128_floor","v128_trunc","v128_nearest","v128_eq","v128_ne","v128_lt","v128_le","v128_gt","v128_ge","v128_convert","v128_trunc_sat","v128_narrow","v128_widen_low","v128_widen_high","v128_qfma","v128_qfms","i8x16","i16x8","i32x4","i64x2","f32x4","f64x2","i8x16_splat","i8x16_extract_lane_s","i8x16_extract_lane_u","i8x16_replace_lane","i8x16_add","i8x16_sub","i8x16_mul","i8x16_min_s","i8x16_min_u","i8x16_max_s","i8x16_max_u","i8x16_avgr_u","i8x16_abs","i8x16_neg","i8x16_add_saturate_s","i8x16_add_saturate_u","i8x16_sub_saturate_s","i8x16_sub_saturate_u","i8x16_shl","i8x16_shr_s","i8x16_shr_u","i8x16_any_true","i8x16_all_true","i8x16_bitmask","i8x16_eq","i8x16_ne","i8x16_lt_s","i8x16_lt_u","i8x16_le_s","i8x16_le_u","i8x16_gt_s","i8x16_gt_u","i8x16_ge_s","i8x16_ge_u","i8x16_narrow_i16x8_s","i8x16_narrow_i16x8_u","i16x8_splat","i16x8_extract_lane_s","i16x8_extract_lane_u","i16x8_replace_lane","i16x8_add","i16x8_sub","i16x8_mul","i16x8_min_s","i16x8_min_u","i16x8_max_s","i16x8_max_u","i16x8_avgr_u","i16x8_abs","i16x8_neg","i16x8_add_saturate_s","i16x8_add_saturate_u","i16x8_sub_saturate_s","i16x8_sub_saturate_u","i16x8_shl","i16x8_shr_s","i16x8_shr_u","i16x8_any_true","i16x8_all_true","i16x8_bitmask","i16x8_eq","i16x8_ne","i16x8_lt_s","i16x8_lt_u","i16x8_le_s","i16x8_le_u","i16x8_gt_s","i16x8_gt_u","i16x8_ge_s","i16x8_ge_u","i16x8_narrow_i32x4_s","i16x8_narrow_i32x4_u","i16x8_widen_low_i8x16_s","i16x8_widen_low_i8x16_u","i16x8_widen_high_i8x16_s","i16x8_widen_high_i8x16_u","i16x8_load8x8_s","i16x8_load8x8_u","i32x4_splat","i32x4_extract_lane","i32x4_replace_lane","i32x4_add","i32x4_sub","i32x4_mul","i32x4_min_s","i32x4_min_u","i32x4_max_s","i32x4_max_u","i32x4_dot_i16x8_s","i32x4_abs","i32x4_neg","i32x4_shl","i32x4_shr_s","i32x4_shr_u","i32x4_any_true","i32x4_all_true","i32x4_bitmask","i32x4_eq","i32x4_ne","i32x4_lt_s","i32x4_lt_u","i32x4_le_s","i32x4_le_u","i32x4_gt_s","i32x4_gt_u","i32x4_ge_s","i32x4_ge_u","i32x4_trunc_sat_f32x4_s","i32x4_trunc_sat_f32x4_u","i32x4_widen_low_i16x8_s","i32x4_widen_low_i16x8_u","i32x4_widen_high_i16x8_s","i32x4_widen_high_i16x8_u","i32x4_load16x4_s","i32x4_load16x4_u","i64x2_splat","i64x2_extract_lane","i64x2_replace_lane","i64x2_add","i64x2_sub","i64x2_neg","i64x2_shl","i64x2_shr_s","i64x2_shr_u","i64x2_any_true","i64x2_all_true","i64x2_trunc_sat_f64x2_s","i64x2_trunc_sat_f64x2_u","i64x2_load32x2_s","i64x2_load32x2_u","f32x4_splat","f32x4_extract_lane","f32x4_replace_lane","f32x4_add","f32x4_sub","f32x4_mul","f32x4_div","f32x4_neg","f32x4_min","f32x4_max","f32x4_pmin","f32x4_pmax","f32x4_abs","f32x4_sqrt","f32x4_ceil","f32x4_floor","f32x4_trunc","f32x4_nearest","f32x4_eq","f32x4_ne","f32x4_lt","f32x4_le","f32x4_gt","f32x4_ge","f32x4_convert_i32x4_s","f32x4_convert_i32x4_u","f32x4_qfma","f32x4_qfms","f64x2_splat","f64x2_extract_lane","f64x2_replace_lane","f64x2_add","f64x2_sub","f64x2_mul","f64x2_div","f64x2_neg","f64x2_min","f64x2_max","f64x2_pmin","f64x2_pmax","f64x2_abs","f64x2_sqrt","f64x2_ceil","f64x2_floor","f64x2_trunc","f64x2_nearest","f64x2_eq","f64x2_ne","f64x2_lt","f64x2_le","f64x2_gt","f64x2_ge","f64x2_convert_i64x2_s","f64x2_convert_i64x2_u","f64x2_qfma","f64x2_qfms","v8x16_shuffle","v8x16_swizzle","v8x16_load_splat","v16x8_load_splat","v32x4_load_splat","v64x2_load_splat","heap_base","rtti_base","visit_globals","visit_members","isFinite","ERROR","WARNING","INFO","Function","memory_size","memory_grow","memory_copy","memory_fill","memory_data","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Int64Array","Uint64Array","Float32Array","Float64Array","wasiAbort","wasiTrace","wasiSeed","builtin_clz","ctx","compiler","checkTypeOptional","checkArgsRequired","arg0","compileExpression","operands","Type","currentType","isValue","unary","UnaryOp","ClzI32","options","isWasm64","ClzI64","error","DiagnosticCode","Operation_0_cannot_be_applied_to_type_1","reportNode","typeArgumentsRange","builtin_ctz","CtzI32","CtzI64","builtin_popcnt","PopcntI32","PopcntI64","builtin_rotl","arg1","flow","currentFlow","temp1","getTempLocal","findUsedLocals","setLocalFlag","index","LocalFlags","WRAPPED","temp2","ret","binary","BinaryOp","OrI32","ShlI32","local_tee","AndI32","ShrU32","local_get","NativeType","I32","SubI32","freeTempLocal","RotlI32","RotlI64","builtin_rotr","RotrI32","RotrI64","builtin_abs","auto","XorI32","AddI32","ShrI32","usizeType","XorI64","AddI64","ShrI64","nativeSizeType","I64","AbsF32","AbsF64","builtin_max","isNumericLiteral","op","GtI32","GtU32","GtI64","GtU64","MaxF32","MaxF64","nativeType","toNativeType","builtin_min","LtI32","LtU32","LtI64","LtU64","MinF32","MinF64","builtin_ceil","CeilF32","CeilF64","builtin_floor","FloorF32","FloorF64","builtin_copysign","CopysignF32","CopysignF64","builtin_nearest","NearestF32","NearestF64","builtin_reinterpret","checkTypeRequired","ReinterpretF32","ReinterpretF64","ReinterpretI32","ReinterpretI64","builtin_sqrt","SqrtF32","SqrtF64","builtin_trunc","TruncF32","TruncF64","builtin_load","checkArgsOptional","contextualType","outType","isIntegerValue","numOperands","immOffset","immAlign","byteSize","evaluateImmediateOffset","evaluateImmediateAlign","isSignedIntegerValue","builtin_store","void","contextIsExact","inType","convertExpression","builtin_add","isNumericValue","makeAdd","builtin_sub","makeSub","builtin_mul","makeMul","builtin_div","makeDiv","builtin_atomic_load","checkFeatureEnabled","builtin_atomic_store","builtin_atomic_binary","opName","atomic_rmw","builtin_atomic_add","AtomicRMWOp","Add","builtin_atomic_sub","Sub","builtin_atomic_and","And","builtin_atomic_or","Or","builtin_atomic_xor","Xor","builtin_atomic_xchg","Xchg","builtin_atomic_cmpxchg","arg2","builtin_atomic_wait","builtin_diagnostic","category","checkTypeAbsent","emitDiagnostic","User_defined_0","DiagnosticCategory","nop","builtin_conversion","builtin_i8x16","expr","precomp","runExpression","ExpressionRunnerFlags","PreserveSideeffects","writeI8","getConstValueI32","Expression_must_be_a_compile_time_constant","builtin_v128_splat","SplatI8x16","SplatI16x8","SplatI32x4","SplatI64x2","SplatF32x4","SplatF64x2","builtin_v128_extract_lane","idx","maxIdx","_0_must_be_a_value_between_1_and_2_inclusive","simd_extract","SIMDExtractOp","ExtractLaneI8x16","ExtractLaneU8x16","ExtractLaneI16x8","ExtractLaneU16x8","ExtractLaneI32x4","ExtractLaneI64x2","ExtractLaneF32x4","ExtractLaneF64x2","builtin_v128_replace_lane","simd_replace","SIMDReplaceOp","ReplaceLaneI8x16","ReplaceLaneI16x8","ReplaceLaneI32x4","ReplaceLaneI64x2","ReplaceLaneF32x4","ReplaceLaneF64x2","builtin_v128_shuffle","laneWidth","laneCount","isPowerOf2","mask","argN","off8","idx8","simd_shuffle","builtin_v128_swizzle","SwizzleV8x16","builtin_v128_load_splat","simd_load","SIMDLoadOp","LoadSplatV8x16","LoadSplatV16x8","LoadSplatV32x4","LoadSplatV64x2","builtin_v128_load_ext","LoadI8ToI16x8","LoadU8ToU16x8","LoadI16ToI32x4","LoadU16ToU32x4","LoadI32ToI64x2","LoadU32ToU64x2","builtin_v128_add","AddI8x16","AddI16x8","AddI32x4","AddI64x2","AddF32x4","AddF64x2","builtin_v128_sub","SubI8x16","SubI16x8","SubI32x4","SubI64x2","SubF32x4","SubF64x2","builtin_v128_mul","MulI8x16","MulI16x8","MulI32x4","MulF32x4","MulF64x2","builtin_v128_div","DivF32x4","DivF64x2","builtin_v128_add_saturate","AddSatI8x16","AddSatU8x16","AddSatI16x8","AddSatU16x8","builtin_v128_sub_saturate","SubSatI8x16","SubSatU8x16","SubSatI16x8","SubSatU16x8","builtin_v128_min","MinI8x16","MinU8x16","MinI16x8","MinU16x8","MinI32x4","MinU32x4","MinF32x4","MinF64x2","builtin_v128_max","MaxI8x16","MaxU8x16","MaxI16x8","MaxU16x8","MaxI32x4","MaxU32x4","MaxF32x4","MaxF64x2","builtin_v128_pmin","PminF32x4","PminF64x2","builtin_v128_pmax","PmaxF32x4","PmaxF64x2","builtin_v128_dot","DotI16x8","builtin_v128_avgr","AvgrU8x16","AvgrU16x8","builtin_v128_eq","EqI8x16","EqI16x8","EqI32x4","EqF32x4","EqF64x2","builtin_v128_ne","NeI8x16","NeI16x8","NeI32x4","NeF32x4","NeF64x2","builtin_v128_lt","LtI8x16","LtU8x16","LtI16x8","LtU16x8","LtI32x4","LtU32x4","LtF32x4","LtF64x2","builtin_v128_le","LeI8x16","LeU8x16","LeI16x8","LeU16x8","LeI32x4","LeU32x4","LeF32x4","LeF64x2","builtin_v128_gt","GtI8x16","GtU8x16","GtI16x8","GtU16x8","GtI32x4","GtU32x4","GtF32x4","GtF64x2","builtin_v128_ge","GeI8x16","GeU8x16","GeI16x8","GeU16x8","GeI32x4","GeU32x4","GeF32x4","GeF64x2","builtin_v128_narrow","NarrowI16x8ToI8x16","NarrowU16x8ToU8x16","NarrowI32x4ToI16x8","NarrowU32x4ToU16x8","builtin_v128_neg","NegI8x16","NegI16x8","NegI32x4","NegI64x2","NegF32x4","NegF64x2","builtin_v128_abs","AbsI8x16","AbsI16x8","AbsI32x4","AbsF32x4","AbsF64x2","builtin_v128_sqrt","SqrtF32x4","SqrtF64x2","builtin_v128_ceil","CeilF32x4","CeilF64x2","builtin_v128_floor","FloorF32x4","FloorF64x2","builtin_v128_trunc","TruncF32x4","TruncF64x2","builtin_v128_nearest","NearestF32x4","NearestF64x2","builtin_v128_convert","ConvertI32x4ToF32x4","ConvertU32x4ToF32x4","ConvertI64x2ToF64x2","ConvertU64x2ToF64x2","builtin_v128_trunc_sat","TruncSatF32x4ToI32x4","TruncSatF32x4ToU32x4","TruncSatF64x2ToI64x2","TruncSatF64x2ToU64x2","builtin_v128_widen_low","WidenLowI8x16ToI16x8","WidenLowU8x16ToU16x8","WidenLowI16x8ToI32x4","WidenLowU16x8ToU32x4","builtin_v128_widen_high","WidenHighI8x16ToI16x8","WidenHighU8x16ToU16x8","WidenHighI16x8ToI32x4","WidenHighU16x8ToU32x4","builtin_v128_shl","simd_shift","SIMDShiftOp","ShlI8x16","ShlI16x8","ShlI32x4","ShlI64x2","builtin_v128_shr","ShrI8x16","ShrU8x16","ShrI16x8","ShrU16x8","ShrI32x4","ShrU32x4","ShrI64x2","ShrU64x2","builtin_v128_bitwise_binary","builtin_v128_any_true","AnyTrueI8x16","AnyTrueI16x8","AnyTrueI32x4","AnyTrueI64x2","builtin_v128_all_true","AllTrueI8x16","AllTrueI16x8","AllTrueI32x4","AllTrueI64x2","builtin_v128_bitmask","BitmaskI8x16","BitmaskI16x8","BitmaskI32x4","builtin_v128_qfma","simd_ternary","SIMDTernaryOp","QFMAF32x4","QFMAF64x2","builtin_v128_qfms","QFMSF32x4","QFMSF64x2","ensureVisitMembersOf","instance","visitRef","program","nativeSizeSize","visitInstance","base","call","internalName","None","hasVisitImpl","isDeclaredInLibrary","visitPrototype","lookupInSelf","ElementKind","FUNCTION_PROTOTYPE","resolver","resolveFunction","compileFunction","visitSignature","visitThisType","thisType","parameterTypes","isStrictlyAssignableTo","needsTempValue","_values","Map_values","j","member","FIELD","parent","fieldOffset","memoryOffset","if","addFunction","createType","flatten","typeToRuntimeFlags","alignLog2","is","evaluateConstantType","Expected_0_type_arguments_but_got_1","Expected_0_arguments_but_got_1","argumentsRange","usize64","getConstValueI64High","getConstValueI64Low","usize32","naturalAlign","align","_0_must_be_a_power_of_two","feature","hasFeature","Feature_0_is_not_enabled","featureToString","setCurrentTypeOnError","Type_0_is_not_generic","expected","expectedMinimum","expectedMaximum","Expected_at_least_0_arguments_but_got_1","contextualUsize","i64_is_i32","i64_low","i64_is_u32","i64_high","thisOperand","builtins","Map","function_builtins","set","isFloatValue","isBooleanValue","classReference","getClass","isAssignableTo","stringInstance","extends","arrayPrototype","isNullableReference","element","lookupExpression","ReportMode","SWALLOW","getExpressionId","ExpressionId","Const","signatureReference","Type_0_has_no_call_signatures","i64_new","getClassOrWrapper","firstOperand","isLiteralKind","String_literal_expected","fieldName","classMembers","has","get","Type_0_has_no_property_1","nextMemoryOffset","resultType","isInternalReference","getSignature","ensureStaticString","id","hasDecorator","DecoratorFlags","maybeDropCondition","LocalGet","NeF32","getLocalGetIndex","F32","temp","NeF64","F64","EqF32","SubF32","EqF64","SubF64","isAny","makeIsTrueish","compileCallDirect","offset","elementType","valuesOperand","Array_literal_expected","numElements","exprs","isStatic","makeZero","buf","writeStaticBuffer","byteLength","addAlignedMemorySegment","fromType","isChangeableTo","Type_0_cannot_be_changed_to_type_1","nonNullableType","noAssert","evaled","Default","getExpressionType","getConstValueF32","getConstValueF64","makeAbort","EqzI32","EqzI64","ref_is_null","alreadyUnchecked","unset","indexArg","operandExprs","nativeParamTypes","classInstance","This_expression_is_not_constructable","ctor","ensureConstructor","checkFieldInitialization","compileInstantiate","functionPrototype","ftype","requiredParameters","shift","thisArg","_this_cannot_be_referenced_in_current_location","compileCallIndirect","isizeType","writeI16","writeI32","writeF32","writeF64","AndV128","OrV128","XorV128","AndNotV128","builtin_v128_bitwise_unary","NotV128","builtin_v128_bitwise_ternary","Bitselect","runtimeFeatures","elementsByName","global","COMPILED","INLINED","constantIntegerValue","global_get","block","managedClasses","nextId","_keys","Map_keys","instanceId","return","current","switch","SubI64","count","data","abvInstance","arrayBufferViewInstance","abvPrototype","setPrototype","mapPrototype","staticArrayPrototype","lastId","isAcyclic","getArrayValueType","getTypeArgumentsTo","rttiFlags","segment","addGlobal","instanceofInstance","stmts","instances","PARENT_SUBST","GETTER_PREFIX","SETTER_PREFIX","INSTANCE_DELIMITER","STATIC_DELIMITER","INNER_DELIMITER","INDEX_SUFFIX","STUB_DELIMITER","CommonNames","funcref","externref","exnref","anyref","u8x16","u16x8","u32x4","u64x2","void_","number","boolean","string","native","indexof","valueof","returnof","null_","true_","false_","this_","super_","constructor","ASC_TARGET","ASC_NO_TREESHAKING","ASC_NO_ASSERT","ASC_MEMORY_BASE","ASC_TABLE_BASE","ASC_OPTIMIZE_LEVEL","ASC_SHRINK_LEVEL","ASC_LOW_MEMORY_LIMIT","ASC_WASI","ASC_FEATURE_SIGN_EXTENSION","ASC_FEATURE_MUTABLE_GLOBALS","ASC_FEATURE_NONTRAPPING_F2I","ASC_FEATURE_BULK_MEMORY","ASC_FEATURE_SIMD","ASC_FEATURE_THREADS","ASC_FEATURE_EXCEPTION_HANDLING","ASC_FEATURE_TAIL_CALLS","ASC_FEATURE_REFERENCE_TYPES","ASC_FEATURE_MULTI_VALUE","ASC_FEATURE_GC","ASC_FEATURE_MEMORY64","I8","I16","Isize","U8","U16","U32","U64","Usize","Bool","V128","Funcref","Externref","Exnref","Anyref","String","StaticArray","Set","ArrayBufferView","ArrayBuffer","Mathf","NativeMath","NativeMathf","ipow32","ipow64","alloc","realloc","free","new_","renew","retain","release","collect","typeinfo","instanceof_","visit","newBuffer","newArray","Feature","Target","Typeinfo","TypeinfoFlags","ExportNames","mangleImportName_moduleName","mangleImportName_elementName","target","WASM32","exportMemory","importMemory","initialMemory","maximumMemory","sharedMemory","importTable","exportTable","sourceMap","explicitStart","memoryBase","tableBase","globalAliases","features","noUnsafe","pedantic","lowMemoryLimit","optimizeLevelHint","shrinkLevelHint","WASM64","isize64","isize32","Constraints","RuntimeFeatures","memory","table","Compiler","DiagnosticEmitter","diagnostics","currentParent","memorySegments","stringSegments","functionTable","builtinArgumentsLength","skippedAutoreleases","inlineStack","lazyFunctions","pendingClassInstanceOf","virtualCalls","pendingElements","doneModuleExports","f32ModInstance","f64ModInstance","f32PowInstance","f64PowInstance","i32PowInstance","i64PowInstance","create","setLowMemoryUnused","featureFlags","FeatureFlags","SignExt","MutableGloabls","NontrappingFPToInt","BulkMemory","SIMD128","Atomics","ExceptionHandling","TailCall","ReferenceTypes","MultiValue","GC","Memory64","setFeatures","startFunctionInstance","makeNativeFunction","Signature","currentBody","compile","initialize","actualFunction","startFunctionBody","files","filesByName","file","USER_ENTRY","compileFile","compileExports","startIsEmpty","isWasi","unshift","global_set","funcRef","nativeParams","nativeResults","typesToNativeTypes","additionalLocals","finalize","addFunctionExport","setStart","cyclicClasses","findCyclicClasses","Set_values","Type_0_is_cyclic_Module_will_include_deferred_garbage_collection","identifierNode","registerConstantInteger","functionsToCompile","clear","compileClassInstanceOf","VIRTUAL","INSTANCE","ensureVirtualStub","finalizeVirtualStub","ensureVarargsStub","delete","removeGlobal","compileRTTI","compileVisitGlobals","compileVisitMembers","i64_align","lowMemoryLimit32","i64_gt","Low_memory_limit_exceeded_by_static_data_0_1","i64_to_string","initialPages","i64_shr_u","Module_requires_at_least_0_pages_of_initial_memory","maximumPages","UNLIMITED_MEMORY","Module_requires_at_least_0_pages_of_maximum_memory","isSharedMemory","Shared_memory_requires_maximum_memory_to_be_defined","Shared_memory_requires_feature_threads_to_be_enabled","setMemory","addMemoryImport","functionTableNames","setFunctionTable","UNLIMITED_TABLE","addTableImport","willOptimize","Importing_the_table_disables_some_indirect_call_optimizations","addTableExport","Exporting_the_table_disables_some_indirect_call_optimizations","ensureModuleExports","elementName","ensureModuleExport","exportsStar","prefix","functionInstances","instanceName","GENERIC","fullName","warning","Exported_generic_function_or_class_has_no_concrete_instances","CLASS_PROTOTYPE","classPrototype","classInstances","PROPERTY_PROTOTYPE","propertyInstance","CONST","STATIC","READONLY","addGlobalExport","Cannot_export_a_mutable_global","ENUMVALUE","enumValue","isImmutable","functionInstance","ensureArgumentsLength","PROPERTY","getterInstance","setterInstance","fieldInstance","internalGetterName","internalSetterName","isUnmanaged","ENUM","NAMESPACE","TYPEDEFINITION","subPrefix","implicitExport","SCOPED","memberName","PRIVATE","compileMembers","compileGlobal","compileEnum","resolveClass","compileClass","resolveProperty","compileProperty","compileElement","exportStar","normalizedPathWithoutExtension","pathWithIndex","File_0_not_found","startFunction","startSignature","previousBody","previousFlow","compileTopLevelStatement","finishAutoreleases","locals","localsByIndex","numLocals","varTypes","ERRORED","initExpr","typeNode","initializerNode","RESOLVED","resolvedType","resolveType","Type_expected","setType","checkTypeSupported","atEnd","Type_0_is_not_assignable_to_type_1","AMBIENT","isDeclaredConstant","isDeclaredInline","MODULE_IMPORT","mangleImportName","addGlobalImport","initializeInStart","GlobalGet","fromName","getGlobalGetName","isGlobalMutable","getGlobal","Mutable_value_cannot_be_inlined","constantValueKind","constantFloatValue","compileInlineConstant","Decorator_0_is_not_valid_here","findDecorator","decoratorNodes","makeRetain","previousParent","previousValue","previousValueIsMut","isInline","initInStart","valueNode","In_const_enum_declarations_member_initializer_must_be_constant_expression","Enum_member_must_have_initializer","makeGlobalAssignment","setConstantIntegerValue","MODULE_EXPORT","forceStdAlternative","previousType","bodyNode","declarationNode","checkSignatureSupported","An_implementation_cannot_be_declared_in_ambient_contexts","RETAINED","local_set","compileFunctionBody","performAutoreleases","addFunctionImport","getFunction","ABSTRACT","INTERFACE","Function_implementation_is_missing_or_not_immediately_following_the_declaration","thisLocal","lookupLocal","compileStatements","GET","SET","compileReturnedExpression","indexBefore","canOverflow","nonNull","isNonnull","NONNULL","allocStmts","makeAllocation","makeFieldInitializationInConstructor","firstStmt","LocalSet","getLocalSetIndex","Explicitly_returning_constructor_drops_this_allocation","A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final","isAnyLocalFlag","ANY_RETAINED","unsetLocalFlag","Constructors_for_derived_classes_must_contain_a_super_call","A_function_whose_declared_type_is_not_void_must_return_a_value","staticMembers","instanceMembers","compileField","compileFieldGetter","compileFieldSetter","getterRef","nativeThisType","nativeValueType","valueExpr","setterRef","NeI64","NeI32","drop","makeRelease","compilePropertyGetter","compilePropertySetter","buffer","alignment","MemorySegment","usizeSize","stringValue","stringSegment","rtHeaderSize","runtimeHeaderSize","segments","createBuffer","addRuntimeMemorySegment","ptr","writeI64","arrayBufferInstance","OBJECTInstance","writeField","bufferSegment","arrayInstance","bufferLength","arrayLength","bufferAddress","STUB","memorySegment","rtInstance","memberStatements","getElementByDeclaration","exportStatement","compileFileByPath","importStatement","stmt","compileStatement","Nop","isLastInBody","compileBlockStatement","compileBreakStatement","compileContinueStatement","compileDoStatement","compileEmptyStatement","compileExpressionStatement","compileForStatement","compileForOfStatement","compileIfStatement","compileReturnStatement","compileSwitchStatement","compileThrowStatement","compileTryStatement","compileVariableStatement","compileVoidStatement","compileWhileStatement","Not_implemented_0","addDebugLocation","isBody","numStatements","Block","getBlockName","getBlockChildCount","getBlockChildAt","needsExplicitUnreachable","outerFlow","innerFlow","fork","freeScopedLocals","inherit","labelNode","breakLabel","A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement","br","continueLabel","A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement","doCompileDoStatement","flowAfter","pushBreakLabel","unifyLocalFlags","flowBefore","bodyFlow","bodyStmts","condFlow","condExpr","condKind","evaluateCondition","tcond","Flow","hasIncompatibleLocalStates","popBreakLabel","hasScopedLocals","loop","doCompileForStatement","loopLabel","loopStmts","inheritNonnullIfTrue","inheritBranch","ifStmts","incrFlow","thenStmts","thenFlow","elseStmts","elseFlow","inheritNonnullIfFalse","inheritMutual","valueExpression","constraints","inlineReturnLabel","numCases","context","tempLocal","tempLocalIndex","breaks","breakIndex","defaultIndex","EqI32","currentBlock","commonCategorical","commonConditional","isLast","nextLabel","terminates","message","newArgs","dropped","numDeclarations","initializers","initAutoreleaseSkipped","uniqueMap","contextualTypeArguments","dummy","addScopedDummyLocal","freeScopedDummyLocal","isConst","local","Local","parentFunction","setConstantFloatValue","scopedLocals","existing","errorRelated","Duplicate_identifier_0","_const_declarations_must_be_initialized","LET","existingLocal","getScopedLocal","isNative","addScopedLocal","CONSTANT","addLocal","isShortIntegerValue","CONDITIONALLY_RETAINED","doCompileWhileStatement","computeSmallIntegerShift","computeSmallIntegerMask","compileAssertionExpression","compileBinaryExpression","compileCallExpression","compileCommaExpression","compileElementAccessExpression","compileFunctionExpression","compileIdentifierExpression","compileInstanceOfExpression","compileLiteralExpression","compileNewExpression","compilePropertyAccessExpression","compileTernaryExpression","compileUnaryPostfixExpression","compileUnaryPrefixExpression","wrap","ensureSmallIntegerWrap","tryUndoAutorelease","explicit","makeRuntimeNonNullCheck","isExternalReference","makeRuntimeUpcastCheck","Conversion_from_type_0_to_1_requires_an_explicit_cast","PromoteF32","DemoteF64","isLongIntegerValue","TruncF32ToI64","TruncF32ToI32","TruncF32ToU64","TruncF32ToU32","TruncF64ToI64","TruncF64ToI32","TruncF64ToU64","TruncF64ToU32","ConvertI64ToF32","ConvertU64ToF32","ConvertI32ToF32","ConvertU32ToF32","ConvertI64ToF64","ConvertU64ToF64","ConvertI32ToF64","ConvertU32ToF64","WrapI64","ExtendI32","ExtendU32","isVaryingIntegerValue","Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit","inheritedConstraints","PREFIX","AS","exceptVoid","info","Expression_is_never_null","leftExpr","leftType","rightExpr","rightType","commonType","compound","Token","LESSTHAN","overload","lookupOverload","OperatorKind","LT","compileBinaryOverload","commonDenominator","Operator_0_cannot_be_applied_to_types_1_and_2","makeLt","GREATERTHAN","GT","makeGt","LESSTHAN_EQUALS","LE","makeLe","GREATERTHAN_EQUALS","GE","makeGe","EQUALS_EQUALS_EQUALS","EQUALS_EQUALS","EQ","operatorTokenToString","makeEq","EXCLAMATION_EQUALS_EQUALS","EXCLAMATION_EQUALS","NE","makeNe","EQUALS","compileAssignment","PLUS_EQUALS","PLUS","ADD","The_0_operator_cannot_be_applied_to_type_1","MINUS_EQUALS","MINUS","SUB","ASTERISK_EQUALS","ASTERISK","MUL","ASTERISK_ASTERISK_EQUALS","ASTERISK_ASTERISK","POW","makePow","SLASH_EQUALS","SLASH","DIV","PERCENT_EQUALS","PERCENT","REM","makeRem","LESSTHAN_LESSTHAN_EQUALS","LESSTHAN_LESSTHAN","intType","BITWISE_SHL","makeShl","GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN","BITWISE_SHR","makeShr","GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN_GREATERTHAN","BITWISE_SHR_U","makeShru","AMPERSAND_EQUALS","AMPERSAND","BITWISE_AND","makeAnd","BAR_EQUALS","BAR","BITWISE_OR","makeOr","CARET_EQUALS","CARET","BITWISE_XOR","makeXor","AMPERSAND_AMPERSAND","rightFlow","performAutoreleasesWithValue","leftAutoreleaseSkipped","rightAutoreleaseSkipped","retainLeftInElse","delayAutorelease","rightStmts","cloneExpression","BAR_BAR","retainLeftInThen","targetType","getTypeOfElement","makeAssignment","currentThisExpression","currentElementExpression","LtF32","LtF64","GtF32","GtF64","LeI32","LeI64","LeU32","LeU64","LeF32","LeF64","GeI32","GeI64","GeU32","GeU64","GeF32","GeF64","EqI64","AddF32","AddF64","MulI32","MulI64","MulF32","MulF64","lookupGlobal","Cannot_find_name_0","makeCallDirect","namespace","namespaceMembers","DivI32","DivI64","DivU32","DivU64","DivF32","DivF64","RemI32","RemI64","RemU32","RemU64","ShlI64","ShrU64","AndI64","OrI64","operatorInstance","thisExpression","LOCAL","Variable_0_used_before_its_declaration","checkUnsafe","propertyPrototype","Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property","isUnchecked","indexedSet","INDEXED_SET","INDEXED_GET","Index_signature_in_type_0_only_permits_reading","Index_signature_is_missing_in_type_0","Indexed_access_may_involve_bounds_checking","indexExpression","tee","isLocalFlag","makeLocalAssignment","isConstructor","setThisFieldFlag","FieldFlags","INITIALIZED","fieldParent","makeFieldAssignment","makeAutorelease","thisExpr","nativeReturnType","tempThis","elementExpr","tempTarget","tempElement","localIndex","alreadyRetained","makeReplace","field","fieldType","nativeFieldType","tempValue","Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors","baseClassInstance","baseCtorInstance","superCall","_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class","compileCallExpressionBuiltin","maybeInferCall","Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures","Expression_cannot_be_represented_by_a_type","resolveTypeArguments","callee","BuiltinContext","fn","methodName","hasThis","The_this_types_of_each_signature_are_incompatible","hasRest","minimum","maximum","relatedReportNode","isLibrary","Operation_is_unsafe","argumentExpressions","checkCallSignature","isAccessOnThis","isAccessOnSuper","includes","makeCallInline","pop","Function_0_cannot_be_inlined_into_itself","numArgumentsInclThis","immediatelyDropped","numParameters","createInline","usedLocals","paramExpr","paramType","argumentLocal","getParameterName","addScopedAlias","initType","checkFieldInitializationInFlow","original","stub","varargsStub","originalSignature","originalParameterTypes","originalParameterDeclarations","isInstance","minArguments","minOperands","maxArguments","maxOperands","numOptional","forwardedOperands","operandIndex","newStub","numNames","ofN","Optional_parameter_must_have_an_initializer","theCall","virtualStub","ref","overloadPrototypes","overloads","tempIndex","builder","SwitchBuilder","unboundOverloadPrototype","isBound","unboundOverloadParent","isProperty","propertyParent","overloadInstance","boundProperty","boundPropertyInstance","boundPrototype","overloadType","originalType","overloadSignature","overloadParameterTypes","overloadNumParameters","paramExprs","n","needsVarargsStub","calledName","addCase","extendees","getAllExtendees","a","b","extendee","removeFunction","render","retainInstance","releaseInstance","newExpr","newType","oldExpr","oldType","getAutoreleaseLocal","isLocalTee","lengthBefore","maybeFinishAutorelease","skipAutorelease","Function_0_is_virtual_and_will_not_be_inlined","theOperands","slice","allOptionalsAreConstant","compilesToConst","resolved","lastOperand","getSideEffects","SideEffects","WritesGlobal","lastOperandType","makeCallIndirect","numExpressions","targetExpression","resolveExpression","indexedGet","contextualSignature","clone","FunctionPrototype","nextAnonymousId","signatureNode","numPresentParameters","parameterNode","isTypeOmitted","thisTypeNode","ensureRuntimeFunction","asNullable","Expression_resolves_to_unusual_type_0","_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class","scopedThis","superType","_super_can_only_be_referenced_in_a_derived_class","maybeCompileEnclosingSource","lookupIdentifierExpression","localType","globalType","A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums","ref_func","namedType","hasTypeArguments","resolveTypeName","makeInstanceofClass","expectedType","makeInstanceofType","actualType","Expression_compiles_to_a_dynamic_check_at_runtime","implicitlyNegate","compileArrayLiteral","floatValue","intValue","determineIntegerLiteralType","i64_to_f32","i64_to_f64","compileStringLiteral","compileObjectLiteral","contextualClass","compileStaticArrayLiteral","arrayType","tempDataStart","nativeElementType","addStaticBuffer","arraySegment","addStaticArrayHeader","arrayAddress","newArrayInstance","nativeArrayType","dataStartMember","bufferSize","newBufferInstance","classType","Cannot_create_an_instance_of_an_abstract_class","ctorPrototype","constructorPrototype","Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal","hasErrors","nativeClassType","omittedFields","memberKey","Property_0_does_not_exist_on_type_1","Property_0_is_private_and_only_accessible_within_class_1","PROTECTED","Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses","Property_0_is_missing_in_type_1_but_required_in_type_2","resolveClassInclTypeArguments","constructorInstance","baseClass","baseCtor","makeNativeFunctionDeclaration","setResolvedInstance","allocExpr","relatedNode","didCheckFieldInitialization","isThisFieldFlag","DEFINITELY_ASSIGNED","Property_0_is_always_assigned_before_being_used","Unnecessary_definite_assignment","Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned","ctorInstance","ctxType","parentEnum","Property_0_is_used_before_being_assigned","Object_is_possibly_null","ifThenFlow","ifThenExpr","ifThenType","ifThenAutoreleaseSkipped","ifElseFlow","ifElseExpr","ifElseType","ifElseAutoreleaseSkipped","getValue","Unreachable","PLUS_PLUS","POSTFIX_INC","getLocalSetValue","compileUnaryOverload","makeOne","MINUS_MINUS","POSTFIX_DEC","setValue","NegF32","NegF64","PREFIX_INC","PREFIX_DEC","EXCLAMATION","NOT","TILDE","BITWISE_NOT","makeNegOne","TYPEOF","compileTypeof","typeString","REPORT","ExtendI8ToI32","ExtendI16ToI32","addDebugInfoFile","debugInfoRef","debugLocations","supported","parameterReportNode","v128_zero","ref_null","allocInstance","newInstance","thisLocalIndex","fieldPrototype","codeLocation","abortInstance","messageArg","makeStaticAbort","messageExpr","filenameExpr","lineAt","columnAt","mangleInternalName","arg","ExportsWalker","includePrivate","seen","visitFile","visitElement","visitGlobal","visitEnum","visitFunctionInstances","visitClassInstances","visitField","visitFunction","hasCompiledMember","visitNamespace","visitAlias","visitClass","IDLBuilder","sb","indentLevel","build","indent","typeToString","originalName","walk","TSDBuilder","remainingMembers","isInterface","extendsNode","code","diagnosticCategoryToString","PEDANTIC","diagnosticCategoryToColor","COLOR_MAGENTA","COLOR_BLUE","COLOR_YELLOW","COLOR_RED","diagnosticCodeToString","COLOR_RESET","DiagnosticMessage","relatedRange","replace","thisRange","otherRange","thisRelatedRange","otherRelatedRange","formatDiagnosticContext","useColors","isLineBreak","showContext","relatedSource","withRange","seenInSource","seenMessagesAtPos","print","sources","console","forEach","key","importState","nodeName","elementsByDeclaration","_","arr","StructDef","fields","AbiAliasDef","newTypeName","wasmType","new_type_name","ActionDef","ability","ricardian_contract","AbiHelper","abiTypeLookup","TableDef","indexType","index_type","keys_names","keys_types","AbiDef","version","types","structs","actions","tables","abiInfo","typeAliasSet","structsLookup","elementLookup","typeNodeAnalyzer","asTypes","getAsTypes","asType","abiType","findSourceAbiType","findElement","getStructFromClzPrototype","clsProto","DATABASE","getExprValue","AbiUtils","checkDatabaseName","getStructFromNode","protoEle","Strings","isAroundQuotation","lookup","AstUtil","getInternalName","ele","struct","basePrototype","impledSerializable","addFieldsFromClassPrototype","fieldDeclare","memberType","hasSpecifyDecorator","NamedTypeNodeDef","getDeclareType","addField","addAbiTypeAlias","addToStruct","funcPrototype","decoratorNode","getSpecifyDecorator","location","isValidAbility","funcProto","funcName","parameter","typeInfo","getActionAbility","ProgramAnalyzar","ContractProgram","TypeEnum","layout","LayoutDef","storeKey","varName","resolveField","ParameterNodeDef","typeNodeMap","setTypeIndex","DecoratorNodeDef","MessageDecoratorNodeDef","payable","mutates","selector","getIdentifier","getBinaryExprRight","removeQuotation","FunctionDef","isReturnable","defaultVals","resolve","param","returnTypeDesc","isReturnVoid","wrapType","TypeUtil","getWrapperType","codecType","item","msgDecorator","messageDecorator","typeWrapperMap","undefined","defaultValMap","abiTypeMap","entrySources","importedElement","unimports","resolveImportSource","defaultVal","getAbiType","getDefaultVal","getArgs","typeDef","isArrayType","isMapType","MAP","NUMBER","typeEnum","findSourceAsElement","findSourceAsTypeName","argType","typeAnalyzer","Collections","isEmptyArray","asTypeName","sourceTypeName","aliasTypeName","TypePair","ty","className","cell","fieldCodecType","ClassInterpreter","clzPrototype","toLowerCase","ContractInterpreter","cntrFuncDefs","msgFuncDefs","lowerFirstCase","resolveContractClass","ElementUtil","isCntrFuncPrototype","isMessageFuncPrototype","msgFunc","MessageFuctionDef","funcDef","StorageInterpreter","resolveInstanceMembers","FIELD_PROTOTYPE","FieldDef","storages","contract","import","ImportSourceDef","sortStorages","getFields","sort","toImportElement","isContractClassPrototype","isStoreClassPrototype","addDefaultImports","storage","beginChar","aChar","DATABASE_CHARSETS","funcType","declareType","bracketIndex","endIndex","impledInterface","classDeclaration","interfaceName","_type","tempClz","interfaces","implTypes","ASTBuilder","visitNode","finish","visitSource","visitNamedTypeNode","visitFunctionTypeNode","visitTypeParameter","visitIdentifierExpression","visitAssertionExpression","visitBinaryExpression","visitCallExpression","visitClassExpression","visitCommaExpression","visitElementAccessExpression","visitFunctionExpression","visitInstanceOfExpression","visitLiteralExpression","visitNewExpression","visitParenthesizedExpression","visitPropertyAccessExpression","visitTernaryExpression","visitUnaryPostfixExpression","visitUnaryPrefixExpression","visitBlockStatement","visitBreakStatement","visitContinueStatement","visitDoStatement","visitEmptyStatement","visitExportStatement","visitExportDefaultStatement","visitExportImportStatement","visitExpressionStatement","visitForStatement","visitForOfStatement","visitIfStatement","visitImportStatement","visitReturnStatement","visitSwitchStatement","visitThrowStatement","visitTryStatement","visitVariableStatement","visitWhileStatement","visitClassDeclaration","visitEnumDeclaration","visitEnumValueDeclaration","visitFieldDeclaration","visitFunctionDeclaration","visitImportDeclaration","visitInterfaceDeclaration","visitMethodDeclaration","visitNamespaceDeclaration","visitTypeDeclaration","visitVariableDeclaration","serializeDecorator","visitExportMember","serializeParameter","visitSwitchCase","visitIndexSignature","visitNodeAndTerminate","visitTypeName","visitTypeNode","visitStringLiteral","elements","visitArguments","numArgs","visitFunctionCommon","visitFloatLiteralExpression","visitIntegerLiteralExpression","visitStringLiteralExpression","visitRegexpLiteralExpression","visitArrayLiteralExpression","visitObjectLiteralExpression","singleQuoted","quote","last","lastCharPos","isDefault","serializeExternalModifiers","numImplementsTypes","numMembers","numValues","serializeAccessModifiers","numTypeParameters","firstDeclaration","REST","OPTIONAL","DECLARE","PUBLIC","FlowFlags","ConditionKind","localFlags","thisFieldFlags","inlineFunction","initThisFieldFlags","nextInlineId","resetBreakContext","branch","except","temps","tempI32s","tempI64s","tempF32s","tempF64s","tempV128s","tempFuncrefs","tempExternrefs","tempExnrefs","tempAnyrefs","nextAutoreleaseId","resetTemporaryName","scopedLocal","setTemporaryName","scopedDummy","scopedAlias","scope","localsByName","defaultIfInlined","actualParent","actualClass","fieldFlags","nextBreakId","stack","breakStack","otherFlags","conditionKind","thisFlags","newFlags","thisLocalFlags","numThisLocalFlags","otherLocalFlags","numOtherLocalFlags","maxLocalFlags","leftFlags","rightFlags","rightLocalFlags","leftLocalFlags","numLeftLocalFlags","numRightLocalFlags","leftFieldFlags","newFieldFlags","rightFieldFlags","before","after","iff","If","getIfFalse","getIfCondition","getIfTrue","Unary","getUnaryOp","getUnaryValue","Binary","getBinaryOp","getBinaryLeft","getBinaryRight","Call","getCallTarget","getCallOperandAt","exprType","canConversionOverflow","Load","signed","isLoadSigned","getLoadBytes","Select","getSelectThen","getSelectElse","instancesByName","levels","findUsedLocalsVisit","used","traverse","formatDiagnosticMessage","Options","alias","FEATURE_SIGN_EXTENSION","FEATURE_MUTABLE_GLOBALS","FEATURE_NONTRAPPING_F2I","FEATURE_BULK_MEMORY","FEATURE_SIMD","FEATURE_THREADS","FEATURE_EXCEPTION_HANDLING","FEATURE_TAIL_CALLS","FEATURE_REFERENCE_TYPES","FEATURE_MULTI_VALUE","FEATURE_GC","FEATURE_MEMORY64","optimizeLevel","shrinkLevel","Program","diagnosticsOffset","getSource","isEntry","parser","parseFile","nextFile","getDependee","util","Auto","hasTemporaryFunction","cachedStrings","lit","binaryen","_malloc","_BinaryenSizeofLiteral","_BinaryenModuleCreate","cArr","allocU8Array","_BinaryenModuleRead","_free","out","_BinaryenLiteralInt32","_BinaryenConst","valueLow","valueHigh","_BinaryenLiteralInt64","_BinaryenLiteralFloat32","_BinaryenLiteralFloat64","__i32_store8","_BinaryenLiteralVec128","_BinaryenRefNull","_BinaryenUnary","_BinaryenBinary","_BinaryenMemorySize","_BinaryenMemoryGrow","_BinaryenLocalGet","_BinaryenExpressionGetType","_BinaryenLocalTee","cStr","allocStringCached","_BinaryenGlobalGet","_BinaryenLoad","_BinaryenStore","_BinaryenAtomicLoad","_BinaryenAtomicStore","_BinaryenAtomicRMW","replacement","_BinaryenAtomicCmpxchg","timeout","_BinaryenAtomicWait","notifyCount","_BinaryenAtomicNotify","_BinaryenAtomicFence","_BinaryenLocalSet","_BinaryenGlobalSet","children","allocPtrArray","_BinaryenBlock","single","Return","Throw","singleType","_BinaryenBreak","_BinaryenDrop","ReadsLocal","ReadsGlobal","_BinaryenLoop","_BinaryenIf","_BinaryenNop","_BinaryenReturn","_BinaryenSelect","defaultName","strs","_BinaryenSwitch","isReturn","_BinaryenReturnCall","_BinaryenCall","params","results","_BinaryenReturnCallIndirect","_BinaryenCallIndirect","_BinaryenUnreachable","dest","_BinaryenMemoryCopy","_BinaryenMemoryFill","catchBody","_BinaryenTry","eventName","_BinaryenThrow","_BinaryenRethrow","cStr1","cStr2","_BinaryenBrOnExn","_BinaryenPop","_BinaryenTupleMake","tuple","_BinaryenTupleExtract","vec","_BinaryenSIMDExtract","_BinaryenSIMDReplace","vec1","vec2","_BinaryenSIMDShuffle","c","_BinaryenSIMDTernary","_BinaryenSIMDShift","_BinaryenSIMDLoad","_BinaryenRefIsNull","_BinaryenRefFunc","mutable","_BinaryenAddGlobal","_BinaryenGetGlobal","_BinaryenRemoveGlobal","attribute","_BinaryenAddEvent","_BinaryenGetEvent","_BinaryenRemoveEvent","_BinaryenAddFunction","_BinaryenGetFunction","_BinaryenRemoveFunction","paramTypes","tempName","func","_BinaryenSetStart","_BinaryenAddFunctionExport","_BinaryenAddTableExport","_BinaryenAddMemoryExport","_BinaryenAddGlobalExport","_BinaryenAddEventExport","_BinaryenRemoveExport","externalModuleName","externalBaseName","cStr3","_BinaryenAddFunctionImport","_BinaryenAddTableImport","shared","_BinaryenAddMemoryImport","_BinaryenAddGlobalImport","_BinaryenAddEventImport","initial","exportName","segs","psvs","offs","sizs","cArr1","cArr2","cArr3","cArr4","u32s","__i32_store","allocU32Array","_BinaryenSetMemory","funcs","_BinaryenSetFunctionTable","contents","_BinaryenAddCustomSection","_BinaryenGetOptimizeLevel","level","_BinaryenSetOptimizeLevel","_BinaryenGetShrinkLevel","_BinaryenSetShrinkLevel","_BinaryenGetDebugInfo","on","_BinaryenSetDebugInfo","_BinaryenGetLowMemoryUnused","_BinaryenSetLowMemoryUnused","_BinaryenGetFastMath","_BinaryenSetFastMath","_BinaryenGetPassArgument","readString","_BinaryenSetPassArgument","_BinaryenClearPassArguments","_BinaryenGetAlwaysInlineMaxSize","_BinaryenSetAlwaysInlineMaxSize","_BinaryenGetFlexibleInlineMaxSize","_BinaryenSetFlexibleInlineMaxSize","_BinaryenGetOneCallerInlineMaxSize","_BinaryenSetOneCallerInlineMaxSize","_BinaryenGetAllowInliningFunctionsWithLoops","enabled","_BinaryenSetAllowInliningFunctionsWithLoops","_BinaryenModuleGetFeatures","_BinaryenModuleSetFeatures","pass","allocString","_BinaryenFunctionRunPasses","_BinaryenModuleRunPasses","passes","cStrs","debugInfo","usesARC","setOptimizeLevel","setShrinkLevel","setDebugInfo","setFastMath","clearPassArguments","setAlwaysInlineMaxSize","setFlexibleInlineMaxSize","setOneCallerInlineMaxSize","setAllowInliningFunctionsWithLoops","getLowMemoryUnused","runPasses","_BinaryenModuleValidate","_BinaryenModuleInterpret","sourceMapUrl","binaryPtr","sourceMapPtr","_BinaryenModuleAllocateAndWrite","__i32_load","binaryLen","BinaryModule","__i32_load8_u","readBuffer","watFormat","_BinaryenModuleDispose","Relooper","noSideEffects","maxDepth","nested1","nested2","_BinaryenExpressionGetId","_BinaryenConstGetValueI32","_BinaryenConstGetValueI64Low","_BinaryenConstGetValueI64High","_BinaryenConstGetValueF32","_BinaryenConstGetValueF64","_BinaryenLocalGetGetIndex","globalName","_BinaryenGlobalGetGetName","_BinaryenLoadGetPtr","_BinaryenLoadIsAtomic","_BinaryenLoadGetBytes","_BinaryenLoadGetOffset","_BinaryenLoadIsSigned","_BinaryenLoadGetAlign","_BinaryenUnaryGetValue","_BinaryenUnaryGetOp","_BinaryenBinaryGetLeft","_BinaryenBinaryGetRight","_BinaryenBinaryGetOp","_BinaryenExpressionCopy","maxLoopIterations","runner","_ExpressionRunnerCreate","_ExpressionRunnerRunAndDispose","_BinaryenModuleAddDebugInfoFileName","_BinaryenModuleGetDebugInfoFileName","fileIndex","lineNumber","columnNumber","_BinaryenFunctionSetDebugLocation","_BinaryenTypeCreate","arity","_BinaryenTypeArity","_BinaryenTypeExpand","_BinaryenLocalSetGetIndex","_BinaryenLocalSetGetValue","_BinaryenLocalSetIsTee","_BinaryenStoreGetBytes","_BinaryenStoreGetOffset","_BinaryenStoreGetPtr","_BinaryenStoreGetValue","_BinaryenBlockGetName","_BinaryenBlockGetNumChildren","_BinaryenBlockGetChildAt","_BinaryenIfGetCondition","_BinaryenIfGetIfTrue","_BinaryenIfGetIfFalse","_BinaryenLoopGetName","_BinaryenLoopGetBody","_BinaryenBreakGetName","_BinaryenBreakGetCondition","_BinaryenSelectGetIfTrue","_BinaryenSelectGetIfFalse","_BinaryenSelectGetCondition","_BinaryenDropGetValue","_BinaryenReturnGetValue","_BinaryenCallGetTarget","_BinaryenCallGetNumOperands","_BinaryenCallGetOperandAt","_BinaryenMemoryGrowGetDelta","_BinaryenFunctionGetBody","_BinaryenFunctionGetName","_BinaryenFunctionGetParams","_BinaryenFunctionGetResults","_BinaryenFunctionGetNumVars","_BinaryenFunctionGetVar","_BinaryenGlobalGetName","_BinaryenGlobalGetType","_BinaryenGlobalIsMutable","_BinaryenGlobalGetInitExpr","event","_BinaryenEventGetName","_BinaryenEventGetAttribute","_BinaryenEventGetParams","_BinaryenEventGetResults","_RelooperCreate","_RelooperAddBlock","from","to","_RelooperAddBranch","_RelooperAddBlockWithSwitch","indexes","i32s","allocI32Array","_RelooperAddBranchForSwitch","entry","labelHelper","_RelooperRenderAndDispose","All","_BinaryenExpressionGetSideEffects","u8s","ptrs","u","stringLengthUTF8","cp","u1","u2","u3","ch","fromCharCodes","labelPostfix","labels","defaultLabel","lastCase","output","Break","numChildren","Loop","Switch","_BinaryenSwitchGetCondition","CallIndirect","_BinaryenCallIndirectGetNumOperands","_BinaryenCallIndirectGetOperandAt","GlobalSet","_BinaryenGlobalSetGetValue","Store","Drop","MemorySize","MemoryGrow","AtomicRMW","_BinaryenAtomicRMWGetPtr","_BinaryenAtomicRMWGetValue","AtomicCmpxchg","_BinaryenAtomicCmpxchgGetPtr","_BinaryenAtomicCmpxchgGetExpected","_BinaryenAtomicCmpxchgGetReplacement","AtomicWait","_BinaryenAtomicWaitGetPtr","_BinaryenAtomicWaitGetExpected","_BinaryenAtomicWaitGetTimeout","AtomicNotify","_BinaryenAtomicNotifyGetPtr","AtomicFence","SIMDExtract","_BinaryenSIMDExtractGetVec","SIMDReplace","_BinaryenSIMDReplaceGetVec","_BinaryenSIMDReplaceGetValue","SIMDShuffle","_BinaryenSIMDShuffleGetLeft","_BinaryenSIMDShuffleGetRight","SIMDTernary","_BinaryenSIMDTernaryGetA","_BinaryenSIMDTernaryGetB","_BinaryenSIMDTernaryGetC","SIMDShift","_BinaryenSIMDShiftGetVec","_BinaryenSIMDShiftGetShift","SIMDLoad","_BinaryenSIMDLoadGetPtr","MemoryInit","_BinaryenMemoryInitGetDest","_BinaryenMemoryInitGetOffset","_BinaryenMemoryInitGetSize","DataDrop","MemoryCopy","_BinaryenMemoryCopyGetDest","_BinaryenMemoryCopyGetSource","_BinaryenMemoryCopyGetSize","MemoryFill","_BinaryenMemoryFillGetDest","_BinaryenMemoryFillGetValue","_BinaryenMemoryFillGetSize","Pop","RefNull","RefIsNull","_BinaryenRefIsNullGetValue","RefFunc","Try","_BinaryenTryGetBody","_BinaryenTryGetCatchBody","_BinaryenThrowGetNumOperands","_BinaryenThrowGetOperandAt","Rethrow","_BinaryenRethrowGetExnref","BrOnExn","_BinaryenBrOnExnGetExnref","TupleMake","_BinaryenTupleMakeGetNumOperands","_BinaryenTupleMakeGetOperandAt","TupleExtract","Dependee","Parser","backlog","seenlog","donelog","onComment","currentSource","dependees","tryParseSignatureIsSignature","parseParametersThis","dependee","Source","USER","tn","Tokenizer","skip","ENDOFFILE","parseTopLevelStatement","skipStatement","startPos","AT","tokenPos","parseDecorator","exportStart","exportEnd","defaultStart","defaultEnd","DEFAULT","declareStart","declareEnd","contextIsAmbient","A_declare_modifier_cannot_be_used_in_an_already_ambient_context","first","peek","nextTokenPos","parseEnum","parseVariable","VAR","parseFunction","state","mark","abstractStart","abstractEnd","nextTokenOnNewLine","reset","parseStatement","_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration","discard","parseClassOrInterface","IdentifierHandling","PREFER","parseNamespace","parseExportImport","parseImport","TYPE","parseTypeDeclaration","skipIdentifier","An_export_assignment_cannot_have_modifiers","parseExportDefaultAlias","parseExport","_0_modifier_cannot_be_used_here","Decorators_are_not_valid_here","createExportDefaultStatement","dependent","readIdentifier","DOT","Identifier_expected","acceptParenthesized","suppressErrors","token","OPENPAREN","isNullableSignature","tryParseFunctionType","CLOSEPAREN","_0_expected","Unexpected_token","innerType","parseType","createNamedType","STRINGLITERAL","parseTypeName","notNullStart","notNull","OPENBRACKET","bracketStart","CLOSEBRACKET","bracketRange","nullable","isSignature","firstParamNameNoType","firstParamKind","paramStart","DOT_DOT_DOT","COLON","QUESTION","A_rest_parameter_cannot_be_optional","createParameter","createOmittedType","EQUALS_GREATERTHAN","createFunctionType","createPropertyAccessExpression","createDecorator","parseArguments","isFor","parseVariableDeclaration","createVariableStatement","SEMICOLON","parentFlags","parentDecorators","isIllegalVariableIdentifier","Initializers_are_not_allowed_in_ambient_contexts","parseExpression","A_definite_assignment_assertion_is_not_permitted_in_this_context","createVariableDeclaration","OPENBRACE","CLOSEBRACE","parseEnumValue","createEnumDeclaration","createEnumValueDeclaration","nextToken","createReturnStatement","seenOptional","typeParameter","parseTypeParameter","Required_type_parameters_may_not_follow_optional_type_parameters","Type_parameter_list_cannot_be_empty","EXTENDS","createTypeParameter","seenRest","reportedRest","parseParameter","A_rest_parameter_must_be_last_in_a_parameter_list","A_required_parameter_cannot_follow_an_optional_parameter","isRest","isOptional","startRange","accessFlags","A_parameter_property_cannot_be_declared_using_a_rest_parameter","A_rest_parameter_cannot_have_an_initializer","Parameter_cannot_have_question_mark_and_initializer","signatureStart","parseTypeParameters","parseParameters","isSetter","A_set_accessor_must_have_exactly_one_parameter","A_set_accessor_parameter_cannot_have_an_initializer","A_get_accessor_cannot_have_parameters","parseBlockStatement","createFunctionDeclaration","createEmptyIdentifierExpression","parseFunctionExpressionCommon","explicitThis","bodyExpression","createExpressionStatement","createFunctionExpression","IMPLEMENTS","Interface_declaration_cannot_have_implements_clause","createInterfaceDeclaration","createClassDeclaration","parseClassMember","createClassExpression","accessStart","accessEnd","staticStart","staticEnd","GENERIC_CONTEXT","readonlyStart","readonlyEnd","isGetter","getStart","getEnd","setEnd","isGetterOrSetter","createConstructorExpression","retIndex","parseIndexSignature","ALWAYS","typeParametersStart","Type_parameters_cannot_appear_on_a_constructor_declaration","An_accessor_cannot_have_type_parameters","createFieldDeclaration","_0_keyword_cannot_be_used_here","Type_annotation_cannot_appear_on_a_constructor_declaration","A_set_accessor_cannot_have_a_return_type_annotation","Method_0_cannot_have_an_implementation_because_it_is_marked_abstract","retMethod","createMethodDeclaration","Constructor_implementation_is_missing","Optional_properties_are_not_supported","retField","createIndexSignature","createNamespaceDeclaration","parseExportMember","FROM","createStringLiteralExpression","createExportStatement","asIdentifier","createExportMember","skipFrom","parseImportDeclaration","createImportDeclaration","createWildcardImportStatement","createImportStatement","createExportImportStatement","topLevel","parseBreak","parseContinue","parseDoStatement","parseForStatement","parseIfStatement","A_return_statement_can_only_be_used_within_a_function_body","parseReturn","createEmptyStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVoidStatement","parseWhileStatement","parseExpressionStatement","createBlockStatement","createBreakStatement","createContinueStatement","createDoStatement","OF","parseForOfStatement","The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer","createForStatement","createForOfStatement","elseStatement","ELSE","createIfStatement","switchCases","switchCase","parseSwitchCase","createSwitchStatement","CASE","createSwitchCase","_case_or_default_expected","createThrowStatement","CATCH","FINALLY","createTryStatement","createTypeDeclaration","createVoidStatement","createWhileStatement","YIELD","DELETE","createUnaryPrefixExpression","The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access","arguments_","tryParseTypeArgumentsBeforeArguments","createNewExpression","createNullExpression","createTrueExpression","createFalseExpression","createThisExpression","again","parseFunctionExpression","inner","createParenthesizedExpression","maybeParseCallExpression","createOmittedExpression","createArrayLiteralExpression","createObjectLiteralExpression","createAssertionExpression","identifierText","_super_must_be_followed_by_an_argument_list_or_member_access","createSuperExpression","INTEGERLITERAL","createIntegerLiteralExpression","readInteger","FLOATLITERAL","createFloatLiteralExpression","readFloat","regexpPattern","readRegexpPattern","createRegexpLiteralExpression","readRegexpFlags","parseClassExpression","Unexpected_end_of_text","Expression_expected","Type_argument_list_cannot_be_empty","precedence","parseExpressionStart","nextPrecedence","determinePrecedence","createInstanceOfExpression","createElementAccessExpression","createUnaryPostfixExpression","createTernaryExpression","commaExprs","createCommaExpression","joinPropertyCall","createBinaryExpression","potentiallyGeneric","createCallExpression","skipBlock","depth","IN","Precedence","QueuedImport","localFile","localIdentifier","foreignIdentifier","foreignPath","foreignPathAlt","QueuedExport","QueuedExportStar","pathLiteral","fromDecorator","UNCHECKED_INDEXED_GET","UNCHECKED_INDEXED_SET","INVALID","fromBinaryToken","fromUnaryPrefixToken","fromUnaryPostfixToken","nextClassId","nextSignatureId","initialized","wrapperClasses","uniqueSignatures","_arrayBufferViewInstance","_arrayBufferInstance","_arrayPrototype","_staticArrayPrototype","_setPrototype","_mapPrototype","_functionPrototype","_int8ArrayPrototype","_int16ArrayPrototype","_int32ArrayPrototype","_int64ArrayPrototype","_uint8ArrayPrototype","_uint8ClampedArrayPrototype","_uint16ArrayPrototype","_uint32ArrayPrototype","_uint64ArrayPrototype","_float32ArrayPrototype","_float64ArrayPrototype","_stringInstance","_allocInstance","_reallocInstance","_freeInstance","_newInstance","_renewInstance","_retainInstance","_releaseInstance","_collectInstance","_visitInstance","_typeinfoInstance","_instanceofInstance","_newBufferInstance","_newArrayInstance","_BLOCKInstance","_OBJECTInstance","_runtimeHeaderSize","nativeDummySignature","nativeSource","Resolver","nativeFile","File","cached","requireClass","lookupFunction","requireFunction","blockOverhead","BLOCKInstance","AL_MASK","headerSize","decoratorFlags","registerNativeType","TypeDefinition","makeNativeTypeDeclaration","queuedImports","queuedExports","queuedExportsStar","queuedExtends","queuedImplements","initializeExports","initializeExportDefault","initializeImports","initializeVariables","initializeClass","initializeEnum","initializeFunction","initializeInterface","initializeNamespace","initializeTypeDefinition","starExports","foreignFile","lookupForeignFile","ensureExportStar","madeProgress","queuedImport","lookupForeign","splice","asAliasNamespace","Module_0_has_no_exported_member_1","exportNames","queuedExport","ensureExport","globalElement","isDeclaredElement","registerWrapperClass","thisPrototype","baseElement","Class_0_is_final_and_cannot_be_extended","Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa","A_class_may_only_extend_another_class","INTERFACE_PROTOTYPE","An_interface_can_only_extend_an_interface","implementsNodes","implementsNode","interfaceElement","interfacePrototype","interfacePrototypes","A_class_can_only_implement_an_interface","markVirtuals","firstChar","markModuleExports","thisInstanceMembers","baseInstanceMembers","thisMember","baseMember","thisMethod","baseMethod","visibilityEquals","Overload_signatures_must_all_be_public_private_or_protected","baseMethodInstances","thisProperty","baseProperty","baseGetter","getterPrototype","thisGetter","baseGetterInstances","baseSetter","setterPrototype","thisSetter","baseSetterInstances","nextPrototype","markModuleExport","classElement","wrappedType","isIntegerInclReference","Global","makeNativeVariableDeclaration","merged","tryMerge","lookupExport","fileQueuedExports","queuedExportForeignPath","acceptedFlags","fromKind","Duplicate_decorator","ClassPrototype","checkDecorators","Unmanaged_classes_cannot_implement_interfaces","memberDeclarations","memberDeclaration","initializeField","methodDeclaration","initializeProperty","method","initializeMethod","FieldPrototype","addInstance","checkOperatorOverloads","firstArg","_0_is_not_a_valid_operator","Duplicate_function_implementation","operatorKind","parentMembers","PropertyPrototype","Duplicate_property_0","ensureProperty","Enum","initializeEnumValue","EnumValue","initializeExport","queued","endsWith","Export_declaration_conflicts_with_exported_declaration_of_0","initializeImport","validDecorators","InterfacePrototype","initializeFieldAsProperty","Namespace","copyMembers","cyclics","Element","shadowType","FILE","localIdentifierIfImport","originalDeclaration","reportedIdentifier","isPublic","vis","declaredElements","DeclaredElement","selfProperty","selfGetter","selfSetter","AcyclicState","typedElements","TypedElement","aliasNamespaces","ensureGlobal","makeNativeNamespaceDeclaration","ns","copyExportsToNamespace","inSelf","ConstantValueKind","VariableLikeElement","i64_zero","boundPrototypes","bound","instanceKey","nameInclTypeParameters","parameterType","parameterName","createParent","registerConcreteElement","getDefaultParameterName","postfix","setDebugLocation","toBound","_isInterface","basePtototype","Class","_id","_acyclic","implementers","isBuiltinArray","lengthField","inheritedTypeArguments","baseName","baseType","iface","uncheckedOverload","overhead","baseOffset","typeKind","i64_is","writeI32AsI64","writeI64AsI32","extendedPrototype","float32ArrayPrototype","float64ArrayPrototype","int8ArrayPrototype","int16ArrayPrototype","int32ArrayPrototype","int64ArrayPrototype","uint8ArrayPrototype","uint8ClampedArrayPrototype","uint16ArrayPrototype","uint32ArrayPrototype","uint64ArrayPrototype","acyclic","hasCycle","cyclesTo","exceptIfMember","older","newer","Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local","src","srcMembers","destMembers","asGlobal","cachedDefaultParameterNames","resolveClassPending","ctxElement","ctxTypes","reportMode","resolveNamedType","resolveFunctionType","isSimpleType","simpleName","Type_0_cannot_be_nullable","typeDefinition","resolveBuiltinNativeType","resolveBuiltinIndexofType","resolveBuiltinValueofType","resolveBuiltinReturnTypeType","parameterTypeNode","returnTypeNode","typeArgument","prev","alternativeReportNode","minParameterCount","maxParameterCount","argumentCount","ctxFlow","resolveFunctionInclTypeArguments","typeParameterNames","argumentNodes","argumentExpression","propagateInferredGenericTypes","resolvedTypeArguments","inferredType","Type_argument_expected","ensureResolvedLazyGlobal","isTypedElement","lookupAssertionExpression","lookupBinaryExpression","lookupCallExpression","lookupCommaExpression","lookupElementAccessExpression","lookupFunctionExpression","lookupThisExpression","lookupSuperExpression","lookupInstanceOfExpression","lookupLiteralExpression","lookupNewExpression","lookupPropertyAccessExpression","lookupTernaryExpression","lookupUnaryPostfixExpression","lookupUnaryPrefixExpression","resolveAssertionExpression","resolveBinaryExpression","resolveCallExpression","resolveCommaExpression","resolveElementAccessExpression","resolveFunctionExpression","resolveIdentifierExpression","resolveThisExpression","resolveSuperExpression","resolveInstanceOfExpression","resolveLiteralExpression","resolveNewExpression","resolvePropertyAccessExpression","resolveTernaryExpression","resolveUnaryPostfixExpression","resolveUnaryPrefixExpression","getElementOfType","targetNode","propertyName","variableLikeElement","wrapper","baseInstance","i64_is_i8","i64_is_u8","i64_is_i16","i64_is_u16","i64_is_bool","Type_0_is_illegal_in_this_context","superLocal","fltType","numNullLiterals","The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly","varType","varElement","thenType","elseType","typesToString","resolvedInstance","getResolvedInstance","classTypeArguments","classTypeParameters","numClassTypeArguments","classTypeParameterName","numFunctionTypeArguments","signatureParameters","numSignatureParameters","parameterDeclaration","nameInclTypeParamters","Interface","pendingClasses","anyPending","_0_is_referenced_directly_or_indirectly_in_its_own_base_expression","setBase","addInterface","finishResolveClass","unimplemented","ifaceMembers","isCompatibleOverride","This_overload_signature_is_not_compatible_with_its_implementation_signature","identifierAndSignatureRange","baseMembers","instanceMemberPrototypes","properties","fieldTypeNode","baseField","Field","propertyGetter","propertySetter","Getter_and_setter_accessors_do_not_agree_in_visibility","Property_0_only_has_a_setter_and_is_missing_a_getter","Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2","overloadKind","overloadPrototype","IndexSignature","pending","dependsOnInstance","_values2","Property","tokenFromKeyword","ASYNC","AWAIT","DEBUGGER","IS","KEYOF","MODULE","PACKAGE","WITH","tokenIsAlsoIdentifier","identifierHandling","unsafeNext","maxTokenLength","chr","isDecimalDigit","commentStartPos","LINE","TRIPLE","closed","testInteger","isIdentifierStart","isKeywordCharacter","posBefore","isIdentifierPart","keywordToken","isWhiteSpace","Invalid_character","checkOnNewLine","maxCompoundLength","tokenBefore","tokenPosBefore","reusableState","State","Unterminated_string_literal","readEscapeSequence","readExtendedUnicodeEscape","readUnicodeEscape","readHexadecimalEscape","fromCharCode","escaped","Unterminated_regular_expression_literal","Invalid_regular_expression_flags","readHexInteger","readBinaryInteger","readOctalInteger","isOctalDigit","Octal_literals_are_not_allowed_in_strict_mode","readDecimalInteger","sepEnd","i64_4","i64_shl","Numeric_separators_are_not_allowed_here","Multiple_consecutive_numeric_separators_are_not_permitted","Hexadecimal_digit_expected","i64_10","Digit_expected","i64_3","Octal_digit_expected","i64_1","Binary_digit_expected","readDecimalFloat","sepCount","readDecimalFloatPartial","replaceAll","parseFloat","allowLeadingZeroSep","remain","value32","invalid","An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive","Unterminated_Unicode_escape_sequence","TypeKind","TypeFlags","_nonNullableType","_nullableType","nullableType","signednessIsRelevant","currentClass","targetClass","currentFunction","targetFunction","isVectorValue","signednessIsImportant","validWat","nullablePostfix","numTypes","signatureTypes","numParameterTypes","nativeTypes","thisThisType","otherThisType","thisParameterTypes","otherParameterTypes","requireSameSize","targetThisType","targetParameterTypes","thisParameterType","targetParameterType","thisReturnType","targetReturnType","optionalStart","restIndex","cloneParameterTypes","readI32","readI64","i32_as_f32","f32_as_i32","i64_as_f64","valueI64","f64_as_i64","overrides","cloned","v","x","separator","ipos","dirname","origin","CharCode","c0","lookupInUnicodeMap","unicodeIdentifierStart","unicodeIdentifierPart","map","mid","midVal","unmanaged","g","toText","wrapModule","emitStackIR","emitText","toAsmjs","emitAsmjs","keys","i64_one","i64_neg_one","i64_pow","rightLo","rightHi","i64_div","i64_rem","i64_rem_u","i64_and","i64_or","i64_xor","i64_shr","i64_not","i64_eq","i64_ne","minSafeF32","MIN_SAFE_INTEGER","maxSafeF32","MAX_SAFE_INTEGER","i64_is_f32","minSafeF64","maxSafeF64","i64_is_f64","fround","globalScope","window","ASC_FEATURE_MUTABLE_GLOBAL","UnreachableError","captureStackTrace","AssertionError","defaultComparator","nanA","nanB","defineProperties","writable","Infinity","NaN","clz32","round","y","sign","isTrueish","CHUNKSIZE","apply","parts","fromCodePoint","search","replacment","split","arraySort","comparator","Number","sincos_sin","sincos_cos","signbit","Boolean","sincos","sin","cos","exp2","arguments","byteOffset","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","globalThis"],"mappings":"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+EACA,mGACA,uKACA,6FACA,2JACA,uFACA,iGACA,qHACA,qGACA,+DACA,iEACA,iGACA,uFACA,yDACA,uGACA,qHACA,yEACA,yLACA,qIACA,2GACA,6IACA,uIACA,uIACA,+GACA,iGACA,yHACA,2EACA,oEACA,oDACA,oCACA,8FACA,kEACA,8CACA,gHACA,oHACA,8HACA,0GACA,8GACA,4EACA,oFACA,oGACA,0GACA,oHACA,wFACA,gFACA,kIACA,kIACA,4FACA,oHACA,oFACA,kFACA,wKACA,sLACA,kIACA,oDACA,wCACA,oJACA,gDACA,kGACA,wGACA,0CACA,kEACA,0DACA,gDACA,gEACA,sIACA,4IACA,0DACA,4DACA,wEACA,sDACA,4FACA,4FACA,oHACA,wDACA,sDACA,8HACA,gKACA,oKACA,sFACA,wEACA,sKACA,sJACA,8IACA,wFACA,0IACA,0DACA,kDACA,gFACA,gGACA,gGACA,wDACA,kFACA,sFACA,0GACA,8GACA,wMACA,oFACA,8HACA,0NACA,sFACA,0IACA,gMACA,0LACA,wGACA,oIACA,kIACA,0HACA,wGACA,oIACA,wFACA,4KACA,sHACA,gFACA,oKACA,gLACA,4FACA,0MACA,wKACA,0FACA,kQACA,8DACA,kGACA,gKACA,oIACA,kJACA,0GACA,kKACA,4DACA,oJACA,oJACA,0GACA,0EACA,4FACA,oFACA,sNACA,8FACA,0QACA,kLACA,sLACA,gHACA,sFACA,8IACA,sDACA,0HACA,wEACA,8CACA,4FACA,gIACA,iLACA,+MA9KF,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAkL1B,kCAAuCypD,GACrC,OAAQA,GACN,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,oBACjB,KAAK,IAAK,MAAO,gCACjB,KAAK,IAAK,MAAO,sDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,uDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,iEACjB,KAAK,IAAK,M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A,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAsDxB,SAAY5f,GACV,uBACA,uBACA,uBACA,uBACA,6BACA,6BACA,uBACA,uBACA,uBACA,uBACA,0BACA,0BACA,4BACA,4BACA,4BACA,4BACA,gCACA,gCACA,0BACA,0BACA,wBACA,wBACA,8BACA,8BACA,0BACA,sCACA,sCACA,sCACA,sCACA,sCACA,sCACA,sCACA,sCACA,wCACA,wCACA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,gCACA,8BACA,wCACA,wCAGA,sCACA,wCACA,sCACA,wCACA,wCAGA,4CACA,4CACA,4CACA,4CACA,4CACA,4CACA,4CACA,4CAGA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,0BACA,4BACA,4BACA,oCACA,oCACA,oCACA,4BAEA,4BACA,oCACA,oCACA,oCACA,4BACA,4BACA,oCACA,oCACA,oCACA,4BACA,oCACA,oCACA,4BACA,4BACA,8BACA,8BACA,gCACA,gCACA,oCACA,4BACA,4BACA,8BACA,8BACA,gCACA,gCACA,oCACA,qDACA,qDACA,qDACA,qDACA,mDACA,mDACA,mDACA,mDACA,qDACA,uDACA,qDACA,uDACA,qDACA,uDACA,qDACA,uDA1HF,CAAY,EAAAA,UAAA,EAAAA,QAAO,KA6HnB,SAAY8B,GACV,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,qBACA,uBACA,wBACA,wBACA,wBACA,0BACA,0BACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,sBACA,wBACA,wBACA,wBACA,wBACA,0BACA,0BACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,wBACA,wBACA,wBACA,wBACA,kCACA,wBACA,wBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,wBACA,wBACA,wBACA,wBACA,kCACA,wBACA,wBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBAGA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,yBACA,2BACA,iCACA,6BACA,mCACA,mCACA,6BACA,mCACA,mCACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BACA,6BACA,mCACA,mCACA,6BACA,mCACA,mCACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BAMA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BAKA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BACA,+BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BACA,+BACA,iDACA,iDACA,iDACA,iDACA,qCA5LF,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KA+LpB,SAAYwG,GACV,iBACA,iBACA,iBACA,eACA,iBACA,mBANF,CAAY,EAAAA,cAAA,EAAAA,YAAW,KASvB,SAAY4C,GACV,2CACA,2CACA,2CACA,2CACA,2CACA,2CACA,2CACA,2CARF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAWzB,SAAYW,GACV,2CACA,2CACA,2CACA,2CACA,2CACA,2CANF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KASzB,SAAYqM,GACV,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,4BACA,4BAZF,CAAY,EAAAA,cAAA,EAAAA,YAAW,KAevB,SAAY+B,GACV,6BACA,6BACA,6BACA,6BACA,6BALF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAQzB,SAAYhN,GACV,uCACA,uCACA,uCACA,uCACA,qCACA,qCACA,uCACA,uCACA,uCAC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,wBACA,0BACA,sBACA,0BACA,kBACA,oBACA,4BACA,kBACA,gBACA,gCACA,wBACA,gBACA,gCACA,8BACA,gBACA,sBACA,kBACA,wBACA,8BACA,kBACA,oBACA,gBACA,0BACA,0BACA,8BACA,wBACA,4BACA,wBACA,kBACA,wBACA,sBACA,wBACA,oBACA,sBACA,oBACA,kBACA,oBACA,wBACA,kBACA,oBACA,sBACA,oBACA,sBAIA,8BACA,gCACA,8BACA,gCACA,kCACA,oCACA,kBACA,kCACA,8BACA,sBACA,4BACA,kCACA,0CACA,gDACA,sCACA,gDACA,oDACA,8DACA,gDACA,oBACA,sBACA,8CACA,4BACA,sBACA,0BACA,8BACA,kCACA,8CACA,0DACA,kFACA,8BACA,kBACA,sBACA,kCACA,sBACA,kDACA,0BACA,4BACA,sBACA,yBACA,mCACA,qCACA,2CACA,6DACA,qCACA,yCACA,6DACA,yEACA,iGACA,6CACA,iCACA,qCACA,iBAIA,iCACA,uCACA,yCACA,qCAIA,2BACA,+BArIF,CAAYA,EAAA,EAAAA,QAAA,EAAAA,MAAK,KAwIjB,SAAYmyC,GACV,yBACA,uBACA,uBAHF,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAM9B,qBAgIA,0BAwBA,uCAA4CpxG,GAE1C,OADAsK,OAAOtK,EAAKrI,QACJqI,EAAKkL,WAAW,IACtB,KAAK,IAAY,MAAe,UAARlL,EACxB,KAAK,IAAY,MAAe,OAARA,EACxB,KAAK,IAAY,MAAe,cAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EAE1B,OAAO,GAGT,iCAAsCwyG,GACpC,OAAQA,GACN,KAAKvzC,EAAMw+C,OAAQ,MAAO,SAC1B,KAAKx+C,EAAM4hD,GAAI,MAAO,KACtB,KAAK5hD,EAAMxxD,WAAY,MAAO,aAC9B,KAAKwxD,EAAMvxD,IAAK,MAAO,MACvB,KAAKuxD,EAAMsZ,OAAQ,MAAO,SAC1B,KAAKtZ,EAAM1sD,KAAM,MAAO,OACxB,KAAK0sD,EAAMu+C,MAAO,MAAO,QACzB,KA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,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAEtCC,EAA+B,CACnC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KACxB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,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","file":"assemblyscript.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__911__) {\nreturn ","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n","/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode,\n  isTrivialAlphanum\n} from \"./util\";\n\n/** Indicates the kind of a node. */\nexport enum NodeKind {\n\n  SOURCE,\n\n  // types\n  NAMEDTYPE,\n  FUNCTIONTYPE,\n  TYPENAME,\n  TYPEPARAMETER,\n  PARAMETER,\n\n  // expressions\n  IDENTIFIER,\n  ASSERTION,\n  BINARY,\n  CALL,\n  CLASS,\n  COMMA,\n  ELEMENTACCESS,\n  FALSE,\n  FUNCTION,\n  INSTANCEOF,\n  LITERAL,\n  NEW,\n  NULL,\n  OMITTED,\n  PARENTHESIZED,\n  PROPERTYACCESS,\n  TERNARY,\n  SUPER,\n  THIS,\n  TRUE,\n  CONSTRUCTOR,\n  UNARYPOSTFIX,\n  UNARYPREFIX,\n\n  // statements\n  BLOCK,\n  BREAK,\n  CONTINUE,\n  DO,\n  EMPTY,\n  EXPORT,\n  EXPORTDEFAULT,\n  EXPORTIMPORT,\n  EXPRESSION,\n  FOR,\n  FOROF,\n  IF,\n  IMPORT,\n  RETURN,\n  SWITCH,\n  THROW,\n  TRY,\n  VARIABLE,\n  VOID,\n  WHILE,\n\n  // declaration statements\n  CLASSDECLARATION,\n  ENUMDECLARATION,\n  ENUMVALUEDECLARATION,\n  FIELDDECLARATION,\n  FUNCTIONDECLARATION,\n  IMPORTDECLARATION,\n  INTERFACEDECLARATION,\n  METHODDECLARATION,\n  NAMESPACEDECLARATION,\n  TYPEDECLARATION,\n  VARIABLEDECLARATION,\n\n  // special\n  DECORATOR,\n  EXPORTMEMBER,\n  SWITCHCASE,\n  INDEXSIGNATURE,\n  COMMENT\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    statement: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(statement, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    statement: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, statement, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    statement: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, statement, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    statements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(statements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.LITERAL\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.LITERAL) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.FLOAT:\n        case LiteralKind.INTEGER: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.LITERAL: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.FLOAT:\n          case LiteralKind.INTEGER:\n          case LiteralKind.STRING: return true;\n        }\n        break;\n      }\n      case NodeKind.NULL:\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.CALL) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PROPERTYACCESS) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.THIS);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.SUPER);\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FUNCTIONTYPE) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPENAME, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMEDTYPE, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    var typeArguments = this.typeArguments;\n    return typeArguments !== null && typeArguments.length > 0;\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONTYPE, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEPARAMETER, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport enum ParameterKind {\n  /** No specific flags. */\n  DEFAULT,\n  /** Is an optional parameter. */\n  OPTIONAL,\n  /** Is a rest parameter. */\n  REST\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARAMETER, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  CUSTOM,\n  GLOBAL,\n  OPERATOR,\n  OPERATOR_BINARY,\n  OPERATOR_PREFIX,\n  OPERATOR_POSTFIX,\n  UNMANAGED,\n  FINAL,\n  INLINE,\n  EXTERNAL,\n  BUILTIN,\n  LAZY,\n  UNSAFE,\n  /* Extension add START */\n  MESSAGE,\n  STORAGE,\n  DEPLOYER,\n  CONSTRUCTOR,\n  CONTRACT,\n  DATABASE,\n  PRIMARYID\n  /* Extension add END */\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.IDENTIFIER) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.BUILTIN;\n          break;\n        }\n        /* Extension add START */\n        case CharCode.c: {\n          if (nameStr == 'contract') return DecoratorKind.CONTRACT;\n          if (nameStr == 'constructor') return DecoratorKind.CONSTRUCTOR;\n          break;\n        }\n        case CharCode.d: {\n          if (nameStr == 'deployer') return DecoratorKind.DEPLOYER;\n          break;\n        }\n        /* Extension add END */\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.EXTERNAL;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.FINAL;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.GLOBAL;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.INLINE;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.LAZY;\n          break;\n        }\n        /* Extension add START */\n        case CharCode.m: {\n          if (nameStr == \"message\") return DecoratorKind.MESSAGE;\n          break;\n        }\n        /* Extension add END */\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.OPERATOR;\n          break;\n        }\n        /* Extension add START */\n        case CharCode.s: {\n          if (nameStr == \"storage\") return DecoratorKind.STORAGE;\n          break;\n        }\n        /* Extension add END */\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.UNMANAGED;\n          if (nameStr == \"unsafe\") return DecoratorKind.UNSAFE;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PROPERTYACCESS) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.IDENTIFIER) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OPERATOR_BINARY;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OPERATOR_PREFIX;\n              if (propStr == \"postfix\") return DecoratorKind.OPERATOR_POSTFIX;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.CUSTOM;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DECORATOR, range);\n  }\n}\n\n/** Comment kinds. */\nexport enum CommentKind {\n  /** Line comment. */\n  LINE,\n  /** Triple-slash line comment. */\n  TRIPLE,\n  /** Block comment. */\n  BLOCK\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMENT, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IDENTIFIER, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport enum LiteralKind {\n  FLOAT,\n  INTEGER,\n  STRING,\n  REGEXP,\n  ARRAY,\n  OBJECT\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.LITERAL, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.ARRAY, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  PREFIX,\n  /** An as assertion, i.e. `expr as T`. */\n  AS,\n  /** A non-null assertion, i.e. `!expr`. */\n  NONNULL,\n  /** A const assertion, i.e. `expr as const`. */\n  CONST\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ASSERTION, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BINARY, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CALL, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.CLASS, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMA, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.CONSTRUCTOR;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ELEMENTACCESS, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.FLOAT, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.FUNCTION, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INSTANCEOF, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.INTEGER, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NEW, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments !== null && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.NULL;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.OBJECT, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.OMITTED, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARENTHESIZED, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PROPERTYACCESS, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.REGEXP, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TERNARY, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.STRING, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.SUPER;\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.THIS;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.TRUE;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.FALSE;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPOSTFIX, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPREFIX, operator, operand, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport enum SourceKind {\n  /** User-provided file. */\n  USER = 0,\n  /** User-provided entry file. */\n  USER_ENTRY = 1,\n  /** Library-provided file. */\n  LIBRARY = 2,\n  /** Library-provided entry file. */\n  LIBRARY_ENTRY = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.SOURCE, new Range(0, text.length));\n    var internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    var pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    var kind = this.sourceKind;\n    return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    var lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LINEFEED) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    var l = 0;\n    var r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INDEXSIGNATURE, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BLOCK, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BREAK, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CLASSDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CONTINUE, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DO, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EMPTY, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMVALUEDECLARATION, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTIMPORT, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTMEMBER, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORT, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTDEFAULT, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.EXPRESSION, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FIELDDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOR, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOROF, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  NONE,\n  /** Parenthesized parameter list. */\n  ARROW_PARENTHESIZED,\n  /** Single parameter without parenthesis. */\n  ARROW_SINGLE\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IF, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORTDECLARATION, name, null, CommonFlags.NONE, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORT, range);\n    var normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = normalizedPath;\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.INTERFACEDECLARATION;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.NONE, range);\n    this.kind = NodeKind.METHODDECLARATION;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMESPACEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.RETURN, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCHCASE, range);\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCH, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.THROW, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TRY, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLEDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLE, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VOID, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.WHILE, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  var pos = path.lastIndexOf(\".\");\n  var len = path.length;\n  if (pos >= 0 && len - pos >= 2) { // at least one char plus dot\n    let cur = pos;\n    while (++cur < len) {\n      if (!isTrivialAlphanum(path.charCodeAt(cur))) {\n        assert(false); // not a valid external path\n        return path;\n      }\n    }\n    return path.substring(0, pos);\n  }\n  assert(false); // not an external path\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NAMEDTYPE) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next !== null || name.identifier.text.length > 0);\n  }\n  return false;\n}\n","/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  NativeType,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  SIMDLoadOp,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Field,\n  Global,\n  DecoratorFlags,\n  ClassPrototype,\n  Class\n} from \"./program\";\n\nimport {\n  findUsedLocals,\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const i32_wait = \"~lib/builtins/i32.wait\";\n  export const i64_wait = \"~lib/builtins/i64.wait\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_saturate = \"~lib/builtins/v128.add_saturate\";\n  export const v128_sub_saturate = \"~lib/builtins/v128.sub_saturate\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_widen_low = \"~lib/builtins/v128.widen_low\";\n  export const v128_widen_high = \"~lib/builtins/v128.widen_high\";\n  export const v128_qfma = \"~lib/builtins/v128.qfma\";\n  export const v128_qfms = \"~lib/builtins/v128.qfms\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_saturate_s = \"~lib/builtins/i8x16.add_saturate_s\";\n  export const i8x16_add_saturate_u = \"~lib/builtins/i8x16.add_saturate_u\";\n  export const i8x16_sub_saturate_s = \"~lib/builtins/i8x16.sub_saturate_s\";\n  export const i8x16_sub_saturate_u = \"~lib/builtins/i8x16.sub_saturate_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_any_true = \"~lib/builtins/i8x16.any_true\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_saturate_s = \"~lib/builtins/i16x8.add_saturate_s\";\n  export const i16x8_add_saturate_u = \"~lib/builtins/i16x8.add_saturate_u\";\n  export const i16x8_sub_saturate_s = \"~lib/builtins/i16x8.sub_saturate_s\";\n  export const i16x8_sub_saturate_u = \"~lib/builtins/i16x8.sub_saturate_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_any_true = \"~lib/builtins/i16x8.any_true\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_widen_low_i8x16_s = \"~lib/builtins/i16x8.widen_low_i8x16_s\";\n  export const i16x8_widen_low_i8x16_u = \"~lib/builtins/i16x8.widen_low_i8x16_u\";\n  export const i16x8_widen_high_i8x16_s = \"~lib/builtins/i16x8.widen_high_i8x16_s\";\n  export const i16x8_widen_high_i8x16_u = \"~lib/builtins/i16x8.widen_high_i8x16_u\";\n  export const i16x8_load8x8_s = \"~lib/builtins/i16x8.load8x8_s\";\n  export const i16x8_load8x8_u = \"~lib/builtins/i16x8.load8x8_u\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_any_true = \"~lib/builtins/i32x4.any_true\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_widen_low_i16x8_s = \"~lib/builtins/i32x4.widen_low_i16x8_s\";\n  export const i32x4_widen_low_i16x8_u = \"~lib/builtins/i32x4.widen_low_i16x8_u\";\n  export const i32x4_widen_high_i16x8_s = \"~lib/builtins/i32x4.widen_high_i16x8_s\";\n  export const i32x4_widen_high_i16x8_u = \"~lib/builtins/i32x4.widen_high_i16x8_u\";\n  export const i32x4_load16x4_s = \"~lib/builtins/i32x4.load16x4_s\";\n  export const i32x4_load16x4_u = \"~lib/builtins/i32x4.load16x4_u\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\"; // i64x2 has no .mul\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_any_true = \"~lib/builtins/i64x2.any_true\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\"; // i64x2 has no .eq etc.\n  export const i64x2_trunc_sat_f64x2_s = \"~lib/builtins/i64x2.trunc_sat_f64x2_s\";\n  export const i64x2_trunc_sat_f64x2_u = \"~lib/builtins/i64x2.trunc_sat_f64x2_u\";\n  export const i64x2_load32x2_s = \"~lib/builtins/i64x2.load32x2_s\";\n  export const i64x2_load32x2_u = \"~lib/builtins/i64x2.load32x2_u\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_qfma = \"~lib/builtins/f32x4.qfma\";\n  export const f32x4_qfms = \"~lib/builtins/f32x4.qfms\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_i64x2_s = \"~lib/builtins/f64x2.convert_i64x2_s\";\n  export const f64x2_convert_i64x2_u = \"~lib/builtins/f64x2.convert_i64x2_u\";\n  export const f64x2_qfma = \"~lib/builtins/f64x2.qfma\";\n  export const f64x2_qfms = \"~lib/builtins/f64x2.qfms\";\n\n  export const v8x16_shuffle = \"~lib/builtins/v8x16.shuffle\";\n  export const v8x16_swizzle = \"~lib/builtins/v8x16.swizzle\";\n  export const v8x16_load_splat = \"~lib/builtins/v8x16.load_splat\";\n  export const v16x8_load_splat = \"~lib/builtins/v16x8.load_splat\";\n  export const v32x4_load_splat = \"~lib/builtins/v32x4.load_splat\";\n  export const v64x2_load_splat = \"~lib/builtins/v64x2.load_splat\";\n\n  // internals\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n\n  // std/number.ts\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/bindings/wasi.ts\n  export const wasiAbort = \"~lib/wasi/index/abort\";\n  export const wasiTrace = \"~lib/wasi/index/trace\";\n  export const wasiSeed = \"~lib/wasi/index/seed\";\n}\n\n/** Builtin compilation context. */\nexport class BuiltinContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Global builtins map. */\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n/** Function builtins map. */\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFloatValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isBooleanValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isSignedIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isAssignableTo(compiler.program.stringInstance)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.extends(compiler.program.arrayPrototype)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isArrayLike\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFunction ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isNullableReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.SWALLOW\n  );\n  return module.i32(element !== null ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  return module.i32(getExpressionId(expr) == ExpressionId.Const ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isManaged ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.kind == TypeKind.VOID ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  var signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return module.i32(signatureReference.parameterTypes.length);\n}\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var type = ctx.typeArguments![0];\n  var classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.STRING)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let classMembers = classReference.members;\n    if (classMembers !== null && classMembers.has(fieldName)) {\n      let member = assert(classMembers.get(fieldName));\n      if (member.kind == ElementKind.FIELD) {\n        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var resultType = evaluateConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  var value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return compiler.ensureStaticString(value);\n}\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return module.i32(signatureReference.id);\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference !== null && !classReference.hasDecorator(DecoratorFlags.UNMANAGED)) {\n    return module.i32(classReference.id);\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.idof, builtin_idof);\n\n// === Math ===================================================================================\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ClzI64\n            : UnaryOp.ClzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.CtzI64\n            : UnaryOp.CtzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.PopcntI64\n            : UnaryOp.PopcntI32,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0),\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1),\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, NativeType.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, NativeType.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotlI64\n            : BinaryOp.RotlI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0),\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1),\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, NativeType.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, NativeType.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotrI64\n            : BinaryOp.RotrI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0),\n                module.i32(31)\n              )\n            ),\n            module.local_get(temp1.index, NativeType.I32)\n          ),\n          module.local_get(temp2.index, NativeType.I32)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.ISIZE: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n        let isWasm64 = options.isWasm64;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32,\n          module.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0),\n                isWasm64 ? module.i64(63) : module.i32(31)\n              )\n            ),\n            module.local_get(temp1.index, options.nativeSizeType)\n          ),\n          module.local_get(temp2.index, options.nativeSizeType)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0),\n                module.i64(63)\n              )\n            ),\n            module.local_get(temp1.index, NativeType.I64)\n          ),\n          module.local_get(temp2.index, NativeType.I64)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.USIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.GtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64: { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64: { op = BinaryOp.GtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtI64\n          : BinaryOp.GtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtU64\n          : BinaryOp.GtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op != -1) {\n      let flow = compiler.currentFlow;\n      let nativeType = type.toNativeType();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0),\n        module.local_tee(temp2.index, arg1),\n        module.binary(op,\n          module.local_get(temp1.index, nativeType),\n          module.local_get(temp2.index, nativeType)\n        )\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.LtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:  { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:  { op = BinaryOp.LtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtI64\n          : BinaryOp.LtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtU64\n          : BinaryOp.LtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op != -1) {\n      let flow = compiler.currentFlow;\n      let nativeType = type.toNativeType();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0),\n        module.local_tee(temp2.index, arg1),\n        module.binary(op,\n          module.local_get(temp1.index, nativeType),\n          module.local_get(temp2.index, nativeType)\n        )\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64, arg0);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let arg0 = compiler.compileExpression(operands[0],\n          compiler.options.isWasm64\n            ? Type.f64\n            : Type.f32,\n          Constraints.CONV_IMPLICIT\n        );\n        compiler.currentType = type;\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ReinterpretF64\n            : UnaryOp.ReinterpretF32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), NativeType.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0),\n          module.local_get(temp.index, NativeType.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), NativeType.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0),\n          module.local_get(temp.index, NativeType.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), NativeType.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0),\n            module.local_get(temp.index, NativeType.F32)\n          ),\n          module.f32(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), NativeType.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0),\n            module.local_get(temp.index, NativeType.F64)\n          ),\n          module.f64(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toNativeType(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltins.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(offset: usize, value: T*, offset?: usize, align?: usize) -> void\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toNativeType(), immOffset, immAlign);\n}\nbuiltins.set(BuiltinNames.store, builtin_store);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.div, builtin_div);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toNativeType(),\n    immOffset\n  );\n}\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toNativeType(), immOffset);\n}\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toNativeType());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  var arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.CONV_IMPLICIT\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  var immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toNativeType());\n}\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.i64, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.ISIZE:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.USIZE: return module.atomic_wait(arg0, arg1, arg2, type.toNativeType());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (!type.isAny(TypeFlags.VALUE | TypeFlags.REFERENCE)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.CONV_IMPLICIT));\n}\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var usizeType = compiler.options.usizeType;\n  var offset: i64;\n  if (typeArguments !== null && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.LITERAL || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.ARRAY) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = compiler.compileExpression(elementExpression, elementType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType, elementExpression);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var toType = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.auto);\n  var fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  var evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>NativeType.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>NativeType.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>NativeType.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>NativeType.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  var abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            arg0\n          ),\n          abort\n        );\n      }\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: return module.if(module.ref_is_null(arg0), abort);\n\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.WRAPPED); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0),\n          module.local_get(temp.index, NativeType.I32),\n          abort\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.I64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(temp.index, arg0)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.nativeSizeType)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0),\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0),\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is_null(\n            module.local_tee(temp.index, arg0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltins.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var flow = compiler.currentFlow;\n  var alreadyUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n  flow.set(FlowFlags.UNCHECKED_CONTEXT);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  var expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UNCHECKED_CONTEXT);\n  return expr;\n}\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  var indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length - 1;\n  var operandExprs = new Array<ExpressionRef>(numOperands);\n  var nativeParamTypes = new Array<NativeType>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    nativeParamTypes[i] = compiler.currentType.toNativeType();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(indexArg, operandExprs, createType(nativeParamTypes), returnType.toNativeType());\n}\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var typeArgument = typeArguments[0];\n  var classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  var ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.NONE, ctx.reportNode);\n}\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  checkTypeAbsent(ctx);\n  var operands = ctx.operands;\n  var reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.ERROR\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.ERROR);\n}\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.WARNING);\n}\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.INFO);\n}\nbuiltins.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.CLASS);\n  var classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  var typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  var ftype = typeArguments[0];\n  var signature = assert(ftype.getSignature());\n  var returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  var indexArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.CONV_IMPLICIT);\n  var thisOperand = assert(ctx.operands.shift());\n  var thisType = signature.thisType;\n  var thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.CONV_IMPLICIT);\n  } else if (thisOperand.kind != NodeKind.NULL) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, indexArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nfunction_builtins.set(\"call\", builtin_function_call);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\n  var compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.CONV_EXPLICIT);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltins.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltins.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltins.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltins.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltins.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltins.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltins.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltins.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltins.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltins.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltins.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltins.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltins.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltins.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp), bytes, off);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  compiler.currentType = type;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.CONV_IMPLICIT);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(BinaryOp.SwizzleV8x16, arg0, arg1);\n}\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV8x16, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV16x8, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV32x4, arg0, immOffset, immAlign);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.LoadSplatV32x4, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV64x2, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.LoadI8ToI16x8, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.LoadU8ToU16x8, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.LoadI16ToI32x4, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.LoadU16ToU32x4, arg0, immOffset, immAlign);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.LoadI32ToI64x2, arg0, immOffset, immAlign);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.LoadU32ToU64x2, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.MulI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_saturate<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_saturate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_saturate\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add_saturate, builtin_v128_add_saturate);\n\n// v128.sub_saturate<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_saturate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_saturate\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub_saturate, builtin_v128_sub_saturate);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.ConvertI64x2ToF64x2, arg0);\n      case TypeKind.U64: return module.unary(UnaryOp.ConvertU64x2ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.TruncSatF64x2ToI64x2, arg0);\n      case TypeKind.U64: return module.unary(UnaryOp.TruncSatF64x2ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.widen_low<T!>(a: v128) -> v128\nfunction builtin_v128_widen_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.WidenLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.WidenLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.WidenLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.WidenLowU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.widen_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_widen_low, builtin_v128_widen_low);\n\n// v128.widen_high<T!>(a: v128) -> v128\nfunction builtin_v128_widen_high(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.WidenHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.WidenHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.WidenHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.WidenHighU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.widen_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_widen_high, builtin_v128_widen_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.ISIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndNotV128);\n}\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true<T!>(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AnyTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AnyTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AnyTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AnyTrueI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AnyTrueI64x2\n            : UnaryOp.AnyTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.any_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AllTrueI64x2\n            : UnaryOp.AllTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.qfma<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_qfma(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.simd_ternary(SIMDTernaryOp.QFMAF32x4, arg0, arg1, arg2);\n      case TypeKind.F64: return module.simd_ternary(SIMDTernaryOp.QFMAF64x2, arg0, arg1, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.qfma\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_qfma, builtin_v128_qfma);\n\n// v128.qfms<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_qfms(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.simd_ternary(SIMDTernaryOp.QFMSF32x4, arg0, arg1, arg2);\n      case TypeKind.F64: return module.simd_ternary(SIMDTernaryOp.QFMSF64x2, arg0, arg1, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.qfms\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_qfms, builtin_v128_qfms);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], NativeType.None);\n}\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], NativeType.None);\n}\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// i32.wait -> atomic.wait<i32>\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\n\n// i64.wait -> atomic.wait<i64>\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.mul -> v128.mul<i8>\nfunction builtin_i8x16_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_mul, builtin_i8x16_mul);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_saturate_s -> v128.add_saturate<i8>\nfunction builtin_i8x16_add_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_saturate_s, builtin_i8x16_add_saturate_s);\n\n// i8x16.add_saturate_u -> v128.add_saturate<u8>\nfunction builtin_i8x16_add_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_saturate_u, builtin_i8x16_add_saturate_u);\n\n// i8x16.sub_saturate_s -> v128.sub_saturate<i8>\nfunction builtin_i8x16_sub_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_saturate_s, builtin_i8x16_sub_saturate_s);\n\n// i8x16.sub_saturate_u -> v128.sub_saturate<u8>\nfunction builtin_i8x16_sub_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_saturate_u, builtin_i8x16_sub_saturate_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.any_true -> v128.any_true<i8>\nfunction builtin_i8x16_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_any_true, builtin_i8x16_any_true);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_saturate_s -> v128.add_saturate<i16>\nfunction builtin_i16x8_add_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_saturate_s, builtin_i16x8_add_saturate_s);\n\n// i16x8.add_saturate_u -> v128.add_saturate<u16>\nfunction builtin_i16x8_add_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_saturate_u, builtin_i16x8_add_saturate_u);\n\n// i16x8.sub_saturate_s -> v128.sub_saturate<i16>\nfunction builtin_i16x8_sub_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_saturate_s, builtin_i16x8_sub_saturate_s);\n\n// i16x8.sub_saturate_u -> v128.sub_saturate<u16>\nfunction builtin_i16x8_sub_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_saturate_u, builtin_i16x8_sub_saturate_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.any_true -> v128.any_true<i16>\nfunction builtin_i16x8_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_any_true, builtin_i16x8_any_true);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.widen_low_i8x16_s -> v128.widen_low<i8>\nfunction builtin_i16x8_widen_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_low_i8x16_s, builtin_i16x8_widen_low_i8x16_s);\n\n// i16x8.widen_low_i8x16_u -> v128.widen_low<u8>\nfunction builtin_i16x8_widen_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_low_i8x16_u, builtin_i16x8_widen_low_i8x16_u);\n\n// i16x8.widen_high_i8x16_s -> v128.widen_high<i8>\nfunction builtin_i16x8_widen_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_high_i8x16_s, builtin_i16x8_widen_high_i8x16_s);\n\n// i16x8.widen_high_i8x16_u -> v128.widen_high<u8>\nfunction builtin_i16x8_widen_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_high_i8x16_u, builtin_i16x8_widen_high_i8x16_u);\n\n// i16x8.load8x8_s -> v128.load_ext<i8>\nfunction builtin_i16x8_load8x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_load8x8_s, builtin_i16x8_load8x8_s);\n\n// i16x8.load8x8_u -> v128.load_ext<u8>\nfunction builtin_i16x8_load8x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_load8x8_u, builtin_i16x8_load8x8_u);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.any_true -> v128.any_true<i32>\nfunction builtin_i32x4_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_any_true, builtin_i32x4_any_true);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.widen_low_i16x8_s -> // v128.widen_low<i16>\nfunction builtin_i32x4_widen_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_low_i16x8_s, builtin_i32x4_widen_low_i16x8_s);\n\n// i32x4.widen_low_i16x8_u -> v128.widen_low<u16>\nfunction builtin_i32x4_widen_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_low_i16x8_u, builtin_i32x4_widen_low_i16x8_u);\n\n// i32x4.widen_high_i16x8_s -> v128.widen_high<i16>\nfunction builtin_i32x4_widen_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_high_i16x8_s, builtin_i32x4_widen_high_i16x8_s);\n\n// i32x4.widen_high_i16x8_u -> v128.widen_high<u16>\nfunction builtin_i32x4_widen_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_high_i16x8_u, builtin_i32x4_widen_high_i16x8_u);\n\n// i32x4.load16x4_s -> v128.load_ext<i16>\nfunction builtin_i32x4_load16x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_load16x4_s, builtin_i32x4_load16x4_s);\n\n// i32x4.load16x4_u -> v128.load_ext<u16>\nfunction builtin_i32x4_load16x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_load16x4_u, builtin_i32x4_load16x4_u);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.any_true -> v128.any_true<i64>\nfunction builtin_i64x2_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_any_true, builtin_i64x2_any_true);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.trunc_sat_f64x2_s -> v128.trunc_sat<i64>\nfunction builtin_i64x2_trunc_sat_f64x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_trunc_sat_f64x2_s, builtin_i64x2_trunc_sat_f64x2_s);\n\n// i64x2.trunc_sat_f64x2_u -> v128.trunc_sat<u64>\nfunction builtin_i64x2_trunc_sat_f64x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_trunc_sat_f64x2_u, builtin_i64x2_trunc_sat_f64x2_u);\n\n// i64x2.load32x2_s -> v128.load_ext<i32>\nfunction builtin_i64x2_load32x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_load32x2_s, builtin_i64x2_load32x2_s);\n\n// i64x2.load32x2_u -> v128.load_ext<u32>\nfunction builtin_i64x2_load32x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_load32x2_u, builtin_i64x2_load32x2_u);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.qfma -> v128.qfma<f32>\nfunction builtin_f32x4_qfma(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfma(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_qfma, builtin_f32x4_qfma);\n\n// f32x4.qfms -> v128.qfms<f32>\nfunction builtin_f32x4_qfms(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfms(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_qfms, builtin_f32x4_qfms);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_i64x2_s -> v128.convert<i64>\nfunction builtin_f64x2_convert_i64x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_i64x2_s, builtin_f64x2_convert_i64x2_s);\n\n// f64x2.convert_i64x2_u -> v128.convert<u64>\nfunction builtin_f64x2_convert_i64x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_i64x2_u, builtin_f64x2_convert_i64x2_u);\n\n// f64x2.qfma -> v128.qfma<f64>\nfunction builtin_f64x2_qfma(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfma(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_qfma, builtin_f64x2_qfma);\n\n// f64x2.qfms -> v128.qfms<f64>\nfunction builtin_f64x2_qfms(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfms(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_qfms, builtin_f64x2_qfms);\n\n// v8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_v8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.v8x16_shuffle, builtin_v8x16_shuffle);\n\n// v8x16.swizzle -> v128.swizzle\nfunction builtin_v8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.v8x16_swizzle, builtin_v8x16_swizzle);\n\n// v8x16.load_splat -> v128.load_splat<u8>\nfunction builtin_v8x16_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v8x16_load_splat, builtin_v8x16_load_splat);\n\n// v16x8.load_splat -> v128.load_splat<u16>\nfunction builtin_v16x8_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v16x8_load_splat, builtin_v16x8_load_splat);\n\n// v32x4.load_splat -> v128.load_splat<u32>\nfunction builtin_v32x4_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v32x4_load_splat, builtin_v32x4_load_splat);\n\n// v64x2.load_splat -> v128.load_splat<u64>\nfunction builtin_v64x2_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v64x2_load_splat, builtin_v64x2_load_splat);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  var module = compiler.module;\n  var exprs = new Array<ExpressionRef>();\n  var nativeSizeType = compiler.options.nativeSizeType;\n  var visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.GLOBAL) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference !== null &&\n      !classReference.hasDecorator(DecoratorFlags.UNMANAGED) &&\n      global.is(CommonFlags.COMPILED)\n    ) {\n      if (global.is(CommonFlags.INLINED)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value))\n            ], NativeType.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, nativeSizeType)\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, nativeSizeType), // tempRef != null\n              module.local_get(0, NativeType.I32) // cookie\n            ], NativeType.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    NativeType.I32,  // cookie\n    NativeType.None, // => void\n    [ nativeSizeType ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var nativeSizeType = usizeType.toNativeType();\n  var nativeSizeSize = usizeType.byteSize;\n  var visitInstance = assert(program.visitInstance);\n  var body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  var base = instance.base;\n  if (base) {\n    body.push(\n      module.call(base.internalName + \"~visit\", [\n        module.local_get(0, nativeSizeType), // this\n        module.local_get(1, NativeType.I32)  // cookie\n      ], NativeType.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  var hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.lookupInSelf(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, nativeSizeType), // this\n            module.local_get(1, NativeType.I32)  // cookie\n          ], NativeType.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  var needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind == ElementKind.FIELD) {\n          if ((<Field>member).parent === instance) {\n            let fieldType = (<Field>member).type;\n            if (fieldType.isManaged) {\n              let fieldOffset = (<Field>member).memoryOffset;\n              assert(fieldOffset >= 0);\n              needsTempValue = true;\n              body.push(\n                // if ($2 = value) __visit($2, $1)\n                module.if(\n                  module.local_tee(2,\n                    module.load(nativeSizeSize, false,\n                      module.local_get(0, nativeSizeType),\n                      nativeSizeType, fieldOffset\n                    )\n                  ),\n                  module.call(visitInstance.internalName, [\n                    module.local_get(2, nativeSizeType), // value\n                    module.local_get(1, NativeType.I32)  // cookie\n                  ], NativeType.None)\n                )\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(instance.internalName + \"~visit\",\n    createType([nativeSizeType, NativeType.I32]),\n    NativeType.None,\n    needsTempValue ? [ nativeSizeType ] : null,\n    module.flatten(body, NativeType.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base) ensureVisitMembersOf(compiler, base);\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var nativeSizeType = usizeType.toNativeType();\n  var managedClasses = program.managedClasses;\n  var visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  var names = new Array<string>();\n  var cases = new Array<ExpressionRef>();\n  var nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    cases[i] = module.block(null, [\n      module.call(instance.internalName + \"~visit\", [\n        module.local_get(0, nativeSizeType), // this\n        module.local_get(1, NativeType.I32)  // cookie\n      ], NativeType.None),\n      module.return()\n    ], NativeType.None);\n    ensureVisitMembersOf(compiler, instance);\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  var current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        nativeSizeType == NativeType.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, nativeSizeType),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, nativeSizeType),\n              module.i32(8) // rtId is at -8\n            ),\n        NativeType.I32, 0\n      )\n    )\n  ], NativeType.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], NativeType.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], NativeType.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ nativeSizeType, NativeType.I32 ]), // this, cookie\n    NativeType.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  var flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.SIGNED)) flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.FLOAT)) flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.NULLABLE)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged) flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var managedClasses = program.managedClasses;\n  var count = managedClasses.size;\n  var size = 4 + 8 * count;\n  var data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  var off = 4;\n  var abvInstance = program.arrayBufferViewInstance;\n  var abvPrototype = abvInstance.prototype;\n  var arrayPrototype = program.arrayPrototype;\n  var setPrototype = program.setPrototype;\n  var mapPrototype = program.mapPrototype;\n  var staticArrayPrototype = program.staticArrayPrototype;\n  var lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isAcyclic) flags |= TypeinfoFlags.ACYCLIC;\n    if (instance !== abvInstance && instance.extends(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extends(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extends(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n    let base = instance.base;\n    writeI32(base ? base.id : 0, data, off); off += 4;\n  }\n  assert(off == size);\n  var usizeType = program.options.usizeType;\n  var segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, NativeType.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, NativeType.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */\nexport function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {\n  var module = compiler.module;\n  var nativeSizeType = compiler.options.nativeSizeType;\n  var instanceofInstance = assert(prototype.program.instanceofInstance);\n  compiler.compileFunction(instanceofInstance);\n\n  var stmts = new Array<ExpressionRef>();\n\n  // if (!ref) return false\n  stmts.push(\n    module.if(\n      module.unary(\n        nativeSizeType == NativeType.I64\n          ? UnaryOp.EqzI64\n          : UnaryOp.EqzI32,\n        module.local_get(0, nativeSizeType)\n      ),\n      module.return(\n        module.i32(0)\n      )\n    )\n  );\n\n  // if (__instanceof(ref, ID[i])) return true\n  var instances = prototype.instances;\n  if (instances !== null && instances.size > 0) {\n    // TODO: for (let instance of instances.values()) {\n    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      stmts.push(\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(0, nativeSizeType),\n            module.i32(instance.id)\n          ], NativeType.I32),\n          module.return(\n            module.i32(1)\n          )\n        )\n      );\n    }\n  }\n\n  // return false\n  stmts.push(\n    module.return(\n      module.i32(0)\n    )\n  );\n\n  module.addFunction(prototype.internalName + \"~instanceof\", nativeSizeType, NativeType.I32, null, module.flatten(stmts));\n}\n\n// Helpers\n\n/** Evaluates the constant type of a type argument *or* expression. */\nfunction evaluateConstantType(ctx: BuiltinContext): Type | null {\n  var compiler = ctx.compiler;\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments !== null && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT);\n    } else {\n      compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments !== null && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  var module = compiler.module;\n  var value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  var align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\n  var compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var compiler = ctx.compiler;\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\n  var operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  var module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n","/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport enum CommonFlags {\n  /** No flags set. */\n  NONE = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  IMPORT = 1 << 0,\n  /** Has an `export` modifier. */\n  EXPORT = 1 << 1,\n  /** Has a `declare` modifier. */\n  DECLARE = 1 << 2,\n  /** Has a `const` modifier. */\n  CONST = 1 << 3,\n  /** Has a `let` modifier. */\n  LET = 1 << 4,\n  /** Has a `static` modifier. */\n  STATIC = 1 << 5,\n  /** Has a `readonly` modifier. */\n  READONLY = 1 << 6,\n  /** Has an `abstract` modifier. */\n  ABSTRACT = 1 << 7,\n  /** Has a `public` modifier. */\n  PUBLIC = 1 << 8,\n  /** Has a `private` modifier. */\n  PRIVATE = 1 << 9,\n  /** Has a `protected` modifier. */\n  PROTECTED = 1 << 10,\n  /** Has a `get` modifier. */\n  GET = 1 << 11,\n  /** Has a `set` modifier. */\n  SET = 1 << 12,\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DEFINITELY_ASSIGNED = 1 << 13,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  AMBIENT = 1 << 14,\n  /** Is generic. */\n  GENERIC = 1 << 15,\n  /** Is part of a generic context. */\n  GENERIC_CONTEXT = 1 << 16,\n  /** Is an instance member. */\n  INSTANCE = 1 << 17,\n  /** Is a constructor. */\n  CONSTRUCTOR = 1 << 18,\n  /** Is a module export. */\n  MODULE_EXPORT = 1 << 19,\n  /** Is a module import. */\n  MODULE_IMPORT = 1 << 20,\n\n  // Compilation states\n\n  /** Is resolved. */\n  RESOLVED = 1 << 21,\n  /** Is compiled. */\n  COMPILED = 1 << 22,\n  /** Did error. */\n  ERRORED = 1 << 23,\n  /** Has a constant value and is therefore inlined. */\n  INLINED = 1 << 24,\n  /** Is scoped. */\n  SCOPED = 1 << 25,\n  /** Is a stub. */\n  STUB = 1 << 26,\n  /** Is a virtual method. */\n  VIRTUAL = 1 << 27,\n  /** Is (part of) a closure. */\n  CLOSURE = 1 << 28,\n\n  // Other\n\n  /** Is quoted. */\n  QUOTED = 1 << 29\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const EMPTY = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const exnref = \"exnref\";\n  export const anyref = \"anyref\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_NO_TREESHAKING = \"ASC_NO_TREESHAKING\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_WASI = \"ASC_WASI\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Exnref = \"Exnref\";\n  export const Anyref = \"Anyref\";\n  export const String = \"String\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const retain = \"__retain\";\n  export const release = \"__release\";\n  export const collect = \"__collect\";\n  export const typeinfo = \"__typeinfo\";\n  export const instanceof_ = \"__instanceof\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n","/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\nimport {\n  BuiltinNames,\n  BuiltinContext,\n  builtins,\n  function_builtins,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI,\n  compileClassInstanceOf\n} from \"./builtins\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  NativeType,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetIndex,\n  needsExplicitUnreachable,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  createType,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  INSTANCE_DELIMITER,\n  STATIC_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  featureToString\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  Enum,\n  Field,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind,\n  findUsedLocals\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  Range,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToNativeTypes\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  uniqueMap,\n  isPowerOf2,\n  v128_zero\n} from \"./util\";\n\n/** Compiler options. */\nexport class Options {\n\n  /** WebAssembly target. Defaults to {@link Target.WASM32}. */\n  target: Target = Target.WASM32;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** If true, generates an explicit start function. */\n  explicitStart: bool = false;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MUTABLE_GLOBALS;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.WASM64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the native size type matching the target. */\n  get nativeSizeType(): NativeType {\n    return this.target == Target.WASM64 ? NativeType.I64 : NativeType.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  NONE = 0,\n\n  /** Must implicitly convert to the target type. */\n  CONV_IMPLICIT = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  CONV_EXPLICIT = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MUST_WRAP = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WILL_DROP = 1 << 3,\n  /** Indicates that the value will be retained immediately. */\n  WILL_RETAIN = 1 << 4,\n  /** Indicates that static data is preferred. */\n  PREFER_STATIC = 1 << 5,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IS_THIS = 1 << 6\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  NONE = 0,\n  /** Requires heap setup. */\n  HEAP = 1 << 0,\n  /** Requires runtime type information setup. */\n  RTTI = 1 << 1,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 2,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 3,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 4\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the explicit start function, if applicable. */\n  export const start = \"_start\"; // match WASI\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n  /** Name of the memory instance, if exported. */\n  export const memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const table = \"table\";\n}\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Module instance being compiled. */\n  module: Module;\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.NONE;\n  /** Expressions known to have skipped an autorelease. Usually function returns. */\n  skippedAutoreleases: Set<ExpressionRef> = new Set();\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending class-specific instanceof helpers. */\n  pendingClassInstanceOf: Set<ClassPrototype> = new Set();\n  /** Functions potentially involving a virtual call. */\n  virtualCalls: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    var options = program.options;\n    var module = Module.create();\n    this.module = module;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    var featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SIGN_EXTENSION)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MUTABLE_GLOBALS)) featureFlags |= FeatureFlags.MutableGloabls;\n    if (options.hasFeature(Feature.NONTRAPPING_F2I)) featureFlags |= FeatureFlags.NontrappingFPToInt;\n    if (options.hasFeature(Feature.BULK_MEMORY)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.SIMD)) featureFlags |= FeatureFlags.SIMD128;\n    if (options.hasFeature(Feature.THREADS)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.EXCEPTION_HANDLING)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TAIL_CALLS)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MULTI_VALUE)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.MEMORY64)) featureFlags |= FeatureFlags.Memory64;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    var startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    var options = this.options;\n    var module = this.module;\n    var program = this.program;\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    var startFunctionInstance = this.currentFlow.actualFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    var startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // add mutable heap and rtti base dummies\n    if (options.isWasm64) {\n      module.addGlobal(BuiltinNames.heap_base, NativeType.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.rtti_base, NativeType.I64, true, module.i64(0));\n    } else {\n      module.addGlobal(BuiltinNames.heap_base, NativeType.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.rtti_base, NativeType.I32, true, module.i32(0));\n    }\n\n    // compile entry file(s) while traversing reachable elements\n    var files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.compileFile(file);\n        this.compileExports(file);\n      }\n    }\n\n    // compile the start function if not empty or if explicitly requested\n    var startIsEmpty = !startFunctionBody.length;\n    var explicitStart = program.isWasi || options.explicitStart;\n    if (!startIsEmpty || explicitStart) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && explicitStart) {\n        module.addGlobal(BuiltinNames.started, NativeType.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, NativeType.I32),\n            module.return(),\n            module.global_set(BuiltinNames.started, module.i32(1))\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.nativeParams,\n        signature.nativeResults,\n        typesToNativeTypes(startFunctionInstance.additionalLocals),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (!explicitStart) module.setStart(funcRef);\n      else module.addFunctionExport(startFunctionInstance.internalName, ExportNames.start);\n    }\n\n    // check if the entire program is acyclic\n    var cyclicClasses = program.findCyclicClasses();\n    if (cyclicClasses.size) {\n      if (options.pedantic) {\n        // TODO: for (let classInstance of cyclicClasses) {\n        for (let _values = Set_values(cyclicClasses), i = 0, k = _values.length; i < k; ++i) {\n          let classInstance = unchecked(_values[i]);\n          this.pedantic(\n            DiagnosticCode.Type_0_is_cyclic_Module_will_include_deferred_garbage_collection,\n            classInstance.identifierNode.range, classInstance.internalName\n          );\n        }\n      }\n    } else {\n      program.registerConstantInteger(\"__GC_ALL_ACYCLIC\", Type.bool, i64_new(1, 0));\n    }\n\n    // compile lazy functions\n    var lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending class-specific instanceof helpers\n    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {\n    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {\n      let prototype = unchecked(_values[i]);\n      compileClassInstanceOf(this, prototype);\n    }\n\n    // set up virtual lookup tables\n    var functionTable = this.functionTable;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.VIRTUAL)) {\n        assert(instance.is(CommonFlags.INSTANCE));\n        functionTable[i] = this.ensureVirtualStub(instance); // incl. varargs\n        this.finalizeVirtualStub(instance);\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    var virtualCalls = this.virtualCalls;\n    while (virtualCalls.size) {\n      // finalizing a stub may discover more virtual calls, so do this in a loop\n      for (let _values = Set_values(virtualCalls), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        this.finalizeVirtualStub(instance);\n        virtualCalls.delete(instance);\n      }\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.RTTI) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    // update the heap base pointer\n    var memoryOffset = this.memoryOffset;\n    memoryOffset = i64_align(memoryOffset, options.usizeType.byteSize);\n    var lowMemoryLimit32 = this.options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n    this.memoryOffset = memoryOffset;\n    module.removeGlobal(BuiltinNames.heap_base);\n    if (this.runtimeFeatures & RuntimeFeatures.HEAP) {\n      if (options.isWasm64) {\n        module.addGlobal(\n          BuiltinNames.heap_base,\n          NativeType.I64,\n          false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(\n          BuiltinNames.heap_base,\n          NativeType.I32,\n          false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // set up memory\n    var initialPages: u32 = 0;\n    if (this.options.memoryBase /* is specified */ || this.memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n    var maximumPages = Module.UNLIMITED_MEMORY;\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n    var isSharedMemory = false;\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.THREADS)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      this.memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.memory : null,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) module.addMemoryImport(\"0\", \"env\", \"memory\", isSharedMemory);\n\n    // set up function table (first elem is blank)\n    var tableBase = this.options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    var functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n    module.setFunctionTable(tableBase + functionTable.length, Module.UNLIMITED_TABLE, functionTableNames, module.i32(tableBase));\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\"0\", \"env\", \"table\");\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(\"0\", ExportNames.table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up module exports\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.ensureModuleExports(file);\n    }\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, NativeType.I32, NativeType.None, null,\n        module.global_set(BuiltinNames.argumentsLength, module.local_get(0, NativeType.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n    return module;\n  }\n\n  // === Exports ==================================================================================\n\n  /** Applies the respective module exports for the specified file. */\n  private ensureModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.ensureModuleExport(elementName, element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.ensureModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Applies the respective module export(s) for the specified element. */\n  private ensureModuleExport(name: string, element: Element, prefix: string = \"\"): void {\n    switch (element.kind) {\n\n      // traverse instances\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>element;\n        let functionInstances = functionPrototype.instances;\n        if (functionInstances !== null && functionInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(functionInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (functionPrototype.is(CommonFlags.GENERIC)) {\n          this.warning(\n            DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n            functionPrototype.identifierNode.range\n          );\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        let classPrototype = <ClassPrototype>element;\n        let classInstances = classPrototype.instances;\n        if (classInstances !== null && classInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(classInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (classPrototype.is(CommonFlags.GENERIC)) {\n          this.warning(\n            DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n            classPrototype.identifierNode.range\n          );\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (propertyInstance) this.ensureModuleExport(name, propertyInstance, prefix);\n        break;\n      }\n\n      // export concrete elements\n      case ElementKind.GLOBAL: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n        if (!isConst && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            global.identifierNode.range\n          );\n        } else {\n          if (element.is(CommonFlags.COMPILED)) this.module.addGlobalExport(element.internalName, prefix + name);\n        }\n        break;\n      }\n      case ElementKind.ENUMVALUE: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            enumValue.identifierNode.range\n          );\n        } else {\n          this.module.addGlobalExport(element.internalName, prefix + name);\n        }\n        break;\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.BUILTIN)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.ensureArgumentsLength();\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          if (functionInstance.is(CommonFlags.COMPILED)) this.module.addFunctionExport(functionInstance.internalName, prefix + name);\n        }\n        break;\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.ensureModuleExport(GETTER_PREFIX + name, getterInstance, prefix);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.ensureModuleExport(SETTER_PREFIX + name, setterInstance, prefix);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (element.is(CommonFlags.COMPILED)) {\n          let module = this.module;\n          module.addFunctionExport(fieldInstance.internalGetterName, prefix + GETTER_PREFIX + name);\n          if (!element.is(CommonFlags.READONLY)) {\n            module.addFunctionExport(fieldInstance.internalSetterName, prefix + SETTER_PREFIX + name);\n          }\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>element;\n        // make the class name itself represent its runtime id\n        if (!classInstance.type.isUnmanaged) {\n          let module = this.module;\n          let internalName = classInstance.internalName;\n\n          if (!this.doneModuleExports.has(element)) {\n            module.addGlobal(internalName, NativeType.I32, false, module.i32(classInstance.id));\n            this.doneModuleExports.add(element);\n          }\n          module.addGlobalExport(internalName, prefix + name);\n        }\n        break;\n      }\n\n      // just traverse members below\n      case ElementKind.ENUM:\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.INDEXSIGNATURE: break;\n\n      default: assert(false); // unexpected module export\n    }\n\n    // traverse members\n    var members = element.members;\n    if (members) {\n      let subPrefix = prefix + name + (element.kind == ElementKind.CLASS\n        ? INSTANCE_DELIMITER\n        : STATIC_DELIMITER\n      );\n      if (element.kind == ElementKind.NAMESPACE) {\n        let implicitExport = element.is(CommonFlags.SCOPED);\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (implicitExport || member.is(CommonFlags.EXPORT)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      } else {\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (!member.is(CommonFlags.PRIVATE)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      }\n    }\n  }\n\n  // === Elements =================================================================================\n\n  /** Compiles any element. */\n  compileElement(element: Element, compileMembers: bool = true): void {\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        this.compileGlobal(<Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        this.compileEnum(<Enum>element);\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n          if (functionInstance) this.compileFunction(functionInstance);\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let classInstance = this.resolver.resolveClass(<ClassPrototype>element, null);\n          if (classInstance) this.compileClass(classInstance);\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n        if (propertyInstance) this.compileProperty(propertyInstance);\n        break;\n      }\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.ENUMVALUE:\n      case ElementKind.INDEXSIGNATURE: break;\n      default: assert(false);\n    }\n    if (compileMembers) {\n      let members = element.members;\n      if (members) {\n        // TODO: for (let element of members.values()) {\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let element = unchecked(_values[i]);\n          this.compileElement(element);\n        }\n      }\n    }\n  }\n\n  /** Compiles a file's exports. */\n  compileExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileElement(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.compileFile(exportStar);\n        this.compileExports(exportStar);\n      }\n    }\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    var file: File;\n    var filesByName = this.program.filesByName;\n    var pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.COMPILED)) return;\n    file.set(CommonFlags.COMPILED);\n\n    // compile top-level statements within the file's start function\n    var startFunction = file.startFunction;\n    var startSignature = startFunction.signature;\n    var previousBody = this.currentBody;\n    var startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    var previousFlow = this.currentFlow;\n    var flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    this.finishAutoreleases(flow, startFunctionBody);\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<NativeType>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toNativeType();\n      module.addFunction(\n        startFunction.internalName,\n        startSignature.nativeParams,\n        startSignature.nativeResults,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      previousBody.push(\n        module.call(startFunction.internalName, null, NativeType.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.COMPILED)) return !global.is(CommonFlags.ERRORED);\n    global.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    var module = this.module;\n    var initExpr: ExpressionRef = 0;\n    var typeNode = global.typeNode;\n    var initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.RESOLVED)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.checkTypeSupported(global.type, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MUST_WRAP | Constraints.WILL_RETAIN | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.ERRORED);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.is(CommonFlags.AMBIENT) && global.hasDecorator(DecoratorFlags.BUILTIN)) {\n      if (global.internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.HEAP;\n      else if (global.internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.RTTI;\n      pendingElements.delete(global);\n      return true;\n    }\n\n    var type = global.type;\n    var nativeType = type.toNativeType();\n    var isDeclaredConstant = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n    var isDeclaredInline = global.hasDecorator(DecoratorFlags.INLINE);\n\n    // Handle imports\n    if (global.is(CommonFlags.AMBIENT)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n        global.set(CommonFlags.MODULE_IMPORT);\n        mangleImportName(global, global.declaration);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          nativeType,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.ERRORED);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    var initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP | Constraints.WILL_RETAIN | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant, attempt to precompute\n      if (getExpressionId(initExpr) != ExpressionId.Const) {\n        if (isDeclaredConstant) {\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              initializeInStart = true;\n            }\n          }\n          if (this.skippedAutoreleases.has(initExpr)) this.skippedAutoreleases.add(initExpr);\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.AMBIENT)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>NativeType.I32: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>NativeType.I64: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>NativeType.F32: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>NativeType.F64: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.ERRORED);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.INLINED); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.INLINED)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PREFER_STATIC | Constraints.WILL_RETAIN);\n      } else {\n        initExpr = this.makeZero(type, global.declaration);\n      }\n    }\n\n    var internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.INLINE, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, nativeType, true, this.makeZero(type, global.declaration));\n      if (type.isManaged && !this.skippedAutoreleases.has(initExpr)) initExpr = this.makeRetain(initExpr, type);\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, nativeType, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.COMPILED)) return !element.is(CommonFlags.ERRORED);\n    element.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    var module = this.module;\n    var previousParent = this.currentParent;\n    this.currentParent = element;\n    var previousValue: EnumValue | null = null;\n    var previousValueIsMut = false;\n    var isInline = element.is(CommonFlags.CONST) || element.hasDecorator(DecoratorFlags.INLINE);\n\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.COMPILED);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.CONV_IMPLICIT // autorelease is not applicable in i32 context\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, NativeType.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, NativeType.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.MODULE_EXPORT)) {\n              module.addGlobal(enumValue.internalName, NativeType.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, NativeType.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.COMPILED)) return !instance.is(CommonFlags.ERRORED);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.BUILTIN)) return true;\n      if (instance.hasDecorator(DecoratorFlags.LAZY)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    instance.set(CommonFlags.COMPILED);\n    var pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    var previousType = this.currentType;\n    var module = this.module;\n    var signature = instance.signature;\n    var bodyNode = instance.prototype.bodyNode;\n    var declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FUNCTIONDECLARATION || declarationNode.kind == NodeKind.METHODDECLARATION);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    var funcRef: FunctionRef;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.AMBIENT)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name\n      if (instance.hasDecorator(DecoratorFlags.EXTERNAL)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator = assert(findDecorator(DecoratorKind.EXTERNAL, decoratorNodes));\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          decorator.range, \"external\"\n        );\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      // retain each argument for as long as the function lives\n      let index = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        // In normal instance functions, `this` is effectively a constant\n        // retained elsewhere so does not need to be retained.\n        if (instance.is(CommonFlags.CONSTRUCTOR)) {\n          // Constructors, however, can allocate their own memory, and as such\n          // must refcount the allocation in case something else is `return`ed.\n          flow.setLocalFlag(index, LocalFlags.RETAINED);\n        }\n        ++index;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i, ++index) {\n        let type = parameterTypes[i];\n        if (type.isManaged) {\n          stmts.push(\n            module.local_set(index,\n              this.makeRetain(\n                module.local_get(index, type.toNativeType()),\n                type\n              )\n            )\n          );\n          flow.setLocalFlag(index, LocalFlags.RETAINED);\n        }\n      }\n\n      let body: ExpressionRef;\n      if (this.compileFunctionBody(instance, stmts)) {\n        if (!flow.is(FlowFlags.TERMINATES)) {\n          this.performAutoreleases(flow, stmts);\n          this.finishAutoreleases(flow, stmts);\n        }\n        body = module.flatten(stmts, instance.signature.returnType.toNativeType());\n      } else {\n        body = module.unreachable();\n      }\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.nativeParams,\n        signature.nativeResults,\n        typesToNativeTypes(instance.additionalLocals),\n        body\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.AMBIENT)) {\n      instance.set(CommonFlags.MODULE_IMPORT);\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.nativeParams,\n        signature.nativeResults\n      );\n      funcRef = module.getFunction(instance.internalName);\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.ABSTRACT) || instance.parent.kind == ElementKind.INTERFACE) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.nativeParams,\n        signature.nativeResults,\n        null,\n        module.unreachable()\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        instance.identifierNode.range\n      );\n      funcRef = 0; // TODO?\n      instance.set(CommonFlags.ERRORED);\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    var module = this.module;\n    var bodyNode = assert(instance.prototype.bodyNode);\n    var returnType = instance.signature.returnType;\n    var flow = this.currentFlow;\n    var thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.BLOCK) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.EXPRESSION);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.GET | CommonFlags.SET));\n\n      // take special care of properly retaining the returned value\n      let expr = this.compileReturnedExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.CONV_IMPLICIT);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        let indexBefore = stmts.length;\n        this.performAutoreleases(flow, stmts);\n        this.finishAutoreleases(flow, stmts);\n        let canOverflow = flow.canOverflow(expr, returnType);\n        let nonNull = flow.isNonnull(expr, returnType);\n        if (stmts.length > indexBefore) {\n          let temp = flow.getTempLocal(returnType);\n          if (!canOverflow) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n          if (nonNull) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n          stmts[indexBefore - 1] = module.local_set(temp.index, expr);\n          stmts.push(module.local_get(temp.index, returnType.toNativeType()));\n          flow.freeTempLocal(temp);\n        }\n        if (!canOverflow) flow.set(FlowFlags.RETURNS_WRAPPED);\n        if (nonNull) flow.set(FlowFlags.RETURNS_NONNULL);\n        flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\n      let nativeSizeType = this.options.nativeSizeType;\n      assert(instance.is(CommonFlags.INSTANCE));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.ACCESSES_THIS | FlowFlags.CONDITIONALLY_ACCESSES_THIS) || !flow.is(FlowFlags.TERMINATES)) {\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          module.if(\n            module.unary(nativeSizeType == NativeType.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n              module.local_get(thisLocal.index, nativeSizeType)\n            ),\n            module.local_set(thisLocal.index,\n              this.makeRetain(\n                this.makeAllocation(classInstance),\n                classInstance.type\n              )\n            )\n          )\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n        if (flow.isInline) {\n          let firstStmt = stmts[0]; // `this` alias assignment\n          assert(getExpressionId(firstStmt) == ExpressionId.LocalSet);\n          assert(getLocalSetIndex(firstStmt) == thisLocal.index);\n          allocStmts.unshift(firstStmt);\n          stmts[0] = module.flatten(allocStmts, NativeType.None);\n        } else {\n          stmts.unshift(\n            module.flatten(allocStmts, NativeType.None)\n          );\n        }\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MAY_RETURN_NONTHIS)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MAY_RETURN_NONTHIS) && !classInstance.hasDecorator(DecoratorFlags.FINAL)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        assert(flow.isAnyLocalFlag(thisLocal.index, LocalFlags.ANY_RETAINED));\n        flow.unsetLocalFlag(thisLocal.index, LocalFlags.ANY_RETAINED); // undo\n        this.performAutoreleases(flow, stmts);\n        this.finishAutoreleases(flow, stmts);\n        stmts.push(module.local_get(thisLocal.index, this.options.nativeSizeType));\n        flow.set(FlowFlags.RETURNS | FlowFlags.RETURNS_NONNULL | FlowFlags.TERMINATES);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base !== null && !flow.is(FlowFlags.CALLS_SUPER)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.TERMINATES)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  // === Classes ==================================================================================\n\n  /** Compiles a priorly resolved class. */\n  compileClass(instance: Class): bool {\n    if (instance.is(CommonFlags.COMPILED)) return true;\n    instance.set(CommonFlags.COMPILED);\n    var prototype = instance.prototype;\n    var staticMembers = (<ClassPrototype>prototype).members;\n    if (staticMembers) {\n      // TODO: for (let element of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.GLOBAL: {\n            this.compileGlobal(<Global>element);\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    this.ensureConstructor(instance, instance.identifierNode);\n    this.checkFieldInitialization(instance);\n\n    var instanceMembers = instance.members;\n    if (instanceMembers) {\n      // TODO: for (let element of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.FIELD: {\n            this.compileField(<Field>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Compiles an instance field to a getter and a setter. */\n  compileField(instance: Field): bool {\n    this.compileFieldGetter(instance);\n    this.compileFieldSetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /** Compiles the getter of the specified instance field. */\n  compileFieldGetter(instance: Field): bool {\n    // A getter retains, while a load, as of a field access, does not.\n    if (instance.getterRef) return true;\n    var type = instance.type;\n    var nativeThisType = this.options.nativeSizeType;\n    var nativeValueType = type.toNativeType();\n    var module = this.module;\n    var valueExpr = module.load(type.byteSize, type.isSignedIntegerValue,\n      module.local_get(0, nativeThisType),\n      nativeValueType, instance.memoryOffset\n    );\n    if (type.isManaged) valueExpr = this.makeRetain(valueExpr, type);\n    instance.getterRef = module.addFunction(instance.internalGetterName, nativeThisType, nativeValueType, null, valueExpr);\n    if (instance.setterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles the setter of the specified instance field. */\n  compileFieldSetter(instance: Field): bool {\n    if (instance.setterRef) return true;\n    var type = instance.type;\n    var nativeThisType = this.options.nativeSizeType;\n    var nativeValueType = type.toNativeType();\n    var module = this.module;\n    var valueExpr: ExpressionRef;\n    var varTypes: NativeType[] | null = null;\n    if (type.isManaged) {\n      // Can't use makeReplace here since there's no corresponding flow, so\n      // 0: this, 1: value, 2: oldValue (temp)\n      valueExpr = module.block(null, [\n        module.if(\n          module.binary(nativeValueType == NativeType.I64 ? BinaryOp.NeI64 : BinaryOp.NeI32,\n            // value != (oldValue = this.field)\n            module.local_get(1, nativeValueType),\n            module.local_tee(2,\n              module.load(type.byteSize, false,\n                module.local_get(0, nativeThisType),\n                nativeValueType, instance.memoryOffset\n              )\n            )\n          ),\n          module.block(null, [\n            module.drop(\n              this.makeRetain(module.local_get(1, nativeValueType), type)\n            ),\n            this.makeRelease(module.local_get(2, nativeValueType), type)\n          ])\n        ),\n        module.local_get(1, nativeValueType)\n      ], nativeValueType);\n      varTypes = [ nativeValueType ];\n    } else {\n      valueExpr = module.local_get(1, nativeValueType);\n    }\n    instance.setterRef = module.addFunction(instance.internalSetterName, createType([ nativeThisType, nativeValueType ]), NativeType.None, varTypes,\n      module.store(type.byteSize,\n        module.local_get(0, nativeThisType),\n        valueExpr,\n        nativeValueType, instance.memoryOffset\n      )\n    );\n    if (instance.getterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles a property to a getter and potentially a setter. */\n  compileProperty(instance: Property): bool {\n    this.compilePropertyGetter(instance);\n    this.compilePropertySetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /* Compiles the getter of the specified property. */\n  compilePropertyGetter(instance: Property): bool {\n    var getterInstance = instance.getterInstance;\n    if (getterInstance) {\n      let ret = this.compileFunction(getterInstance);\n      let setterInstance = instance.setterInstance;\n      if (getterInstance.is(CommonFlags.COMPILED) && (!setterInstance || setterInstance.is(CommonFlags.COMPILED))) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  /** Compiles the setter of the specified property. */\n  compilePropertySetter(instance: Property): bool {\n    var setterInstance = instance.setterInstance;\n    if (setterInstance) {\n      let ret = this.compileFunction(setterInstance);\n      let getterInstance = instance.getterInstance;\n      if (getterInstance !== null && getterInstance.is(CommonFlags.COMPILED) && setterInstance.is(CommonFlags.COMPILED)) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    var memoryOffset = i64_align(this.memoryOffset, alignment);\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    // Runtime objects imply a full BLOCK and OBJECT header, see rt/common.ts\n    // ((memoryOffset + sizeof_usize + AL_MASK) & ~AL_MASK) - sizeof_usize\n    var usizeSize = this.options.usizeType.byteSize;\n    var memoryOffset = i64_sub(i64_align(i64_add(this.memoryOffset, i64_new(usizeSize)), 16), i64_new(usizeSize));\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    var program = this.program;\n    var rtHeaderSize = program.runtimeHeaderSize;\n    var stringInstance = assert(program.stringInstance);\n    var stringSegment: MemorySegment;\n    var segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, rtHeaderSize + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    var ptr = i64_add(stringSegment.offset, i64_new(rtHeaderSize));\n    this.currentType = stringInstance.type;\n    if (this.options.isWasm64) {\n      return this.module.i64(i64_low(ptr), i64_high(ptr));\n    } else {\n      assert(i64_is_u32(ptr));\n      return this.module.i32(i64_low(ptr));\n    }\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    var length = values.length;\n    var byteSize = elementType.byteSize;\n    var nativeType = elementType.toNativeType();\n    switch (<u32>nativeType) {\n      case <u32>NativeType.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == nativeType);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == nativeType);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == nativeType);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>NativeType.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == nativeType);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>NativeType.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == nativeType);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>NativeType.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == nativeType);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    var program = this.program;\n    var arrayBufferInstance = program.arrayBufferInstance;\n    var buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    assert(this.writeStaticBuffer(buf, program.runtimeHeaderSize, elementType, values) == buf.length);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(elementType: Type, bufferSegment: MemorySegment): MemorySegment {\n    var program = this.program;\n    var runtimeHeaderSize = program.runtimeHeaderSize;\n    var arrayPrototype = assert(program.arrayPrototype);\n    var arrayInstance = assert(this.resolver.resolveClass(arrayPrototype, [ elementType ]));\n    var bufferLength = bufferSegment.buffer.length - runtimeHeaderSize;\n    var arrayLength = i32(bufferLength / elementType.byteSize);\n    var bufferAddress = i64_add(bufferSegment.offset, i64_new(runtimeHeaderSize));\n\n    var buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.COMPILED) && !instance.is(CommonFlags.STUB));\n    var program = this.program;\n    var memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.runtimeHeaderSize));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.CLASSDECLARATION: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.ENUM);\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potentiall merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.GLOBAL);\n            if (\n              !element.is(CommonFlags.AMBIENT) && // delay imports\n              !element.hasDecorator(DecoratorFlags.LAZY)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element !== null && element.kind == ElementKind.GLOBAL) { // static\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.EXPORT: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath !== null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION:\n      case NodeKind.METHODDECLARATION:\n      case NodeKind.INTERFACEDECLARATION:\n      case NodeKind.INDEXSIGNATURE:\n      case NodeKind.TYPEDECLARATION: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement,\n    /** Whether this is the last statement of the body, if known. */\n    isLastInBody: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.BLOCK: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.BREAK: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.DO: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.FOR: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.FOROF: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.IF: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.RETURN: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.THROW: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.TRY: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.VOID: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.WHILE: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Whether this is an immediate body statement. */\n    isBody: bool = false,\n    /** Statements to append to that is also returned. Created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    var numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    var module = this.module;\n    var flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());\n        break;\n      }\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    var statements = statement.statements;\n    var outerFlow = this.currentFlow;\n    var innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    var stmts = this.compileStatements(statements);\n    if (!innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) this.performAutoreleases(innerFlow, stmts);\n    innerFlow.freeScopedLocals();\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    var flow = this.currentFlow;\n    var breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    var stmts = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, stmts);\n    var parent = flow.parent;\n    while (parent !== null && parent.breakLabel == breakLabel) {\n      this.performAutoreleases(parent, stmts, /* finalize */ false);\n      parent = parent.parent;\n    }\n    flow.freeScopedLocals();\n    stmts.push(module.br(breakLabel));\n    flow.set(FlowFlags.BREAKS);\n    return module.flatten(stmts);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    var flow = this.currentFlow;\n    var continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.CONTINUES | FlowFlags.TERMINATES);\n    var stmts = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, stmts);\n    var current: Flow | null = flow.parent;\n    while (current !== null && current.continueLabel === continueLabel) {\n      this.performAutoreleases(current, stmts, /* finalize */ false);\n      current = current.parent;\n    }\n    flow.freeScopedLocals();\n    stmts.push(module.br(continueLabel));\n    return module.flatten(stmts);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement, null);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                           flow\n    //  (loop $continue                          recompile?\n    //   (body)                                  bodyFlow \n    //   [autorelease]                                    \n    //                                                   breaks or terminates?\n    //   (local.set $tcond (condition))         condFlow \n    //   [autorelease]                                   \n    //   (br_if (local.get $tcond) $continue)  condition?\n    //  )                                     \n    // )                                      \n\n    var label = outerFlow.pushBreakLabel();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"do-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"do-continue|\" + label;\n    flow.continueLabel = continueLabel;\n\n    // Compile the body (always executes)\n    var bodyFlow = flow.fork();\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Shortcut if body never falls through\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      flow.inherit(bodyFlow);\n\n    // Otherwise evaluate the condition\n    } else {\n      this.performAutoreleases(bodyFlow, bodyStmts);\n\n      let condFlow = flow.fork();\n      this.currentFlow = condFlow;\n      let condExpr = this.makeIsTrueish(\n        this.compileExpression(statement.condition, Type.i32),\n        this.currentType,\n        statement.condition\n      );\n      let condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false\n      if (condKind == ConditionKind.FALSE) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        this.performAutoreleases(condFlow, bodyStmts);\n        flow.inherit(bodyFlow);\n\n      // Terminate if condition is always true and body never breaks\n      } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        this.performAutoreleases(condFlow, bodyStmts);\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n        flow.set(FlowFlags.TERMINATES);\n\n      } else {\n        let tcond = condFlow.getTempLocal(Type.bool);\n        bodyStmts.push(\n          module.local_set(tcond.index, condExpr)\n        );\n        this.performAutoreleases(condFlow, bodyStmts);\n        bodyStmts.push(\n          module.br(continueLabel,\n            module.local_get(tcond.index, NativeType.I32)\n          )\n        );\n        condFlow.freeTempLocal(tcond);\n        flow.inherit(condFlow);\n\n        // Detect if local flags are incompatible before and after looping, and\n        // if so recompile by unifying local flags between iterations. Note that\n        // this may be necessary multiple times where locals depend on each other.\n        if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n          outerFlow.popBreakLabel();\n          this.currentFlow = outerFlow;\n          return this.doCompileDoStatement(statement, flow);\n        }\n      }\n    }\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(bodyStmts)\n      )\n    ]);\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.CONV_IMPLICIT);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement, null);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (initializer)                   flow\n    // (block $break                    \n    //  (loop $loop                      recompile?\n    //   (local.set $tcond (condition))  condFlow \n    //   [autorelease]                            \n    //   (if (local.get $tcond)                    condition?\n    //    (block $continue                         \n    //     (body)                       bodyFlow \n    //     [autorelease]                         \n    //    )                                      breaks or terminates?\n    //    (incrementor)                 incrFlow \n    //    [autorelease]                          \n    //                                 \n    //    (br $loop)                  \n    //   )                              \n    //  )                               \n    // )                                \n    // [autorelease]                  \n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    var breakLabel = \"for-break\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"for-continue|\" + label;\n    flow.continueLabel = continueLabel;\n    var loopLabel = \"for-loop|\" + label;\n\n    // Compile initializer if present (but wait with autoreleases)\n    var initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.EXPRESSION ||\n        initializer.kind == NodeKind.VARIABLE\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr: ExpressionRef;\n    var condKind: ConditionKind;\n    var condition = statement.condition;\n    if (condition) {\n      condExpr = this.makeIsTrueish(\n        this.compileExpression(condition, Type.bool),\n        this.currentType,\n        condition\n      );\n      condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false (body never runs)\n      if (condKind == ConditionKind.FALSE) {\n        stmts.push(\n          module.drop(condExpr)\n        );\n        this.performAutoreleases(condFlow, stmts);\n        condFlow.freeScopedLocals();\n        flow.inherit(condFlow);\n        this.performAutoreleases(flow, stmts);\n        flow.freeScopedLocals();\n        outerFlow.inherit(flow);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condKind = ConditionKind.TRUE;\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp while we autorelease\n    var tcond = flow.getTempLocal(Type.bool);\n    var loopStmts = new Array<ExpressionRef>();\n    loopStmts.push(\n      module.local_set(tcond.index, condExpr)\n    );\n    this.performAutoreleases(condFlow, loopStmts);\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Check if body terminates\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n      bodyStmts.push(module.unreachable());\n    } else {\n      this.performAutoreleases(bodyFlow, bodyStmts);\n    }\n    if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n    else flow.inheritBranch(bodyFlow);\n    bodyFlow.freeScopedLocals();\n\n    var ifStmts = new Array<ExpressionRef>();\n    ifStmts.push(\n      module.block(continueLabel, bodyStmts)\n    );\n\n    // Compile the incrementor if it runs\n    // Can still fall through to here if body continues, hence is already known to terminate\n    if (!bodyFlow.is(FlowFlags.TERMINATES) || bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES)) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        let incrFlow = flow.fork();\n        this.currentFlow = incrFlow;\n        ifStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.CONV_IMPLICIT | Constraints.WILL_DROP)\n        );\n        this.performAutoreleases(incrFlow, ifStmts);\n        incrFlow.freeScopedLocals();\n        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing\n        this.currentFlow = flow;\n      }\n\n      ifStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        assert(!bodyFlow.hasScopedLocals);\n        flow.freeScopedLocals();\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement, flow);\n      }\n    }\n    loopStmts.push(\n      module.if(module.local_get(tcond.index, NativeType.I32),\n        module.flatten(ifStmts)\n      )\n    );\n\n    stmts.push(\n      module.block(breakLabel, [\n        module.loop(loopLabel,\n          module.flatten(loopStmts)\n        )\n      ])\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    flow.freeScopedLocals();\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      stmts.push(module.unreachable());\n    } else {\n      this.performAutoreleases(flow, stmts);\n    }\n    this.currentFlow = outerFlow;\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var ifTrue = statement.ifTrue;\n    var ifFalse = statement.ifFalse;\n\n    // (if               flow\n    //  (condition)       condition?\n    //  (block                       \n    //   (ifTrue)         thenFlow \n    //   [autorelease]             \n    //  )                          \n    //  (block                      present?\n    //   (ifFalse)                   elseFlow\n    //   [autorelease]              \n    //  )                           \n    // )                 \n    // ...              \n    // [autorelease]               incl. condition\n\n    // Precompute the condition (always executes)\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.TRUE: {\n        return module.block(null, [\n          module.drop(condExpr),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.FALSE: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExpr),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExpr);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    var flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    var thenStmts = new Array<ExpressionRef>();\n    var thenFlow = flow.fork();\n    this.currentFlow = thenFlow;\n    thenFlow.inheritNonnullIfTrue(condExpr);\n    if (ifTrue.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    var thenTerminates = thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n    if (thenTerminates) {\n      thenStmts.push(module.unreachable());\n    } else {\n      this.performAutoreleases(thenFlow, thenStmts);\n    }\n    thenFlow.freeScopedLocals();\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    if (ifFalse) {\n      let elseStmts = new Array<ExpressionRef>();\n      let elseFlow = flow.fork();\n      this.currentFlow = elseFlow;\n      elseFlow.inheritNonnullIfFalse(condExpr);\n      if (ifFalse.kind == NodeKind.BLOCK) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      let elseTerminates = elseFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n      if (elseTerminates) {\n        elseStmts.push(module.unreachable());\n      } else {\n        this.performAutoreleases(elseFlow, elseStmts);\n      }\n      elseFlow.freeScopedLocals();\n      this.currentFlow = flow;\n      flow.inheritMutual(thenFlow, elseFlow);\n      return module.if(condExpr,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      flow.inheritBranch(thenFlow);\n      flow.inheritNonnullIfFalse(condExpr,\n        thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)\n          ? null     // thenFlow terminates: just inherit\n          : thenFlow // must become nonnull in thenFlow otherwise\n      );\n      return module.if(condExpr,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement,\n    isLastInBody: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var expr: ExpressionRef = 0;\n    var flow = this.currentFlow;\n    var returnType = flow.returnType;\n\n    var valueExpression = statement.value;\n    if (valueExpression) {\n      if (returnType == Type.void) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          valueExpression.range, this.currentType.toString(), returnType.toString()\n        );\n        this.currentType = Type.void;\n        return module.unreachable();\n      }\n      let constraints = Constraints.CONV_IMPLICIT;\n      if (flow.actualFunction.is(CommonFlags.MODULE_EXPORT)) constraints |= Constraints.MUST_WRAP;\n\n      // take special care of properly retaining the returned value\n      expr = this.compileReturnedExpression(valueExpression, returnType, constraints);\n      if (flow.actualFunction.is(CommonFlags.CONSTRUCTOR) && valueExpression.kind != NodeKind.THIS) {\n        flow.set(FlowFlags.MAY_RETURN_NONTHIS);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      expr = module.unreachable();\n    }\n\n    var stmts = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, stmts);\n    this.finishAutoreleases(flow, stmts);\n\n    if (returnType != Type.void && stmts.length > 0) {\n      let temp = flow.getTempLocal(returnType);\n      if (flow.isNonnull(expr, returnType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n      stmts.unshift(\n        module.local_set(temp.index, expr)\n      );\n      expr = module.local_get(temp.index, returnType.toNativeType());\n      flow.freeTempLocal(temp);\n    }\n    flow.freeScopedLocals();\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n\n    // If the last statement anyway, make it the block's return value\n    if (isLastInBody && expr != 0 && returnType != Type.void) {\n      if (!stmts.length) return expr;\n      stmts.push(expr);\n      return module.flatten(stmts, returnType.toNativeType());\n    }\n\n    // When inlining, break to the end of the inlined function's block (no need to wrap)\n    if (flow.isInline) {\n      if (!stmts.length) return module.br(assert(flow.inlineReturnLabel), 0, expr);\n      stmts.push(module.br(assert(flow.inlineReturnLabel), 0, expr));\n      // stmts.push(module.createUnreachable());\n      return module.flatten(stmts);\n    }\n\n    // Otherwise emit a normal return\n    if (!stmts.length) return module.return(expr);\n    stmts.push(module.return(expr));\n    return module.flatten(stmts);\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    var module = this.module;\n\n    var cases = statement.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return this.compileExpression(statement.condition, Type.void,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n\n    // Everything within a switch uses the same break context\n    var outerFlow = this.currentFlow;\n    var context = outerFlow.pushBreakLabel();\n\n    // introduce a local for evaluating the condition (exactly once)\n    var tempLocal = outerFlow.getTempLocal(Type.u32);\n    var tempLocalIndex = tempLocal.index;\n\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\n    var breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set( // initializer\n      tempLocalIndex,\n      this.compileExpression(statement.condition, Type.u32,\n        Constraints.CONV_IMPLICIT\n      )\n    );\n\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\n    var breakIndex = 1;\n    var defaultIndex = -1;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let label = case_.label;\n      if (label) {\n        breaks[breakIndex++] = module.br(\"case\" + i.toString() + \"|\" + context,\n          module.binary(BinaryOp.EqI32,\n            module.local_get(tempLocalIndex, NativeType.I32),\n            this.compileExpression(label, Type.u32,\n              Constraints.CONV_IMPLICIT\n            )\n          )\n        );\n      } else {\n        defaultIndex = i;\n      }\n    }\n\n    outerFlow.freeTempLocal(tempLocal);\n\n    // otherwise br to default respectively out of the switch if there is no default case\n    breaks[breakIndex] = module.br((defaultIndex >= 0\n      ? \"case\" + defaultIndex.toString()\n      : \"break\"\n    ) + \"|\" + context);\n\n    // nest blocks in order\n    var currentBlock = module.block(\"case0|\" + context, breaks, NativeType.None);\n    var commonCategorical = FlowFlags.ANY_CATEGORICAL;\n    var commonConditional = 0;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Each switch case initiates a new branch\n      let innerFlow = outerFlow.fork();\n      this.currentFlow = innerFlow;\n      let breakLabel = \"break|\" + context;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : \"case\" + (i + 1).toString() + \"|\" + context;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let terminates = false;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n          if (innerFlow.is(FlowFlags.TERMINATES)) terminates = true;\n          break;\n        }\n      }\n      stmts.length = count;\n      if (terminates || isLast || innerFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        commonCategorical &= innerFlow.flags;\n      }\n      commonConditional |= innerFlow.flags & FlowFlags.ANY_CONDITIONAL;\n\n      // Switch back to the parent flow\n      if (!terminates) this.performAutoreleases(innerFlow, stmts);\n      innerFlow.unset(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS\n      );\n      innerFlow.freeScopedLocals();\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, NativeType.None); // must be a labeled block\n    }\n    outerFlow.popBreakLabel();\n\n    // If the switch has a default (guaranteed to handle any value), propagate common flags\n    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.BREAKS;\n    outerFlow.flags |= commonConditional & ~FlowFlags.CONDITIONALLY_BREAKS;\n    // TODO: what about local states?\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    var flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.THROWS | FlowFlags.TERMINATES);\n\n    var stmts = new Array<ExpressionRef>();\n    var value = statement.value;\n    var message: Expression | null = null;\n    if (value.kind == NodeKind.NEW) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    // generates dead code (after unreachable) but still updates state\n    var dropped = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, dropped);\n    this.finishAutoreleases(flow, dropped);\n    flow.freeScopedLocals();\n\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var declarations = statement.declarations;\n    var numDeclarations = declarations.length;\n    var flow = this.currentFlow;\n    var initializers = new Array<ExpressionRef>();\n    var resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n      let initAutoreleaseSkipped = false;\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n          );\n          initAutoreleaseSkipped = this.skippedAutoreleases.has(initExpr);\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto,\n          Constraints.WILL_RETAIN\n        ); // reports\n        initAutoreleaseSkipped = this.skippedAutoreleases.has(initExpr);\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = this.currentType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.CONST);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>NativeType.I32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>NativeType.I64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>NativeType.F32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>NativeType.F64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a virtual local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.LET | CommonFlags.CONST) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.parentFunction.addLocal(type, name, declaration);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        }\n        let isManaged = type.isManaged;\n        if (initExpr) {\n          if (flow.isNonnull(initExpr, type)) flow.setLocalFlag(local.index, LocalFlags.NONNULL);\n          if (isManaged) {\n            flow.setLocalFlag(local.index, LocalFlags.RETAINED);\n            initializers.push(\n              module.local_set(local.index,\n                initAutoreleaseSkipped\n                  ? initExpr\n                  : this.makeRetain(initExpr, type)\n              )\n            );\n          } else {\n            initializers.push(\n              module.local_set(local.index, initExpr)\n            );\n            if (local.type.isShortIntegerValue) {\n              if (!flow.canOverflow(initExpr, type)) flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\n              else flow.unsetLocalFlag(local.index, LocalFlags.WRAPPED);\n            }\n          }\n        } else {\n          if (isManaged) {\n            // This is necessary because the first use (and assign) of the local could be taking place\n            // in a loop, subsequently marking it retained, but the second iteration of the loop\n            // still wouldn't release whatever is assigned in the first. Likewise, if the variable wasn't\n            // initialized but becomes released later on, whatever was stored before would be released.\n            // TODO: Detect this condition inside of a loop instead?\n            initializers.push(\n              module.local_set(local.index,\n                this.makeZero(type, declaration)\n              )\n            );\n            flow.setLocalFlag(local.index, LocalFlags.CONDITIONALLY_RETAINED);\n          } else if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\n          }\n        }\n      }\n    }\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.CONV_EXPLICIT | Constraints.WILL_DROP\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement, null);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                   flow\n    //  (loop $continue                  recompile?\n    //   (local.set $tcond (condition))  condFlow \n    //   [autorelease]                            \n    //   (if (local.get $tcond)                    condition?\n    //    (body)                        bodyFlow \n    //    [autorelease]                          \n    //                                           breaks or terminates?\n    //    (br $continue)               \n    //   )                            \n    //  )                               \n    // )                              \n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"while-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"while-continue|\" + label;\n    flow.continueLabel = continueLabel;\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.FALSE) {\n      stmts.push(\n        module.drop(condExpr)\n      );\n      this.performAutoreleases(condFlow, stmts);\n      assert(!flow.hasScopedLocals);\n      outerFlow.popBreakLabel();\n      this.currentFlow = outerFlow;\n      return module.flatten(stmts);\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp while we autorelease\n    var tcond = flow.getTempLocal(Type.bool);\n    stmts.push(\n      module.local_set(tcond.index, condExpr)\n    );\n    this.performAutoreleases(condFlow, stmts);\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Simplify if body always terminates\n    if (bodyFlow.is(FlowFlags.TERMINATES)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n    // Terminate if condition is always true and body never breaks\n    } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n      this.performAutoreleases(bodyFlow, bodyStmts);\n      bodyStmts.push(\n        module.br(continueLabel)\n      );\n      flow.set(FlowFlags.TERMINATES);\n\n    } else {\n      let breaks = bodyFlow.is(FlowFlags.BREAKS);\n      if (breaks) {\n        bodyStmts.push(\n          module.unreachable()\n        );\n      } else {\n        this.performAutoreleases(bodyFlow, bodyStmts);\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n      }\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      // Here: Only relevant if flow does not always break.\n      if (!breaks && Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        flow.freeTempLocal(tcond);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileWhileStatement(statement, flow);\n      }\n    }\n    stmts.push(\n      module.if(module.local_get(tcond.index, NativeType.I32),\n        module.flatten(bodyStmts)\n      )\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(stmts)\n      )\n    ]);\n    if (condKind == ConditionKind.TRUE && outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.INLINED | CommonFlags.RESOLVED));\n    var type = element.type;\n    switch (\n      !(constraints & (Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT)) &&\n      type.isIntegerValue &&\n      contextualType.isIntegerValue &&\n      type.size < contextualType.size\n        ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension\n        : (this.currentType = type).kind\n    ) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.INTEGER\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.INTEGER\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.BUILTIN) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.PARENTHESIZED) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.ASSERTION: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.BINARY: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.CALL: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.COMMA: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType.signatureReference, constraints);\n        break;\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.THIS:\n      case NodeKind.SUPER:\n      case NodeKind.TRUE: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.NEW: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    var currentType = this.currentType;\n    var wrap = (constraints & Constraints.MUST_WRAP) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.CONV_EXPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = contextualType;\n      } else if (constraints & Constraints.CONV_IMPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Compiles an expression that is about to be returned, taking special care of retaining and setting flow states. */\n  private compileReturnedExpression(\n    /** Expression to compile. */\n    expression: Expression,\n    /** Return type of the function. */\n    returnType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    // pretend to retain the expression immediately so the autorelease, if any, is skipped\n    var expr = this.compileExpression(expression, returnType, constraints | Constraints.WILL_RETAIN);\n    var flow = this.currentFlow;\n    if (returnType.isManaged) {\n      // check if that worked, and if it didn't, keep the reference alive\n      if (!this.skippedAutoreleases.has(expr)) {\n        let index = this.tryUndoAutorelease(expr, flow);\n        if (index == -1) expr = this.makeRetain(expr, returnType);\n        this.skippedAutoreleases.add(expr);\n      }\n    }\n    // remember return states\n    if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n    if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n\n    // void to any\n    if (fromType.kind == TypeKind.VOID) {\n      assert(toType.kind != TypeKind.VOID); // convertExpression should not be called with void -> void\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.VOID) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // downcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // upcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeUpcastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.NONE, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32 : UnaryOp.ExtendU32,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var inheritedConstraints = constraints & ~(Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT);\n    switch (expression.assertionKind) {\n      case AssertionKind.PREFIX:\n      case AssertionKind.AS: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.CONV_EXPLICIT);\n      }\n      case AssertionKind.NONNULL: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.LITERAL && (<LiteralExpression>operand).literalKind == LiteralKind.ARRAY) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.CLASS) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var left = expression.left;\n    var right = expression.right;\n\n    var leftExpr: ExpressionRef;\n    var leftType: Type;\n    var rightExpr: ExpressionRef;\n    var rightType: Type;\n    var commonType: Type | null;\n\n    var expr: ExpressionRef;\n    var compound = false;\n\n    var operator = expression.operator;\n    switch (operator) {\n      case Token.LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LESSTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EQUALS_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EQUALS_EQUALS) { // can't overload '==='\n          let classReference = leftType.getClassOrWrapper(this.program);\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.EQ);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EXCLAMATION_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EXCLAMATION_EQUALS) { // can't overload '!=='\n          let classReference = leftType.getClass();\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.NE);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EQUALS: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.PLUS_EQUALS: compound = true;\n      case Token.PLUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.ADD);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.MINUS_EQUALS: compound = true;\n      case Token.MINUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.SUB);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MUL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK_ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POW);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.SLASH_EQUALS: compound = true;\n      case Token.SLASH: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.DIV);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.PERCENT_EQUALS: compound = true;\n      case Token.PERCENT: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.REM);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;\n      case Token.LESSTHAN_LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR_U);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.AMPERSAND_EQUALS: compound = true;\n      case Token.AMPERSAND: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overloadd\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_AND);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.BAR_EQUALS: compound = true;\n      case Token.BAR: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_OR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.CARET_EQUALS: compound = true;\n      case Token.CARET: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_XOR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & (Constraints.WILL_RETAIN | Constraints.MUST_WRAP);\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfTrue(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n          expr = module.if(\n            this.makeIsTrueish(leftExpr, leftType, left),\n            this.makeIsTrueish(rightExpr, rightType, right),\n            module.i32(0)\n          );\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n\n          // references must properly retain and release, with the same outcome independent of the branch taken\n          if (leftType.isManaged) {\n            let leftAutoreleaseSkipped = this.skippedAutoreleases.has(leftExpr);\n            let rightAutoreleaseSkipped = this.skippedAutoreleases.has(rightExpr);\n            let temp = flow.getTempLocal(leftType);\n            leftExpr = module.local_tee(temp.index, leftExpr);\n\n            // instead of retaining left and releasing it again in right when right\n            // is taken, we can also just retain left if right is not taken\n            let retainLeftInElse = false;\n            if (leftAutoreleaseSkipped != rightAutoreleaseSkipped) { // xor\n              if (!leftAutoreleaseSkipped) {\n                retainLeftInElse = true;\n              } else {\n                rightExpr = this.makeRetain(rightExpr, rightType);\n                rightAutoreleaseSkipped = true;\n              }\n            } else if (!(constraints & Constraints.WILL_RETAIN)) { // otherwise keep right alive a little longer\n              rightExpr = this.delayAutorelease(rightExpr, rightType, rightFlow, flow);\n            }\n\n            let rightStmts = new Array<ExpressionRef>();\n            if (leftAutoreleaseSkipped) { // left turned out to be true'ish and is dropped\n              rightStmts.unshift(\n                this.makeRelease(\n                  module.local_get(temp.index, leftType.toNativeType()),\n                  leftType\n                )\n              );\n            }\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType, rightStmts);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              rightExpr,\n              retainLeftInElse\n                ? this.makeRetain(\n                    module.local_get(temp.index, leftType.toNativeType()),\n                    leftType\n                  )\n                : module.local_get(temp.index, leftType.toNativeType())\n            );\n            if (leftAutoreleaseSkipped || rightAutoreleaseSkipped) this.skippedAutoreleases.add(expr);\n            if (temp) flow.freeTempLocal(temp);\n\n          // basic values can use more aggressive optimizations\n          } else {\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            // simplify if cloning left without side effects is possible\n            if (expr = module.cloneExpression(leftExpr, true, 0)) {\n              expr = module.if(\n                this.makeIsTrueish(leftExpr, this.currentType, left),\n                rightExpr,\n                expr\n              );\n\n            // if not possible, tee left to a temp\n            } else {\n              let tempLocal = flow.getTempLocal(leftType);\n              if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.WRAPPED);\n              if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NONNULL);\n              expr = module.if(\n                this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr), leftType, left),\n                rightExpr,\n                module.local_get(tempLocal.index, leftType.toNativeType())\n              );\n              flow.freeTempLocal(tempLocal);\n            }\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      case Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & (Constraints.WILL_RETAIN | Constraints.MUST_WRAP);\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfFalse(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, leftType);\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n          expr = module.if(\n            this.makeIsTrueish(leftExpr, leftType, left),\n            module.i32(1),\n            this.makeIsTrueish(rightExpr, rightType, right)\n          );\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n\n          // references must properly retain and release, with the same outcome independent of the branch taken\n          if (leftType.isManaged) {\n            let leftAutoreleaseSkipped = this.skippedAutoreleases.has(leftExpr);\n            let rightAutoreleaseSkipped = this.skippedAutoreleases.has(rightExpr);\n            let temp = flow.getTempLocal(leftType);\n            leftExpr = module.local_tee(temp.index, leftExpr);\n\n            // instead of retaining left and releasing it again in right when right\n            // is taken, we can also just retain left if right is not taken\n            let retainLeftInThen = false;\n            if (leftAutoreleaseSkipped != rightAutoreleaseSkipped) { // xor\n              if (!leftAutoreleaseSkipped) {\n                retainLeftInThen = true;\n              } else {\n                rightExpr = this.makeRetain(rightExpr, rightType);\n                rightAutoreleaseSkipped = true;\n              }\n            } else if (!(constraints & Constraints.WILL_RETAIN)) { // otherwise keep right alive a little longer\n              rightExpr = this.delayAutorelease(rightExpr, rightType, rightFlow, flow);\n            }\n\n            let rightStmts = new Array<ExpressionRef>();\n            if (leftAutoreleaseSkipped) { // left turned out to be false'ish and is dropped\n              // TODO: usually, false'ish means left is null, but this might not hold\n              // once implicit conversion with strings is performed and left is \"\", so:\n              rightStmts.unshift(\n                this.makeRelease(\n                  module.local_get(temp.index, leftType.toNativeType()),\n                  leftType\n                )\n              );\n            }\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType, rightStmts);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              retainLeftInThen\n                ? this.makeRetain(\n                    module.local_get(temp.index, leftType.toNativeType()),\n                    leftType\n                  )\n                : module.local_get(temp.index, leftType.toNativeType()),\n              rightExpr\n            );\n            if (leftAutoreleaseSkipped || rightAutoreleaseSkipped) this.skippedAutoreleases.add(expr);\n            if (temp) flow.freeTempLocal(temp);\n\n          // basic values can use more aggressive optimizations\n          } else {\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            // simplify if cloning left without side effects is possible\n            if (expr = module.cloneExpression(leftExpr, true, 0)) {\n              expr = module.if(\n                this.makeIsTrueish(leftExpr, leftType, left),\n                expr,\n                rightExpr\n              );\n\n            // if not possible, tee left to a temp. local\n            } else {\n              let temp = flow.getTempLocal(leftType);\n              if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n              if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n              expr = module.if(\n                this.makeIsTrueish(module.local_tee(temp.index, leftExpr), leftType, left),\n                module.local_get(temp.index, leftType.toNativeType()),\n                rightExpr\n              );\n              flow.freeTempLocal(temp);\n            }\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    var targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr, // TODO: delay release above if possible?\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtI64\n            : BinaryOp.LtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtU64\n            : BinaryOp.LtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtI64\n            : BinaryOp.GtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtU64\n            : BinaryOp.GtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeI64\n            : BinaryOp.LeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeU64\n            : BinaryOp.LeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeI64\n            : BinaryOp.GeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeU64\n            : BinaryOp.GeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.EqI64\n            : BinaryOp.EqI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueI8x16,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AddI64\n            : BinaryOp.AddI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.MulI64\n            : BinaryOp.MulI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookupGlobal(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookupGlobal(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let isWasm64 = this.options.isWasm64;\n        let instance = isWasm64 ? this.i64PowInstance : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookupGlobal(isWasm64 ? CommonNames.ipow64 : CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivI64\n            : BinaryOp.DivI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivU64\n            : BinaryOp.DivU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemI64\n            : BinaryOp.RemI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemU64\n            : BinaryOp.RemU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShlI64\n            : BinaryOp.ShlI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrI64\n            : BinaryOp.ShrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AndI64\n            : BinaryOp.AndI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.OrI64\n            : BinaryOp.OrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.XorI64\n            : BinaryOp.XorI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    var rightType: Type;\n    if (operatorInstance.is(CommonFlags.INSTANCE)) {\n      let classInstance = assert(operatorInstance.parent); assert(classInstance.kind == ElementKind.CLASS);\n      rightType = operatorInstance.signature.parameterTypes[0];\n    } else {\n      // FIXME: if LHS type differs we can't recompile left because that'd completely confuse\n      // local states, like having retained locals that actually do not even exist, possibly\n      // releasing something random in that local before and evil things like that. Hence this\n      // assumes that LHS type matches, which in turn means that static overloads must be\n      // guaranteed to never mismatch LHS type, which in turn means that we can't have shiny\n      // things like multiple static overloads for different combinations of LHS/RHS types.\n      // We might want that at some point of course, but requires to complete the resolver so\n      // it can actually resolve every kind of expression without ever having to recompile.\n      rightType = operatorInstance.signature.parameterTypes[1];\n    }\n    var rightExpr = this.compileExpression(right, rightType, Constraints.CONV_IMPLICIT);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    var program = this.program;\n    var resolver = program.resolver;\n    var flow = this.currentFlow;\n    var target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    var elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    var targetType: Type;\n    switch (target.kind) {\n      case ElementKind.GLOBAL: {\n        // not yet compiled if a static field compiled as a global\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\n        // fall-through\n      }\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this\n        targetType = indexedSet.signature.parameterTypes[1];     // 2nd parameter is the element\n        if (indexedSet.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    var valueExpr = this.compileExpression(valueExpression, targetType, Constraints.WILL_RETAIN);\n    var valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // NOTE: Only locals, globals and fields can make use of skipped autoreleases while\n    // everything else must insert the skipped autorelease now. See (*)\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.CONSTANT, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable();\n        if (target.isAny(CommonFlags.CONST | CommonFlags.READONLY)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let initializerNode = fieldInstance.initializerNode;\n        let isConstructor = flow.actualFunction.is(CommonFlags.CONSTRUCTOR);\n\n        // Cannot assign to readonly fields except in constructors if there's no initializer\n        if (fieldInstance.is(CommonFlags.READONLY)) {\n          if (!isConstructor || initializerNode !== null) {\n            this.error(\n              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n              valueExpression.range, fieldInstance.internalName\n            );\n            return module.unreachable();\n          }\n        }\n\n        // Mark initialized fields in constructors\n        thisExpression = assert(thisExpression);\n        if (isConstructor && thisExpression.kind == NodeKind.THIS) {\n          flow.setThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED);\n        }\n\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        return this.makeFieldAssignment(fieldInstance,\n          valueExpr,\n          valueType,\n          this.compileExpression(\n            thisExpression,\n            (<Class>fieldParent).type,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          ),\n          tee\n        );\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        let valueType = setterInstance.signature.parameterTypes[0];\n        if (this.skippedAutoreleases.has(valueExpr)) valueExpr = this.makeAutorelease(valueExpr, valueType, flow); // (*)\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let nativeReturnType = returnType.toNativeType();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, nativeReturnType)\n            ], valueExpression)\n          ], nativeReturnType);\n          flow.freeTempLocal(tempThis);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toNativeType());\n        }\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.CLASS);\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let valueType = setterInstance.signature.parameterTypes[1];\n        if (this.skippedAutoreleases.has(valueExpr)) valueExpr = this.makeAutorelease(valueExpr, valueType, flow); // (*)\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          classInstance.type,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let elementExpr = this.compileExpression(assert(indexExpression), Type.i32, Constraints.CONV_IMPLICIT);\n        if (tee) {\n          let tempTarget = flow.getTempLocal(classInstance.type);\n          let tempElement = flow.getTempLocal(this.currentType);\n          let returnType = getterInstance.signature.returnType;\n          flow.freeTempLocal(tempTarget);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr),\n              module.local_tee(tempElement.index, elementExpr),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toNativeType()),\n              module.local_get(tempElement.index, tempElement.type.toNativeType())\n            ], valueExpression)\n          ], returnType.toNativeType());\n          flow.freeTempLocal(tempElement);\n          flow.freeTempLocal(tempTarget);\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, possibly retaining and releasing affected references and keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var type = local.type;\n    assert(type != Type.void);\n    var localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NONNULL);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NONNULL);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.INITIALIZED);\n\n    if (type.isManaged) {\n      let alreadyRetained = this.skippedAutoreleases.has(valueExpr);\n      if (flow.isAnyLocalFlag(localIndex, LocalFlags.ANY_RETAINED)) {\n        valueExpr = this.makeReplace(\n          valueExpr,\n          valueType,\n          module.local_get(localIndex, type.toNativeType()),\n          type,\n          alreadyRetained\n        );\n        if (tee) { // local = REPLACE(local, value)\n          this.currentType = type;\n          return module.local_tee(localIndex, valueExpr);\n        } else { // void(local = REPLACE(local, value))\n          this.currentType = Type.void;\n          return module.local_set(localIndex, valueExpr);\n        }\n      } else {\n        flow.unsetLocalFlag(localIndex, LocalFlags.CONDITIONALLY_RETAINED);\n        flow.setLocalFlag(localIndex, LocalFlags.RETAINED);\n        if (!alreadyRetained) valueExpr = this.makeRetain(valueExpr, valueType);\n        if (tee) { // local = __retain(value, local)\n          this.currentType = type;\n          return module.local_tee(localIndex, valueExpr);\n        } else { // void(local = __retain(value, local))\n          this.currentType = Type.void;\n          return module.local_set(localIndex, valueExpr);\n        }\n      }\n    } else {\n      if (type.isShortIntegerValue) {\n        if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.WRAPPED);\n        else flow.unsetLocalFlag(localIndex, LocalFlags.WRAPPED);\n      }\n      if (tee) { // local = value\n        this.currentType = type;\n        return module.local_tee(localIndex, valueExpr);\n      } else { // void(local = value)\n        this.currentType = Type.void;\n        return module.local_set(localIndex, valueExpr);\n      }\n    }\n  }\n\n  /** Makes an assignment to a global, possibly retaining and releasing affected references. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var type = global.type;\n    assert(type != Type.void);\n    var nativeType = type.toNativeType();\n\n    if (type.isManaged) {\n      let alreadyRetained = this.skippedAutoreleases.has(valueExpr);\n      valueExpr = module.global_set(global.internalName,\n        this.makeReplace(\n          valueExpr,\n          valueType,\n          module.global_get(global.internalName, nativeType),\n          type,\n          alreadyRetained\n        )\n      );\n      if (tee) { // (global = REPLACE(global, value))), global\n        this.currentType = type;\n        return module.block(null, [\n          valueExpr,\n          module.global_get(global.internalName, nativeType)\n        ], nativeType);\n      } else { // global = REPLACE(global, value)\n        this.currentType = Type.void;\n        return valueExpr;\n      }\n    } else {\n      valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n      if (tee) { // (global = value), global\n        this.currentType = type;\n        return module.block(null, [\n          module.global_set(global.internalName, valueExpr),\n          module.global_get(global.internalName, nativeType)\n        ], nativeType);\n      } else { // global = value\n        this.currentType = Type.void;\n        return module.global_set(global.internalName,\n          valueExpr\n        );\n      }\n    }\n  }\n\n  /** Makes an assignment to a field, possibly retaining and releasing affected references. */\n  private makeFieldAssignment(\n    /** The field to assign to. */\n    field: Field,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** The value of `this`. */\n    thisExpr: ExpressionRef,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var fieldType = field.type;\n    var nativeFieldType = fieldType.toNativeType();\n    assert(field.parent.kind == ElementKind.CLASS);\n    var thisType = (<Class>field.parent).type;\n    var nativeThisType = thisType.toNativeType();\n\n    if (!field.is(CommonFlags.COMPILED)) {\n      field.set(CommonFlags.COMPILED);\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(field.type, typeNode);\n    }\n\n    if (fieldType.isManaged && thisType.isManaged) {\n      let tempThis = flow.getTempLocal(thisType, findUsedLocals(valueExpr));\n      // set before and read after valueExpr executes below ^\n      let alreadyRetained = this.skippedAutoreleases.has(valueExpr);\n      let ret: ExpressionRef;\n      if (tee) { // ((t1 = this).field = REPLACE(t1.field, t2 = value)), t2\n        let tempValue = flow.getTempLocal(fieldType);\n        if (!flow.canOverflow(valueExpr, fieldType)) flow.setLocalFlag(tempValue.index, LocalFlags.WRAPPED);\n        if (flow.isNonnull(valueExpr, fieldType)) flow.setLocalFlag(tempValue.index, LocalFlags.NONNULL);\n        ret = module.block(null, [\n          module.store(fieldType.byteSize,\n            module.local_tee(tempThis.index, thisExpr),\n            this.makeReplace(\n              module.local_tee(tempValue.index, valueExpr),\n              valueType,\n              module.load(fieldType.byteSize, fieldType.isSignedIntegerValue,\n                module.local_get(tempThis.index, nativeThisType),\n                nativeFieldType, field.memoryOffset\n              ),\n              fieldType,\n              alreadyRetained\n            ),\n            nativeFieldType, field.memoryOffset\n          ),\n          module.local_get(tempValue.index, nativeFieldType)\n        ], nativeFieldType);\n        flow.freeTempLocal(tempValue);\n        this.currentType = fieldType;\n      } else { // (t1 = this).field = REPLACE(t1.field, value)\n        ret = module.store(fieldType.byteSize,\n          module.local_tee(tempThis.index, thisExpr),\n          this.makeReplace(\n            valueExpr,\n            valueType,\n            module.load(fieldType.byteSize, fieldType.isSignedIntegerValue,\n              module.local_get(tempThis.index, nativeThisType),\n              nativeFieldType, field.memoryOffset\n            ),\n            fieldType,\n            alreadyRetained\n          ),\n          nativeFieldType, field.memoryOffset\n        );\n        this.currentType = Type.void;\n      }\n      flow.freeTempLocal(tempThis);\n      return ret;\n    } else {\n      if (tee) { // (this.field = (t1 = value)), t1\n        let temp = flow.getTempLocal(fieldType);\n        if (!flow.canOverflow(valueExpr, fieldType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n        if (flow.isNonnull(valueExpr, fieldType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n        let ret = module.block(null, [\n          module.store(fieldType.byteSize,\n            thisExpr,\n            module.local_tee(temp.index, valueExpr),\n            nativeFieldType, field.memoryOffset\n          ),\n          module.local_get(temp.index, nativeFieldType)\n        ], nativeFieldType);\n        flow.freeTempLocal(temp);\n        this.currentType = fieldType;\n        return ret;\n      } else { // this.field = value\n        this.currentType = Type.void;\n        return module.store(fieldType.byteSize,\n          thisExpr,\n          valueExpr,\n          nativeFieldType, field.memoryOffset\n        );\n      }\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.SUPER) {\n      let flow = this.currentFlow;\n      let actualFunction = flow.actualFunction;\n      if (!actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(actualFunction.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let baseClassInstance = assert(classInstance.base);\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let nativeSizeType = this.options.nativeSizeType;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, nativeSizeType),\n        Constraints.WILL_RETAIN\n      );\n      assert(baseClassInstance.type.isUnmanaged || this.skippedAutoreleases.has(superCall)); // guaranteed\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.ACCESSES_THIS |\n        FlowFlags.CONDITIONALLY_ACCESSES_THIS\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.ACCESSES_THIS | FlowFlags.CALLS_SUPER);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall);\n    }\n\n    // otherwise resolve normally\n    var target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = this.resolver.currentThisExpression;\n\n    var signature: Signature | null;\n    var indexArg: ExpressionRef;\n    switch (target.kind) {\n\n      // direct call: concrete function\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.BUILTIN)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n\n      // indirect call: index argument with signature (non-generic, can't be inlined)\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        signature = local.type.signatureReference;\n        if (signature) {\n          if (local.is(CommonFlags.INLINED)) {\n            indexArg = module.i32(i64_low(local.constantIntegerValue));\n          } else {\n            indexArg = module.local_get(local.index, NativeType.I32);\n          }\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, local.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        signature = global.type.signatureReference;\n        if (signature) {\n          indexArg = module.global_get(global.internalName, global.type.toNativeType());\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, global.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        signature = fieldType.signatureReference;\n        if (signature) {\n          let fieldParent = fieldInstance.parent;\n          assert(fieldParent.kind == ElementKind.CLASS);\n          indexArg = module.load(4, false,\n            this.compileExpression(\n              assert(thisExpression),\n              (<Class>fieldParent).type,\n              Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n            ),\n            NativeType.I32,\n            fieldInstance.memoryOffset\n          );\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, fieldType.toString()\n        );\n        return module.unreachable();\n      }\n\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance);\n        let thisArg: ExpressionRef = 0;\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        indexArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);\n        signature = this.currentType.signatureReference;\n        if (!signature) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>target;\n        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          signature = ftype.getSignature();\n          indexArg = this.compileExpression(expression.expression, ftype, Constraints.CONV_IMPLICIT);\n          break;\n        }\n        // fall-through\n      }\n\n      // not supported\n      default: {\n        let type = this.resolver.getTypeOfElement(target);\n        if (type) {\n          this.error(\n            DiagnosticCode.Type_0_has_no_call_signatures,\n            expression.range, type.toString()\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            expression.range\n          );\n        }\n        return module.unreachable();\n      }\n    }\n    return this.compileCallIndirect(\n      assert(signature), // FIXME: bootstrap can't see this yet\n      indexArg,\n      expression.args,\n      expression,\n      0,\n      contextualType == Type.void\n    );\n  }\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    var typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.actualFunction.parent,\n        uniqueMap<string,Type>(this.currentFlow.contextualTypeArguments),\n        expression\n      );\n    }\n    var callee = expression.expression;\n    var ctx = new BuiltinContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PROPERTYACCESS\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    // global builtins\n    var internalName = prototype.internalName;\n    if (builtins.has(internalName)) {\n      let fn = assert(builtins.get(internalName));\n      return fn(ctx);\n    }\n    // class builtins\n    var parent = prototype.parent;\n    if (parent.kind == ElementKind.CLASS) {\n      let classPrototype = (<Class>parent).prototype;\n      if (classPrototype == this.program.functionPrototype) {\n        let methodName = prototype.name;\n        if (function_builtins.has(methodName)) {\n          let fn = assert(function_builtins.get(methodName));\n          return fn(ctx);\n        }\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    var thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    var hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range,\n        \"Rest parameters\"\n      );\n      return false;\n    }\n\n    var minimum = signature.requiredParameters;\n    var maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n    var signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let actualFunction = this.currentFlow.actualFunction;\n    if (actualFunction.is(CommonFlags.CONSTRUCTOR) && reportNode.isAccessOnThis) {\n      let parent = actualFunction.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.INLINE) && (!instance.is(CommonFlags.VIRTUAL) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        inlineStack.push(instance);\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n            Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n          );\n        }\n        // make the inlined call (is aware of autoreleases)\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WILL_DROP) != 0);\n        if (this.currentType.isManaged) {\n          if (!(constraints & Constraints.WILL_RETAIN)) {\n            expr = this.makeAutorelease(expr, instance.signature.returnType, this.currentFlow);\n          } else {\n            this.skippedAutoreleases.add(expr);\n          }\n        }\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    if (signature.returnType.isManaged) {\n      if (constraints & Constraints.WILL_DROP) {\n        // Skip autorelease and simply release\n        return this.makeCallDirect(instance, operands, reportNode, true);\n      } else if (constraints & Constraints.WILL_RETAIN) {\n        // Skip autorelease and remember\n        let expr = this.makeCallDirect(instance, operands, reportNode, false, true);\n        this.skippedAutoreleases.add(expr);\n        return expr;\n      } else {\n        return this.makeCallDirect(instance, operands, reportNode, false, false);\n      }\n    }\n    return this.makeCallDirect(instance, operands, reportNode,\n      (constraints & Constraints.WILL_DROP) != 0\n    );\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var numArguments = operands ? operands.length : 0;\n    var signature = instance.signature;\n    var parameterTypes = signature.parameterTypes;\n    var numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    var previousFlow = this.currentFlow;\n    var flow = Flow.createInline(previousFlow.parentFunction, instance);\n    var body = [];\n    var usedLocals = new Set<i32>();\n\n    // Prepare compiled arguments right to left, keeping track of used locals.\n    for (let i = numArguments - 1; i >= 0; --i) {\n      // This is necessary because a later expression must not set an earlier argument local, which\n      // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where\n      // the right expression would reassign the foregoing argument local. So, we iterate from right\n      // to left, remembering what's used later, and don't use these for earlier arguments, making\n      // the example above essentially `t2=1, t1=(t1 = 2)`.\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType, usedLocals);\n      findUsedLocals(paramExpr, usedLocals);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\n      // inlining is aware of skipped autoreleases:\n      if (paramType.isManaged) {\n        if (!this.skippedAutoreleases.has(paramExpr)) paramExpr = this.makeRetain(paramExpr, paramType);\n        flow.setLocalFlag(argumentLocal.index, LocalFlags.RETAINED);\n      }\n      body.unshift(\n        module.local_set(argumentLocal.index, paramExpr)\n      );\n    }\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType, usedLocals);\n      // In normal instance functions, `this` is effectively a constant\n      // retained elsewhere so does not need to be retained.\n      if (instance.is(CommonFlags.CONSTRUCTOR)) {\n        // Constructors, however, can allocate their own memory, and as such\n        // must refcount the allocation in case something else is `return`ed.\n        flow.setLocalFlag(thisLocal.index, LocalFlags.RETAINED);\n      }\n      body.unshift(\n        module.local_set(thisLocal.index, thisArg)\n      );\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      if (!flow.canOverflow(initExpr, initType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(initExpr, initType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\n      if (initType.isManaged) {\n        flow.setLocalFlag(argumentLocal.index, LocalFlags.RETAINED);\n        if (!this.skippedAutoreleases.has(initExpr)) initExpr = this.makeRetain(initExpr, initType);\n      }\n      body.push(\n        module.local_set(argumentLocal.index, initExpr)\n      );\n    }\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    if (!flow.is(FlowFlags.TERMINATES)) {\n      this.performAutoreleases(flow, body);\n      this.finishAutoreleases(flow, body);\n    }\n    flow.freeScopedLocals();\n    var returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    var expr = module.block(flow.inlineReturnLabel, body, returnType.toNativeType());\n    this.currentType = returnType;\n    if (returnType.isManaged) {\n      if (immediatelyDropped) {\n        expr = this.makeRelease(expr, returnType);\n        this.currentType = Type.void;\n      }\n    }\n    return expr;\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): void {\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(BuiltinNames.argumentsLength, NativeType.I32, true, module.i32(0));\n    }\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    var stub = original.varargsStub;\n    if (stub) return stub;\n\n    var originalSignature = original.signature;\n    var originalParameterTypes = originalSignature.parameterTypes;\n    var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    var returnType = originalSignature.returnType;\n    var isInstance = original.is(CommonFlags.INSTANCE);\n\n    // arguments excl. `this`, operands incl. `this`\n    var minArguments = originalSignature.requiredParameters;\n    var minOperands = minArguments;\n    var maxArguments = originalParameterTypes.length;\n    var maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    var numOptional = assert(maxOperands - minOperands);\n\n    var forwardedOperands = new Array<ExpressionRef>(minOperands);\n    var operandIndex = 0;\n\n    // forward `this` if applicable\n    var module = this.module;\n    if (isInstance) {\n      forwardedOperands[0] = module.local_get(0, this.options.nativeSizeType);\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, originalParameterTypes[i].toNativeType());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\");\n    stub.signature.requiredParameters = maxArguments;\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    var previousFlow = this.currentFlow;\n    var flow = stub.flow;\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    var numNames = numOptional + 1; // incl. outer block\n    var names = new Array<string>(numNames);\n    var ofN = \"of\" + numOptional.toString();\n    for (let i = 0; i < numNames; ++i) {\n      let label = i.toString() + ofN;\n      names[i] = label;\n    }\n    var body = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(BuiltinNames.argumentsLength, NativeType.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(BuiltinNames.argumentsLength, NativeType.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = module.local_set(operandIndex,\n          this.compileExpression(\n            initializer,\n            type,\n            Constraints.CONV_IMPLICIT\n          )\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      body = module.block(names[i + 1], [\n        body,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toNativeType());\n    }\n    assert(operandIndex == maxOperands);\n\n    var stmts: ExpressionRef[] = [ body ];\n    var theCall = module.call(original.internalName, forwardedOperands, returnType.toNativeType());\n    if (returnType != Type.void) {\n      this.performAutoreleasesWithValue(flow, theCall, returnType, stmts);\n    } else {\n      stmts.push(theCall);\n      this.performAutoreleases(flow, stmts);\n    }\n    flow.freeScopedLocals();\n    this.currentFlow = previousFlow;\n\n    var funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.nativeParams,\n      stub.signature.nativeResults,\n      typesToNativeTypes(stub.additionalLocals),\n      module.flatten(stmts, returnType.toNativeType())\n    );\n    stub.set(CommonFlags.COMPILED);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the virtual stub for the specified function. */\n  ensureVirtualStub(original: Function): Function {\n    // A virtual stub is a function redirecting virtual calls to the actual\n    // overload targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    var stub = original.virtualStub;\n    if (stub) return stub;\n    stub = original.newStub(\"virtual\");\n    original.virtualStub = stub;\n    var module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.nativeParams,\n      stub.signature.nativeResults,\n      null,\n      module.unreachable()\n    );\n    this.virtualCalls.add(original);\n    return stub;\n  }\n\n  /** Finalizes the virtual stub of the specified function. */\n  private finalizeVirtualStub(instance: Function): void {\n    var stub = this.ensureVirtualStub(instance);\n    if (stub.is(CommonFlags.COMPILED)) return;\n\n    // Wouldn't be here if there wasn't at least one overload\n    var overloadPrototypes = assert(instance.prototype.overloads);\n\n    var module = this.module;\n    var usizeType = this.options.usizeType;\n    var nativeSizeType = usizeType.toNativeType();\n    var parameterTypes = instance.signature.parameterTypes;\n    var returnType = instance.signature.returnType;\n    var numParameters = parameterTypes.length;\n    var tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    var builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          nativeSizeType == NativeType.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, nativeSizeType),\n          nativeSizeType == NativeType.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        NativeType.I32\n      )\n    );\n\n    // A method's `overloads` property contains its unbound overload prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved and compiled as\n    // we are going to call them conditionally based on this's class id.\n    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverloadPrototype = _values[i];\n      assert(!unboundOverloadPrototype.isBound);\n      let unboundOverloadParent = unboundOverloadPrototype.parent;\n      let isProperty = unboundOverloadParent.kind == ElementKind.PROPERTY_PROTOTYPE;\n      let classInstances: Map<string,Class> | null;\n      if (isProperty) {\n        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;\n        assert(propertyParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>propertyParent).instances;\n      } else {\n        assert(unboundOverloadParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>unboundOverloadParent).instances;\n      }\n      if (classInstances) {\n        for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n          let classInstance = _values[j];\n          let overloadInstance: Function | null;\n          if (isProperty) {\n            let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));\n            assert(boundProperty.kind == ElementKind.PROPERTY_PROTOTYPE);\n            let boundPropertyInstance = this.resolver.resolveProperty(<PropertyPrototype>boundProperty);\n            if (!boundPropertyInstance) continue;\n            if (instance.is(CommonFlags.GET)) {\n              overloadInstance = boundPropertyInstance.getterInstance;\n            } else {\n              assert(instance.is(CommonFlags.SET));\n              overloadInstance = boundPropertyInstance.setterInstance;\n            }\n          } else {\n            let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));\n            assert(boundPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n            overloadInstance = this.resolver.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n          }\n          if (!overloadInstance || !this.compileFunction(overloadInstance)) continue;\n          let overloadType = overloadInstance.type;\n          let originalType = instance.type;\n          if (!overloadType.isAssignableTo(originalType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()\n            );\n            continue;\n          }\n          // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n          let overloadSignature = overloadInstance.signature;\n          let overloadParameterTypes = overloadSignature.parameterTypes;\n          let overloadNumParameters = overloadParameterTypes.length;\n          let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);\n          paramExprs[0] = module.local_get(0, nativeSizeType); // this\n          for (let n = 1; n <= numParameters; ++n) {\n            paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toNativeType());\n          }\n          let needsVarargsStub = false;\n          for (let n = numParameters; n < overloadNumParameters; ++n) {\n            // TODO: inline constant initializers and skip varargs stub\n            paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n], overloadInstance.declaration);\n            needsVarargsStub = true;\n          }\n          let calledName = needsVarargsStub\n            ? this.ensureVarargsStub(overloadInstance).internalName\n            : overloadInstance.internalName;\n          let nativeReturnType = overloadSignature.returnType.toNativeType();\n          let stmts = new Array<ExpressionRef>();\n          if (needsVarargsStub) {\n            this.ensureArgumentsLength();\n            // Safe to prepend since paramExprs are local.get's\n            stmts.push(module.global_set(BuiltinNames.argumentsLength, module.i32(numParameters)));\n          }\n          if (returnType == Type.void) {\n            stmts.push(\n              module.call(calledName, paramExprs, nativeReturnType)\n            );\n            stmts.push(\n              module.return()\n            );\n          } else {\n            stmts.push(\n              module.return(\n                module.call(calledName, paramExprs, nativeReturnType)\n              )\n            );\n          }\n          builder.addCase(classInstance.id, stmts);\n          // Also alias each extendee inheriting this exact overload\n          let extendees = classInstance.getAllExtendees(\n            isProperty\n              ? unboundOverloadParent.name\n              : instance.prototype.name\n          );\n          for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {\n            let extendee = _values[a];\n            builder.addCase(extendee.id, stmts);\n          }\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extendees inheriting the original function.\n    var body: ExpressionRef;\n    if (instance.prototype.bodyNode) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, nativeSizeType); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toNativeType());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toNativeType());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the virtual stub function\n    var ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.nativeParams,\n      stub.signature.nativeResults,\n      [ NativeType.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toNativeType())\n    );\n    stub.set(CommonFlags.COMPILED);\n  }\n\n  // <reference-counting>\n\n  /** Makes a retain call, retaining the expression's value. */\n  makeRetain(expr: ExpressionRef, type: Type): ExpressionRef {\n    var retainInstance = this.program.retainInstance;\n    this.compileFunction(retainInstance);\n    return this.module.call(retainInstance.internalName, [ expr ], this.options.nativeSizeType);\n  }\n\n  /** Makes a release call, releasing the expression's value. Changes the current type to void.*/\n  makeRelease(expr: ExpressionRef, type: Type): ExpressionRef {\n    var releaseInstance = this.program.releaseInstance;\n    this.compileFunction(releaseInstance);\n    return this.module.call(releaseInstance.internalName, [ expr ], NativeType.None);\n  }\n\n  /** Makes a replace, retaining the new expression's value and releasing the old expression's value, in this order. */\n  makeReplace(\n    /** New value being assigned. */\n    newExpr: ExpressionRef,\n    /** The type of the new expression. */\n    newType: Type,\n    /** Old value being replaced. */\n    oldExpr: ExpressionRef,\n    /** The type of the old expression. */\n    oldType: Type,\n    /** Whether the new value is already retained. */\n    alreadyRetained: bool = false,\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var nativeSizeType = this.options.nativeSizeType;\n    if (alreadyRetained) {\n      // (t1=newExpr), __release(oldExpr), t1\n      // it is important that `newExpr` evaluates before `oldExpr` is released, hence the local\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(oldExpr));\n      let ret = module.block(null, [\n        module.local_set(temp.index, newExpr),\n        this.makeRelease(oldExpr, oldType),\n        module.local_get(temp.index, nativeSizeType)\n      ], nativeSizeType);\n      flow.freeTempLocal(temp);\n      return ret;\n    } else {\n      // if ((t1=newExpr) != (t2=oldExpr)) {\n      //   t1 = __retain(t1);\n      //   __release(t2);\n      // }, t1\n      let usizeType = this.options.usizeType;\n      let temp1 = flow.getTempLocal(usizeType, findUsedLocals(oldExpr));\n      let temp2 = flow.getTempLocal(usizeType);\n      let ret = module.block(null, [\n        module.if(\n          module.binary(nativeSizeType == NativeType.I64 ? BinaryOp.NeI64 : BinaryOp.NeI32,\n            module.local_tee(temp1.index, newExpr),\n            module.local_tee(temp2.index, oldExpr)\n          ),\n          module.block(null, [\n            module.local_set(temp1.index,\n              this.makeRetain(module.local_get(temp1.index, nativeSizeType), newType)\n            ),\n            this.makeRelease(module.local_get(temp2.index, nativeSizeType), oldType)\n          ])\n        ),\n        module.local_get(temp1.index, nativeSizeType)\n      ], nativeSizeType);\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n\n  /** Makes an autorelease call at the end of the specified `flow`. */\n  makeAutorelease(\n    /** Expression to autorelease. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Flow that should autorelease. Defaults to the current flow. */\n    flow: Flow = this.currentFlow\n  ): ExpressionRef {\n    // An 'autorelease' is the assignment of a managed reference to a temporary local,\n    // keeping the reference alive until the surrounding flow concludes. This is useful\n    // if a reference is not being immediately assigned to something that would keep it\n    // alive, like a local or a global, yet it'll remain alive in other code. Example:\n    //\n    //   callReceivingAReference(callReturningAReference())\n    //\n    // will be transformed into an autorelease like\n    //\n    //   callReceivingAReference(t = callReturningAReference())\n    //   ...\n    //   __release(t)\n    //\n    // since releasing immediately would free the value before the call:\n    //\n    //   callReceivingAReference((__release(t = callReturningAReference()), t))\n    //\n    var local = flow.getAutoreleaseLocal(type);\n    if (flow.isNonnull(expr, type)) flow.setLocalFlag(local.index, LocalFlags.NONNULL);\n    return this.module.local_tee(local.index, expr);\n  }\n\n  /**\n   * Attempts to undo an autorelease in the specified `flow`.\n   * Returns the index of the previously retaining variable or -1 if not possible.\n   */\n  tryUndoAutorelease(\n    /** Expression being autoreleased. */\n    expr: ExpressionRef,\n    /** Flow that would autorelease. */\n    flow: Flow\n  ): i32 {\n    // The following assumes that the expression actually belongs to the flow and that\n    // top-level autoreleases are never undone. While that's true, it's not necessary\n    // to check presence in scopedLocals.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalGet: { // local.get(idx)\n        let index = getLocalGetIndex(expr);\n        if (flow.isAnyLocalFlag(index, LocalFlags.ANY_RETAINED)) {\n          flow.unsetLocalFlag(index, LocalFlags.ANY_RETAINED);\n          return index;\n        }\n        break;\n      }\n      case ExpressionId.LocalSet: { // local.tee(idx, expr)\n        if (isLocalTee(expr)) {\n          // NOTE: Can't remove the local.tee completely because it's already compiled\n          // and a child of something else. Preventing the final release however makes\n          // it optimize away.\n          let index = getLocalSetIndex(expr);\n          if (flow.isAnyLocalFlag(index, LocalFlags.ANY_RETAINED)) {\n            flow.unsetLocalFlag(index, LocalFlags.ANY_RETAINED);\n            return index;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Block: { // { ..., local.get|tee(...) }\n        if (getBlockName(expr) === null) { // must not be a break target\n          let count = getBlockChildCount(expr);\n          if (count) {\n            return this.tryUndoAutorelease(getBlockChildAt(expr, count - 1), flow);\n          }\n        }\n        break;\n      }\n    }\n    return -1;\n  }\n\n  /** Delays an autorelease in `innerFlow` until `outerFlow` concludes. */\n  delayAutorelease(\n    /** Expression being autoreleased in `innerFlow`. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Inner flow that would autorelease. Must not have processed autoreleases yet. */\n    innerFlow: Flow,\n    /** Outer flow that should autorelease instead. */\n    outerFlow: Flow\n  ): ExpressionRef {\n    // Attempt to undo the autorelease in `innerFlow`\n    var index = this.tryUndoAutorelease(expr, innerFlow);\n    return ~index\n      // If it worked, autorelease in `outerFlow` instead\n      ? this.makeAutorelease(expr, type, outerFlow)\n      // If it didn't work, extend the lifetime into `outerFlow`\n      : this.makeAutorelease(this.makeRetain(expr, type), type, outerFlow);\n  }\n\n  /** Performs any queued autoreleases in the specified flow. */\n  performAutoreleases(\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[],\n    /**\n     * Whether to finalize affected locals. Defaults to `true`, which\n     * is almost always correct, except when bubbling up parent flows\n     * in break-like scenarios.\n     */\n    finalize: bool = true\n  ): void {\n    // Autoreleases must be performed whenever a flow concludes, decrementing\n    // the RC of all the references in that flow scheduled for an autorelease.\n    var scopedLocals = flow.scopedLocals;\n    if (scopedLocals) {\n      let module = this.module;\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          let localIndex = local.index;\n          if (flow.isAnyLocalFlag(localIndex, LocalFlags.ANY_RETAINED)) {\n            if (finalize) flow.unsetLocalFlag(localIndex, LocalFlags.ANY_RETAINED);\n            stmts.push(\n              this.makeRelease(\n                module.local_get(localIndex, local.type.toNativeType()),\n                local.type\n              )\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /** Performs any queued autoreleases in the specified flow and returns the given value. */\n  performAutoreleasesWithValue(\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Value to return. */\n    valueExpr: ExpressionRef,\n    /** Type of the returned value. */\n    valueType: Type,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[] | null = null,\n    /** Whether to finalize affected locals. */\n    finalize: bool = true\n  ): ExpressionRef {\n    if (!stmts) stmts = new Array<ExpressionRef>();\n    stmts.push(\n      this.module.nop()\n    );\n    var lengthBefore = stmts.length;\n    this.performAutoreleases(flow, stmts, finalize);\n    var module = this.module;\n    if (stmts.length > lengthBefore) {\n      let nativeType = valueType.toNativeType();\n      let temp = flow.getTempLocal(valueType);\n      if (!flow.canOverflow(valueExpr, valueType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(valueExpr, valueType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n      stmts[lengthBefore - 1] = module.local_set(temp.index, valueExpr); // nop -> set\n      stmts.push(\n        module.local_get(temp.index, nativeType) // append get\n      );\n      let ret = module.flatten(stmts, nativeType);\n      flow.freeTempLocal(temp);\n      return ret;\n    } else if (stmts.length > 1) {\n      stmts[lengthBefore - 1] = valueExpr; // nop -> value\n      return module.flatten(stmts, valueType.toNativeType());\n    }\n    return valueExpr;\n  }\n\n  /** Finishes any queued autoreleases in the actual function of the specified flow. */\n  finishAutoreleases(\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[]\n  ): void {\n    // Differs from `performAutoreleases` in that concluding this flow also\n    // concludes all its parent flows, for example on a `return`.\n    if (flow.isInline) {\n      // Traverse to the top-most flow containing the inlined function's\n      // locals as scoped locals and release these instead of all the locals.\n      let current = flow;\n      let parent: Flow | null;\n      while (parent = current.parent) current = parent;\n      let scopedLocals = current.scopedLocals;\n      if (scopedLocals) {\n        // TODO: for (let local of scopedLocals.values()) {\n        for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n          let local = unchecked(_values[i]);\n          this.maybeFinishAutorelease(local, flow, stmts);\n        }\n      }\n    } else {\n      let localsByIndex = flow.parentFunction.localsByIndex;\n      for (let i = 0, k = localsByIndex.length; i < k; ++i) {\n        let local = unchecked(localsByIndex[i]);\n        this.maybeFinishAutorelease(local, flow, stmts);\n      }\n    }\n  }\n\n  /** Finishes a single autorelease of the specified local. */\n  private maybeFinishAutorelease(\n    /** Local to finish autoreleasing. */\n    local: Local,\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[]\n  ): void {\n    var localIndex = local.index;\n    var module = this.module;\n    if (~localIndex && flow.isAnyLocalFlag(localIndex, LocalFlags.ANY_RETAINED)) {\n      flow.unsetLocalFlag(localIndex, LocalFlags.ANY_RETAINED);\n      stmts.push(\n        this.makeRelease(\n          module.local_get(localIndex, local.type.toNativeType()),\n          local.type\n        )\n      );\n    }\n  }\n\n  // </reference-counting>\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false,\n    /** Skip the usual autorelease and manage this at the callsite instead. */\n    skipAutorelease: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.INLINE)) {\n      if (!instance.is(CommonFlags.VIRTUAL)) {\n        assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.INSTANCE)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          let returnType = this.currentType;\n          if (returnType.isManaged) {\n            if (!skipAutorelease) {\n              expr = this.makeAutorelease(expr, returnType);\n            } else {\n              this.skippedAutoreleases.add(expr);\n            }\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = instance.signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = instance.signature.parameterTypes;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (instance.is(CommonFlags.INSTANCE)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    var returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.CONV_IMPLICIT\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.SWALLOW);\n          if (resolved) {\n            if (resolved.kind == ElementKind.GLOBAL) {\n              let global = <Global>resolved;\n              if (this.compileGlobal(global)) {\n                if (global.is(CommonFlags.INLINED)) {\n                  operands.push(\n                    this.compileInlineConstant(global, parameterTypes[i], Constraints.CONV_IMPLICIT)\n                  );\n                } else {\n                  operands.push(\n                    this.convertExpression(\n                      module.global_get(global.internalName, global.type.toNativeType()),\n                      global.type, parameterTypes[i], false, initializer\n                    )\n                  );\n                }\n                continue;\n              }\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i], instance.declaration));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant) {\n        if (!instance.is(CommonFlags.MODULE_IMPORT)) {\n          let original = instance;\n          instance = this.ensureVarargsStub(instance);\n          if (!this.compileFunction(instance)) return module.unreachable();\n          instance.flow.flags = original.flow.flags;\n          let nativeReturnType = returnType.toNativeType();\n          // We know the last operand is optional and omitted, so inject setting\n          // ~argumentsLength into that operand, which is always safe.\n          let lastOperand = operands[maxOperands - 1];\n          assert(!(getSideEffects(lastOperand) & SideEffects.WritesGlobal));\n          let lastOperandType = parameterTypes[maxArguments - 1];\n          operands[maxOperands - 1] = module.block(null, [\n            module.global_set(BuiltinNames.argumentsLength, module.i32(numArguments)),\n            lastOperand\n          ], lastOperandType.toNativeType());\n          let expr = module.call(instance.internalName, operands, nativeReturnType);\n          this.currentType = returnType;\n          if (returnType.isManaged) {\n            if (immediatelyDropped) {\n              expr = this.makeRelease(expr, returnType);\n              this.currentType = Type.void;\n            } else if (!skipAutorelease) {\n              expr = this.makeAutorelease(expr, returnType);\n            } else {\n              this.skippedAutoreleases.add(expr);\n            }\n          }\n          this.ensureArgumentsLength();\n          return expr;\n        }\n      }\n    }\n\n    // Call the virtual stub with the vtable if the function has overloads\n    if (instance.is(CommonFlags.VIRTUAL) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureVirtualStub(instance);\n    }\n\n    // If the return value is of a reference type it has not yet been released but is in flight\n    // which is equivalent to a skipped autorelease. Hence, insert either a release if it is\n    // dropped anyway, preserve the skipped autorelease if explicitly requested or autorelease now.\n    var expr = module.call(instance.internalName, operands, returnType.toNativeType());\n    this.currentType = returnType;\n    if (returnType.isManaged) {\n      if (immediatelyDropped) {\n        expr = this.makeRelease(expr, returnType);\n        this.currentType = Type.void;\n      } else if (!skipAutorelease) {\n        expr = this.makeAutorelease(expr, returnType);\n      }\n    }\n    return expr;\n  }\n\n  /** Compiles an indirect call using an index argument and a signature. */\n  compileCallIndirect(\n    signature: Signature,\n    indexArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, indexArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to the function at `indexArg` in the function table. */\n  makeCallIndirect(\n    signature: Signature,\n    indexArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = signature.parameterTypes;\n    var returnType = signature.returnType;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i], reportNode));\n      }\n    }\n\n    if (this.options.isWasm64) {\n      indexArg = module.unary(UnaryOp.WrapI64, indexArg);\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    this.ensureArgumentsLength();\n    var nativeSizeType = this.options.nativeSizeType;\n    if (getSideEffects(indexArg) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(indexArg));\n      indexArg = module.block(null, [\n        module.local_set(temp.index, indexArg),\n        module.global_set(BuiltinNames.argumentsLength, module.i32(numArguments)),\n        module.local_get(temp.index, nativeSizeType)\n      ], nativeSizeType);\n      flow.freeTempLocal(temp);\n    } else { // simplify\n      indexArg = module.block(null, [\n        module.global_set(BuiltinNames.argumentsLength, module.i32(numArguments)),\n        indexArg\n      ], nativeSizeType);\n    }\n    var expr = module.call_indirect(\n      nativeSizeType == NativeType.I64\n        ? module.unary(UnaryOp.WrapI64,\n            module.load(8, false, indexArg, NativeType.I64)\n          )\n        : module.load(4, false, indexArg, NativeType.I32),\n      operands,\n      signature.nativeParams,\n      signature.nativeResults\n    );\n    this.currentType = returnType;\n    if (returnType.isManaged) {\n      if (immediatelyDropped) {\n        expr = this.makeRelease(expr, returnType);\n        this.currentType = Type.void;\n      } else {\n        expr = this.makeAutorelease(expr, returnType);\n      }\n    }\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var expressions = expression.expressions;\n    var numExpressions = expressions.length;\n    var exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.CONV_IMPLICIT | Constraints.WILL_DROP\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toNativeType());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var targetExpression = expression.expression;\n    var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedGet = classReference.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.CONV_IMPLICIT\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualSignature: Signature | null,\n    constraints: Constraints\n  ): ExpressionRef {\n    var declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n    var prototype = new FunctionPrototype(\n      declaration.name.text.length\n        ? declaration.name.text\n        : \"anonymous|\" + (actualFunction.nextAnonymousId++).toString(),\n      actualFunction,\n      declaration,\n      DecoratorFlags.NONE\n    );\n    var instance: Function | null;\n    var contextualTypeArguments = uniqueMap(flow.contextualTypeArguments);\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return this.module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            actualFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return this.module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return this.module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return this.module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return this.module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return this.module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return this.module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return this.module.unreachable();\n        }\n      }\n\n      let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n      signature.requiredParameters = numParameters; // !\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      if (!this.compileFunction(instance)) return this.module.unreachable();\n      this.currentType = contextualSignature.type;\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n    }\n\n    var offset = this.ensureRuntimeFunction(instance); // reports\n    return this.options.isWasm64\n      ? this.module.i64(i64_low(offset), i64_high(offset))\n      : this.module.i32(i64_low(offset));\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    var internalPath = expression.range.source.internalPath;\n    var filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    var enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.COMPILED)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.NULL: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType, expression);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.TRUE: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.FALSE: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.THIS: {\n        let thisType = actualFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR) && !(constraints & Constraints.IS_THIS)) {\n          let parent = actualFunction.parent;\n          assert(parent.kind == ElementKind.CLASS);\n          this.checkFieldInitialization(<Class>parent, expression);\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.ACCESSES_THIS);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toNativeType());\n      }\n      case NodeKind.SUPER: {\n        let flow = this.currentFlow;\n        let actualFunction = flow.actualFunction;\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n          if (!flow.is(FlowFlags.CALLS_SUPER)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toNativeType());\n            }\n          }\n        }\n        if (actualFunction.is(CommonFlags.INSTANCE)) {\n          let parent = assert(actualFunction.parent);\n          assert(parent.kind == ElementKind.CLASS);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toNativeType());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    var currentParent = this.currentParent;\n    if (!currentParent) currentParent = actualFunction;\n    var target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NONNULL, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.parentFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toNativeType());\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toNativeType());\n      }\n      case ElementKind.ENUMVALUE: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.COMPILED)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, NativeType.I32);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes !== null && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Expected_0_arguments_but_got_1,\n            expression.range, typeParameterNodes.length.toString(), \"0\"\n          );\n          return module.unreachable();\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          uniqueMap<string,Type>(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (contextualType.isExternalReference) {\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName);\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var flow = this.currentFlow;\n    var isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NAMEDTYPE) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.actualFunction, ReportMode.SWALLOW);\n        if (element !== null && element.kind == ElementKind.CLASS_PROTOTYPE) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.GENERIC)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    var expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.actualFunction,\n      uniqueMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var expr = this.compileExpression(expression.expression, expectedType);\n    var actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    var nativeSizeType = actualType.toNativeType();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // downcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          nativeSizeType == NativeType.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType, expression.expression)\n        );\n      }\n\n      // upcast - check dynamically\n      if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              nativeSizeType == NativeType.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, nativeSizeType),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // downcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n\n      // upcast - check dynamically\n      } else if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          // FIXME: the temp local and the if can be removed here once flows\n          // perform null checking, which would error earlier when checking\n          // uninitialized (thus zero) `var a: A` to be an instance of something.\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              nativeSizeType == NativeType.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, nativeSizeType),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    var module = this.module;\n    var expr = this.compileExpression(expression.expression, Type.auto);\n    var actualType = this.currentType;\n    var nativeSizeType = actualType.toNativeType();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    var classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extends(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            nativeSizeType == NativeType.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType, expression.expression)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        this.pendingClassInstanceOf.add(prototype);\n        return module.call(prototype.internalName + \"~instanceof\", [ expr ], NativeType.I32);\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.ARRAY: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.FLOAT: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.INTEGER: {\n        let intValue = (<IntegerLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          intValue = i64_sub(\n            i64_new(0),\n            intValue\n          );\n        }\n        let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);\n        this.currentType = type;\n        switch (type.kind) {\n          case TypeKind.ISIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.USIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.STRING: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.OBJECT: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.REGEXP: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    var expr = this.ensureStaticString(expression.value);\n    if (constraints & Constraints.WILL_RETAIN) {\n      this.skippedAutoreleases.add(expr);\n    } else {\n      // not necessary since this is static data anyway\n      // expr = this.makeAutorelease(expr, this.currentType);\n    }\n    return expr;\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass !== null && contextualClass.extends(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    var element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.CLASS);\n    var arrayInstance = <Class>element;\n    var arrayType = arrayInstance.type;\n    var elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n    var arrayBufferInstance = assert(program.arrayBufferInstance);\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n    var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var isStatic = !elementType.isExternalReference;\n    var nativeElementType = elementType.toNativeType();\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n\n      let runtimeHeaderSize = program.runtimeHeaderSize;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(runtimeHeaderSize));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PREFER_STATIC) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(runtimeHeaderSize));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        // __newArray(length, alignLog2, classId, staticBuffer)\n        let expr = this.makeCallDirect(program.newArrayInstance, [\n          module.i32(length),\n          program.options.isWasm64\n            ? module.i64(elementType.alignLog2)\n            : module.i32(elementType.alignLog2),\n          module.i32(arrayInstance.id),\n          program.options.isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        expr = this.makeRetain(expr, arrayType);\n        if (arrayType.isManaged) {\n          if (!(constraints & Constraints.WILL_RETAIN)) {\n            expr = this.makeAutorelease(expr, arrayType);\n          } else {\n            this.skippedAutoreleases.add(expr);\n          }\n        }\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var setter = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!setter) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var nativeArrayType = arrayType.toNativeType();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeRetain(\n          this.makeCallDirect(program.newArrayInstance, [\n            module.i32(length),\n            program.options.isWasm64\n              ? module.i64(elementType.alignLog2)\n              : module.i32(elementType.alignLog2),\n            module.i32(arrayInstance.id),\n            program.options.isWasm64\n              ? module.i64(0)\n              : module.i32(0)\n          ], expression),\n          arrayType\n        )\n      )\n    );\n    // tempData = tempThis.dataStart\n    var dataStartMember = assert(arrayInstance.lookupInSelf(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.FIELD);\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, nativeArrayType),\n          nativeArrayType,\n          (<Field>dataStartMember).memoryOffset\n        )\n      )\n    );\n    var isManaged = elementType.isManaged;\n    for (let i = 0, alignLog2 = elementType.alignLog2; i < length; ++i) {\n      let valueExpr = values[i];\n      if (isManaged) {\n        // value = __retain(value)\n        if (!this.skippedAutoreleases.has(valueExpr)) {\n          valueExpr = this.makeRetain(valueExpr, elementType);\n        }\n      }\n      // store<T>(tempData, value, immOffset)\n      stmts.push(\n        module.store(elementType.byteSize,\n          module.local_get(tempDataStart.index, nativeArrayType),\n          valueExpr,\n          nativeElementType,\n          i << alignLog2\n        )\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, nativeArrayType)\n    );\n    flow.freeTempLocal(tempThis);\n    flow.freeTempLocal(tempDataStart);\n    this.currentType = arrayType;\n    var expr = module.flatten(stmts, nativeArrayType);\n    if (arrayType.isManaged) {\n      if (constraints & Constraints.WILL_RETAIN) {\n        this.skippedAutoreleases.add(expr);\n      } else {\n        expr = this.makeAutorelease(expr, arrayType, this.currentFlow);\n      }\n    }\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    var arrayInstance = assert(contextualType.getClass());\n    var arrayType = arrayInstance.type;\n    var typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    var elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var nativeElementType = elementType.toNativeType();\n    var isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(elementExpression, elementType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    var isWasm64 = this.options.isWasm64;\n    var bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.runtimeHeaderSize));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PREFER_STATIC) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        if (constraints & Constraints.WILL_RETAIN) {\n          this.skippedAutoreleases.add(expr);\n        } else {\n          // not necessary since this is static data anyway\n          // expr = this.makeAutorelease(expr, arrayType, flow);\n        }\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeRetain(\n          this.makeCallDirect(program.newBufferInstance, [\n            isWasm64\n              ? module.i64(bufferSize)\n              : module.i32(bufferSize),\n            module.i32(arrayInstance.id),\n            isWasm64\n              ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n              : module.i32(i64_low(bufferAddress))\n          ], expression),\n          program.arrayBufferInstance.type\n        );\n        if (arrayType.isManaged) {\n          if (constraints & Constraints.WILL_RETAIN) {\n            this.skippedAutoreleases.add(expr);\n          } else {\n            expr = this.makeAutorelease(expr, arrayType);\n          }\n        }\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var setter = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!setter) {\n      flow.freeTempLocal(tempThis);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var nativeArrayType = arrayType.toNativeType();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeRetain(\n          this.makeCallDirect(program.newBufferInstance, [\n            isWasm64\n              ? module.i64(bufferSize)\n              : module.i32(bufferSize),\n            module.i32(arrayInstance.id)\n          ], expression),\n          program.arrayBufferInstance.type\n        )\n      )\n    );\n    var isManaged = elementType.isManaged;\n    for (let i = 0, alignLog2 = elementType.alignLog2; i < length; ++i) {\n      let valueExpr = values[i];\n      if (isManaged) {\n        // value = __retain(value)\n        if (!this.skippedAutoreleases.has(valueExpr)) {\n          valueExpr = this.makeRetain(valueExpr, elementType);\n        }\n      }\n      // store<T>(tempThis, value, immOffset)\n      stmts.push(\n        module.store(elementType.byteSize,\n          module.local_get(tempThis.index, nativeArrayType),\n          valueExpr,\n          nativeElementType,\n          i << alignLog2\n        )\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, nativeArrayType)\n    );\n    flow.freeTempLocal(tempThis);\n    this.currentType = arrayType;\n    var expr = module.flatten(stmts, nativeArrayType);\n    if (arrayType.isManaged) {\n      if (constraints & Constraints.WILL_RETAIN) {\n        this.skippedAutoreleases.add(expr);\n      } else {\n        expr = this.makeAutorelease(expr, arrayType, this.currentFlow);\n      }\n    }\n    return expr;\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    var module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    var classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    var classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    var ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    var isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.UNMANAGED, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    var names = expression.names;\n    var numNames = names.length;\n    var values = expression.values;\n    var members = classReference.members;\n    var hasErrors = false;\n    var exprs = new Array<ExpressionRef>();\n    var flow = this.currentFlow;\n    var tempLocal = isManaged\n      ? flow.getAutoreleaseLocal(classType)\n      : flow.getTempLocal(classType);\n    var nativeClassType = classType.toNativeType();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    var omittedFields = new Set<Field>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member !== null && member.kind == ElementKind.FIELD) {\n          omittedFields.add(<Field>member); // incl. private/protected\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member: DeclaredElement;\n      if (!members || !members.has(memberName) || (member = assert(members.get(memberName))).kind != ElementKind.FIELD) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PRIVATE)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PROTECTED)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let fieldInstance = <Field>member;\n      let fieldType = fieldInstance.type;\n\n      let expr = this.compileExpression(values[i], fieldType, Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN);\n      if (fieldType.isManaged && !this.skippedAutoreleases.has(expr)) {\n        expr = this.makeRetain(expr, fieldType);\n      }\n      exprs.push(\n        module.store( // TODO: handle setters as well\n          fieldType.byteSize,\n          module.local_get(tempLocal.index, nativeClassType),\n          expr,\n          fieldType.toNativeType(),\n          fieldInstance.memoryOffset\n        )\n      );\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(fieldInstance);\n    }\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let fieldInstance = _values[j];\n      let fieldType = fieldInstance.type;\n\n      if (fieldInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (fieldType.isReference) {\n        if (!fieldType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, fieldInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (fieldType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.ISIZE:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.USIZE:\n        case TypeKind.BOOL:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          exprs.push(\n            module.store( // TODO: handle setters as well\n              fieldType.byteSize,\n              module.local_get(tempLocal.index, nativeClassType),\n              this.makeZero(fieldType, expression),\n              fieldType.toNativeType(),\n              fieldInstance.memoryOffset\n            )\n          );\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, fieldInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    var ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.WILL_RETAIN, expression)\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, nativeClassType)\n    );\n\n    if (!isManaged) flow.freeTempLocal(tempLocal);\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, nativeClassType);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    var target = this.resolver.resolveTypeName(expression.typeName, flow.actualFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.CLASS_PROTOTYPE) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    var classPrototype = <ClassPrototype>target;\n    var classInstance: Class | null = null;\n    var typeArguments = expression.typeArguments;\n    var classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) !== null &&\n      classReference.is(CommonFlags.GENERIC)\n    ) {\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        uniqueMap<string,Type>(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.actualFunction.parent, // relative to caller\n        uniqueMap<string,Type>(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.INLINE)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    var instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.COMPILED)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.INLINE)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = uniqueMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          baseCtor.signature,\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.INSTANCE | CommonFlags.CONSTRUCTOR\n            )\n          ),\n          null,\n          new Signature(this.program, null, classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n        let members = classInstance.members;\n        if (!members) classInstance.members = members = new Map();\n        members.set(\"constructor\", instance.prototype);\n      }\n\n      instance.internalName = classInstance.internalName + INSTANCE_DELIMITER + \"constructor\";\n      instance.set(CommonFlags.COMPILED);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      classInstance.constructorInstance = instance;\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let nativeSizeType = this.options.nativeSizeType;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   if (!this) this = <ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      let allocExpr = this.makeAllocation(classInstance);\n      let classType = classInstance.type;\n      if (classType.isManaged) allocExpr = this.makeRetain(allocExpr, classType);\n      stmts.push(\n        module.if(\n          module.unary(nativeSizeType == NativeType.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n            module.local_get(0, nativeSizeType)\n          ),\n          module.local_set(0, allocExpr)\n        )\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, nativeSizeType);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toNativeType());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false, true)\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      let body = this.performAutoreleasesWithValue(flow, module.local_get(0, nativeSizeType), classInstance.type, stmts);\n      flow.freeScopedLocals();\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<NativeType>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toNativeType());\n      }\n      let funcRef = module.addFunction(instance.internalName, signature.nativeParams, signature.nativeResults, varTypes, body);\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    var ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    var members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind == ElementKind.FIELD && element.parent == classInstance) {\n          let field = <Field>element;\n          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.INITIALIZED)) {\n            if (!field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n              if (relatedNode) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  relatedNode.range,\n                  field.internalName\n                );\n              } else {\n                this.error(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  field.internalName\n                );\n              }\n            }\n          } else if (field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n            if (field.type.isReference) {\n              this.warning( // involves a runtime check\n                DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n                field.identifierNode.range,\n                field.internalName\n              );\n            } else {\n              this.pedantic( // is a nop anyway\n                DiagnosticCode.Unnecessary_definite_assignment,\n                field.identifierNode.range\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.CONSTRUCTOR));\n    var parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.CLASS);\n    var classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n    var expr = this.compileCallDirect( // no need for another autoreleased local\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType, reportNode),\n      constraints\n    );\n    if (getExpressionType(expr) != NativeType.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.GLOBAL: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toNativeType());\n      }\n      case ElementKind.ENUMVALUE: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.ENUM);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, NativeType.I32);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        assert(fieldInstance.memoryOffset >= 0);\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        thisExpression = assert(thisExpression);\n        let thisExpr = this.compileExpression(\n          thisExpression,\n          (<Class>fieldParent).type,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let thisType = this.currentType;\n        if (\n          flow.actualFunction.is(CommonFlags.CONSTRUCTOR) &&\n          thisExpression.kind == NodeKind.THIS &&\n          !flow.isThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED) &&\n          !fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED)\n        ) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_used_before_being_assigned,\n            expression.range,\n            fieldInstance.identifierNode.range,\n            fieldInstance.internalName\n          );\n        }\n        if (thisType.isNullableReference) {\n          if (!flow.isNonnull(thisExpr, thisType)) {\n            this.error(\n              DiagnosticCode.Object_is_possibly_null,\n              thisExpression.range\n            );\n          }\n        }\n        if (!fieldInstance.is(CommonFlags.COMPILED)) {\n          fieldInstance.set(CommonFlags.COMPILED);\n          let typeNode = fieldInstance.typeNode;\n          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);\n        }\n        this.currentType = fieldType;\n        let ret = module.load(\n          fieldType.byteSize,\n          fieldType.isSignedIntegerValue,\n          thisExpr,\n          fieldType.toNativeType(),\n          fieldInstance.memoryOffset\n        );\n        if (fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED) && fieldType.isReference && !fieldType.isNullableReference) {\n          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);\n        }\n        return ret;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance);\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var ifThen = expression.ifThen;\n    var ifElse = expression.ifElse;\n\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(expression.condition, Type.bool),\n      this.currentType,\n      expression.condition\n    );\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    var condKind = this.evaluateCondition(condExpr);\n    if (condKind == ConditionKind.TRUE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));\n    }\n    if (condKind == ConditionKind.FALSE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));\n    }\n\n    var inheritedConstraints = constraints & Constraints.WILL_RETAIN;\n\n    var outerFlow = this.currentFlow;\n    var ifThenFlow = outerFlow.fork();\n    ifThenFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = ifThenFlow;\n    var ifThenExpr = this.compileExpression(ifThen, ctxType, inheritedConstraints);\n    var ifThenType = this.currentType;\n    var ifThenAutoreleaseSkipped = this.skippedAutoreleases.has(ifThenExpr);\n\n    var ifElseFlow = outerFlow.fork();\n    ifElseFlow.inheritNonnullIfFalse(condExpr);\n    this.currentFlow = ifElseFlow;\n    var ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType, inheritedConstraints);\n    var ifElseType = this.currentType;\n    var ifElseAutoreleaseSkipped = this.skippedAutoreleases.has(ifElseExpr);\n\n    var commonType = Type.commonDenominator(ifThenType, ifElseType, false);\n    if (!commonType) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        ifElse.range, ifElseType.toString(), ifThenType.toString()\n      );\n      this.currentType = ctxType;\n      return module.unreachable();\n    }\n    ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n    ifThenType = commonType;\n    ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n    ifElseType = commonType;\n    this.currentType = commonType;\n\n    if (ifThenAutoreleaseSkipped != ifElseAutoreleaseSkipped) { // unify to both skipped\n      if (!ifThenAutoreleaseSkipped) {\n        ifThenExpr = this.makeRetain(ifThenExpr, ifThenType);\n        ifThenAutoreleaseSkipped = true;\n      } else {\n        ifElseExpr = this.makeRetain(ifElseExpr, ifElseType);\n        ifElseAutoreleaseSkipped = true;\n      }\n    } else if (!ifThenAutoreleaseSkipped && commonType.isManaged) { // keep alive a little longer\n      if (constraints & Constraints.WILL_RETAIN) { // try to undo both\n        let ifThenIndex = this.tryUndoAutorelease(ifThenExpr, ifThenFlow);\n        if (ifThenIndex == -1) ifThenExpr = this.makeRetain(ifThenExpr, ifThenType);\n        let ifElseIndex = this.tryUndoAutorelease(ifElseExpr, ifElseFlow);\n        if (ifElseIndex == -1) ifElseExpr = this.makeRetain(ifElseExpr, ifElseType);\n        ifThenAutoreleaseSkipped = true;\n        ifElseAutoreleaseSkipped = true;\n      } else {\n        ifThenExpr = this.delayAutorelease(ifThenExpr, ifThenType, ifThenFlow, outerFlow);\n        ifElseExpr = this.delayAutorelease(ifElseExpr, ifElseType, ifElseFlow, outerFlow);\n      }\n    }\n\n    ifThenExpr = this.performAutoreleasesWithValue(ifThenFlow, ifThenExpr, commonType);\n    ifThenFlow.freeScopedLocals();\n\n    ifElseExpr = this.performAutoreleasesWithValue(ifElseFlow, ifElseExpr, commonType);\n    ifElseFlow.freeScopedLocals();\n\n    this.currentFlow = outerFlow;\n    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);\n\n    var expr = module.if(condExpr, ifThenExpr, ifElseExpr);\n    assert(ifThenAutoreleaseSkipped == ifElseAutoreleaseSkipped);\n    if (ifThenAutoreleaseSkipped) this.skippedAutoreleases.add(expr);\n    return expr;\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    var getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.NONE\n    );\n\n    // shortcut if compiling the getter already failed\n    if (getExpressionId(getValue) == ExpressionId.Unreachable) return getValue;\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    var tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue\n      );\n    }\n\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS_PLUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_INC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_DEC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      if (tempLocal) flow.freeTempLocal(tempLocal);\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    var setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    flow.freeTempLocal(tempLocal);\n    var nativeType = tempLocal.type.toNativeType();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, nativeType)\n    ], nativeType); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var compound = false;\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PLUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.MINUS: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.NONE, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MINUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              this.makeZero(this.currentType, expression.operand),\n              expr\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.PLUS_PLUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_INC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_DEC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.EXCLAMATION: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.TILDE: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.XorI64\n                : BinaryOp.XorI32,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TYPEOF: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var operand = expression.operand;\n    var expr: ExpressionRef = 0;\n    var stringInstance = this.program.stringInstance;\n    var typeString: string;\n    if (operand.kind == NodeKind.NULL) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.SWALLOW);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PROPERTYACCESS:\n          case NodeKind.ELEMENTACCESS: {\n            operand = operand.kind == NodeKind.PROPERTYACCESS\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.REPORT);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.CLASS_PROTOTYPE:\n          case ElementKind.NAMESPACE:\n          case ElementKind.ENUM: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype === stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.nativeSizeType)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.ExtendI8ToI32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.ExtendI16ToI32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n      case TypeKind.BOOL: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    var parentFunction = this.currentFlow.parentFunction;\n    var source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    parentFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.SIMD, reportNode);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode);\n      case TypeKind.EXNREF: {\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\n            && this.checkFeatureEnabled(Feature.EXCEPTION_HANDLING, reportNode);\n      }\n      case TypeKind.ANYREF: {\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    var supported = true;\n    var explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    var parameterTypes = signature.parameterTypes;\n    var parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    var module = this.module;\n    var evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.TRUE\n        : ConditionKind.FALSE;\n    }\n    return ConditionKind.UNKNOWN;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF:\n        return module.ref_null(type.toNativeType());\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.BOOL: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      }\n      case TypeKind.USIZE: if (type.isManaged && this.skippedAutoreleases.has(expr)) expr = this.makeAutorelease(expr, type);\n      case TypeKind.ISIZE: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n        //\n        // and finally:\n        // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n        return module.binary(BinaryOp.LeU32,\n          module.binary(BinaryOp.SubI32,\n            module.binary(BinaryOp.ShlI32,\n              module.unary(UnaryOp.ReinterpretF32, expr),\n              module.i32(1)\n            ),\n            module.i32(2) // 1 << 1\n          ),\n          module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n        );\n      }\n      case TypeKind.F64: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n        //\n        // and finally:\n        // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n        return module.binary(BinaryOp.LeU64,\n          module.binary(BinaryOp.SubI64,\n            module.binary(BinaryOp.ShlI64,\n              module.unary(UnaryOp.ReinterpretF64, expr),\n              module.i64(1)\n            ),\n            module.i64(2) // 1 << 1\n          ),\n          module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF:{\n        return module.ref_is_null(expr);\n      }\n      default: {\n        assert(false);\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    var program = this.program;\n    assert(classInstance.program == program);\n    var module = this.module;\n    var options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.nativeSizeType);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.nativeSizeType);\n    }\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    var members = classInstance.members;\n    if (!members) return stmts;\n\n    var module = this.module;\n    var flow = this.currentFlow;\n    var isInline = flow.isInline;\n    var thisLocalIndex = isInline\n      ? flow.lookupLocal(CommonNames.this_)!.index\n      : 0;\n    var nativeSizeType = this.options.nativeSizeType;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (\n        member.kind != ElementKind.FIELD || // not a field\n        member.parent != classInstance      // inherited field\n      ) continue;\n\n      let field = <Field>member;\n      assert(!field.isAny(CommonFlags.CONST));\n      let fieldType = field.type;\n      let nativeFieldType = fieldType.toNativeType();\n      let fieldPrototype = field.prototype;\n      let initializerNode = fieldPrototype.initializerNode;\n      let parameterIndex = fieldPrototype.parameterIndex;\n      let initExpr: ExpressionRef;\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(fieldType, typeNode);\n\n      // if declared as a constructor parameter, use its value\n      if (parameterIndex >= 0) {\n        initExpr = module.local_get(\n          isInline\n            ? flow.lookupLocal(field.name)!.index\n            : 1 + parameterIndex, // this is local 0\n          nativeFieldType\n        );\n        if (fieldType.isManaged) initExpr = this.makeRetain(initExpr, fieldType);\n\n      // fall back to use initializer if present\n      } else if (initializerNode) {\n        initExpr = this.compileExpression(initializerNode, fieldType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        if (fieldType.isManaged && !this.skippedAutoreleases.has(initExpr)) {\n          initExpr = this.makeRetain(initExpr, fieldType);\n        }\n\n      // otherwise initialize with zero\n      } else {\n        initExpr = this.makeZero(fieldType, fieldPrototype.declaration);\n      }\n\n      stmts.push(\n        module.store(fieldType.byteSize,\n          module.local_get(thisLocalIndex, nativeSizeType),\n          initExpr,\n          nativeFieldType,\n          field.memoryOffset\n        )\n      );\n    }\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    var stringInstance = program.stringInstance;\n    var messageArg: ExpressionRef;\n    if (message !== null) {\n      // The message argument works much like an arm of an IF that does not become executed if the\n      // assertion succeeds respectively is only being computed if the program actually crashes.\n      // Hence, let's make it so that the autorelease is skipped at the end of the current block,\n      // essentially ignoring the message GC-wise. Doesn't matter anyway on a crash.\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN);\n    } else {\n      messageArg = this.makeZero(stringInstance.type, codeLocation);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var module = this.module;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    var filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    var range = codeLocation.range;\n    var source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        NativeType.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n    flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n    expr = module.if(\n      module.local_tee(temp.index, expr),\n      module.local_get(temp.index, type.toNativeType()),\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected null\"), reportNode) // TODO: throw\n    );\n    flow.freeTempLocal(temp);\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime upcast check, e.g. on `<Child>parent`. */\n  makeRuntimeUpcastCheck(\n    /** Expression being upcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    var instanceofInstance = this.program.instanceofInstance;\n    assert(this.compileFunction(instanceofInstance));\n    expr = module.if(\n      module.call(instanceofInstance.internalName, [\n        module.local_tee(temp.index, expr),\n        module.i32(toType.classReference!.id)\n      ], NativeType.I32),\n      module.local_get(temp.index, type.toNativeType()),\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\n    );\n    flow.freeTempLocal(temp);\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\n\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.INSTANCE), true\n  );\n  if (!element.hasDecorator(DecoratorFlags.EXTERNAL)) return;\n\n  var program = element.program;\n  var decorator = assert(findDecorator(DecoratorKind.EXTERNAL, declaration.decorators));\n  var args = decorator.args;\n  if (args !== null && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.STRING)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.STRING)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n\nvar mangleImportName_moduleName: string;\nvar mangleImportName_elementName: string;\n","/**\n * @fileoverview Builders for various definitions describing a module.\n *\n * - TSDBuilder: Creates a TypeScript definition file (.d.ts)\n * - IDLBuilder: Creates a WebIDL interface definition (.webidl)\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  Program,\n  Element,\n  ElementKind,\n  Global,\n  Enum,\n  EnumValue,\n  Field,\n  Function,\n  FunctionPrototype,\n  Class,\n  ClassPrototype,\n  Namespace,\n  ConstantValueKind,\n  Interface,\n  Property,\n  PropertyPrototype,\n  File\n} from \"./program\";\n\nimport {\n  Type,\n  TypeKind\n} from \"./types\";\n\nimport {\n  SourceKind\n} from \"./ast\";\n\nimport {\n  indent\n} from \"./util\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.PRIVATE) && !this.includePrivate) return;\n    var seen = this.seen;\n    if (!element.is(CommonFlags.INSTANCE) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        if (element.is(CommonFlags.COMPILED)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        if (element.is(CommonFlags.COMPILED)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.ENUMVALUE: break; // handled by visitEnum\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (fieldInstance.is(CommonFlags.COMPILED)) this.visitField(name, fieldInstance);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n        break;\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.NAMESPACE: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TYPEDEFINITION: break;\n      default: assert(false);\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitField(name: string, element: Field): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n/** A WebIDL definitions builder. */\nexport class IDLBuilder extends ExportsWalker {\n\n  /** Builds WebIDL definitions for the specified program. */\n  static build(program: Program): string {\n    return new IDLBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (isConst) sb.push(\"const \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\" \");\n    sb.push(name);\n    if (isConst) {\n      switch (element.constantValueKind) {\n        case ConstantValueKind.INTEGER: {\n          sb.push(\" = \");\n          sb.push(i64_to_string(element.constantIntegerValue));\n          break;\n        }\n        case ConstantValueKind.FLOAT: {\n          sb.push(\" = \");\n          sb.push(element.constantFloatValue.toString());\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    sb.push(\";\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          let isConst = enumValue.is(CommonFlags.INLINED);\n          indent(sb, this.indentLevel);\n          if (isConst) sb.push(\"const \");\n          else sb.push(\"readonly \");\n          sb.push(\"unsigned long \");\n          sb.push(memberName);\n          if (isConst) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(this.typeToString(signature.returnType));\n    sb.push(\" \");\n    sb.push(name);\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    // var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      // if (i >= requiredParameters) sb.push(\"optional \");\n      sb.push(this.typeToString(parameters[i]));\n      sb.push(\" \");\n      sb.push(element.getParameterName(i));\n    }\n    sb.push(\");\\n\");\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      indent(sb, this.indentLevel);\n      sb.push(\"interface \");\n      sb.push(element.name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    // TODO\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    // TODO\n  }\n\n  visitNamespace(name: string, element: Namespace): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // TODO\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"byte\";\n      case TypeKind.I16: return \"short\";\n      case TypeKind.I32: return \"long\";\n      case TypeKind.I64: return \"long long\";\n      case TypeKind.ISIZE: return this.program.options.isWasm64 ? \"long long\" : \"long\";\n      case TypeKind.U8: return \"octet\";\n      case TypeKind.U16: return \"unsigned short\";\n      case TypeKind.U32: return \"unsigned long\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"unsigned long long\";\n      case TypeKind.USIZE: return this.program.options.isWasm64 ? \"unsigned long long\" : \"unsigned long\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"boolean\";\n      case TypeKind.F32: return \"unrestricted float\";\n      case TypeKind.F64: return \"unrestricted double\";\n      case TypeKind.VOID: return \"void\";\n      default: {\n        assert(false);\n        return \"\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    sb.push(\"interface ASModule {\\n\");\n    ++this.indentLevel;\n    this.walk();\n    --this.indentLevel;\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program): string {\n    return new TSDBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.STATIC)) {\n      if (isConst) sb.push(\"static readonly \");\n      else sb.push(\"static \");\n    } else {\n      if (isConst) sb.push(\"export const \");\n      else sb.push(\"export var \");\n    }\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (element.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    var remainingMembers = 0;\n    if (members) {\n      remainingMembers = members.size;\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          indent(sb, this.indentLevel);\n          sb.push(memberName);\n          if (member.is(CommonFlags.INLINED)) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\",\\n\");\n          --remainingMembers;\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    if (remainingMembers) this.visitNamespace(name, element);\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.isAny(CommonFlags.PRIVATE | CommonFlags.SET)) return;\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n    if (element.is(CommonFlags.GET)) {\n      sb.push(\"get \");\n      sb.push(name); // 'get:funcName' internally\n      sb.push(\"(): \");\n      sb.push(this.typeToString(signature.returnType));\n      sb.push(\";\\n\");\n      return;\n    } else {\n      if (!element.isAny(CommonFlags.STATIC | CommonFlags.INSTANCE)) sb.push(\"export function \");\n      sb.push(name);\n    }\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    // var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      // if (i >= requiredParameters) sb.push(\"optional \");\n      sb.push(element.getParameterName(i));\n      sb.push(\": \");\n      sb.push(this.typeToString(parameters[i]));\n    }\n    if (element.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)) {\n      sb.push(\")\");\n    } else {\n      sb.push(\"): \");\n      sb.push(this.typeToString(signature.returnType));\n    }\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    var isInterface = element.kind == ElementKind.INTERFACE;\n    indent(sb, this.indentLevel++);\n    if (isInterface) {\n      sb.push(\"export interface \");\n    } else {\n      sb.push(\"export \");\n      if (element.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n      sb.push(\"class \");\n    }\n    sb.push(name);\n    var base = element.base;\n    if (base !== null && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {\n      sb.push(\" extends \");\n      let extendsNode = assert(element.prototype.extendsNode);\n      sb.push(extendsNode.name.identifier.text); // TODO: fqn?\n    }\n    sb.push(\" {\\n\");\n    var staticMembers = element.prototype.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    var instanceMembers = element.members;\n    if (instanceMembers) {\n      // TODO: for (let member of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.parent == element) { // own member\n          this.visitElement(member.name, member);\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    if (element.is(CommonFlags.PRIVATE)) return;\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n    if (element.is(CommonFlags.READONLY)) sb.push(\"readonly \");\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      let sb = this.sb;\n      indent(sb, this.indentLevel++);\n      sb.push(\"export namespace \");\n      sb.push(name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"export const \");\n    sb.push(name);\n    sb.push(\": typeof \");\n    sb.push(originalName);\n    sb.push(\";\\n\");\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.VOID: return \"void\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.EXNREF: return \"exnref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      default: {\n        assert(false);\n        return \"any\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    var isWasm64 = this.program.options.isWasm64;\n    sb.push(\"declare module ASModule {\\n\");\n    sb.push(\"  type i8 = number;\\n\");\n    sb.push(\"  type i16 = number;\\n\");\n    sb.push(\"  type i32 = number;\\n\");\n    sb.push(\"  type i64 = bigint;\\n\");\n    if (isWasm64) {\n      sb.push(\"  type isize = bigint;\\n\");\n    } else {\n      sb.push(\"  type isize = number;\\n\");\n    }\n    sb.push(\"  type u8 = number;\\n\");\n    sb.push(\"  type u16 = number;\\n\");\n    sb.push(\"  type u32 = number;\\n\");\n    sb.push(\"  type u64 = bigint;\\n\");\n    if (isWasm64) {\n      sb.push(\"  type usize = bigint;\\n\");\n    } else {\n      sb.push(\"  type usize = number;\\n\");\n    }\n    sb.push(\"  type f32 = number;\\n\");\n    sb.push(\"  type f64 = number;\\n\");\n    sb.push(\"  type bool = boolean | number;\\n\");\n    ++this.indentLevel;\n    this.walk();\n    --this.indentLevel;\n    sb.push(\"}\\n\");\n    sb.push(\"export default ASModule;\\n\");\n    return this.sb.join(\"\");\n  }\n}\n\n// helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nfunction hasCompiledMember(element: Element): bool {\n  var members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FUNCTION_PROTOTYPE: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.CLASS_PROTOTYPE: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.COMPILED) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n","/**\n * @fileoverview Generated from diagnosticsMessages.json. Do not edit.\n * @license Apache-2.0\n */\n\n/* tslint:disable:max-line-length */\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Cannot_export_a_mutable_global = 205,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Exported_generic_function_or_class_has_no_concrete_instances = 232,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Type_0_is_cyclic_Module_will_include_deferred_garbage_collection = 900,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 205: return \"Cannot export a mutable global.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 232: return \"Exported generic function or class has no concrete instances.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 900: return \"Type '{0}' is cyclic. Module will include deferred garbage collection.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n","/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  PEDANTIC,\n  /** Informatory message. */\n  INFO,\n  /** Warning message. */\n  WARNING,\n  /** Error message. */\n  ERROR\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return \"PEDANTIC\";\n    case DiagnosticCategory.INFO: return \"INFO\";\n    case DiagnosticCategory.WARNING: return \"WARNING\";\n    case DiagnosticCategory.ERROR: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** ANSI escape sequence for blue foreground. */\nexport const COLOR_BLUE: string = \"\\u001b[96m\";\n/** ANSI escape sequence for yellow foreground. */\nexport const COLOR_YELLOW: string = \"\\u001b[93m\";\n/** ANSI escape sequence for red foreground. */\nexport const COLOR_RED: string = \"\\u001b[91m\";\n/** ANSI escape sequence for magenta foreground. */\nexport const COLOR_MAGENTA: string = \"\\u001b[95m\";\n/** ANSI escape sequence to reset the foreground color. */\nexport const COLOR_RESET: string = \"\\u001b[0m\";\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return COLOR_MAGENTA;\n    case DiagnosticCategory.INFO: return COLOR_BLUE;\n    case DiagnosticCategory.WARNING: return COLOR_YELLOW;\n    case DiagnosticCategory.ERROR: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    var message = diagnosticCodeToString(code);\n    if (arg0 !== null) message = message.replace(\"{0}\", arg0);\n    if (arg1 !== null) message = message.replace(\"{1}\", arg1);\n    if (arg2 !== null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    var thisRange = this.range;\n    var otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    var thisRelatedRange = this.relatedRange;\n    var otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    var range = this.range;\n    if (range) {\n      let source = range.source;\n      return (\n        diagnosticCategoryToString(this.category) +\n        \" \" +\n        this.code.toString() +\n        \": \\\"\" +\n        this.message +\n        \"\\\" in \" +\n        source.normalizedPath +\n        \"(\" +\n        source.lineAt(range.start).toString() +\n        \",\" +\n        source.columnAt().toString() +\n        \"+\" +\n        (range.end - range.start).toString() +\n        \")\"\n      );\n    }\n    return (\n      diagnosticCategoryToString(this.category) +\n      \" \" +\n      this.code.toString() +\n      \": \" +\n      this.message\n    );\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n\n  // general information\n  var sb: string[] = [];\n  if (useColors) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (useColors) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  var range = message.range;\n  if (range) {\n    let source = range.source;\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range, useColors));\n    }\n    sb.push(\"\\n\");\n    sb.push(\" in \");\n    sb.push(source.normalizedPath);\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    let relatedRange = message.relatedRange;\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange, useColors));\n      }\n      sb.push(\"\\n\");\n      sb.push(\" in \");\n      sb.push(relatedSource.normalizedPath);\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nexport function formatDiagnosticContext(range: Range, useColors: bool = false): string {\n  var text = range.source.text;\n  var len = text.length;\n  var start = range.start;\n  var end = range.end;\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  var sb: string[] = [\n    \"\\n \",\n    text.substring(start, end),\n    \"\\n \"\n  ];\n  while (start < range.start) {\n    sb.push(\" \");\n    start++;\n  }\n  if (useColors) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      if (isLineBreak(text.charCodeAt(start))) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      }\n      sb.push(\"~\");\n    }\n  }\n  if (useColors) sb.push(COLOR_RESET);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n","import { ImportStatement, NodeKind, SourceKind } from \"../ast\";\nimport { Program } from \"../program\";\n\nexport class ProgramAnalyzar {\n  private program: Program;\n\n  constructor(program: Program) {\n    this.program = program;\n    this.print();\n  }\n  \n  print(): void {\n    // this.logFilesByName();\n    // this.logElementsByDeclaration();\n    // this.logSources();\n  }\n\n  logSources(): void {\n    for (let index = 0; index < this.program.sources.length; index ++) {\n      let source = this.program.sources[index];\n      console.log(`source: ${SourceKind[source.sourceKind]}, path: ${source.internalPath}`);\n    }\n  }\n\n  logFilesByName(): void {\n    this.program.filesByName.forEach((file, key) => {\n      if (key == '../patractlabs/ask/examples/preprocess/origin') {\n        console.log(`key: ${key}, file namne: ${file}`);\n        for (let index = 0; index < file.source.statements.length; index++) {\n          let statement = file.source.statements[index];\n          console.log(`file Decalaration kind: ${NodeKind[statement.kind]}`);\n          if (statement.kind == NodeKind.IMPORT) {\n            let importState = <ImportStatement>statement;\n            for (let i = 0; importState.declarations && i < importState.declarations.length; i++) {\n              let nodeName = importState.declarations[i].range.toString();\n              console.log(`nodeName: ${nodeName}`);\n            }\n          }\n        }\n      }\n    });\n  }\n\n  logElementsByDeclaration(): void {\n    this.program.elementsByDeclaration.forEach((_, key) => {\n      if (key.kind == NodeKind.IMPORTDECLARATION || key.kind == NodeKind.IMPORT) {\n        console.log(`Decalaration kind: ${NodeKind[key.kind]}`);\n      }\n    });\n  }\n}","export class Collections {\n\n  /**\n   * Check the array is empty\n   * @param arr parameter array\n   */\n  static isEmptyArray<T>(arr: T[]): boolean {\n    return arr.length == 0;\n  }\n\n  static newArray<T>(arg1: T): T[] {\n    var arr = new Array<T>();\n    arr.push(arg1);\n    return arr;\n  }\n}\n","import {\n  ElementKind,\n  Element,\n  ClassPrototype,\n  FunctionPrototype,\n  Program,\n  VariableLikeElement,\n} from \"../program\";\n\nimport {\n  DecoratorKind,\n  FunctionDeclaration,\n  DeclarationStatement,\n  FieldDeclaration,\n  NodeKind,\n  ParameterNode,\n  Expression,\n  VariableLikeDeclarationStatement,\n  StringLiteralExpression,\n  TypeNode,\n  DecoratorNode,\n  Node,\n  ClassDeclaration,\n  NamedTypeNode,\n} from \"../ast\";\n\nimport {\n  AstUtil\n} from \"./utils\";\n\nimport {\n  Strings,\n  AbiUtils\n} from \"./primitiveutil\";\nimport { ProgramAnalyzar } from \"./analyzer\";\nimport { ContractProgram } from \"./interperter\";\nimport { NamedTypeNodeDef } from \"./contract/base\";\nclass StructDef {\n  name: string = '';\n  fields: Array<Object> = new Array<Object>();\n  base: string = '';\n\n  addField(name: string, type: string): void {\n    this.fields.push({ \"name\": name, \"type\": type });\n  }\n}\n\n\nclass AbiAliasDef {\n  new_type_name: string;\n  type: string;\n\n  constructor(newTypeName: string, wasmType: string) {\n    this.new_type_name = newTypeName;\n    this.type = wasmType;\n  }\n}\n\n/**\n * Contract abi action. This class represents one action structure.\n * The field \"ability\" represents whether action would change the db status.\n * It has two values, normal and pureview.\n * Pureview represents readable action which would not change the db.\n */\nclass ActionDef {\n  name: string;\n  type: string;\n  ability: string;\n  ricardian_contract: string = \"\";\n\n  constructor(name: string, type: string, ability: string = \"normal\") {\n    this.name = name;\n    this.type = type;\n    this.ability = ability;\n  }\n\n  static isValidAbility(ability: string): boolean {\n    return ability == \"normal\" || ability == \"pureview\";\n  }\n}\n\nexport class AbiHelper {\n  /**\n   * Main node support internal abi type\n   * bool\n   */\n  static abiTypeLookup: Map<string, string> = new Map([\n    [\"i8\", \"int8\"],\n    [\"i16\", \"int16\"],\n    [\"i32\", \"int32\"],\n    [\"i64\", \"int64\"],\n    [\"isize\", \"uin32\"],\n    [\"u8\", \"uint8\"],\n    [\"u16\", \"uint16\"],\n    [\"u32\", \"uint32\"],\n    [\"u64\", \"uint64\"],\n    [\"usize\", \"usize\"],\n    [\"f32\", \"float32\"],\n    [\"f64\", \"float64\"],\n    [\"bool\", \"bool\"],\n    [\"boolean\", \"bool\"],\n    [\"string\", \"string\"],\n    [\"String\", \"string\"],\n  ]);\n}\n\nclass TableDef {\n  name: string;\n  type: string;\n  index_type: string = \"i64\";\n  keys_names: string[] = [\"currency\"];\n  keys_types: string[] = [\"uint64\"];\n\n  constructor(name: string, type: string, indexType: string = \"i64\") {\n    this.name = name;\n    this.type = type;\n    this.index_type = indexType;\n  }\n}\n\n/**\n * Abi defination\n */\nclass AbiDef {\n  version: string = \"link\";\n  types: Array<AbiAliasDef> = new Array<AbiAliasDef>();\n  structs: Array<StructDef> = new Array<StructDef>();\n  actions: Array<ActionDef> = new Array<ActionDef>();\n  tables: Array<TableDef> = new Array<TableDef>();\n}\n\n\nexport class ContractInfo {\n\n  abiInfo: AbiDef = new AbiDef();\n  program: Program;\n  abiTypeLookup: Map<string, string> = AbiHelper.abiTypeLookup;\n  typeAliasSet: Set<string> = new Set<string>();\n  structsLookup: Map<string, StructDef> = new Map();\n  elementLookup: Map<string, Element> = new Map();\n\n  constructor(program: Program) {\n    this.program = program;\n  }\n\n  private addAbiTypeAlias(typeNodeAnalyzer: NamedTypeNodeDef): void {\n    var asTypes = typeNodeAnalyzer.getAsTypes();\n    for (let asType of asTypes) {\n      if (this.typeAliasSet.has(asType)) {\n        continue;\n      }\n      // if the as argument is basic type, get his alias type\n      let abiType = typeNodeAnalyzer.findSourceAbiType(asType);\n      if (abiType && asType != abiType) {\n        this.abiInfo.types.push(new AbiAliasDef(asType, abiType));\n      }\n      // If the as argument is class, convert it to struct\n      let element = typeNodeAnalyzer.findElement(asType);\n      if (element && element.kind == ElementKind.CLASS_PROTOTYPE) {\n        let classPrototype = <ClassPrototype>element;\n        this.getStructFromClzPrototype(classPrototype);\n      }\n      this.typeAliasSet.add(asType);\n    }\n  }\n\n  resolveDatabaseDecorator(clsProto: ClassPrototype): void {\n    var decorators = clsProto.decoratorNodes;\n    if (!decorators) {\n      return;\n    }\n    for (let decorator of decorators) {\n      if (decorator.decoratorKind == DecoratorKind.DATABASE && decorator.args) {\n        // Decorator argument must have two arguments\n        if (decorator.args.length != 2) {\n          throw new Error(\"Database decorator must have two arguments\");\n        }\n        let type = decorator.args[0].range.toString();\n        let name = this.getExprValue(clsProto, decorator.args[1]);\n        AbiUtils.checkDatabaseName(name);\n        this.abiInfo.tables.push(new TableDef(name, type));\n        this.getStructFromNode(clsProto, decorator.args[0]);\n      }\n    }\n  }\n\n  /**\n   * Get the expression value.\n   * @param expr\n   */\n  getExprValue(protoEle: Element,expr: Expression): string {\n    var arg: string = expr.range.toString();\n    if (Strings.isAroundQuotation(arg)) {\n      return arg.substring(1, arg.length - 1);\n    }\n    var element = protoEle.lookup(arg);\n    var internalName = AstUtil.getInternalName(expr);\n    if (!element) {\n      element = this.program.elementsByName.get(internalName) || null;\n    }\n    if (element) {\n      let declaration = <VariableLikeDeclarationStatement> (<VariableLikeElement>element).declaration;\n      if (declaration.initializer) {\n        let literal = <StringLiteralExpression>declaration.initializer;\n        return literal.value;\n      }\n    }\n    throw new Error(`Can't find constant ${internalName}`);\n  }\n\n  /**\n  *  Get struct from expression.\n  */\n  private getStructFromNode(ele: Element, node: Node): void {\n    var element = ele.lookup(node.range.toString());\n    var classPrototype = <ClassPrototype>element;\n    this.getStructFromClzPrototype(classPrototype);\n  }\n\n  /**\n   * Add the field of the class to the structure\n   * @param classPrototype The class prototype\n   * @param struct The abi structure\n   */\n  private addFieldsFromClassPrototype(classPrototype: ClassPrototype, struct: StructDef): void {\n    var members: DeclarationStatement[] = (<ClassDeclaration>classPrototype.declaration).members;\n    if (classPrototype.basePrototype && AstUtil.impledSerializable(classPrototype.basePrototype)) {\n      this.addFieldsFromClassPrototype(classPrototype.basePrototype, struct);\n    }\n    for (let member of members) {\n      if (member.kind == NodeKind.FIELDDECLARATION) {\n        let fieldDeclare: FieldDeclaration = <FieldDeclaration>member;\n        let memberName = member.name.range.toString();\n        let memberType: TypeNode | null = fieldDeclare.type;\n        if (memberType && !AstUtil.hasSpecifyDecorator(fieldDeclare, DecoratorKind.DEPLOYER)) {\n          let typeNodeAnalyzer: NamedTypeNodeDef = new NamedTypeNodeDef(classPrototype, <NamedTypeNode>memberType);\n          let abiType = typeNodeAnalyzer.getDeclareType();\n          struct.addField(memberName, abiType);\n          this.addAbiTypeAlias(typeNodeAnalyzer);\n        }\n      }\n    }\n  }\n\n  private getStructFromClzPrototype(classPrototype: ClassPrototype): void {\n    if (!this.abiTypeLookup.get(classPrototype.name)) {\n      let struct = new StructDef();\n      struct.name = classPrototype.name;\n      this.addFieldsFromClassPrototype(classPrototype, struct);\n      this.addToStruct(struct);\n    }\n  }\n\n  /**\n   * It need to check the struct having fields.\n   * @param struct the struct to add\n   */\n  private addToStruct(struct: StructDef): void {\n    if (!this.structsLookup.has(struct.name)) {\n      this.abiInfo.structs.push(struct);\n      this.structsLookup.set(struct.name, struct);\n    }\n  }\n\n  /**\n  *  Resolve ClassPrototype to dispatcher\n  */\n  private getActionAbility(funcPrototype: FunctionPrototype): string {\n    var statement = funcPrototype.declaration;\n    var decoratorNode: DecoratorNode | null = AstUtil.getSpecifyDecorator(statement, DecoratorKind.MESSAGE);\n    if (!decoratorNode) {\n      throw new Error(`The function don't have action decorator, location: ${AstUtil.location(statement.range)}.`);\n    }\n    var args: Expression[] | null = decoratorNode.args;\n    if (args && args.length > 0) {\n      let arg = this.getExprValue(funcPrototype, args[0]);\n      if (!ActionDef.isValidAbility(arg)) {\n        throw new Error(`Invalid action ability arguments: ${arg}, location: ${AstUtil.location(statement.range)}.`);\n      }\n      return arg;\n    }\n    return \"normal\";\n  }\n\n  /**\n   * Resolve funciton prototype to abi\n   */\n  private resolveFunctionPrototype(funcProto: FunctionPrototype): void {\n\n    var declaration: FunctionDeclaration = <FunctionDeclaration> funcProto.declaration;\n    var funcName = declaration.name.range.toString();\n    var signature = declaration.signature;\n\n    var struct = new StructDef();\n    struct.name = funcName;\n\n    var parameters: ParameterNode[] = signature.parameters;\n    for (let parameter of parameters) {\n      let type: TypeNode = parameter.type;\n      let typeInfo = new NamedTypeNodeDef(funcProto,  <NamedTypeNode>type);\n      let abiType = typeInfo.getDeclareType();\n      struct.addField(parameter.name.range.toString(), abiType);\n      this.addAbiTypeAlias(typeInfo);\n    }\n\n    this.addToStruct(struct);\n    this.abiInfo.actions.push(new ActionDef(funcName, funcName, this.getActionAbility(funcProto)));\n  }\n}\n\nexport function getContractInfo(program: Program): ContractProgram {\n  new ProgramAnalyzar(program);\n  return new ContractProgram(program);\n}\n","import { DecoratorKind, DecoratorNode, FieldDeclaration, ImportStatement, NamedTypeNode, NodeKind, ParameterNode, Source, SourceKind, TypeDeclaration, TypeNode } from \"../../ast\";\nimport { Element, ElementKind, FieldPrototype, FunctionPrototype, TypeDefinition } from \"../../program\";\nimport { AstUtil } from \"../utils\";\nimport { Collections } from \"../collectionutil\";\nimport { AbiHelper } from \"../contract\";\nimport { LayoutDef } from \"./storage\";\nimport { Strings } from \"../primitiveutil\";\n\n/**\n * The parameter type enum\n * basic type and composite type, array and map. \n * \n */\nexport enum TypeEnum {\n  NUMBER,\n  STRING,\n  ARRAY,\n  MAP,\n  CLASS\n}\nexport class FieldDef {\n  protected fieldPrototype: FieldPrototype;\n  layout: LayoutDef = new LayoutDef();\n  name: string = \"\";\n  type: NamedTypeNodeDef | null = null;\n  storeKey: string = \"\";\n  varName: string = \"\";\n  path: string = \"\";\n\n  constructor(field: FieldPrototype) {\n    this.fieldPrototype = field;\n    this.name = field.name;\n    this.varName = \"_\" + this.name;\n    this.storeKey = this.fieldPrototype.parent.name + this.name;\n    this.resolveField();\n  }\n\n  private resolveField(): void {\n    let fieldDeclaration: FieldDeclaration = <FieldDeclaration>this.fieldPrototype.declaration;\n    let commonType: TypeNode | null = fieldDeclaration.type;\n    if (commonType && commonType.kind == NodeKind.NAMEDTYPE) {\n      let typeNode = <NamedTypeNode>commonType;\n      this.type = new NamedTypeNodeDef(this.fieldPrototype, typeNode);\n    }\n  }\n}\n\nexport class ParameterNodeDef {\n  private parameterNode: ParameterNode;\n  name: string;\n  type: NamedTypeNodeDef;\n\n  constructor(parent: Element, parameterNode: ParameterNode) {\n    this.parameterNode = parameterNode;\n    this.name = this.parameterNode.name.range.toString();\n    this.type = new NamedTypeNodeDef(parent, <NamedTypeNode>this.parameterNode.type);\n  }\n\n  setTypeIndex(typeNodeMap: Map<string, NamedTypeNodeDef>): void {\n    this.type.setTypeIndex(typeNodeMap);\n  }\n}\n\nexport class DecoratorNodeDef {\n  private decorator: DecoratorNode;\n\n  constructor(decorator: DecoratorNode) {\n    this.decorator = decorator;    \n  }\n}\n\nexport class MessageDecoratorNodeDef extends DecoratorNodeDef {\n  \n  private payable: boolean = false;\n  private mutates: string = \"true\";\n  private selector: string = \"\";\n\n  constructor(decorator: DecoratorNode) {\n    super(decorator);\n    if (decorator.args) {\n      decorator.args.forEach(expression => {\n        let identifier = AstUtil.getIdentifier(expression);\n        if (identifier == 'payable') {\n          this.payable = true;\n        } else if (identifier == 'mutates') {\n          this.mutates = AstUtil.getBinaryExprRight(expression);\n        } else if (identifier == 'selector') {\n          this.selector = Strings.removeQuotation(AstUtil.getBinaryExprRight(expression));\n        }\n      });\n    }\n  }\n}\n\nexport class FunctionDef {\n  private funcProto: FunctionPrototype;\n  methodName: string = \"\";\n  parameters: ParameterNodeDef[] = new Array();\n  isReturnable: boolean = false;\n  returnType: NamedTypeNodeDef | undefined;\n  defaultVals: string[] = new Array();\n\n  constructor(funcPrototype: FunctionPrototype) {\n    this.funcProto = funcPrototype;\n    this.methodName = this.funcProto.name;\n    this.resolve();\n  }\n\n  resolve(): void {\n    let params = this.funcProto.functionTypeNode.parameters; \n    params.forEach(param => {\n      this.parameters.push(new ParameterNodeDef(this.funcProto, param));\n    });\n    let returnType = this.funcProto.functionTypeNode.returnType;\n    let returnTypeDesc = new NamedTypeNodeDef(this.funcProto, <NamedTypeNode>returnType);\n    if (!returnTypeDesc.isReturnVoid()) {\n      let wrapType = TypeUtil.getWrapperType(returnTypeDesc.name);\n      returnTypeDesc.codecType = wrapType;\n      returnTypeDesc.originalType = returnTypeDesc.name;\n      this.isReturnable = true;\n    }\n    this.returnType = returnTypeDesc;\n  }\n\n  public setTypeIndex(typeNodeMap: Map<string, NamedTypeNodeDef>): void {\n    this.parameters.forEach(item => {\n      item.setTypeIndex(typeNodeMap);\n    });\n    if (this.isReturnable) {\n      this.returnType!.setTypeIndex(typeNodeMap);\n    }\n  }\n}\n\nexport class MessageFuctionDef extends FunctionDef {\n\n  messageDecorator: MessageDecoratorNodeDef;\n\n  constructor(funcPrototype: FunctionPrototype) {\n    super(funcPrototype);\n    let msgDecorator = AstUtil.getSpecifyDecorator(funcPrototype.declaration, DecoratorKind.MESSAGE);\n    this.messageDecorator =  new MessageDecoratorNodeDef(msgDecorator!);\n  }\n\n}\nexport class TypeUtil {\n\n  static typeWrapperMap: Map<string, string> = new Map([\n    [\"i8\", \"Int8\"],\n    [\"i16\", \"Int16\"],\n    [\"i32\", \"Int32\"],\n    [\"i64\", \"Int64\"],\n    [\"isize\", \"Int32\"],\n    [\"u8\", \"UInt8\"],\n    [\"u16\", \"UInt16\"],\n    [\"u32\", \"UInt32\"],\n    [\"u64\", \"UInt64\"],\n    [\"usize\", \"UInt32\"],\n    [\"f32\", \"float32\"],\n    [\"f64\", \"float64\"],\n    [\"bool\", \"Bool\"],\n    [\"boolean\", \"Bool\"],\n    [\"string\", \"ScaleString\"]\n  ]);\n\n  static abiTypeMap: Map<string, string> = new Map([\n    [\"i8\", \"i8\"],\n    [\"i16\", \"i16\"],\n    [\"i32\", \"i32\"],\n    [\"i64\", \"i64\"],\n    [\"isize\", \"i32\"],\n    [\"u8\", \"u8\"],\n    [\"u16\", \"u16\"],\n    [\"u32\", \"u32\"],\n    [\"u64\", \"u64\"],\n    [\"usize\", \"u32\"],\n    [\"bool\", \"bool\"],\n    [\"boolean\", \"bool\"],\n    [\"string\", \"str\"]\n  ]);\n\n\n  static defaultValMap: Map<string, string> = new Map([\n    [\"i8\", \"0\"],\n    [\"i16\", \"0\"],\n    [\"i32\", \"0\"],\n    [\"i64\", \"0\"],\n    [\"isize\", \"0\"],\n    [\"u8\", \"0\"],\n    [\"u16\", \"0\"],\n    [\"u32\", \"0\"],\n    [\"u64\", \"0\"],\n    [\"usize\", \"0\"],\n    [\"f32\", \"0\"],\n    [\"f64\", \"0\"],\n    [\"bool\", \"false\"],\n    [\"boolean\", \"false\"],\n    [\"string\", \"''\"]\n  ]);\n\n  static getWrapperType(asType: string): string {\n    let type: string | undefined = TypeUtil.typeWrapperMap.get(asType);\n    return type == undefined ? \"\" : type;\n  }\n\n  static getDefaultVal(asType: string): string {\n    let type: string | undefined = TypeUtil.defaultValMap.get(asType);\n    return type == undefined ? \"\" : type;\n  }\n\n  static getAbiType(asType: string): string {\n    let type: string | undefined = TypeUtil.abiTypeMap.get(asType);\n    return type == undefined ? \"\" : type;\n  }\n}\nexport class ImportSourceDef {\n  private entrySources: Source[] = new Array();\n  private importedElement: Set<String> = new Set();\n  unimports: String[] = new Array();\n\n  constructor(sources: Source[]) {\n    sources.forEach(element => {\n      if (element.sourceKind == SourceKind.USER_ENTRY) {\n        this.entrySources.push(element);\n        this.resolveImportSource(element);\n      }\n    });\n  }\n\n  private resolveImportSource(source: Source): void {\n    source.statements.forEach(statement => {\n      if (statement.kind == NodeKind.IMPORT) {\n        let importStatement = <ImportStatement> statement;\n        if (importStatement.declarations) {\n          importStatement.declarations.forEach(declaration => {\n            this.importedElement.add(declaration.range.toString());\n          });\n        }\n      }\n    });\n  }\n\n  toImportElement(name: String): void {\n    if (!this.importedElement.has(name)) {\n      this.unimports.push(name);\n    } \n    this.importedElement.add(name);\n  }\n}\n\n\n/**\n * Type node description\n */\nexport class NamedTypeNodeDef {\n  protected parent: Element;\n  protected typeNode: NamedTypeNode;\n  typeKind: TypeEnum | undefined;\n  typeArguments: NamedTypeNodeDef[] = new Array();\n  name: string = \"\";\n  codecType: string = \"\";\n  originalType: string = \"\";\n  defaultVal: string = \"\";\n  abiType: string = \"\";\n  index: i32 = 0;\n\n  constructor(parent: Element, typeNode: NamedTypeNode) {\n    this.parent = parent;\n    this.typeNode = typeNode;\n    this.name = typeNode.name.range.toString();\n    this.originalType = this.name;\n    this.abiType = TypeUtil.getAbiType(this.name);\n    this.codecType = TypeUtil.getWrapperType(this.originalType);\n    this.defaultVal = TypeUtil.getDefaultVal(this.originalType);\n    this.getArgs();\n  }\n\n  public setTypeIndex(typeNodeMap: Map<string, NamedTypeNodeDef>): void {\n    let originalType = this.originalType;\n    if (!typeNodeMap.has(originalType)) {\n      this.index = typeNodeMap.size + 1;\n      typeNodeMap.set(originalType, this);\n    } else {\n      let typeDef = typeNodeMap.get(originalType);\n      this.index = typeDef!.index;\n    }\n  }\n\n\n  getDeclareType(): string {\n    return this.typeNode.range.toString();\n  }\n\n  isReturnVoid(): boolean {\n    return this.name == \"void\";\n  }\n\n  get typeEnum(): TypeEnum {\n    var typeName = this.name;\n    if (AstUtil.isString(typeName)) {\n      return TypeEnum.STRING;\n    }\n    if (AstUtil.isArrayType(typeName)) {\n      return TypeEnum.ARRAY;\n    }\n    if (AstUtil.isMapType(typeName)) {\n      return TypeEnum.MAP;\n    }\n    var type = this.findElement(typeName);\n\n    if (type) {\n      if (type.kind == ElementKind.TYPEDEFINITION) {\n        let typeDefine = <TypeDefinition>type;\n        let declaration = <TypeDeclaration>typeDefine.declaration;\n        let _typeNode = <NamedTypeNode>declaration.type;\n        let name = _typeNode.name.range.toString();\n        if (AbiHelper.abiTypeLookup.get(name) && name != \"Asset\") {\n          return TypeEnum.NUMBER;\n        }\n      }\n      if (type.kind == ElementKind.CLASS_PROTOTYPE) {\n        return TypeEnum.CLASS;\n      }\n    }\n    return TypeEnum.NUMBER;\n  }\n\n  isArray(): boolean {\n    return this.typeEnum == TypeEnum.ARRAY;\n  }\n\n  getArrayArgAbiTypeEnum(): TypeEnum {\n    var typeName = this.getArgs()[0];\n    if (AstUtil.isString(typeName)) {\n      return TypeEnum.STRING;\n    }\n    var type = this.findSourceAsElement(typeName);\n    if (type != null && type.kind == ElementKind.CLASS_PROTOTYPE) {\n      return TypeEnum.CLASS;\n    }\n    return TypeEnum.NUMBER;\n  }\n\n  isPrimaryType(): boolean {\n    if (this.typeEnum == TypeEnum.NUMBER) {\n      return this.findSourceAsTypeName(this.name) == \"u64\";\n    }\n    return false;\n  }\n\n  getArrayArg(): string {\n    if (this.typeNode.typeArguments) {\n      return this.typeNode.typeArguments[0].range.toString();\n    }\n    throw new Error(`The typenode is not array:${this.name}.`\n      + ` Location in ${AstUtil.location(this.typeNode.range)}`);\n  }\n\n  getAbiDeclareType(): string {\n    var abiType = this.typeEnum;\n    var typeName = this.typeNode.name.range.toString();\n    switch (abiType) {\n      case TypeEnum.STRING: {\n        return \"string\";\n      }\n      case TypeEnum.NUMBER:\n      case TypeEnum.CLASS: {\n        return typeName;\n      }\n      case TypeEnum.ARRAY: {\n        return `${this.getArgs()[0]}[]`;\n      }\n      case TypeEnum.MAP: {\n        return `${this.getArgs().join(\",\")}{}`;\n      }\n      default: {\n        return typeName;\n      }\n    }\n  }\n\n  private getArgs(): string[] {\n    var args = this.typeNode.typeArguments;\n    var argType = new Array<string>();\n    if (args) {\n      for (let arg of args) {\n        // console.log(`arg node type kind`, NodeKind[arg.kind]);\n        if (arg.kind == NodeKind.NAMEDTYPE) {\n          let typeAnalyzer: NamedTypeNodeDef = new NamedTypeNodeDef(this.parent, <NamedTypeNode>arg);\n          this.typeArguments.push(typeAnalyzer);\n        }\n        argType.push(arg.range.toString());\n      }\n    }\n    return argType;\n  }\n\n  getAsTypes(): string[] {\n    var args = this.getArgs();\n    if (!Collections.isEmptyArray(args)) {\n      return args;\n    }\n    return [this.name];\n  }\n\n  /**\n  * the typename maybe global scope or local scope.\n  * So search the local firtst, then search the global scope.\n  *\n  * @param typeName typename without type arguments\n  */\n  findElement(typeName: string): Element | null {\n    return this.parent.lookup(typeName);\n  }\n\n  /**\n   * Get the type {@type Type} by the type name\n   * @param asTypeName the AssemblyScript type name\n   */\n  private findSourceAsElement(asTypeName: string): Element | null {\n    var sourceTypeName = this.findSourceAsTypeName(asTypeName);\n    var sourceType: Element | null = this.parent.lookup(sourceTypeName);\n    return sourceType;\n  }\n\n  /**\n   * Find the source type name,\n   * eg: declare type account_name = u64;\n   *     declare type account_name_alias = account_name;\n   *     findSourceAsTypeName(\"account_name_alias\") return \"account_name\";\n   */\n  private findSourceAsTypeName(typeName: string): string {\n    var element = this.parent.lookup(typeName);\n    if (element && element.kind == ElementKind.TYPEDEFINITION) {\n      let typeDefine = <TypeDefinition>element;\n      let aliasTypeName = typeDefine.typeNode.range.toString();\n      return this.findSourceAsTypeName(aliasTypeName);\n    }\n    return typeName;\n  }\n\n  findSourceAbiType(typeName: string): string {\n    var abiType: string | null = AbiHelper.abiTypeLookup.get(typeName) || null;\n    if (abiType) {\n      return abiType;\n    }\n    var element = this.parent.lookup(typeName);\n    if (element && element.kind == ElementKind.TYPEDEFINITION) {\n      let typeDefine = <TypeDefinition>element;\n      let aliasTypeName = typeDefine.typeNode.range.toString();\n      return this.findSourceAbiType(aliasTypeName);\n    }\n    return typeName;\n  }\n}\n","export class TypePair {\n  key: string = \"\";\n  ty: i32 = 0;\n}\n\nexport class StorageDef {\n  className: string = \"\";\n  fields: FieldDef[] = new Array();\n}\n\nexport class LayoutDef {\n}\n\nexport class CellLayoutDef extends LayoutDef {\n  cell: TypePair = new TypePair();\n}\n\nexport class FieldDef {\n  layout: LayoutDef = new LayoutDef();\n  name: string = \"\";\n  fieldType: string = \"\";\n  fieldCodecType: string | undefined = \"\";\n  storeKey: string = \"\";\n  varName: string = \"\";\n  path: string = \"\";\n}","import { FunctionPrototype, ClassPrototype, ElementKind, DeclaredElement, FieldPrototype, Program } from \"../program\";\nimport { Range } from \"../tokenizer\";\nimport { ElementUtil } from \"./utils\";\nimport { FunctionDef, FieldDef, ImportSourceDef, NamedTypeNodeDef, MessageFuctionDef } from \"./contract/base\";\nimport { Strings } from \"./primitiveutil\";\n\nexport class ClassInterpreter {\n  protected classPrototype: ClassPrototype;\n  className: string;\n  instanceName: string;\n  range: Range;\n  \n  constructor(clzPrototype: ClassPrototype) {\n    this.classPrototype = clzPrototype;\n    this.className = clzPrototype.name;\n    this.instanceName = \"_\" + this.className.toLowerCase();\n    this.range = this.classPrototype.declaration.range;\n  }\n}\n\nexport class ContractInterpreter extends ClassInterpreter {\n  name: string;\n  version: string;\n  cntrFuncDefs: FunctionDef[] = new Array();\n  msgFuncDefs: FunctionDef[] = new Array();\n  isReturnable: boolean = false;\n  \n  constructor(clzPrototype: ClassPrototype)  {\n    super(clzPrototype);\n    this.name = Strings.lowerFirstCase(this.className);\n    this.version = \"1.0\";\n    this.instanceName = Strings.lowerFirstCase(this.className);\n    this.resolveContractClass();\n  }\n\n  private resolveContractClass(): void {\n    if (this.classPrototype && this.classPrototype.instanceMembers) {\n      this.classPrototype.instanceMembers.forEach((instance, _) => {\n        if (ElementUtil.isCntrFuncPrototype(instance)) {\n          this.cntrFuncDefs.push(new FunctionDef(<FunctionPrototype>instance));\n        }\n        if (ElementUtil.isMessageFuncPrototype(instance)) {\n          let msgFunc = new MessageFuctionDef(<FunctionPrototype>instance);\n          this.isReturnable = this.isReturnable || msgFunc.isReturnable;\n          this.msgFuncDefs.push(msgFunc);\n        }\n      });\n    }\n  }\n\n  public setTypeIndex(typeNodeMap: Map<string, NamedTypeNodeDef>): void {\n    this.cntrFuncDefs.forEach(funcDef => {\n      funcDef.setTypeIndex(typeNodeMap);\n    });\n    this.msgFuncDefs.forEach(funcDef => {\n      funcDef.setTypeIndex(typeNodeMap);\n    });\n  }\n}\n\nexport class StorageInterpreter extends ClassInterpreter {\n\n  fields: FieldDef[] = new Array();\n  constructor(clzPrototype: ClassPrototype) {\n    super(clzPrototype);\n    if (this.classPrototype.instanceMembers) {\n      this.resolveInstanceMembers(this.classPrototype.instanceMembers);\n    }\n  }\n\n  resolveInstanceMembers(instanceMembers: Map<string, DeclaredElement>): void {\n    instanceMembers.forEach((element, _) => {\n      if (element.kind == ElementKind.FIELD_PROTOTYPE) {\n        this.fields.push(new FieldDef(<FieldPrototype>element));\n      }\n    });\n  }\n\n  setTypeIndex(typeNodeMap: Map<string, NamedTypeNodeDef>): void {\n    this.fields.forEach(item => {\n      if (item.type) {\n        item.type.setTypeIndex(typeNodeMap);\n      }\n    });\n  }\n}\n\nexport class ContractProgram {\n  program: Program;\n  contract: ContractInterpreter | null;\n  storages: StorageInterpreter[] = new Array();\n  types: NamedTypeNodeDef[] = new Array();\n  fields: FieldDef[] = new Array();\n  import: ImportSourceDef;\n  \n  private typeNodeMap: Map<string, NamedTypeNodeDef> = new Map<string, NamedTypeNodeDef>();\n\n  constructor(program: Program) {\n    this.program = program;\n    this.contract = null;\n    this.import = new ImportSourceDef(program.sources);\n    this.resolve();\n    this.sortStorages();\n    this.getFields();\n  }\n\n  private sortStorages(): void {\n    this.storages.sort((a: ClassInterpreter, b: ClassInterpreter): i32 => b.range.start - a.range.start);\n  }\n\n  private getFields(): void {\n    this.storages.forEach(item => {\n      item.fields.forEach(field => {\n        this.fields.push(field);\n      });\n    });\n  }\n  \n  private addDefaultImports(): void {\n    this.import.toImportElement(\"FnParameters\");\n    this.import.toImportElement(\"Msg\");\n    this.import.toImportElement(\"Storage\");\n    if (this.contract && this.contract.isReturnable) {\n      this.import.toImportElement(\"ReturnData\");\n    }\n  }\n\n  private resolve(): void {\n    this.program.elementsByName.forEach((element, _) => {\n      if (ElementUtil.isContractClassPrototype(element)) {\n        this.contract = new ContractInterpreter(<ClassPrototype>element);\n      }\n      if (ElementUtil.isStoreClassPrototype(element)) {\n        this.storages.push(new StorageInterpreter(<ClassPrototype>element));\n      }\n    });\n    this.setTypeIndex();\n    this.addDefaultImports();\n\n    this.typeNodeMap.forEach((value, _) => {\n      this.types.push(value);\n      this.import.toImportElement(value.codecType);\n    });\n  }\n\n  private setTypeIndex(): void {\n    if (this.contract) {\n      this.contract.setTypeIndex(this.typeNodeMap);\n    }\n    this.storages.forEach(storage => {\n      storage.setTypeIndex(this.typeNodeMap);\n    });\n  }\n}","export class Strings {\n\n  /**\n     * Judge the string whetehr aroud by qutation or not.\n     * The charcode of '\"' is 0x22\n     * @param str The string to judge\n     */\n  static isAroundQuotation(str: string): bool {\n    if (str == undefined || str == null) {\n      return false;\n    }\n    var beginChar = str.charCodeAt(0);\n    var endChar = str.charCodeAt(str.length - 1);\n    return (beginChar == endChar) && (beginChar == 0x22 || beginChar == 0x27);\n  }\n\n  static EMPTY = '';\n\n  /**\n   * If the string around quotation, remove the quotation.\n   * @param str The source string\n   */\n  static removeQuotation(str: string): string {\n    if (Strings.isAroundQuotation(str)) {\n      return str.substring(1, str.length - 1);\n    }\n    return str;\n  }\n\n  static lowerFirstCase(str: string): string {\n    if (str.length <= 1) {\n      return str.toLowerCase();\n    } else {\n      return str.substring(0, 1).toLowerCase() + str.substring(1, str.length);\n    }\n  }\n}\n\nexport class AbiUtils {\n  private static DATABASE_CHARSETS = \"abcdefghijklmnopqrstuvwxyz12345.\";\n\n  /**\n   * Check the action name whether is legal.\n   * The action name should be less or equal than 21 characters.\n   * @param str the action name\n   */\n  static checkActionName(str: string): void {\n    assert(str.length > 0, `Action name should not empty.`);\n    assert(str.length <= 21, `Action Name:${str} should be less than 21 characters.`);\n  }\n\n  /**\n   * Check the database name whether is legal.\n   * The database name should be less or equal than 12 characters.\n   * @param name the database name\n   */\n  static checkDatabaseName(name: string): void {\n    assert(name.length > 0, `Table name should not empty.`);\n    assert(name.length <= 12, `Table name Name:${name} should be less than 12 characters.`);\n    for (let aChar of name) {\n      assert(AbiUtils.DATABASE_CHARSETS.includes(aChar), `Table name:${name} should only contain the chars:${AbiUtils.DATABASE_CHARSETS}`);\n    }\n  }\n}\nexport class Verify {\n\n  static verify(expression: boolean, message: string): void {\n    if (!expression) {\n      throw new Error(message);\n    }\n  }\n}\n","import {\n  DeclarationStatement,\n  DecoratorKind,\n  Node,\n  ClassDeclaration,\n  DecoratorNode,\n  Expression,\n  NodeKind,\n  IdentifierExpression,\n  BinaryExpression\n} from \"../ast\";\n\nimport {\n  Range\n} from \"../tokenizer\";\n\nimport {\n  ClassPrototype,\n  Element,\n  ElementKind,\n  FunctionPrototype\n} from \"../program\";\nimport { DecoratorNodeDef } from \"./contract/base\";\n\nexport class ElementUtil {\n\n  static isContractClassPrototype(element: Element): boolean {\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      let clzPrototype = <ClassPrototype>element;\n      return clzPrototype.instanceMembers != null &&\n        AstUtil.hasSpecifyDecorator(clzPrototype.declaration, DecoratorKind.CONTRACT);\n    }\n    return false;\n  }\n\n  static isStoreClassPrototype(element: Element): boolean {\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      let clzPrototype = <ClassPrototype>element;\n      return clzPrototype.instanceMembers != null &&\n        AstUtil.hasSpecifyDecorator(clzPrototype.declaration, DecoratorKind.STORAGE);\n    }\n    return false;\n  }\n\n  /**\n   * Check the element whether is action function prototype.\n   * @param element \n   */\n  static isCntrFuncPrototype(element: Element): boolean {\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      return AstUtil.hasSpecifyDecorator((<FunctionPrototype>element).declaration, DecoratorKind.CONSTRUCTOR);\n    }\n    return false;\n  }\n\n  /**\n   * Check the element whether is action function prototype.\n   * @param element \n   */\n  static isMessageFuncPrototype(element: Element): boolean {\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      let funcType = <FunctionPrototype>element;\n      return AstUtil.hasSpecifyDecorator(funcType.declaration, DecoratorKind.MESSAGE);\n    }\n    return false;\n  }\n\n}\nexport class AstUtil {\n\n  static getSpecifyDecorator(statement: DeclarationStatement, kind: DecoratorKind): DecoratorNode | null {\n    if (statement.decorators) {\n      for (let decorator of statement.decorators) {\n        if (decorator.decoratorKind == kind) {\n          return decorator;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n     * Check the statment weather have the specify the decorator\n     * @param statement Ast declaration statement\n     * @param kind The specify decorators\n     */\n  static hasSpecifyDecorator(statement: DeclarationStatement, kind: DecoratorKind): boolean {\n    if (statement.decorators) {      \n      for (let decorator of statement.decorators) {\n        if (decorator.decoratorKind == kind) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  static getIdentifier(expression: Expression): string {\n    if (expression.kind == NodeKind.IDENTIFIER) {\n      return (<IdentifierExpression>expression).text;\n    } else if (expression.kind == NodeKind.BINARY) {\n      return (<BinaryExpression>expression).left.range.toString();\n    }\n    return \"\";\n  }\n\n  static getBinaryExprRight(expression: Expression): string {\n    if (expression.kind == NodeKind.BINARY) {\n      return (<BinaryExpression>expression).right.range.toString();\n    }\n    return \"\";\n  }\n\n  static isString(typeName: string): boolean {\n    return \"string\" == typeName || \"String\" == typeName;\n  }\n\n  /**\n     * Get the node internal name\n     * @param node The program node\n     */\n  static getInternalName(node: Node): string {\n    var internalPath = node.range.source.internalPath;\n    var name = node.range.toString();\n    var internalName = `${internalPath}/${name}`;\n    return internalName.replace(\",\", \"_\");\n  }\n\n  /**\n     * Get the basic type name\n     * If the type name is string[], so the basic type name is string\n     * @param declareType\n     */\n  static getArrayTypeArgument(declareType: string): string {\n    var bracketIndex = declareType.indexOf(\"[\");\n    if (bracketIndex != -1) {\n      let index = declareType.indexOf(\" \") == -1 ? bracketIndex : declareType.indexOf(\" \");\n      return declareType.substring(0, index);\n    }\n    bracketIndex = declareType.indexOf(\"<\");\n    if (bracketIndex != -1) {\n      let endIndex = declareType.indexOf(\">\");\n      return declareType.substring(bracketIndex + 1, endIndex);\n    }\n    return declareType;\n  }\n\n  /**\n     * Test the declare type whether is array type or not.\n     * @param declareType The declare type\n     */\n  static isArrayType(declareType: string): boolean {\n    return declareType == \"[]\" || declareType == \"Array\";\n  }\n\n  /**\n     * Whether the declare type is map\n     * @param declareType the declare type\n     */\n  static isMapType(declareType: string): boolean {\n    return declareType == \"Map\";\n  }\n\n  /**\n     * Test the class whether to implement the Serializable interface or not.\n     */\n  static impledSerializable(classPrototype: ClassPrototype | null): boolean {\n    if (!classPrototype) {\n      return false;\n    }\n    const interfaceName = \"Serializable\";\n    var havingInterface = AstUtil.impledInterface(<ClassDeclaration>classPrototype.declaration, interfaceName);\n    return havingInterface || AstUtil.impledSerializable(classPrototype.basePrototype);\n  }\n\n  /**\n     * Test the class whetherto implement the Returnable interface or not.\n     * @param classDeclaration The class declaration\n     */\n  static impledReturnable(classDeclaration: ClassDeclaration): boolean {\n    const interfaceName = \"Returnable\";\n    return AstUtil.impledInterface(classDeclaration, interfaceName);\n  }\n\n  private static impledInterface(classDeclaration: ClassDeclaration, interfaceName: string): boolean {\n    var implementsTypes = classDeclaration.implementsTypes;\n    if (implementsTypes) {\n      for (let _type of implementsTypes) {\n        if (_type.name.range.toString() == interfaceName) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n     * Check the classPrototype whther have the contract class.\n     */\n  static extendedContract(classPrototype: ClassPrototype): boolean {\n    const contractName = \"Contract\";\n    var basePrototype: ClassPrototype | null = classPrototype.basePrototype;\n    if (basePrototype && basePrototype.name == contractName) {\n      return true;\n    }\n    return false;\n  }\n\n  static isClassPrototype(element: Element): boolean {\n    return element.kind == ElementKind.CLASS_PROTOTYPE;\n  }\n\n  static isSpecifyElement(element: Element, kind: ElementKind): boolean {\n    return element.kind == kind;\n  }\n\n  /**\n     * Get interfaces that class prototype implements.\n     * @param classPrototype classPrototype\n     */\n  static impledInterfaces(classPrototype: ClassPrototype): string[] {\n    var tempClz: ClassPrototype | null = classPrototype;\n    var interfaces: string[] = new Array<string>();\n    while (tempClz != null) {\n      let implTypes = (<ClassDeclaration>tempClz.declaration).implementsTypes;\n      if (implTypes) {\n        for (let type of implTypes) {\n          interfaces.push(type.name.range.toString());\n        }\n      }\n      tempClz = tempClz.basePrototype;\n    }\n    return interfaces;\n  }\n\n  static location(range: Range): string {\n    // TODO\n    return range.source.normalizedPath + \":\"\n      + range.start.toString(10) + \":\"\n      + range.end.toString(10);\n  }\n}","/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    var builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.SOURCE: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TYPEPARAMETER: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.SUPER:\n      case NodeKind.THIS:\n      case NodeKind.TRUE:\n      case NodeKind.CONSTRUCTOR:\n      case NodeKind.IDENTIFIER: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.ASSERTION: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.BINARY: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.CALL: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.CLASS: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.COMMA: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.NEW: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.PARENTHESIZED: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.BLOCK: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.BREAK: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.DO: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.EXPORT: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTIMPORT: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.FOR: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.FOROF: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.IF: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.RETURN: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.THROW: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.TRY: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.WHILE: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMVALUEDECLARATION: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.IMPORTDECLARATION: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.METHODDECLARATION: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VARIABLEDECLARATION: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.DECORATOR: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.EXPORTMEMBER: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.PARAMETER: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SWITCHCASE: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.INDEXSIGNATURE: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    var statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    var sb = this.sb;\n    var current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    var typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    var isNullable = node.isNullable;\n    var sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    var explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    var parameters = node.parameters;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    var returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"[\");\n    var elements = node.elementExpressions;\n    var numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    var sb = this.sb;\n    var names = node.names;\n    var values = node.values;\n    var numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name === value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    var sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.PREFIX: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.AS: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NONNULL: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.CONST: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    var sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    var numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    var declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    var expressions = node.expressions;\n    var numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    var sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    var declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.FLOAT: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.INTEGER: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.STRING: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.REGEXP: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.ARRAY: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.OBJECT: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    this.sb.push(i64_to_string(node.value));\n  }\n\n  visitStringLiteral(str: string, singleQuoted: bool = false): void {\n    var sb = this.sb;\n    var off = 0;\n    var quote = singleQuoted ? \"'\" : \"\\\"\";\n    sb.push(quote);\n    var i = 0;\n    for (let k = str.length; i < k;) {\n      switch (str.charCodeAt(i)) {\n        case CharCode.NULL: {\n          if (i > off) sb.push(str.substring(off, off = i + 1));\n          sb.push(\"\\\\0\");\n          off = ++i;\n          break;\n        }\n        case CharCode.BACKSPACE: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\b\");\n          break;\n        }\n        case CharCode.TAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\t\");\n          break;\n        }\n        case CharCode.LINEFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\n\");\n          break;\n        }\n        case CharCode.VERTICALTAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\v\");\n          break;\n        }\n        case CharCode.FORMFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\f\");\n          break;\n        }\n        case CharCode.CARRIAGERETURN: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\r\");\n          off = ++i;\n          break;\n        }\n        case CharCode.DOUBLEQUOTE: {\n          if (!singleQuoted) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\\\\"\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.SINGLEQUOTE: {\n          if (singleQuoted) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\'\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.BACKSLASH: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\\\");\n          off = ++i;\n          break;\n        }\n        default: {\n          ++i;\n          break;\n        }\n      }\n    }\n    if (i > off) sb.push(str.substring(off, i));\n    sb.push(quote);\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    var sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    var sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.VARIABLE || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.EXPRESSION  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CLOSEBRACE ||\n        last.charCodeAt(lastCharPos) == CharCode.SEMICOLON)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    var sb = this.sb;\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    var indexSignature = node.indexSignature;\n    var members = node.members;\n    var numMembers = members.length;\n    if (indexSignature !== null || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FIELDDECLARATION || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    var sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.statement);\n    if (node.statement.kind == NodeKind.BLOCK) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    var values = node.values;\n    var numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    var sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    var members = node.members;\n    if (members != null && members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    var path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    var declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    var type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    var initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    var condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    var incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    var sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    var signature = node.signature;\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    var body = node.body;\n    var returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    var sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    var ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.BLOCK) {\n      sb.push(\";\\n\");\n    }\n    var ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.BLOCK) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    var externalName = node.foreignName;\n    var name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"import \");\n    var declarations = node.declarations;\n    var namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    var sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.GET)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.SET)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    var members = node.members;\n    var numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    var value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    var sb = this.sb;\n    var label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    var sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    var sb = this.sb;\n    sb.push(\"try {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var statements = node.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[i]);\n    }\n    var catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    var finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    var declarations = node.declarations;\n    var numDeclarations = assert(declarations.length);\n    var firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.CONST) ? \"const \" : firstDeclaration.is(CommonFlags.LET) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    var sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    var statement = node.statement;\n    if (statement.kind == NodeKind.EMPTY) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(node.statement);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    var sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    var args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    var sb = this.sb;\n    var kind = node.parameterKind;\n    var implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.REST) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.OPTIONAL && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.EXPORT)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.IMPORT)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.DECLARE)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.PUBLIC)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.PRIVATE)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.PROTECTED)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.STATIC)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.ABSTRACT)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.READONLY)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    var ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n","/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Global,\n  Field,\n  Class\n} from \"./program\";\n\nimport {\n  NativeType,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getConstValueI64High,\n  getUnaryValue,\n  getCallOperandAt,\n  traverse\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  uniqueMap\n} from \"./util\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  RETURNS = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  RETURNS_WRAPPED = 1 << 1,\n  /** This flow always returns a non-null value. */\n  RETURNS_NONNULL = 1 << 2,\n  /** This flow always throws. */\n  THROWS = 1 << 3,\n  /** This flow always breaks. */\n  BREAKS = 1 << 4,\n  /** This flow always continues. */\n  CONTINUES = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  ACCESSES_THIS = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CALLS_SUPER = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  TERMINATES = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  CONDITIONALLY_RETURNS = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  CONDITIONALLY_THROWS = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  CONDITIONALLY_BREAKS = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  CONDITIONALLY_CONTINUES = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  CONDITIONALLY_ACCESSES_THIS = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MAY_RETURN_NONTHIS = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UNCHECKED_CONTEXT = 1 << 15,\n\n  // masks\n\n  /** Any categorical flag. */\n  ANY_CATEGORICAL = FlowFlags.RETURNS\n                  | FlowFlags.RETURNS_WRAPPED\n                  | FlowFlags.RETURNS_NONNULL\n                  | FlowFlags.THROWS\n                  | FlowFlags.BREAKS\n                  | FlowFlags.CONTINUES\n                  | FlowFlags.ACCESSES_THIS\n                  | FlowFlags.CALLS_SUPER\n                  | FlowFlags.TERMINATES,\n\n  /** Any conditional flag. */\n  ANY_CONDITIONAL = FlowFlags.CONDITIONALLY_RETURNS\n                  | FlowFlags.CONDITIONALLY_THROWS\n                  | FlowFlags.CONDITIONALLY_BREAKS\n                  | FlowFlags.CONDITIONALLY_CONTINUES\n                  | FlowFlags.CONDITIONALLY_ACCESSES_THIS\n}\n\n/** Flags indicating the current state of a local. */\nexport enum LocalFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  /** Local is constant. */\n  CONSTANT = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  WRAPPED = 1 << 1,\n  /** Local is non-null. */\n  NONNULL = 1 << 2,\n  /** Local is initialized. */\n  INITIALIZED = 1 << 3,\n  /** Local is retained. */\n  RETAINED = 1 << 4,\n\n  /** Local must be conditionally retained. */\n  CONDITIONALLY_RETAINED = 1 << 5,\n\n  /** Any retained flag. */\n  ANY_RETAINED = RETAINED\n               | CONDITIONALLY_RETAINED\n}\n\n/** Flags indicating the current state of a field. */\nexport enum FieldFlags {\n  NONE = 0,\n  INITIALIZED = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  UNKNOWN,\n  /** Condition is always true. */\n  TRUE,\n  /** Condition is always false. */\n  FALSE\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the parent flow of the specified function. */\n  static createParent(parentFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    if (parentFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow within `parentFunction`. */\n  static createInline(parentFunction: Function, inlineFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    flow.inlineFunction = inlineFunction;\n    flow.inlineReturnLabel = inlineFunction.internalName + \"|inlined.\" + (inlineFunction.nextInlineId++).toString();\n    if (inlineFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Function this flow belongs to. */\n    public parentFunction: Function\n  ) {\n    /* nop */\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.NONE;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Field,FieldFlags> | null = null;\n  /** Function being inlined, when inlining. */\n  inlineFunction: Function | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction !== null;\n  }\n\n  /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */\n  get actualFunction(): Function {\n    var inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.parentFunction;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.actualFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.actualFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  /** Forks this flow to a child flow. */\n  fork(resetBreakContext: bool = false): Flow {\n    var branch = new Flow(this.parentFunction);\n    branch.parent = this;\n    if (resetBreakContext) {\n      branch.flags = this.flags & ~(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS |\n        FlowFlags.CONTINUES |\n        FlowFlags.CONDITIONALLY_CONTINUES\n      );\n    } else {\n      branch.flags = this.flags;\n      branch.continueLabel = this.continueLabel;\n      branch.breakLabel = this.breakLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = uniqueMap<Field,FieldFlags>(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineFunction = this.inlineFunction;\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type, except: Set<i32> | null = null): Local {\n    var parentFunction = this.parentFunction;\n    var temps: Local[] | null;\n    switch (<u32>type.toNativeType()) {\n      case <u32>NativeType.I32: { temps = parentFunction.tempI32s; break; }\n      case <u32>NativeType.I64: { temps = parentFunction.tempI64s; break; }\n      case <u32>NativeType.F32: { temps = parentFunction.tempF32s; break; }\n      case <u32>NativeType.F64: { temps = parentFunction.tempF64s; break; }\n      case <u32>NativeType.V128: { temps = parentFunction.tempV128s; break; }\n      case <u32>NativeType.Funcref: { temps = parentFunction.tempFuncrefs; break; }\n      case <u32>NativeType.Externref: { temps = parentFunction.tempExternrefs; break; }\n      case <u32>NativeType.Exnref: { temps = parentFunction.tempExnrefs; break; }\n      case <u32>NativeType.Anyref: { temps = parentFunction.tempAnyrefs; break; }\n      default: throw new Error(\"concrete type expected\");\n    }\n    var local: Local;\n    if (except) {\n      if (temps !== null && temps.length > 0) {\n        for (let i = 0, k = temps.length; i < k; ++i) {\n          if (!except.has(temps[i].index)) {\n            local = temps[i];\n            let k = temps.length - 1;\n            while (i < k) unchecked(temps[i] = temps[i++ + 1]);\n            temps.length = k;\n            local.type = type;\n            local.flags = CommonFlags.NONE;\n            this.unsetLocalFlag(local.index, ~0);\n            return local;\n          }\n        }\n      }\n      local = parentFunction.addLocal(type);\n    } else {\n      if (temps !== null && temps.length > 0) {\n        local = assert(temps.pop());\n        local.type = type;\n        local.flags = CommonFlags.NONE;\n      } else {\n        local = parentFunction.addLocal(type);\n      }\n    }\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Gets a local that sticks around until this flow is exited, and then released. */\n  getAutoreleaseLocal(type: Type, except: Set<i32> | null = null): Local {\n    var local = this.getTempLocal(type, except);\n    local.set(CommonFlags.SCOPED);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    scopedLocals.set(\"~auto\" + (this.parentFunction.nextAutoreleaseId++).toString(), local);\n    this.setLocalFlag(local.index, LocalFlags.RETAINED);\n    return local;\n  }\n\n  /** Frees the temporary local for reuse. */\n  freeTempLocal(local: Local): void {\n    if (local.is(CommonFlags.INLINED)) return;\n    assert(local.index >= 0);\n    var parentFunction = this.parentFunction;\n    var temps: Local[];\n    assert(local.type != null); // internal error\n    local.resetTemporaryName();\n    switch (<u32>local.type.toNativeType()) {\n      case <u32>NativeType.I32: {\n        let tempI32s = parentFunction.tempI32s;\n        if (tempI32s) temps = tempI32s;\n        else parentFunction.tempI32s = temps = [];\n        break;\n      }\n      case <u32>NativeType.I64: {\n        let tempI64s = parentFunction.tempI64s;\n        if (tempI64s) temps = tempI64s;\n        else parentFunction.tempI64s = temps = [];\n        break;\n      }\n      case <u32>NativeType.F32: {\n        let tempF32s = parentFunction.tempF32s;\n        if (tempF32s) temps = tempF32s;\n        else parentFunction.tempF32s = temps = [];\n        break;\n      }\n      case <u32>NativeType.F64: {\n        let tempF64s = parentFunction.tempF64s;\n        if (tempF64s) temps = tempF64s;\n        else parentFunction.tempF64s = temps = [];\n        break;\n      }\n      case <u32>NativeType.V128: {\n        let tempV128s = parentFunction.tempV128s;\n        if (tempV128s) temps = tempV128s;\n        else parentFunction.tempV128s = temps = [];\n        break;\n      }\n      case <u32>NativeType.Funcref: {\n        let tempFuncrefs = parentFunction.tempFuncrefs;\n        if (tempFuncrefs) temps = tempFuncrefs;\n        else parentFunction.tempFuncrefs = temps = [];\n        break;\n      }\n      case <u32>NativeType.Externref: {\n        let tempExternrefs = parentFunction.tempExternrefs;\n        if (tempExternrefs) temps = tempExternrefs;\n        else parentFunction.tempExternrefs = temps = [];\n        break;\n      }\n      case <u32>NativeType.Exnref: {\n        let tempExnrefs = parentFunction.tempExnrefs;\n        if (tempExnrefs) temps = tempExnrefs;\n        else parentFunction.tempExnrefs = temps = [];\n        break;\n      }\n      case <u32>NativeType.Anyref: {\n        let tempAnyrefs = parentFunction.tempAnyrefs;\n        if (tempAnyrefs) temps = tempAnyrefs;\n        else parentFunction.tempAnyrefs = temps = [];\n        break;\n      }\n      default: throw new Error(\"concrete type expected\");\n    }\n    assert(local.index >= 0);\n    temps.push(local);\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals !== null && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type, except: Set<i32> | null = null): Local {\n    var scopedLocal = this.getTempLocal(type, except);\n    scopedLocal.setTemporaryName(name);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type): Local {\n    var scopedDummy = new Local(name, -1, type, this.parentFunction);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedDummy.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else {\n      let existingLocal = scopedLocals.get(name);\n      if (existingLocal) {\n        if (reportNode) {\n          if (!existingLocal.declaration.range.source.isNative) {\n            this.parentFunction.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportNode.range,\n              existingLocal.declaration.name.range,\n              name\n            );\n          } else {\n            this.parentFunction.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportNode.range, name\n            );\n          }\n        }\n        return existingLocal;\n      }\n    }\n    assert(index < this.parentFunction.localsByIndex.length);\n    var scopedAlias = new Local(name, index, type, this.parentFunction);\n    // not flagged as SCOPED as it must not be free'd when the flow is finalized\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Tests if this flow has any scoped locals that must be free'd. */\n  get hasScopedLocals(): bool {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    var scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Frees this flow's scoped variables and returns its parent flow. */\n  freeScopedLocals(): void {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          this.freeTempLocal(local);\n        }\n      }\n      this.scopedLocals = null;\n    }\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    var current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope !== null && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    var localsByName = this.parentFunction.localsByName;\n    if (localsByName.has(name)) return assert(localsByName.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    var element = this.lookupLocal(name);\n    if (element) return element;\n    return this.actualFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    var actualFunction = this.actualFunction;\n    assert(actualFunction.is(CommonFlags.CONSTRUCTOR));\n    var actualParent = actualFunction.parent;\n    assert(actualParent.kind == ElementKind.CLASS);\n    var actualClass = <Class>actualParent;\n    this.thisFieldFlags = new Map();\n    var members = actualClass.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind == ElementKind.FIELD) {\n          let field = <Field>member;\n          if (\n            // guaranteed by super\n            field.parent != actualClass ||\n            // has field initializer\n            field.initializerNode !== null ||\n            // is initialized as a ctor parameter\n            field.prototype.parameterIndex != -1 ||\n            // is safe to initialize with zero\n            field.type.isAny(TypeFlags.VALUE | TypeFlags.NULLABLE)\n          ) {\n            this.setThisFieldFlag(field, FieldFlags.INITIALIZED);\n          }\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Field, flag: FieldFlags): bool {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Field, flag: FieldFlags): void {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n    }\n  }\n\n  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */\n  pushBreakLabel(): string {\n    var parentFunction = this.parentFunction;\n    var id = parentFunction.nextBreakId++;\n    var stack = parentFunction.breakStack;\n    if (!stack) parentFunction.breakStack = [ id ];\n    else stack.push(id);\n    var label = id.toString();\n    parentFunction.breakLabel = label;\n    return label;\n  }\n\n  /** Pops the most recent break label from the stack. */\n  popBreakLabel(): void {\n    var parentFunction = this.parentFunction;\n    var stack = assert(parentFunction.breakStack);\n    var length = assert(stack.length);\n    stack.pop();\n    if (length > 1) {\n      parentFunction.breakLabel = stack[length - 2].toString();\n    } else {\n      parentFunction.breakLabel = null;\n      parentFunction.breakStack = null;\n    }\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.parentFunction == this.parentFunction);\n    assert(other.parent == this); // currently the case, but might change\n    var otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        otherFlags &= ~FlowFlags.TERMINATES;\n      }\n      otherFlags &= ~(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */\n  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.UNKNOWN): void {\n    assert(other.parentFunction == this.parentFunction);\n    switch (conditionKind) {\n      case ConditionKind.TRUE: this.inherit(other); // always executes\n      case ConditionKind.FALSE: return;             // never executes\n    }\n\n    // Note that flags in `this` flow have already happened. For instance,\n    // a return cannot be undone no matter what'd happen in subsequent branches,\n    // but an allocation, which doesn't terminate, can become conditional. Not\n    // all flags have a corresponding conditional flag that's tracked.\n\n    var thisFlags = this.flags;\n    var otherFlags = other.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (thisFlags & FlowFlags.RETURNS) { // nothing can change that\n      newFlags |= FlowFlags.RETURNS;\n    } else if (otherFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_WRAPPED;\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_NONNULL;\n\n    if (thisFlags & FlowFlags.THROWS) { // nothing can change that\n      newFlags |= FlowFlags.THROWS;\n    } else if (otherFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (thisFlags & FlowFlags.BREAKS) { // nothing can change that\n      newFlags |= FlowFlags.BREAKS;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (thisFlags & FlowFlags.CONTINUES) { // nothing can change that\n      newFlags |= FlowFlags.CONTINUES;\n    } else if (other.continueLabel === this.continueLabel) {\n      if (otherFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (thisFlags & FlowFlags.ACCESSES_THIS) { // can become conditional\n      if (otherFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (otherFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CALLS_SUPER;\n\n    if (thisFlags & FlowFlags.TERMINATES) { // nothing can change that\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (thisFlags & FlowFlags.UNCHECKED_CONTEXT);\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    var numThisLocalFlags = thisLocalFlags.length;\n    var otherLocalFlags = other.localFlags;\n    var numOtherLocalFlags = otherLocalFlags.length;\n    var maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      let newFlags = thisFlags & otherFlags & (\n        LocalFlags.CONSTANT  |\n        LocalFlags.WRAPPED   |\n        LocalFlags.NONNULL   |\n        LocalFlags.INITIALIZED\n      );\n      if (thisFlags & LocalFlags.RETAINED) {\n        if (otherFlags & LocalFlags.RETAINED) {\n          newFlags |= LocalFlags.RETAINED;\n        } else {\n          newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n        }\n      } else if (otherFlags & LocalFlags.RETAINED) {\n        newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & LocalFlags.CONDITIONALLY_RETAINED;\n      }\n      thisLocalFlags[i] = newFlags;\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */\n  inheritMutual(left: Flow, right: Flow): void {\n    assert(left.parentFunction == right.parentFunction);\n    assert(left.parentFunction == this.parentFunction);\n    // This differs from the previous method in that no flags are guaranteed\n    // to happen unless it is the case in both flows.\n\n    var leftFlags = left.flags;\n    var rightFlags = right.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (leftFlags & FlowFlags.RETURNS) {\n      if (rightFlags & FlowFlags.RETURNS) {\n        newFlags |= FlowFlags.RETURNS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n      }\n    } else if (rightFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_WRAPPED) && (rightFlags & FlowFlags.RETURNS_WRAPPED)) {\n      newFlags |= FlowFlags.RETURNS_WRAPPED;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_NONNULL) && (rightFlags & FlowFlags.RETURNS_NONNULL)) {\n      newFlags |= FlowFlags.RETURNS_NONNULL;\n    }\n\n    if (leftFlags & FlowFlags.THROWS) {\n      if (rightFlags & FlowFlags.THROWS) {\n        newFlags |= FlowFlags.THROWS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n      }\n    } else if (rightFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (leftFlags & FlowFlags.BREAKS) {\n      if (rightFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.BREAKS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else if (rightFlags & FlowFlags.BREAKS) {\n      newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (leftFlags & FlowFlags.CONTINUES) {\n      if (rightFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONTINUES;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else if (rightFlags & FlowFlags.CONTINUES) {\n      newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (leftFlags & FlowFlags.ACCESSES_THIS) {\n      if (rightFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (rightFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    if ((leftFlags & FlowFlags.CALLS_SUPER) && (rightFlags & FlowFlags.CALLS_SUPER)) {\n      newFlags |= FlowFlags.CALLS_SUPER;\n    }\n\n    if ((leftFlags & FlowFlags.TERMINATES) && (rightFlags & FlowFlags.TERMINATES)) {\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (this.flags & FlowFlags.UNCHECKED_CONTEXT);\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.TERMINATES) {\n      if (!(rightFlags & FlowFlags.TERMINATES)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.TERMINATES) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        let newFlags = leftFlags & rightFlags & (\n          LocalFlags.CONSTANT  |\n          LocalFlags.WRAPPED   |\n          LocalFlags.NONNULL   |\n          LocalFlags.INITIALIZED\n        );\n        if (leftFlags & LocalFlags.RETAINED) {\n          if (rightFlags & LocalFlags.RETAINED) {\n            newFlags |= LocalFlags.RETAINED;\n          } else {\n            newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n          }\n        } else if (rightFlags & LocalFlags.RETAINED) {\n          newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n        } else {\n          newFlags |= (leftFlags | rightFlags) & LocalFlags.CONDITIONALLY_RETAINED;\n        }\n        thisLocalFlags[i] = newFlags;\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    var leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Field,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.INITIALIZED) != 0 && rightFieldFlags.has(key) && \n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.INITIALIZED)\n        ) {\n          newFieldFlags.set(key, FieldFlags.INITIALIZED);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if the specified flows have differing local states. */\n  static hasIncompatibleLocalStates(before: Flow, after: Flow): bool {\n    var numThisLocalFlags = before.localFlags.length;\n    var numOtherLocalFlags = after.localFlags.length;\n    var parentFunction = before.parentFunction;\n    assert(parentFunction === after.parentFunction);\n    var localsByIndex = parentFunction.localsByIndex;\n    assert(localsByIndex === after.parentFunction.localsByIndex);\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (before.isLocalFlag(i, LocalFlags.WRAPPED) && !after.isLocalFlag(i, LocalFlags.WRAPPED)) {\n          return true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (before.isLocalFlag(i, LocalFlags.NONNULL) && !after.isLocalFlag(i, LocalFlags.NONNULL)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Unifies local flags between this and the other flow. */\n  unifyLocalFlags(other: Flow): void {\n    var numThisLocalFlags = this.localFlags.length;\n    var numOtherLocalFlags = other.localFlags.length;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {\n        this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped\n      }\n      if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {\n        this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null\n      }\n      assert(\n        // having different retain states would be a problem because the compiler\n        // either can't release a retained local or would release a non-retained local\n        this.isAnyLocalFlag(i, LocalFlags.ANY_RETAINED) == other.isAnyLocalFlag(i, LocalFlags.ANY_RETAINED)\n      );\n    }\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (!ifFalse) break;\n        if (getExpressionId(ifFalse) == ExpressionId.Const) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          if (\n            (getExpressionType(ifFalse) == NativeType.I32 && getConstValueI32(ifFalse) == 0) ||\n            (getExpressionType(ifFalse) == NativeType.I64 && getConstValueI64Low(ifFalse) == 0 && getConstValueI64High(ifFalse) == 0)\n          ) {\n            this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n            this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n          }\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 && getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        let name = getCallTarget(expr);\n        let program = this.parentFunction.program;\n        if (name == program.retainInstance.internalName) {\n          // __retain just passes through the argument\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        if (getExpressionId(ifTrue) == ExpressionId.Const) {\n          let ifFalse = getIfFalse(expr);\n          if (!ifFalse) break;\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          let exprType = getExpressionType(ifTrue);\n          if (\n            (exprType == NativeType.I32 && getConstValueI32(ifTrue) != 0) ||\n            (exprType == NativeType.I64 && (getConstValueI64Low(ifTrue) != 0 || getConstValueI64High(ifTrue) != 0))\n          ) {\n            this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n            this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n          }\n\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true for this to become false\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 || getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true for this to become false\n            }\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n    assert(type != Type.void);\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    var operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.parentFunction.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.GLOBAL);\n        return canConversionOverflow((<Global>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>NativeType.I32: { value = getConstValueI32(expr); break; }\n          case <u32>NativeType.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>NativeType.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>NativeType.F64: { value = i32(getConstValueF64(expr)); break; }\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.I8: return value < <i32>i8.MIN_VALUE || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16: return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8: return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16: return value < 0 || value > <i32>u16.MAX_VALUE;\n          case TypeKind.BOOL: return (value & ~1) != 0;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.parentFunction.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.FUNCTION);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.RETURNS_WRAPPED)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    var levels = 0;\n    var parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    var sb = new Array<string>();\n    if (this.is(FlowFlags.RETURNS)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.RETURNS_WRAPPED)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.RETURNS_NONNULL)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.THROWS)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.BREAKS)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.CONTINUES)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.ACCESSES_THIS)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CALLS_SUPER)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.TERMINATES)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.CONDITIONALLY_RETURNS)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.CONDITIONALLY_THROWS)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.CONDITIONALLY_BREAKS)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.CONDITIONALLY_CONTINUES)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.CONDITIONALLY_ACCESSES_THIS)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MAY_RETURN_NONTHIS)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return \"Flow(\" + this.actualFunction.toString() + \")[\" + levels.toString() + \"] \" + sb.join(\" \");\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n\n/** Finds all indexes of locals used in the specified expression. */\nexport function findUsedLocals(expr: ExpressionRef, used: Set<i32> = new Set<i32>()): Set<i32> {\n  traverse(expr, used, findUsedLocalsVisit);\n  return used;\n}\n\n/** A visitor function for use with `traverse` that finds all indexes of used locals. */\nfunction findUsedLocalsVisit(expr: ExpressionRef, used: Set<i32>): void {\n  switch (getExpressionId(expr)) {\n    case ExpressionId.LocalGet: {\n      used.add(getLocalGetIndex(expr));\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      used.add(getLocalSetIndex(expr));\n      // fall-through for value\n    }\n    default: traverse(expr, used, findUsedLocalsVisit);\n  }\n}\n","/**\n * @fileoverview JavaScript glue code.\n * @license Apache-2.0\n */\n\nimport \"../../../std/portable/index\";\nimport \"../binaryen\";\nimport \"./float\";\nimport \"./i64\";\nimport \"./collections\";\n","/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport { Target, Feature } from \"./common\";\nimport { Compiler, Options } from \"./compiler\";\nimport { IDLBuilder, TSDBuilder } from \"./definitions\";\nimport { DiagnosticMessage, DiagnosticCategory, formatDiagnosticMessage } from \"./diagnostics\";\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Sets a 'globalAliases' value. */\nexport function setGlobalAlias(options: Options, alias: string, name: string): void {\n  var globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Sets the `explicitStart` option. */\nexport function setExplicitStart(options: Options, explicitStart: bool): void {\n  options.explicitStart = explicitStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SIGN_EXTENSION;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MUTABLE_GLOBALS;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NONTRAPPING_F2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BULK_MEMORY;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.SIMD;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.THREADS;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.EXCEPTION_HANDLING;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TAIL_CALLS;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.REFERENCE_TYPES;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MULTI_VALUE;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.MEMORY64;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.INFO;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.WARNING;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.ERROR;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds WebIDL definitions for the specified program. */\nexport function buildIDL(program: Program): string {\n  return IDLBuilder.build(program);\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program): string {\n  return TSDBuilder.build(program);\n}\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./definitions\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./ext/contract\";\n// TODO: When vTables are pulled, perhaps it would be better to extend an ASTWalker\nexport * from \"./extra/ast\";\nimport * as util from \"./util/index\";\nexport { util };\n\n// TODO: compat with 0.9, remove with 0.10\nexport * from \"./util/index\";\n","/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { Target } from \"./common\";\nimport * as binaryen from \"./glue/binaryen\";\n\nexport type ModuleRef = usize;\nexport type FunctionRef = usize;\nexport type ExpressionRef = usize;\nexport type GlobalRef = usize;\nexport type EventRef = usize;\nexport type ImportRef = usize;\nexport type ExportRef = usize;\nexport type RelooperRef = usize;\nexport type RelooperBlockRef = usize;\nexport type Index = u32;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\nexport type NativeType = usize;\nexport namespace NativeType {\n  export const None: NativeType = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: NativeType = 1 /* _BinaryenTypeUnreachable */;\n  export const I32: NativeType = 2 /* _BinaryenTypeInt32 */;\n  export const I64: NativeType = 3 /* _BinaryenTypeInt64 */;\n  export const F32: NativeType = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: NativeType = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: NativeType = 6 /* _BinaryenTypeVec128 */;\n  export const Funcref: NativeType = 7 /* _BinaryenTypeFuncref */;\n  export const Externref: NativeType = 8 /* _BinaryenTypeExternref */;\n  export const Exnref: NativeType = 9 /* _BinaryenTypeExnref */;\n  export const Anyref: NativeType = 10 /* _BinaryenTypeAnyref */;\n  export const Auto: NativeType = -1 /* _BinaryenTypeAuto */;\n}\n\nexport enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGloabls = 2 /* _BinaryenFeatureMutableGlobals */,\n  NontrappingFPToInt = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD128 = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048, // TODO: missing in Binaryen API\n  All = 4095 /* _BinaryenFeatureAll */\n}\n\nexport enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  // SIMDLoadStoreLane = 35,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIsNull = 42 /* _BinaryenRefIsNullId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  Try = 45 /* _BinaryenTryId */,\n  Throw = 46 /* _BinaryenThrowId */,\n  Rethrow = 47 /* _BinaryenRethrowId */,\n  BrOnExn = 48 /* _BinaryenBrOnExnId */,\n  TupleMake = 49 /* _BinaryenTupleMakeId */,\n  TupleExtract = 50 /* _BinaryenTupleExtractId */\n}\n\nexport enum UnaryOp {\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  ExtendI32 = 22 /* _BinaryenExtendSInt32 */,\n  ExtendU32 = 23 /* _BinaryenExtendUInt32 */,\n  WrapI64 = 24 /* _BinaryenWrapInt64 */,\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  ReinterpretF32 = 33 /* _BinaryenReinterpretFloat32 */,\n  ReinterpretF64 = 34 /* _BinaryenReinterpretFloat64 */,\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  PromoteF32 = 43 /* _BinaryenPromoteFloat32 */,\n  DemoteF64 = 44 /* _BinaryenDemoteFloat64 */,\n  ReinterpretI32 = 45 /* _BinaryenReinterpretInt32 */,\n  ReinterpretI64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n  ExtendI8ToI32 = 47 /* _BinaryenExtendS8Int32 */,\n  ExtendI16ToI32 = 48 /* _BinaryenExtendS16Int32 */,\n  ExtendI8ToI64 = 49 /* _BinaryenExtendS8Int64 */,\n  ExtendI16ToI64 = 50 /* _BinaryenExtendS16Int64 */,\n  ExtendI32ToI64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  TruncF32ToI32Sat = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  TruncF32ToU32Sat = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  TruncF64ToI32Sat = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  TruncF64ToU32Sat = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  TruncF32ToI64Sat = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  TruncF32ToU64Sat = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  TruncF64ToI64Sat = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  TruncF64ToU64Sat = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  AbsI8x16 = 67 /* __BinaryenAbsVecI8x16 */,\n  NegI8x16 = 68 /* _BinaryenNegVecI8x16 */,\n  AnyTrueI8x16 = 69 /* _BinaryenAnyTrueVecI8x16 */,\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  BitmaskI8x16 = 71 /* __BinaryenBitmaskVecI8x16 */,\n  AbsI16x8 = 72 /* __BinaryenAbsVecI16x8 */,\n  // PopcntVecI8x16\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  AnyTrueI16x8 = 75 /* _BinaryenAnyTrueVecI16x8 */,\n  AllTrueI16x8 = 76 /* _BinaryenAllTrueVecI16x8 */,\n  BitmaskI16x8 = 77 /* _BinaryenBitmaskVecI16x8 */,\n  AbsI32x4 = 78 /* _BinaryenAbsVecI32x4 */,\n  NegI32x4 = 79 /* _BinaryenNegVecI32x4 */,\n  AnyTrueI32x4 = 80 /* _BinaryenAnyTrueVecI32x4 */,\n  AllTrueI32x4 = 81 /* _BinaryenAllTrueVecI32x4 */,\n  BitmaskI32x4 = 82 /* _BinaryenBitmaskVecI32x4 */,\n  NegI64x2 = 83 /* _BinaryenNegVecI64x2 */,\n  AnyTrueI64x2 = 84 /* _BinaryenAnyTrueVecI64x2 */,\n  AllTrueI64x2 = 85 /* _BinaryenAllTrueVecI64x2 */,\n  AbsF32x4 = 86 /* _BinaryenAbsVecF32x4 */,\n  NegF32x4 = 87 /* _BinaryenNegVecF32x4 */,\n  SqrtF32x4 = 88 /* _BinaryenSqrtVecF32x4 */,\n  CeilF32x4 = 89 /* _BinaryenCeilVecF32x4 */,\n  FloorF32x4 = 90 /* _BinaryenFloorVecF32x4 */,\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  AbsF64x2 = 93 /* _BinaryenAbsVecF64x2 */,\n  NegF64x2 = 94 /* _BinaryenNegVecF64x2 */,\n  SqrtF64x2 = 95 /* _BinaryenSqrtVecF64x2 */,\n  CeilF64x2 = 96 /* _BinaryenCeilVecF64x2 */,\n  FloorF64x2 = 97 /* _BinaryenFloorVecF64x2 */,\n  TruncF64x2 = 97 /* BinaryenTruncVecF64x2 */,\n  NearestF64x2 = 98 /* BinaryenNearestVecF64x2 */,\n  TruncSatF32x4ToI32x4 = 100 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  TruncSatF32x4ToU32x4 = 101 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  TruncSatF64x2ToI64x2 = 102 /* _BinaryenTruncSatSVecF64x2ToVecI64x2 */,\n  TruncSatF64x2ToU64x2 = 103 /* _BinaryenTruncSatUVecF64x2ToVecI64x2 */,\n  ConvertI32x4ToF32x4 = 104 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  ConvertU32x4ToF32x4 = 105 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  ConvertI64x2ToF64x2 = 106 /* _BinaryenConvertSVecI64x2ToVecF64x2 */,\n  ConvertU64x2ToF64x2 = 107 /* _BinaryenConvertUVecI64x2ToVecF64x2 */,\n  WidenLowI8x16ToI16x8 = 108 /* _BinaryenWidenLowSVecI8x16ToVecI16x8 */,\n  WidenHighI8x16ToI16x8 = 109 /* _BinaryenWidenHighSVecI8x16ToVecI16x8 */,\n  WidenLowU8x16ToU16x8 = 110 /* _BinaryenWidenLowUVecI8x16ToVecI16x8 */,\n  WidenHighU8x16ToU16x8 = 111 /* _BinaryenWidenHighUVecI8x16ToVecI16x8 */,\n  WidenLowI16x8ToI32x4 = 112 /* _BinaryenWidenLowSVecI16x8ToVecI32x4 */,\n  WidenHighI16x8ToI32x4 = 113 /* _BinaryenWidenHighSVecI16x8ToVecI32x4 */,\n  WidenLowU16x8ToU32x4 = 114 /* _BinaryenWidenLowUVecI16x8ToVecI32x4 */,\n  WidenHighU16x8ToU32x4 = 115 /* _BinaryenWidenHighUVecI16x8ToVecI32x4 */\n}\n\nexport enum BinaryOp {\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  EqF32x4 = 106 /* _BinaryenEqVecF32x4 */,\n  NeF32x4 = 107 /* _BinaryenNeVecF32x4 */,\n  LtF32x4 = 108 /* _BinaryenLtVecF32x4 */,\n  GtF32x4 = 109 /* _BinaryenGtVecF32x4 */,\n  LeF32x4 = 110 /* _BinaryenLeVecF32x4 */,\n  GeF32x4 = 111 /* _BinaryenGeVecF32x4 */,\n  EqF64x2 = 112 /* _BinaryenEqVecF64x2 */,\n  NeF64x2 = 113 /* _BinaryenNeVecF64x2 */,\n  LtF64x2 = 114 /* _BinaryenLtVecF64x2 */,\n  GtF64x2 = 115 /* _BinaryenGtVecF64x2 */,\n  LeF64x2 = 116 /* _BinaryenLeVecF64x2 */,\n  GeF64x2 = 117 /* _BinaryenGeVecF64x2 */,\n  AndV128 = 118 /* _BinaryenAndVec128 */,\n  OrV128 = 119 /* _BinaryenOrVec128 */,\n  XorV128 = 120 /* _BinaryenXorVec128 */,\n  AndNotV128 = 121 /* _BinaryenAndNotVec128 */,\n  AddI8x16 = 122 /* _BinaryenAddVecI8x16 */,\n  AddSatI8x16 = 123 /* _BinaryenAddSatSVecI8x16 */,\n  AddSatU8x16 = 124 /* _BinaryenAddSatUVecI8x16 */,\n  SubI8x16 = 125 /* _BinaryenSubVecI8x16 */,\n  SubSatI8x16 = 126 /* _BinaryenSubSatSVecI8x16 */,\n  SubSatU8x16 = 127 /* _BinaryenSubSatUVecI8x16 */,\n  MulI8x16 = 128 /* _BinaryenMulVecI8x16 */,\n  MinI8x16 = 129 /* _BinaryenMinSVecI8x16 */,\n  MinU8x16 = 130 /* _BinaryenMinUVecI8x16 */,\n  MaxI8x16 = 131 /* _BinaryenMaxSVecI8x16 */,\n  MaxU8x16 = 132 /* _BinaryenMaxUVecI8x16 */,\n  AvgrU8x16 = 133 /* _BinaryenAvgrUVecI8x16 */,\n  AddI16x8 = 134 /* _BinaryenAddVecI16x8 */,\n  AddSatI16x8 = 135 /* _BinaryenAddSatSVecI16x8 */,\n  AddSatU16x8 = 136 /* _BinaryenAddSatUVecI16x8 */,\n  SubI16x8 = 137 /* _BinaryenSubVecI16x8 */,\n  SubSatI16x8 = 138 /* _BinaryenSubSatSVecI16x8 */,\n  SubSatU16x8 = 139 /* _BinaryenSubSatUVecI16x8 */,\n  MulI16x8 = 140 /* _BinaryenMulVecI16x8 */,\n  MinI16x8 = 141 /* _BinaryenMinSVecI16x8 */,\n  MinU16x8 = 142 /* _BinaryenMinUVecI16x8 */,\n  MaxI16x8 = 143 /* _BinaryenMaxSVecI16x8 */,\n  MaxU16x8 = 144 /* _BinaryenMaxUVecI16x8 */,\n  AvgrU16x8 = 145 /* _BinaryenAvgrUVecI16x8 */,\n  // Q15MulrSatSVecI16x8,\n  // ExtMulLowSVecI16x8,\n  // ExtMulHighSVecI16x8,\n  // ExtMulLowUVecI16x8,\n  // ExtMulHighUVecI16x8,\n  AddI32x4 = 151 /* _BinaryenAddVecI32x4 */,\n  SubI32x4 = 152 /* _BinaryenSubVecI32x4 */,\n  MulI32x4 = 153 /* _BinaryenMulVecI32x4 */,\n  MinI32x4 = 154 /* _BinaryenMinSVecI32x4 */,\n  MinU32x4 = 155 /* _BinaryenMinUVecI32x4 */,\n  MaxI32x4 = 156 /* _BinaryenMaxSVecI32x4 */,\n  MaxU32x4 = 157 /* _BinaryenMaxUVecI32x4 */,\n  DotI16x8 = 158 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  AddI64x2 = 163 /* _BinaryenAddVecI64x2 */,\n  SubI64x2 = 164 /* _BinaryenSubVecI64x2 */,\n  // ExtMulLowSVecI64x2\n  // ExtMulHighSVecI64x2\n  // ExtMulLowUVecI64x2\n  // ExtMulHighUVecI64x2\n  AddF32x4 = 170 /* _BinaryenAddVecF32x4 */,\n  SubF32x4 = 171 /* _BinaryenSubVecF32x4 */,\n  MulF32x4 = 172 /* _BinaryenMulVecF32x4 */,\n  DivF32x4 = 173 /* _BinaryenDivVecF32x4 */,\n  MinF32x4 = 174 /* _BinaryenMinVecF32x4 */,\n  MaxF32x4 = 175 /* _BinaryenMaxVecF32x4 */,\n  PminF32x4 = 176 /* _BinaryenPMinVecF32x4 */,\n  PmaxF32x4 = 177 /* _BinaryenPMaxVecF32x4 */,\n  AddF64x2 = 178 /* _BinaryenAddVecF64x2 */,\n  SubF64x2 = 179 /* _BinaryenSubVecF64x2 */,\n  MulF64x2 = 180 /* _BinaryenMulVecF64x2 */,\n  DivF64x2 = 181 /* _BinaryenDivVecF64x2 */,\n  MinF64x2 = 182 /* _BinaryenMinVecF64x2 */,\n  MaxF64x2 = 183 /* _BinaryenMaxVecF64x2 */,\n  PminF64x2 = 184 /* _BinaryenPMinVecF64x2 */,\n  PmaxF64x2 = 185 /* _BinaryenPMaxVecF64x2 */,\n  NarrowI16x8ToI8x16 = 186 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  NarrowU16x8ToU8x16 = 187 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  NarrowI32x4ToI16x8 = 188 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  NarrowU32x4ToU16x8 = 189 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  SwizzleV8x16 = 190 /* _BinaryenSwizzleVec8x16 */\n}\n\nexport enum AtomicRMWOp {\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\nexport enum SIMDExtractOp {\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\nexport enum SIMDReplaceOp {\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\nexport enum SIMDShiftOp {\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\nexport enum SIMDTernaryOp {\n  Bitselect = 0 /* _BinaryenBitselectVec128 */,\n  QFMAF32x4 = 1 /* _BinaryenQFMAVecF32x4 */,\n  QFMSF32x4 = 2 /* _BinaryenQFMSVecF32x4 */,\n  QFMAF64x2 = 3 /* _BinaryenQFMAVecF64x2 */,\n  QFMSF64x2 = 4 /* _BinaryenQFMSVecF64x2 */\n}\n\nexport enum SIMDLoadOp {\n  LoadSplatV8x16 = 0 /* _BinaryenLoadSplatVec8x16 */,\n  LoadSplatV16x8 = 1 /* _BinaryenLoadSplatVec16x8 */,\n  LoadSplatV32x4 = 2 /* _BinaryenLoadSplatVec32x4 */,\n  LoadSplatV64x2 = 3 /* _BinaryenLoadSplatVec64x2 */,\n  LoadI8ToI16x8 = 4 /* _BinaryenLoadExtSVec8x8ToVecI16x8 */,\n  LoadU8ToU16x8 = 5 /* _BinaryenLoadExtUVec8x8ToVecI16x8 */,\n  LoadI16ToI32x4 = 6 /* _BinaryenLoadExtSVec16x4ToVecI32x4 */,\n  LoadU16ToU32x4 = 7 /* _BinaryenLoadExtUVec16x4ToVecI32x4 */,\n  LoadI32ToI64x2 = 8 /* _BinaryenLoadExtSVec32x2ToVecI64x2 */,\n  LoadU32ToU64x2 = 9 /* _BinaryenLoadExtUVec32x2ToVecI64x2 */\n}\n\nexport enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef\n  ) {\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n  }\n\n  private lit: usize;\n\n  static create(): Module {\n    return new Module(binaryen._BinaryenModuleCreate());\n  }\n\n  static createFrom(buffer: Uint8Array): Module {\n    var cArr = allocU8Array(buffer);\n    var module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length));\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f32(value: f32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    var out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, bytes[i]);\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: NativeType): ExpressionRef {\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenUnary(this.ref, op, expr);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(): ExpressionRef {\n    return binaryen._BinaryenMemorySize(this.ref);\n  }\n\n  memory_grow(delta: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenMemoryGrow(this.ref, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    type: NativeType = NativeType.Auto\n  ): ExpressionRef {\n    if (type == NativeType.Auto) type = binaryen._BinaryenExpressionGetType(value);\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: NativeType\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount);\n  }\n\n  atomic_fence(): ExpressionRef {\n    return binaryen._BinaryenAtomicFence(this.ref);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: NativeType = NativeType.None\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    var cArr = allocPtrArray(children);\n    var ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: NativeType = NativeType.None\n  ): ExpressionRef {\n    var length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      assert(singleType == NativeType.Unreachable || singleType == type);\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: NativeType = NativeType.Auto\n  ): ExpressionRef {\n    if (type == NativeType.Auto) {\n      type = binaryen._BinaryenExpressionGetType(ifTrue);\n      assert(type == binaryen._BinaryenExpressionGetType(ifFalse));\n    }\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var numNames = names.length;\n    var strs = new Array<usize>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      strs[i] = this.allocStringCached(names[i]);\n    }\n    var cArr = allocPtrArray(strs);\n    var cStr = this.allocStringCached(defaultName);\n    var ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: NativeType,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(target);\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: NativeType\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: NativeType,\n    results: NativeType,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: NativeType,\n    results: NativeType\n  ): ExpressionRef {\n    return this.call_indirect(index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size);\n  }\n\n  // exception handling\n\n  try(\n    body: ExpressionRef,\n    catchBody: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenTry(this.ref, body, catchBody);\n  }\n\n  throw(\n    eventName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(eventName);\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    exnref: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRethrow(this.ref, exnref);\n  }\n\n  br_on_exn(\n    name: string,\n    eventName: string,\n    exnref: ExpressionRef\n  ): ExpressionRef {\n    var cStr1 = this.allocStringCached(name);\n    var cStr2 = this.allocStringCached(eventName);\n    return binaryen._BinaryenBrOnExn(this.ref, cStr1, cStr2, exnref);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    var cArr = allocU8Array(mask);\n    var ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr);\n  }\n\n  // reference types\n\n  ref_is_null(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIsNull(this.ref, expr);\n  }\n\n  ref_func(\n    name: string\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: NativeType,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n  }\n\n  // events\n\n  addEvent(\n    name: string,\n    attribute: u32,\n    params: NativeType,\n    results: NativeType\n  ): EventRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddEvent(this.ref, cStr, attribute, params, results);\n  }\n\n  getEvent(\n    name: string\n  ): EventRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetEvent(this.ref, cStr);\n  }\n\n  removeEvent(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveEvent(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: NativeType,\n    results: NativeType,\n    varTypes: NativeType[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocPtrArray(varTypes);\n    var ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: NativeType,\n    paramTypes: NativeType[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    var cArr = allocPtrArray(paramTypes);\n    var ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addEventExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddEventExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    var cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: NativeType,\n    results: NativeType\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: NativeType,\n    mutable: bool = false\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addEventImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    attribute: u32,\n    params: NativeType,\n    results: NativeType\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddEventImport(\n      this.ref, cStr1, cStr2, cStr3, attribute, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    shared: bool = false\n  ): void {\n    var cStr = this.allocStringCached(exportName);\n    var k = segments.length;\n    var segs = new Array<usize>(k);\n    var psvs = new Uint8Array(k);\n    var offs = new Array<ExpressionRef>(k);\n    var sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = segments[i];\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      segs[i] = allocU8Array(buffer);\n      psvs[i] = 0; // no passive segments currently\n      offs[i] = target == Target.WASM64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset));\n      sizs[i] = buffer.length;\n    }\n    var cArr1 = allocPtrArray(segs);\n    var cArr2 = allocU8Array(psvs);\n    var cArr3 = allocPtrArray(offs);\n    var cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(segs[i]);\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    var numNames = funcs.length;\n    var names = new Array<usize>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    var cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  }\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    var cStr = this.allocStringCached(key);\n    var ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    var cStr1 = this.allocStringCached(key);\n    var cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPass(pass: string, func: FunctionRef = 0): void {\n    var cStr = allocString(pass);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cStr, 1);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cStr, 1);\n    }\n    binaryen._free(cStr);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    var numNames = passes.length;\n    var cStrs = new Array<usize>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    var cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(optimizeLevel: i32, shrinkLevel: i32, debugInfo: bool = false, usesARC: bool = true): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"merge-locals\");\n\n        passes.push(\"code-folding\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"local-cse\");\n        passes.push(\"reorder-locals\");\n      }\n      // FIXME: see issue #1288\n      // if (usesARC) {\n      //   if (optimizeLevel < 3) {\n      //     passes.push(\"flatten\");\n      //   }\n      //   passes.push(\"post-assemblyscript\");\n      // }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-names\");\n      passes.push(\"remove-unused-brs\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 && shrinkLevel <= 1) {\n        passes.push(\"licm\");\n      }\n      passes.push(\"simplify-locals-nostructure\");\n      passes.push(\"vacuum\");\n\n      passes.push(\"reorder-locals\");\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"vacuum\");\n\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n      }\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"merge-blocks\");\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (usesARC) {\n        // works best after inlining to cover most retains/releases\n        passes.push(\"post-assemblyscript-finalize\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"optimize-instructions\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-nonfunction-module-elements\");\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    var out = this.lit; // safe to reuse as long as..\n    assert(binaryen._BinaryenSizeofLiteral() >= 12);\n    var cStr = allocString(sourceMapUrl);\n    var binaryPtr: usize = 0;\n    var sourceMapPtr: usize = 0;\n    binaryen._BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\n    binaryPtr = assert(binaryen.__i32_load(out));\n    var binaryLen = binaryen.__i32_load(out + 4);\n    sourceMapPtr = binaryen.__i32_load(out + 8); // may be NULL\n    var binary = new BinaryModule(readBuffer(binaryPtr, binaryLen), readString(sourceMapPtr));\n    if (cStr) binaryen._free(cStr);\n    binaryen._free(binaryPtr);\n    if (sourceMapPtr) binaryen._free(sourceMapPtr);\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  toAsmjs(): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  private cachedStrings: Map<string,usize> = new Map();\n\n  private allocStringCached(str: string | null): usize {\n    if (str === null) return 0;\n    var cachedStrings = this.cachedStrings;\n    if (cachedStrings.has(str)) return <usize>cachedStrings.get(str);\n    var ptr = allocString(str);\n    cachedStrings.set(str, ptr);\n    return ptr;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStrings), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStrings = new Map();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  cloneExpression(\n    expr: ExpressionRef,\n    noSideEffects: bool = false,\n    maxDepth: i32 = i32.MAX_VALUE\n  ): ExpressionRef { // currently supports side effect free expressions only\n    if (maxDepth < 0) return 0;\n    maxDepth -= 1;\n\n    var nested1: ExpressionRef,\n        nested2: ExpressionRef;\n\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Const: {\n        switch (<u32>binaryen._BinaryenExpressionGetType(expr)) {\n          case <u32>NativeType.I32: {\n            return this.i32(binaryen._BinaryenConstGetValueI32(expr));\n          }\n          case <u32>NativeType.I64: {\n            return this.i64(\n              binaryen._BinaryenConstGetValueI64Low(expr),\n              binaryen._BinaryenConstGetValueI64High(expr)\n            );\n          }\n          case <u32>NativeType.F32: {\n            return this.f32(binaryen._BinaryenConstGetValueF32(expr));\n          }\n          case <u32>NativeType.F64: {\n            return this.f64(binaryen._BinaryenConstGetValueF64(expr));\n          }\n          case <u32>NativeType.V128: {\n            // TODO\n            return 0;\n          }\n          // Not possible to clone an externref as it is opaque\n          case <u32>NativeType.Externref: {\n            return 0;\n          }\n          default: {\n            throw new Error(\"concrete type expected\");\n          }\n        }\n      }\n      case ExpressionId.LocalGet: {\n        return binaryen._BinaryenLocalGet(this.ref,\n          binaryen._BinaryenLocalGetGetIndex(expr),\n          binaryen._BinaryenExpressionGetType(expr)\n        );\n      }\n      case ExpressionId.GlobalGet: {\n        let globalName = binaryen._BinaryenGlobalGetGetName(expr);\n        if (!globalName) break;\n        return binaryen._BinaryenGlobalGet(\n          this.ref, globalName, binaryen._BinaryenExpressionGetType(expr)\n        );\n      }\n      case ExpressionId.Load: {\n        if (!(nested1 = this.cloneExpression(\n          binaryen._BinaryenLoadGetPtr(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        return (\n          binaryen._BinaryenLoadIsAtomic(expr)\n            ? binaryen._BinaryenAtomicLoad(this.ref,\n                binaryen._BinaryenLoadGetBytes(expr),\n                binaryen._BinaryenLoadGetOffset(expr),\n                binaryen._BinaryenExpressionGetType(expr),\n                nested1\n              )\n            : binaryen._BinaryenLoad(this.ref,\n                binaryen._BinaryenLoadGetBytes(expr),\n                binaryen._BinaryenLoadIsSigned(expr),\n                binaryen._BinaryenLoadGetOffset(expr),\n                binaryen._BinaryenLoadGetAlign(expr),\n                binaryen._BinaryenExpressionGetType(expr),\n                nested1\n              )\n        );\n      }\n      case ExpressionId.Unary: {\n        if (!(nested1 = this.cloneExpression(\n          binaryen._BinaryenUnaryGetValue(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        return binaryen._BinaryenUnary(\n          this.ref, binaryen._BinaryenUnaryGetOp(expr), nested1\n        );\n      }\n      case ExpressionId.Binary: {\n        if (!(nested1 = this.cloneExpression(\n          binaryen._BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        if (!(nested2 = this.cloneExpression(\n          binaryen._BinaryenBinaryGetRight(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        return binaryen._BinaryenBinary(\n          this.ref, binaryen._BinaryenBinaryGetOp(expr), nested1, nested2\n        );\n      }\n    }\n    return 0;\n  }\n\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    var runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    var precomp =  binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      assert(getExpressionId(precomp) == ExpressionId.Const);\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    var cStr = allocString(name);\n    var ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: NativeType[] | null): NativeType {\n  if (!types) return NativeType.None;\n  switch (types.length) {\n    case 0: return NativeType.None;\n    case 1: return types[0];\n  }\n  var cArr = allocPtrArray(types);\n  var ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: NativeType): NativeType[] {\n  var arity = binaryen._BinaryenTypeArity(type);\n  var cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  var types = new Array<NativeType>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    types[i] = binaryen.__i32_load(cArr + (<usize>i << 2));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): NativeType {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): NativeType {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): NativeType {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): NativeType[] {\n  var count = binaryen._BinaryenFunctionGetNumVars(func);\n  var types = new Array<NativeType>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    types[i] = binaryen._BinaryenFunctionGetVar(func, i);\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): NativeType {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// events\n\nexport function getEventName(event: EventRef): string | null {\n  return readString(binaryen._BinaryenEventGetName(event));\n}\n\nexport function getEventAttribute(event: EventRef): u32 {\n  return binaryen._BinaryenEventGetAttribute(event);\n}\n\nexport function getEventParams(event: EventRef): NativeType {\n  return binaryen._BinaryenEventGetParams(event);\n}\n\nexport function getEventResults(event: EventRef): NativeType {\n  return binaryen._BinaryenEventGetResults(event);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    var cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    var cases = this.cases;\n    var index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    var cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    var module = this.module;\n    var cases = this.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    var values = this.values;\n    var numValues = values.length;\n    var indexes = this.indexes;\n    var entry = new Array<ExpressionRef>(1 + numValues + 1);\n    var labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      labels[i] = \"case\" + i.toString() + labelPostfix;\n    }\n    entry[0] = module.local_set(localIndex, this.condition);\n    for (let i = 0; i < numValues; ++i) {\n      let index = indexes[i];\n      entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, NativeType.I32),\n          module.i32(values[i])\n        )\n      );\n    }\n    var defaultIndex = this.defaultIndex;\n    var defaultLabel = \"default\" + labelPostfix;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    var current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(labels[i], block);\n    }\n    var lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ImplicitTrap = 256 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 512 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 1024 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 2048 /* _BinaryenSideEffectDanglingPop */,\n  Any = 4095 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, features);\n}\n\nexport function hasSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): bool {\n  return getSideEffects(expr, features) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  var len = u8s.length;\n  var ptr = binaryen._malloc(len);\n  for (let i = 0; i < len; ++i) {\n    binaryen.__i32_store8(ptr + i, u8s[i]);\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  var len = i32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  var idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = i32s[i];\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  var len = u32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  var idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = u32s[i];\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.WASM64);\n  var len = ptrs.length;\n  var ptr = binaryen._malloc(len << 2);\n  var idx = ptr;\n  for (let i = 0, k = len; i < k; ++i) {\n    let val = ptrs[i];\n    binaryen.__i32_store(idx, <i32>val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  var len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let u = str.charCodeAt(i);\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      len += 1;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else {\n      len += 4;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str === null) return 0;\n  var ptr = binaryen._malloc(stringLengthUTF8(str) + 1) >>> 0;\n  // the following is based on Emscripten's stringToUTF8Array\n  var idx = ptr;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let u = str.charCodeAt(i);\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      binaryen.__i32_store8(idx++, u as u8);\n    } else if (u <= 0x7FF) {\n      binaryen.__i32_store8(idx++, (0xC0 |  (u >>> 6)       ) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\n    } else if (u <= 0xFFFF) {\n      binaryen.__i32_store8(idx++, (0xE0 |  (u >>> 12)      ) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\n    } else {\n      assert(u < 0x200000, \"Invalid Unicode code point during allocString\");\n      binaryen.__i32_store8(idx++, (0xF0 |  (u >>> 18)      ) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>> 12) & 63)) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\n    }\n  }\n  binaryen.__i32_store8(idx, 0);\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  var ret = new Uint8Array(len);\n  for (let i = 0; i < len; ++i) {\n    ret[i] = binaryen.__i32_load8_u(ptr + <usize>i);\n  }\n  return ret;\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  var arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  var cp: u32;\n  var u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(0xD800 | (ch >>> 10));\n      arr.push(0xDC00 | (ch & 0x3FF));\n    }\n  }\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */\nexport function needsExplicitUnreachable(expr: ExpressionRef): bool {\n  // not applicable if pushing a value to the stack\n  if (binaryen._BinaryenExpressionGetType(expr) != NativeType.Unreachable) {\n    return false;\n  }\n\n  switch (binaryen._BinaryenExpressionGetId(expr)) {\n    case ExpressionId.Unreachable:\n    case ExpressionId.Return: return false;\n    case ExpressionId.Break: {\n      return binaryen._BinaryenBreakGetCondition(expr) != 0;\n    }\n    case ExpressionId.Block: {\n      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it\n        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable\n        return (\n          numChildren > 0 &&\n          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))\n        );\n      }\n    }\n  }\n  return true;\n}\n\n/** Traverses all expression members of an expression, calling the given visitor. */\nexport function traverse<T>(\n  expr:  ExpressionRef,\n  data:  T,\n  visit: (expr: ExpressionRef, data: T) => void\n): bool {\n  switch (getExpressionId(expr)) {\n    case ExpressionId.Block: {\n      for (let i: Index = 0, n = binaryen._BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n        visit(binaryen._BinaryenBlockGetChildAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      visit(binaryen._BinaryenIfGetCondition(expr), data);\n      visit(binaryen._BinaryenIfGetIfTrue(expr), data);\n      let ifFalse = binaryen._BinaryenIfGetIfFalse(expr);\n      if (ifFalse) visit(ifFalse, data);\n      break;\n    }\n    case ExpressionId.Loop: {\n      visit(binaryen._BinaryenLoopGetBody(expr), data);\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = binaryen._BinaryenBreakGetCondition(expr);\n      if (condition) visit(condition, data);\n      break;\n    }\n    case ExpressionId.Switch: {\n      visit(binaryen._BinaryenSwitchGetCondition(expr), data);\n      break;\n    }\n    case ExpressionId.Call: {\n      for (let i: Index = 0, n = binaryen._BinaryenCallGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenCallGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      for (let i: Index = 0, n = binaryen._BinaryenCallIndirectGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenCallIndirectGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      visit(binaryen._BinaryenLocalSetGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      visit(binaryen._BinaryenGlobalSetGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Load: {\n      visit(binaryen._BinaryenLoadGetPtr(expr), data);\n      break;\n    }\n    case ExpressionId.Store: {\n      visit(binaryen._BinaryenStoreGetPtr(expr), data);\n      visit(binaryen._BinaryenStoreGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      visit(binaryen._BinaryenUnaryGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Binary: {\n      visit(binaryen._BinaryenBinaryGetLeft(expr), data);\n      visit(binaryen._BinaryenBinaryGetRight(expr), data);\n      break;\n    }\n    case ExpressionId.Select: {\n      visit(binaryen._BinaryenSelectGetIfTrue(expr), data);\n      visit(binaryen._BinaryenSelectGetIfFalse(expr), data);\n      visit(binaryen._BinaryenSelectGetCondition(expr), data);\n      break;\n    }\n    case ExpressionId.Drop: {\n      visit(binaryen._BinaryenDropGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Return: {\n      visit(binaryen._BinaryenReturnGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.MemorySize:\n      break;\n    case ExpressionId.MemoryGrow:\n      visit(binaryen._BinaryenMemoryGrowGetDelta(expr), data);\n      break;\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      visit(binaryen._BinaryenAtomicRMWGetPtr(expr), data);\n      visit(binaryen._BinaryenAtomicRMWGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      visit(binaryen._BinaryenAtomicCmpxchgGetPtr(expr), data);\n      visit(binaryen._BinaryenAtomicCmpxchgGetExpected(expr), data);\n      visit(binaryen._BinaryenAtomicCmpxchgGetReplacement(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      visit(binaryen._BinaryenAtomicWaitGetPtr(expr), data);\n      visit(binaryen._BinaryenAtomicWaitGetExpected(expr), data);\n      visit(binaryen._BinaryenAtomicWaitGetTimeout(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      visit(binaryen._BinaryenAtomicNotifyGetPtr(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      visit(binaryen._BinaryenSIMDExtractGetVec(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      visit(binaryen._BinaryenSIMDReplaceGetVec(expr), data);\n      visit(binaryen._BinaryenSIMDReplaceGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      visit(binaryen._BinaryenSIMDShuffleGetLeft(expr), data);\n      visit(binaryen._BinaryenSIMDShuffleGetRight(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      visit(binaryen._BinaryenSIMDTernaryGetA(expr), data);\n      visit(binaryen._BinaryenSIMDTernaryGetB(expr), data);\n      visit(binaryen._BinaryenSIMDTernaryGetC(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      visit(binaryen._BinaryenSIMDShiftGetVec(expr), data);\n      visit(binaryen._BinaryenSIMDShiftGetShift(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      visit(binaryen._BinaryenSIMDLoadGetPtr(expr), data);\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      visit(binaryen._BinaryenMemoryInitGetDest(expr), data);\n      visit(binaryen._BinaryenMemoryInitGetOffset(expr), data);\n      visit(binaryen._BinaryenMemoryInitGetSize(expr), data);\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      visit(binaryen._BinaryenMemoryCopyGetDest(expr), data);\n      visit(binaryen._BinaryenMemoryCopyGetSource(expr), data);\n      visit(binaryen._BinaryenMemoryCopyGetSize(expr), data);\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      visit(binaryen._BinaryenMemoryFillGetDest(expr), data);\n      visit(binaryen._BinaryenMemoryFillGetValue(expr), data);\n      visit(binaryen._BinaryenMemoryFillGetSize(expr), data);\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIsNull: {\n      visit(binaryen._BinaryenRefIsNullGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.Try: {\n      visit(binaryen._BinaryenTryGetBody(expr), data);\n      visit(binaryen._BinaryenTryGetCatchBody(expr), data);\n      break;\n    }\n    case ExpressionId.Throw: {\n      for (let i: Index = 0, n = binaryen._BinaryenThrowGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenThrowGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      visit(binaryen._BinaryenRethrowGetExnref(expr), data);\n      break;\n    }\n    case ExpressionId.BrOnExn: {\n      visit(binaryen._BinaryenBrOnExnGetExnref(expr), data);\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      for (let i: Index = 0, n = binaryen._BinaryenTupleMakeGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenTupleMakeGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      break;\n    }\n    default: assert(false);\n  }\n  return true;\n}\n","/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  Range,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] | null = null\n  ) {\n    super(diagnostics);\n    this.sources = sources ? sources : new Array<Source>();\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    var normalizedPath = normalizePath(path);\n    var internalPath = mangleInternalPath(path);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text === null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    var source = new Source(\n      isEntry\n        ? SourceKind.USER_ENTRY\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LIBRARY_ENTRY\n            : SourceKind.LIBRARY\n          : SourceKind.USER,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n\n    // tokenize and parse\n    var tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    var statements = source.statements;\n    while (!tn.skip(Token.ENDOFFILE)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    var flags = CommonFlags.NONE;\n    var startPos = -1;\n\n    // check decorators\n    var decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.AT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    var exportStart = 0;\n    var exportEnd = 0;\n    var defaultStart = 0;\n    var defaultEnd = 0;\n    if (tn.skip(Token.EXPORT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.EXPORT;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.DEFAULT)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    var declareStart = 0;\n    var declareEnd = 0;\n    var contextIsAmbient = namespace != null && namespace.is(CommonFlags.AMBIENT);\n    if (tn.skip(Token.DECLARE)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.AMBIENT;\n    }\n\n    // parse the statement\n    var statement: Statement | null = null;\n\n    // handle declarations\n    var first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.CONST: {\n        tn.next();\n        flags |= CommonFlags.CONST;\n        if (tn.skip(Token.ENUM)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.LET: flags |= CommonFlags.LET;\n      case Token.VAR: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ENUM: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.FUNCTION: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ABSTRACT: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        let next = tn.peek(true);\n        if (tn.nextTokenOnNewLine) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        if (next != Token.CLASS) {\n          if (next == Token.INTERFACE) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.ABSTRACT;\n        // fall through\n      }\n      case Token.CLASS:\n      case Token.INTERFACE: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.NAMESPACE: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.IMPORT: {\n        tn.next();\n        flags |= CommonFlags.IMPORT;\n        if (flags & CommonFlags.EXPORT) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.EXPORT) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.PREFER)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.DECLARE) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement !== null) {\n      switch (statement.kind) {\n        case NodeKind.ENUMDECLARATION:\n        case NodeKind.FUNCTIONDECLARATION:\n        case NodeKind.CLASSDECLARATION:\n        case NodeKind.INTERFACEDECLARATION:\n        case NodeKind.NAMESPACEDECLARATION: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    var backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    var dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    var first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    var current = first;\n    while (tn.skip(Token.DOT)) {\n      if (tn.skip(Token.IDENTIFIER)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    var token = tn.next();\n    var startPos = tn.tokenPos;\n\n    var type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OPENPAREN) {\n\n      // '(' FunctionSignature ')' '|' 'null'?\n      let isNullableSignature = tn.skip(Token.OPENPAREN);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isNullableSignature) {\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \")\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.BAR)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"|\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.NULL)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          signature.isNullable = true;\n        }\n        return signature;\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n      // Type (',' Type)* ')'\n      if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.VOID) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.THIS) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.TRUE || token == Token.FALSE) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.NULL) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.STRINGLITERAL) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.IDENTIFIER) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LESSTHAN)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.COMMA));\n        if (!tn.skip(Token.GREATERTHAN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | null\n    while (tn.skip(Token.BAR)) {\n      if (tn.skip(Token.NULL)) {\n        type.isNullable = true;\n      } else {\n        let notNullStart = tn.pos;\n        let notNull = this.parseType(tn, false, true);\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\n          );\n        }\n        return null;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OPENBRACKET)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CLOSEBRACKET)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.BAR)) {\n        if (tn.skip(Token.NULL)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    var state = tn.mark();\n    var startPos = tn.tokenPos;\n    var parameters: ParameterNode[] | null = null;\n    var thisType: NamedTypeNode | null = null;\n    var isSignature: bool = false;\n    var firstParamNameNoType: IdentifierExpression | null = null;\n    var firstParamKind: ParameterKind = ParameterKind.DEFAULT;\n\n    if (tn.skip(Token.CLOSEPAREN)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.DEFAULT;\n        if (tn.skip(Token.DOT_DOT_DOT)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.REST;\n        }\n        if (tn.skip(Token.THIS)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NAMEDTYPE) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.QUESTION)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.REST) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.OPTIONAL;\n            }\n          }\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.COMMA) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.COMMA));\n      if (!tn.skip(Token.CLOSEPAREN)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    var returnType: TypeNode | null;\n    if (tn.skip(Token.EQUALS_GREATERTHAN)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n    if (!parameters) parameters = [];\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    var startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.DOT)) {\n        if (tn.skipIdentifier(IdentifierHandling.PREFER)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OPENPAREN)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    var declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declarations.push(declaration);\n    } while (tn.skip(Token.COMMA));\n\n    var ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    var flags = parentFlags;\n    if (tn.skip(Token.EXCLAMATION)) {\n      flags |= CommonFlags.DEFINITELY_ASSIGNED;\n    }\n\n    var type: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      type = this.parseType(tn, true);\n    }\n\n    var initializer: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!initializer) return null;\n    } else if (!isFor) {\n      if (flags & CommonFlags.CONST) {\n        if (!(flags & CommonFlags.AMBIENT)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    var range = Range.join(identifier.range, tn.range());\n    if (initializer !== null && (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.IDENTIFIER) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OPENBRACE) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    var members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let member = this.parseEnumValue(tn, CommonFlags.NONE);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEBRACE)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    var ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var value: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      value = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    var startPos = tn.tokenPos;\n    var expr: Expression | null = null;\n    if (\n      tn.peek(true) != Token.SEMICOLON &&\n      tn.nextToken != Token.CLOSEBRACE &&\n      !tn.nextTokenOnNewLine\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    var ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    var typeParameters = new Array<TypeParameterNode>();\n    var seenOptional = false;\n    var start = tn.tokenPos;\n    while (!tn.skip(Token.GREATERTHAN)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType !== null) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.GREATERTHAN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.IDENTIFIER) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EXTENDS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    var parameters = new Array<ParameterNode>();\n    var seenRest: ParameterNode | null = null;\n    var seenOptional = false;\n    var reportedRest = false;\n    var thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.THIS)) {\n      if (tn.skip(Token.COLON)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NAMEDTYPE) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest !== null && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.OPTIONAL: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.REST: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    var isRest = false;\n    var isOptional = false;\n    var startRange: Range | null = null;\n    var accessFlags: CommonFlags = CommonFlags.NONE;\n    if (isConstructor) {\n      if (tn.skip(Token.PUBLIC)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PUBLIC;\n      } else if (tn.skip(Token.PROTECTED)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PROTECTED;\n      } else if (tn.skip(Token.PRIVATE)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PRIVATE;\n      }\n      if (tn.peek() == Token.READONLY) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.COLON) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.READONLY;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.DOT_DOT_DOT)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.QUESTION)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.REST\n          : isOptional\n            ? ParameterKind.OPTIONAL\n            : ParameterKind.DEFAULT,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var signatureStart = -1;\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    if (!tn.skip(Token.OPENPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    var thisType = this.parseParametersThis;\n\n    var isSetter = (flags & CommonFlags.SET) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer !== null) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.GET) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    var returnType: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (tn.skip(Token.OPENBRACE)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.AMBIENT)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    var ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.NONE,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n    var arrowKind = ArrowKind.NONE;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.FUNCTION) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OPENPAREN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.ARROW_PARENTHESIZED;\n      assert(tn.token == Token.OPENPAREN);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    var signatureStart = tn.pos;\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    var returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.ARROW_SINGLE && tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OPENBRACE)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OPENBRACE)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    var declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    var isInterface = tn.token == Token.INTERFACE;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    var identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    var extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.EXTENDS)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NAMEDTYPE) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    var implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.IMPLEMENTS)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.COMMA));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    var isInterface = parent.kind == NodeKind.INTERFACEDECLARATION;\n    var startPos = 0;\n    var decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.AT)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.AT));\n      if (isInterface && decorators !== null) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    var flags = parent.flags & CommonFlags.AMBIENT;\n\n    // implemented methods are virtual\n    if (isInterface) flags |= CommonFlags.VIRTUAL;\n\n    var accessStart = 0;\n    var accessEnd = 0;\n    if (tn.skip(Token.PUBLIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.PUBLIC;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PRIVATE)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.PRIVATE;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PROTECTED)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.PROTECTED;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    var staticStart = 0;\n    var staticEnd = 0;\n    var abstractStart = 0;\n    var abstractEnd = 0;\n    if (tn.skip(Token.STATIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.STATIC;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.INSTANCE;\n      if (tn.skip(Token.ABSTRACT)) {\n        if (isInterface || !parent.is(CommonFlags.ABSTRACT)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.ABSTRACT;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.GENERIC) flags |= CommonFlags.GENERIC_CONTEXT;\n    }\n\n    var readonlyStart = 0;\n    var readonlyEnd = 0;\n    if (tn.peek() == Token.READONLY) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.COLON) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.READONLY;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    var state = tn.mark();\n    var isConstructor = false;\n    var isGetter = false;\n    var getStart = 0;\n    var getEnd = 0;\n    var isSetter = false;\n    var setStart = 0;\n    var setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.GET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.GET;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.SET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.SET;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.CONSTRUCTOR)) {\n        flags |= CommonFlags.CONSTRUCTOR;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.READONLY) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    var isGetterOrSetter = isGetter || isSetter;\n    var name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OPENBRACKET)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.PUBLIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PROTECTED) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PRIVATE) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.SEMICOLON);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.GENERIC;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OPENPAREN)) {\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.PUBLIC |\n            CommonFlags.PROTECTED |\n            CommonFlags.PRIVATE |\n            CommonFlags.READONLY\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.INSTANCE,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer !== null) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.COLON)) {\n        if (name.kind == NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.CONSTRUCTOR);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OPENBRACE)) {\n        if (flags & CommonFlags.AMBIENT) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.AMBIENT | CommonFlags.ABSTRACT))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.ABSTRACT) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.GET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.SET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.QUESTION)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.EXCLAMATION)) {\n        flags |= CommonFlags.DEFINITELY_ASSIGNED;\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n      }\n      let range = tn.range(startPos, tn.pos);\n      if (\n        (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0 &&\n        (isInterface || initializer !== null || (flags & CommonFlags.STATIC) != 0)\n      ) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators !== null && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    var start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.COLON)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NAMEDTYPE) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CLOSEBRACKET)) {\n            if (tn.skip(Token.COLON)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NAMEDTYPE) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OPENBRACE)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) members.push(member);\n          else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.ENDOFFILE)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        tn.skip(Token.SEMICOLON);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    var path: StringLiteralExpression | null = null;\n    var currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OPENBRACE)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path !== null) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else if (tn.skip(Token.ASTERISK)) {\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    var name = tn.readIdentifier();\n    var range = tn.range();\n    var ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    var startPos = tn.tokenPos;\n    var members: ImportDeclaration[] | null = null;\n    var namespaceName: IdentifierExpression | null = null;\n    var skipFrom = false;\n    if (tn.skip(Token.OPENBRACE)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.ASTERISK)) { // import * from \"file\"\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.IDENTIFIER, IdentifierHandling.PREFER)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.COMMA)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.FROM)) {\n      if (tn.skip(Token.STRINGLITERAL)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.EQUALS)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    var state = tn.mark();\n    var token = tn.next();\n    var statement: Statement | null = null;\n    switch (token) {\n      case Token.BREAK: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.CONST: {\n        statement = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos);\n        break;\n      }\n      case Token.CONTINUE: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.DO: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.FOR: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.IF: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.LET: {\n        statement = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos);\n        break;\n      }\n      case Token.VAR: {\n        statement = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos);\n        break;\n      }\n      case Token.OPENBRACE: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.RETURN: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.SEMICOLON: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.SWITCH: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.THROW: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.TRY: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.VOID: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.WHILE: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.NONE, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    var statements = new Array<Statement>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.ENDOFFILE) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    var startPos = tn.tokenPos;\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.WHILE)) {\n\n      if (tn.skip(Token.OPENPAREN)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CLOSEPAREN)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    var expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    var ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    var startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OPENPAREN)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.CONST)) {\n        initializer = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.LET)) {\n        initializer = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.VAR)) {\n        initializer = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.SEMICOLON)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.OF)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.EXPRESSION) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.IDENTIFIER) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.VARIABLE) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.VARIABLE) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.CONST) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.SEMICOLON) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.SEMICOLON)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.SEMICOLON) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CLOSEPAREN)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    var iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CLOSEPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.ELSE)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        if (tn.skip(Token.OPENBRACE)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CLOSEBRACE)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    var startPos = tn.tokenPos;\n    var statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.CASE)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.DEFAULT)) {\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn);\n    if (!expression) return null;\n    var ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    var startPos = tn.tokenPos;\n    var stmt: Statement | null;\n    if (tn.skip(Token.OPENBRACE)) {\n      let statements = new Array<Statement>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        statements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.CATCH)) {\n        if (!tn.skip(Token.OPENPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.FINALLY)) {\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        statements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LESSTHAN)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.GENERIC;\n      }\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn, Precedence.GROUPING);\n    if (!expression) return null;\n    var ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    var token = tn.next(IdentifierHandling.PREFER);\n    var startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.DOT_DOT_DOT:\n      case Token.YIELD: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.EXCLAMATION:\n      case Token.TILDE:\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.DELETE: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER:\n          case NodeKind.ELEMENTACCESS:\n          case NodeKind.PROPERTYACCESS: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.NEW: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OPENPAREN) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.NULL: return Node.createNullExpression(tn.range());\n      case Token.TRUE: return Node.createTrueExpression(tn.range());\n      case Token.FALSE: return Node.createFalseExpression(tn.range());\n      case Token.THIS: return Node.createThisExpression(tn.range());\n      case Token.CONSTRUCTOR: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OPENPAREN: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.ARROW_PARENTHESIZED\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.PREFER)) {\n\n            // function expression\n            case Token.DOT_DOT_DOT: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.IDENTIFIER: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CLOSEPAREN: {\n                  if (\n                    !tn.skip(Token.COLON) &&\n                    !tn.skip(Token.EQUALS_GREATERTHAN)\n                  ) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.COLON: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.QUESTION: {\n                  if (\n                    tn.skip(Token.COLON) ||   // optional parameter with type\n                    tn.skip(Token.COMMA) ||   // optional parameter without type\n                    tn.skip(Token.CLOSEPAREN) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.COMMA: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OPENBRACKET: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CLOSEBRACKET)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.COMMA) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACKET)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OPENBRACE: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.STRINGLITERAL)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.COLON)) {\n            let value = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACE)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LESSTHAN: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GREATERTHAN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.CALL);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.PREFIX,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.IDENTIFIER: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.peek(true) == Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.ARROW_SINGLE,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.SUPER: {\n        if (tn.peek() != Token.DOT && tn.nextToken != Token.OPENPAREN) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.STRINGLITERAL: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.INTEGERLITERAL: {\n        return Node.createIntegerLiteralExpression(tn.readInteger(), tn.range(startPos, tn.pos));\n      }\n      case Token.FLOATLITERAL: {\n        return Node.createFloatLiteralExpression(tn.readFloat(), tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.SLASH: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.SLASH)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.FUNCTION: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.CLASS: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.ENDOFFILE) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    var state = tn.mark();\n    if (!tn.skip(Token.LESSTHAN)) return null;\n    var start = tn.tokenPos;\n    var typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() === Token.GREATERTHAN) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.COMMA));\n    if (tn.skip(Token.GREATERTHAN)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OPENPAREN)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    var args = new Array<Expression>();\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let expr = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.COMMA\n  ): Expression | null {\n    assert(precedence != Precedence.NONE);\n    var expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    var startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    var nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.AS: {\n          if (tn.skip(Token.CONST)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.CONST,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.AS,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.EXCLAMATION: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NONNULL,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.INSTANCEOF: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OPENBRACKET: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CLOSEBRACKET)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.PLUS_PLUS:\n        case Token.MINUS_MINUS: {\n          if (\n            expr.kind != NodeKind.IDENTIFIER &&\n            expr.kind != NodeKind.ELEMENTACCESS &&\n            expr.kind != NodeKind.PROPERTYACCESS\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.QUESTION: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.COLON)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.COMMA\n            ? Precedence.COMMA + 1\n            : Precedence.COMMA\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.COMMA: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.COMMA));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.DOT: {\n          if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.CALL) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          expr = this.maybeParseCallExpression(tn, expr, true);\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.EQUALS:\n        case Token.PLUS_EQUALS:\n        case Token.MINUS_EQUALS:\n        case Token.ASTERISK_ASTERISK_EQUALS:\n        case Token.ASTERISK_EQUALS:\n        case Token.SLASH_EQUALS:\n        case Token.PERCENT_EQUALS:\n        case Token.LESSTHAN_LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.AMPERSAND_EQUALS:\n        case Token.CARET_EQUALS:\n        case Token.BAR_EQUALS:\n        case Token.ASTERISK_ASTERISK: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LESSTHAN:\n        case Token.GREATERTHAN:\n        case Token.LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_EQUALS:\n        case Token.EQUALS_EQUALS:\n        case Token.EQUALS_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS:\n        case Token.PLUS:\n        case Token.MINUS:\n        case Token.ASTERISK:\n        case Token.SLASH:\n        case Token.PERCENT:\n        case Token.LESSTHAN_LESSTHAN:\n        case Token.GREATERTHAN_GREATERTHAN:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n        case Token.AMPERSAND:\n        case Token.BAR:\n        case Token.CARET:\n        case Token.AMPERSAND_AMPERSAND:\n        case Token.BAR_BAR: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    var callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.IDENTIFIER: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.CALL: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    var typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OPENPAREN) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    tn.peek(true);\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek(true);\n      if (\n        nextToken == Token.ENDOFFILE ||   // next step should handle this\n        nextToken == Token.SEMICOLON      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL: {\n          tn.readString();\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          break;\n        }\n        case Token.OPENBRACE: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    var depth = 1;\n    var again = true;\n    do {\n      switch (tn.next()) {\n        case Token.ENDOFFILE: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OPENBRACE: {\n          ++depth;\n          break;\n        }\n        case Token.CLOSEBRACE: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL: {\n          tn.readString();\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  NONE,\n  COMMA,\n  SPREAD,\n  YIELD,\n  ASSIGNMENT,\n  CONDITIONAL,\n  LOGICAL_OR,\n  LOGICAL_AND,\n  BITWISE_OR,\n  BITWISE_XOR,\n  BITWISE_AND,\n  EQUALITY,\n  RELATIONAL,\n  SHIFT,\n  ADDITIVE,\n  MULTIPLICATIVE,\n  EXPONENTIATED,\n  UNARY_PREFIX,\n  UNARY_POSTFIX,\n  CALL,\n  MEMBERACCESS,\n  GROUPING\n}\n\n/** Determines the precende of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.COMMA: return Precedence.COMMA;\n    case Token.EQUALS:\n    case Token.PLUS_EQUALS:\n    case Token.MINUS_EQUALS:\n    case Token.ASTERISK_ASTERISK_EQUALS:\n    case Token.ASTERISK_EQUALS:\n    case Token.SLASH_EQUALS:\n    case Token.PERCENT_EQUALS:\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.AMPERSAND_EQUALS:\n    case Token.CARET_EQUALS:\n    case Token.BAR_EQUALS: return Precedence.ASSIGNMENT;\n    case Token.QUESTION: return Precedence.CONDITIONAL;\n    case Token.BAR_BAR: return Precedence.LOGICAL_OR;\n    case Token.AMPERSAND_AMPERSAND: return Precedence.LOGICAL_AND;\n    case Token.BAR: return Precedence.BITWISE_OR;\n    case Token.CARET: return Precedence.BITWISE_XOR;\n    case Token.AMPERSAND: return Precedence.BITWISE_AND;\n    case Token.EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS:\n    case Token.EQUALS_EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS_EQUALS: return Precedence.EQUALITY;\n    case Token.AS:\n    case Token.IN:\n    case Token.INSTANCEOF:\n    case Token.LESSTHAN:\n    case Token.GREATERTHAN:\n    case Token.LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_EQUALS: return Precedence.RELATIONAL;\n    case Token.LESSTHAN_LESSTHAN:\n    case Token.GREATERTHAN_GREATERTHAN:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return Precedence.SHIFT;\n    case Token.PLUS:\n    case Token.MINUS: return Precedence.ADDITIVE;\n    case Token.ASTERISK:\n    case Token.SLASH:\n    case Token.PERCENT: return Precedence.MULTIPLICATIVE;\n    case Token.ASTERISK_ASTERISK: return Precedence.EXPONENTIATED;\n    case Token.PLUS_PLUS:\n    case Token.MINUS_MINUS: return Precedence.UNARY_POSTFIX;\n    case Token.DOT:\n    case Token.NEW:\n    case Token.OPENBRACKET:\n    case Token.EXCLAMATION: return Precedence.MEMBERACCESS;\n  }\n  return Precedence.NONE;\n}\n","/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// DeclaredElement          Base class of elements with a declaration\n//  TypedElement           Base class of elements resolving to a type\n//   TypeDefinition       Type alias declaration\n//   VariableLikeElement  Base class of all variable-like elements\n//    EnumValue          Enum value\n//    Global             File global\n//    Local              Function local\n//    Field              Class field (instance only)\n//    Property           Class property\n//   IndexSignature       Class index signature\n//   Function             Concrete function instance\n//   Class                Concrete class instance\n//  Namespace              Namespace with static members\n//  FunctionPrototype      Prototype of concrete function instances\n//  FieldPrototype         Prototype of concrete field instances\n//  PropertyPrototype      Prototype of concrete property instances\n//  ClassPrototype         Prototype of concrete classe instances\n// File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  LIBRARY_SUBST,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  INVALID,\n\n  // indexed access\n  INDEXED_GET,            // a[]\n  INDEXED_SET,            // a[]=b\n  UNCHECKED_INDEXED_GET,  // unchecked(a[])\n  UNCHECKED_INDEXED_SET,  // unchecked(a[]=b)\n\n  // binary\n  ADD,                    // a + b\n  SUB,                    // a - b\n  MUL,                    // a * b\n  DIV,                    // a / b\n  REM,                    // a % b\n  POW,                    // a ** b\n  BITWISE_AND,            // a & b\n  BITWISE_OR,             // a | b\n  BITWISE_XOR,            // a ^ b\n  BITWISE_SHL,            // a << b\n  BITWISE_SHR,            // a >> b\n  BITWISE_SHR_U,          // a >>> b\n  EQ,                     // a == b\n  NE,                     // a != b\n  GT,                     // a > b\n  GE,                     // a >= b\n  LT,                     // a < b\n  LE,                     // a <= b\n\n  // unary prefix\n  PLUS,                   // +a\n  MINUS,                  // -a\n  NOT,                    // !a\n  BITWISE_NOT,            // ~a\n  PREFIX_INC,             // ++a\n  PREFIX_DEC,             // --a\n\n  // unary postfix\n  POSTFIX_INC,            // a++\n  POSTFIX_DEC             // a--\n\n  // not overridable:\n  // IDENTITY             // a === b\n  // LOGICAL_AND          // a && b\n  // LOGICAL_OR           // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OPENBRACKET: {\n            if (arg == \"[]\") return OperatorKind.INDEXED_GET;\n            if (arg == \"[]=\") return OperatorKind.INDEXED_SET;\n            break;\n          }\n          case CharCode.OPENBRACE: {\n            if (arg == \"{}\") return OperatorKind.UNCHECKED_INDEXED_GET;\n            if (arg == \"{}=\") return OperatorKind.UNCHECKED_INDEXED_SET;\n            break;\n          }\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.ADD;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.SUB;\n            break;\n          }\n          case CharCode.ASTERISK: {\n            if (arg == \"*\") return OperatorKind.MUL;\n            if (arg == \"**\") return OperatorKind.POW;\n            break;\n          }\n          case CharCode.SLASH: {\n            if (arg == \"/\") return OperatorKind.DIV;\n            break;\n          }\n          case CharCode.PERCENT: {\n            if (arg == \"%\") return OperatorKind.REM;\n            break;\n          }\n          case CharCode.AMPERSAND: {\n            if (arg == \"&\") return OperatorKind.BITWISE_AND;\n            break;\n          }\n          case CharCode.BAR: {\n            if (arg == \"|\") return OperatorKind.BITWISE_OR;\n            break;\n          }\n          case CharCode.CARET: {\n            if (arg == \"^\") return OperatorKind.BITWISE_XOR;\n            break;\n          }\n          case CharCode.EQUALS: {\n            if (arg == \"==\") return OperatorKind.EQ;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!=\") return OperatorKind.NE;\n            break;\n          }\n          case CharCode.GREATERTHAN: {\n            if (arg == \">\") return OperatorKind.GT;\n            if (arg == \">=\") return OperatorKind.GE;\n            if (arg == \">>\") return OperatorKind.BITWISE_SHR;\n            if (arg == \">>>\") return OperatorKind.BITWISE_SHR_U;\n            break;\n          }\n          case CharCode.LESSTHAN: {\n            if (arg == \"<\") return OperatorKind.LT;\n            if (arg == \"<=\") return OperatorKind.LE;\n            if (arg == \"<<\") return OperatorKind.BITWISE_SHL;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_PREFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.PLUS;\n            if (arg == \"++\") return OperatorKind.PREFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.MINUS;\n            if (arg == \"--\") return OperatorKind.PREFIX_DEC;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!\") return OperatorKind.NOT;\n            break;\n          }\n          case CharCode.TILDE: {\n            if (arg == \"~\") return OperatorKind.BITWISE_NOT;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_POSTFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"++\") return OperatorKind.POSTFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"--\") return OperatorKind.POSTFIX_DEC;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS:\n      case Token.PLUS_EQUALS: return OperatorKind.ADD;\n      case Token.MINUS:\n      case Token.MINUS_EQUALS: return OperatorKind.SUB;\n      case Token.ASTERISK:\n      case Token.ASTERISK_EQUALS: return OperatorKind.MUL;\n      case Token.SLASH:\n      case Token.SLASH_EQUALS: return OperatorKind.DIV;\n      case Token.PERCENT:\n      case Token.PERCENT_EQUALS: return OperatorKind.REM;\n      case Token.ASTERISK_ASTERISK:\n      case Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;\n      case Token.AMPERSAND:\n      case Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;\n      case Token.BAR:\n      case Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;\n      case Token.CARET:\n      case Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;\n      case Token.EQUALS_EQUALS: return OperatorKind.EQ;\n      case Token.EXCLAMATION_EQUALS: return OperatorKind.NE;\n      case Token.GREATERTHAN: return OperatorKind.GT;\n      case Token.GREATERTHAN_EQUALS: return OperatorKind.GE;\n      case Token.LESSTHAN: return OperatorKind.LT;\n      case Token.LESSTHAN_EQUALS: return OperatorKind.LE;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS: return OperatorKind.PLUS;\n      case Token.MINUS: return OperatorKind.MINUS;\n      case Token.EXCLAMATION: return OperatorKind.NOT;\n      case Token.TILDE: return OperatorKind.BITWISE_NOT;\n      case Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    var nativeSource = new Source(SourceKind.LIBRARY_ENTRY, LIBRARY_SUBST + \".wasm\", \"[native code]\");\n    this.nativeSource = nativeSource;\n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    var nativeFile = new File(this, nativeSource);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Parser instance. */\n  parser: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code source. */\n  nativeSource: Source;\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Signature[] = new Array<Signature>(0);\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    var cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    var cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    var cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    var cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    var cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    var cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    var cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    var cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    var cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    var cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    var cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    var cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    var cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    var cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    var cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    var cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    var cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    return this.lookupFunction(CommonNames.abort);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    var cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    var cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    var cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    var cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    var cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__retain(ptr: usize): usize` instance. */\n  get retainInstance(): Function {\n    var cached = this._retainInstance;\n    if (!cached) this._retainInstance = cached = this.requireFunction(CommonNames.retain);\n    return cached;\n  }\n  private _retainInstance: Function | null = null;\n\n  /** Gets the runtime `__release(ptr: usize): void` instance. */\n  get releaseInstance(): Function {\n    var cached = this._releaseInstance;\n    if (!cached) this._releaseInstance = cached = this.requireFunction(CommonNames.release);\n    return cached;\n  }\n  private _releaseInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    var cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    var cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */\n  get typeinfoInstance(): Function {\n    var cached = this._typeinfoInstance;\n    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);\n    return cached;\n  }\n  private _typeinfoInstance: Function | null = null;\n\n  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */\n  get instanceofInstance(): Function {\n    var cached = this._instanceofInstance;\n    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);\n    return cached;\n  }\n  private _instanceofInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    var cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    var cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    var cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    var cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Tests whether this is a WASI program. */\n  get isWasi(): bool {\n    return this.elementsByName.has(CommonNames.ASC_WASI);\n  }\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    var sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the size of a runtime header. */\n  get runtimeHeaderSize(): i32 {\n    var cached = this._runtimeHeaderSize;\n    if (!cached) {\n      // see: rt/common.ts\n      var blockOverhead = this.BLOCKInstance.nextMemoryOffset;\n      var totalOverhead = this.OBJECTInstance.nextMemoryOffset;\n      const AL_SIZE = 16;\n      const AL_MASK = AL_SIZE - 1;\n      var objectOverhead = (totalOverhead - blockOverhead + AL_MASK) & ~AL_MASK;\n      var headerSize = blockOverhead + objectOverhead;\n      assert(headerSize == 20);\n      this._runtimeHeaderSize = cached = headerSize;\n    }\n    return cached;\n  }\n  private _runtimeHeaderSize: u32 = 0;\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): VariableDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): TypeDeclaration {\n    var range = this.nativeSource.range;\n    var identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): FunctionDeclaration {\n    var range = this.nativeSource.range;\n    var signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.NONE, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): NamespaceDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    var elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    var options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.exnref, Type.exnref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.WASM64 : Target.WASM32));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SIGN_EXTENSION) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MUTABLE_GLOBALS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NONTRAPPING_F2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BULK_MEMORY) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.SIMD) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.THREADS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.EXCEPTION_HANDLING) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TAIL_CALLS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.REFERENCE_TYPES) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MULTI_VALUE) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.MEMORY64) ? 1 : 0, 0));\n\n    // remember deferred elements\n    var queuedImports = new Array<QueuedImport>();\n    var queuedExports = new Map<File,Map<string,QueuedExport>>();\n    var queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    var queuedExtends = new Array<ClassPrototype>();\n    var queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.EXPORT: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.EXPORTDEFAULT: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.IMPORT: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.VARIABLE: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.CLASSDECLARATION: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.ENUMDECLARATION: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FUNCTIONDECLARATION: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.INTERFACEDECLARATION: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NAMESPACEDECLARATION: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TYPEDECLARATION: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            queuedImport.foreignPath,\n            queuedImport.foreignPathAlt,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let foreignFile = this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt);\n          if (foreignFile) {\n            let localFile = queuedImport.localFile;\n            let localName = localIdentifier.text;\n            localFile.add(\n              localName,\n              foreignFile.asAliasNamespace(\n                localName,\n                localFile,\n                localIdentifier\n              ),\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n            assert(false); // already reported by the parser not finding the file\n          }\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            localName,\n            foreignPath,\n            assert(queuedExport.foreignPathAlt), // must be set if foreignPath is\n            queuedExports\n          );\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.lookupInSelf(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookupGlobal(localName);\n            if (globalElement !== null && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)\n    assert(this.arrayBufferInstance.id == 0);\n    assert(this.stringInstance.id == 1);\n    assert(this.arrayBufferViewInstance.id == 2);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.SIMD)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.EXCEPTION_HANDLING)) {\n        this.registerWrapperClass(Type.exnref, CommonNames.Exnref);\n      }\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    var resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.CLASS_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.FINAL)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=\n            thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          thisPrototype.basePrototype = basePrototype;\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          thisPrototype.basePrototype = <InterfacePrototype>baseElement;\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // check for virtual overloads in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.markVirtuals(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      let isWasi = this.isWasi;\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort,\n          isWasi\n            ? BuiltinNames.wasiAbort\n            : BuiltinNames.abort\n        );\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace,\n          isWasi\n            ? BuiltinNames.wasiTrace\n            : BuiltinNames.trace\n        );\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed,\n          isWasi\n            ? BuiltinNames.wasiSeed\n            : BuiltinNames.seed\n        );\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            throw new Error(\"no such global element: \" + name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Marks virtual members in a base class overloaded in this class. */\n  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {\n    // TODO: make this work with interfaaces as well\n    var thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let _values = Map_values(thisInstanceMembers), j = 0, l = _values.length; j < l; ++j) {\n            let thisMember = _values[j];\n            if (\n              !thisMember.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.PRIVATE) &&\n              baseInstanceMembers.has(thisMember.name)\n            ) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              if (\n                thisMember.kind == ElementKind.FUNCTION_PROTOTYPE &&\n                baseMember.kind == ElementKind.FUNCTION_PROTOTYPE\n              ) {\n                let thisMethod = <FunctionPrototype>thisMember;\n                let baseMethod = <FunctionPrototype>baseMember;\n                if (!thisMethod.visibilityEquals(baseMethod)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisMethod.identifierNode.range, baseMethod.identifierNode.range\n                  );\n                }\n                baseMember.set(CommonFlags.VIRTUAL);\n                let overloads = baseMethod.overloads;\n                if (!overloads) baseMethod.overloads = overloads = new Set();\n                overloads.add(<FunctionPrototype>thisMember);\n                let baseMethodInstances = baseMethod.instances;\n                if (baseMethodInstances) {\n                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n                    let baseMethodInstance = _values[a];\n                    baseMethodInstance.set(CommonFlags.VIRTUAL);\n                  }\n                }\n              } else if (\n                thisMember.kind == ElementKind.PROPERTY_PROTOTYPE &&\n                baseMember.kind == ElementKind.PROPERTY_PROTOTYPE\n              ) {\n                let thisProperty = <PropertyPrototype>thisMember;\n                let baseProperty = <PropertyPrototype>baseMember;\n                if (!thisProperty.visibilityEquals(baseProperty)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisProperty.identifierNode.range, baseProperty.identifierNode.range\n                  );\n                }\n                baseProperty.set(CommonFlags.VIRTUAL);\n                let baseGetter = baseProperty.getterPrototype;\n                if (baseGetter) {\n                  baseGetter.set(CommonFlags.VIRTUAL);\n                  let thisGetter = thisProperty.getterPrototype;\n                  if (thisGetter) {\n                    let overloads = baseGetter.overloads;\n                    if (!overloads) baseGetter.overloads = overloads = new Set();\n                    overloads.add(thisGetter);\n                  }\n                  let baseGetterInstances = baseGetter.instances;\n                  if (baseGetterInstances) {\n                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseGetterInstance = _values[a];\n                      baseGetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n                let baseSetter = baseProperty.setterPrototype;\n                if (baseSetter !== null && thisProperty.setterPrototype !== null) {\n                  baseSetter.set(CommonFlags.VIRTUAL);\n                  let thisSetter = thisProperty.setterPrototype;\n                  if (thisSetter) {\n                    let overloads = baseSetter.overloads;\n                    if (!overloads) baseSetter.overloads = overloads = new Set();\n                    overloads.add(thisSetter);\n                  }\n                  let baseSetterInstances = baseSetter.instances;\n                  if (baseSetterInstances) {\n                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseSetterInstance = _values[a];\n                      baseSetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n              } else {\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  thisMember.identifierNode.range,\n                  baseMember.identifierNode.range\n                );\n              }\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    var element = this.lookupGlobal(name);\n    if (!element) throw new Error(\"Missing standard library component: \" + name);\n    if (element.kind != kind) throw Error(\"Invalid standard library component: \" + name);\n    return element;\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  private requireClass(name: string): Class {\n    var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);\n    var resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(\"Invalid standard library class: \" + name);\n    return resolved;\n  }\n\n  /** Obtains a non-generic global function and returns it. Returns `null` if it does not exist. */\n  private lookupFunction(name: string): Function | null {\n    var prototype = this.lookupGlobal(name);\n    if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  /** Requires that a global function is present and returns it. */\n  private requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    var prototype = <FunctionPrototype>this.require(name, ElementKind.FUNCTION_PROTOTYPE);\n    var resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(\"Invalid standard library function: \" + name);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.MODULE_EXPORT);\n    switch (element.kind) {\n      case ElementKind.CLASS_PROTOTYPE: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.PROPERTY:\n      case ElementKind.FUNCTION:\n      case ElementKind.FIELD:\n      case ElementKind.CLASS: assert(false); // assumes that there are no instances yet\n    }\n    var staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    var element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.EXPORT),\n      DecoratorFlags.BUILTIN\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    var wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    var element = assert(this.lookupGlobal(className));\n    assert(element.kind == ElementKind.CLASS_PROTOTYPE);\n    var classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    var elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing !== element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookupGlobal(name: string): Element | null {\n    var elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Looks up the element of the specified name in the global scope. Errors if not present. */\n  requireGlobal(name: string): Element {\n    var elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    throw new Error(\"missing global\");\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    var filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n      if (!foreignFile) return null; // no such file\n\n      // search already resolved exports\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // otherwise traverse queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n          if (queuedExportForeignPath) { // imported from another file\n            foreignName = queuedExport.localIdentifier.text;\n            foreignPath = queuedExportForeignPath;\n            foreignPathAlt = assert(queuedExport.foreignPathAlt);\n            continue;\n          } else { // local element of this file\n            element = foreignFile.lookupInSelf(queuedExport.localIdentifier.text);\n            if (element) return element;\n          }\n        }\n      }\n      break;\n    } while (true);\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    var flags = DecoratorFlags.NONE;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (flag == DecoratorFlags.BUILTIN) {\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\n              this.error(\n                DiagnosticCode.Decorator_0_is_not_valid_here,\n                decorator.range, decorator.name.range.toString()\n              );\n            } else {\n              flags |= flag;\n            }\n          } else if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    // if (flags) throw new Error();\n    return flags;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    var name = declaration.name.text;\n    var element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.FINAL |\n        DecoratorFlags.UNMANAGED |\n        DecoratorFlags.STORAGE |\n        DecoratorFlags.CONTRACT\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    var implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    // initialize members\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method !== null && methodDeclaration.name.kind == NodeKind.CONSTRUCTOR) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.INDEXSIGNATURE: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var name = declaration.name.text;\n    var decorators = declaration.decorators;\n    var element: DeclaredElement;\n    var acceptedFlags: DecoratorFlags = DecoratorFlags.UNSAFE;\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    if (declaration.is(CommonFlags.STATIC)) { // global variable\n      assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);\n      acceptedFlags |= DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.READONLY)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.ABSTRACT | CommonFlags.GET | CommonFlags.SET));\n      element = new FieldPrototype(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    var isStatic = declaration.is(CommonFlags.STATIC);\n    // Extension add\n    var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE | DecoratorFlags.DEPLOYER | DecoratorFlags.CONSTRUCTOR;\n    if (!declaration.is(CommonFlags.GENERIC)) {\n      acceptedFlags |= DecoratorFlags.OPERATOR_BINARY\n                    |  DecoratorFlags.OPERATOR_PREFIX\n                    |  DecoratorFlags.OPERATOR_POSTFIX;\n    }\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.OPERATOR:\n          case DecoratorKind.OPERATOR_BINARY:\n          case DecoratorKind.OPERATOR_PREFIX:\n          case DecoratorKind.OPERATOR_POSTFIX: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.STRING)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.INVALID) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.overloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    var name = declaration.name.text;\n    if (declaration.is(CommonFlags.STATIC)) {\n      let parentMembers = parent.members;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    var name = declaration.name.text;\n    var isGetter = declaration.is(CommonFlags.GET);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    var element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.INLINE | DecoratorFlags.UNSAFE\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    var name = declaration.name.text;\n    var element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.INLINE |\n        DecoratorFlags.LAZY\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    var values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    var name = declaration.name.text;\n    var element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.NONE\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    var members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var localName = member.localName.text;\n    var foreignName = member.exportedName.text;\n\n    // check for duplicates\n    var element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath === null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.lookupInSelf(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    var declaration = statement.declaration;\n    var element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    var element = this.lookupForeign(declaration.foreignName.text, foreignPath, foreignPathAlt, queuedExports);\n    if (element) {\n      parent.add(declaration.name.text, element, declaration.name /* isImport */);\n      return;\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    // Extension Add\n    var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN | DecoratorFlags.DEPLOYER;\n    if (declaration.is(CommonFlags.AMBIENT)) {\n      validDecorators |= DecoratorFlags.EXTERNAL;\n    } else {\n      validDecorators |= DecoratorFlags.INLINE;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.EXPORT)) {\n        validDecorators |= DecoratorFlags.LAZY;\n      }\n    }\n    if (!declaration.is(CommonFlags.INSTANCE)) {\n      if (parent.kind != ElementKind.CLASS_PROTOTYPE) {\n        validDecorators |= DecoratorFlags.GLOBAL;\n      }\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    var name = declaration.name.text;\n    var element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    var typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.GET,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.READONLY)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.SET,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    var name = declaration.name.text;\n    var original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL)\n    );\n    if (!parent.add(name, original)) return null;\n    var element = assert(parent.lookupInSelf(name)); // possibly merged\n    var members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.CLASSDECLARATION: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.ENUMDECLARATION: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FUNCTIONDECLARATION: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.INTERFACEDECLARATION: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NAMESPACEDECLARATION: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TYPEDECLARATION: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.VARIABLE: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // retain original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var name = declaration.name.text;\n    var element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.NONE)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.DECLARE)) {\n        acceptedFlags |= DecoratorFlags.EXTERNAL;\n      }\n      if (declaration.is(CommonFlags.CONST)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   var current: Class | null = target;\n  //   var arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n\n  /** Finds all cyclic classes. */\n  findCyclicClasses(): Set<Class> {\n    var cyclics = new Set<Class>();\n    // TODO: for (let instance of this.managedClasses.values()) {\n    for (let _values = Map_values(this.managedClasses), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      if (!instance.isAcyclic) cyclics.add(instance);\n    }\n    return cyclics;\n  }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport enum ElementKind {\n  /** A {@link Global}. */\n  GLOBAL,\n  /** A {@link Local}. */\n  LOCAL,\n  /** An {@link Enum}. */\n  ENUM,\n  /** An {@link EnumValue}. */\n  ENUMVALUE,\n  /** A {@link FunctionPrototype}. */\n  FUNCTION_PROTOTYPE,\n  /** A {@link Function}. */\n  FUNCTION,\n  /** A {@link FunctionTarget}. */\n  FUNCTION_TARGET,\n  /** A {@link ClassPrototype}. */\n  CLASS_PROTOTYPE,\n  /** A {@link Class}. */\n  CLASS,\n  /** An {@link InterfacePrototype}. */\n  INTERFACE_PROTOTYPE,\n  /** An {@link Interface}. */\n  INTERFACE,\n  /** A {@link FieldPrototype}. */\n  FIELD_PROTOTYPE,\n  /** A {@link Field}. */\n  FIELD,\n  /** A {@link PropertyPrototype}.  */\n  PROPERTY_PROTOTYPE,\n  /** A {@link Property}. */\n  PROPERTY,\n  /** A {@link Namespace}. */\n  NAMESPACE,\n  /** A {@link File}. */\n  FILE,\n  /** A {@link TypeDefinition}.  */\n  TYPEDEFINITION,\n  /** An {@link IndexSignature}. */\n  INDEXSIGNATURE\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  NONE = 0,\n  /** Is a program global. */\n  GLOBAL = 1 << 0,\n  /** Is a binary operator overload. */\n  OPERATOR_BINARY = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OPERATOR_PREFIX = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OPERATOR_POSTFIX = 1 << 3,\n  /** Is an unmanaged class. */\n  UNMANAGED = 1 << 4,\n  /** Is a final class. */\n  FINAL = 1 << 5,\n  /** Is always inlined. */\n  INLINE = 1 << 6,\n  /** Is using a different external name. */\n  EXTERNAL = 1 << 7,\n  /** Is a builtin. */\n  BUILTIN = 1 << 8,\n  /** Is compiled lazily. */\n  LAZY = 1 << 9,\n  /** Is considered unsafe code. */\n  UNSAFE = 1 << 10,\n  /* Extension add START */\n  MESSAGE = 1 << 11,\n  STORAGE = 1 << 12,\n  DEPLOYER = 1 << 13,\n  CONTRACT = 1 << 14,\n  DATABASE = 1 << 15,\n  PRIMARYID = 1 << 16,\n  CONSTRUCTOR = 1 << 17\n  /* Extension add END */\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;\n      case DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;\n      case DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;\n      case DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;\n      case DecoratorKind.FINAL: return DecoratorFlags.FINAL;\n      case DecoratorKind.INLINE: return DecoratorFlags.INLINE;\n      case DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;\n      case DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;\n      case DecoratorKind.LAZY: return DecoratorFlags.LAZY;\n      case DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;\n      /* Extension add START */\n      case DecoratorKind.CONTRACT: return DecoratorFlags.CONTRACT;\n      case DecoratorKind.DEPLOYER: return DecoratorFlags.DEPLOYER;\n      case DecoratorKind.CONSTRUCTOR: return DecoratorFlags.CONSTRUCTOR;\n      case DecoratorKind.STORAGE: return DecoratorFlags.STORAGE;\n      /* Extension add END */\n      default: return DecoratorFlags.NONE;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.NONE;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.FILE);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    var current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.FILE) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n\n  /** Looks up the element with the specified name within this element. */\n  lookupInSelf(name: string): DeclaredElement | null {\n    var members = this.members;\n    if (members !== null && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element, like in JS. */\n  abstract lookup(name: string): Element | null;\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    var originalDeclaration = element.declaration;\n    var members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent !== this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    var program = this.program;\n    if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.PRIVATE | CommonFlags.PROTECTED);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.PUBLIC);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.PRIVATE | CommonFlags.PROTECTED;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return this.internalName + \", kind=\" + this.kind.toString();\n  }\n}\n\n// Kinds of all declared elements\nvar declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    var declaration = this.declaration;\n    var identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FUNCTIONDECLARATION || declaration.kind == NodeKind.METHODDECLARATION) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      return Range.join(identifierNode.range, signatureNode.range);\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n\n  /** Checks if this element is a compatible override of the specified. */\n  isCompatibleOverride(base: DeclaredElement): bool {\n    var self: DeclaredElement = this; // TS\n    var kind = self.kind;\n    if (kind == base.kind) {\n      switch (kind) {\n        case ElementKind.FUNCTION: {\n          return (<Function>self).signature.isAssignableTo((<Function>base).signature, /* sameSize */ true);\n        }\n        case ElementKind.PROPERTY: {\n          let selfProperty = <Property>self;\n          let baseProperty = <Property>base;\n          let selfGetter = selfProperty.getterInstance;\n          let baseGetter = baseProperty.getterInstance;\n          if (selfGetter) {\n            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {\n              return false;\n            }\n          } else if (baseGetter) {\n            return false;\n          }\n          let selfSetter = selfProperty.setterInstance;\n          let baseSetter = baseProperty.setterInstance;\n          if (selfSetter) {\n            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {\n              return false;\n            }\n          } else if (baseSetter) {\n            return false;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n// Kinds of all typed elements\nvar typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.RESOLVED));\n    this.type = type;\n    this.set(CommonFlags.RESOLVED);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.FILE,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    var startFunction = this.program.makeNativeFunction(\n      \"start:\" + this.internalName,\n      new Signature(program, null, Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.GLOBAL)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.lookupInSelf(name)); // possibly merged locally\n    if (element.is(CommonFlags.EXPORT) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  lookupInSelf(name: string): DeclaredElement | null {\n    var element = super.lookupInSelf(name);\n    if (element) return element;\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].lookupInSelf(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var element = this.lookupInSelf(name);\n    if (element) return element;\n    return this.program.lookupGlobal(name);\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    var exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LIBRARY_ENTRY) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    var exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    var exports = this.exports;\n    if (exports !== null && exports.has(name)) return assert(exports.get(name));\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string, \n    parent: Element, \n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    var declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    var ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.SCOPED);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    var exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.TYPEDEFINITION,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.NAMESPACE,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var inSelf = this.lookupInSelf(name);\n    if (inSelf) return inSelf;\n    return this.parent.lookup(name);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUM,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var inSelf = this.lookupInSelf(name);\n    if (inSelf) return inSelf;\n    return this.parent.lookup(name);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  NONE,\n  /** Constant integer value. */\n  INTEGER,\n  /** Constant float value. */\n  FLOAT\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.INTEGER;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.FLOAT;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n\n  /** @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUMVALUE,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.GLOBAL,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.LOCAL,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n\n  /** Sets the temporary name of this local. */\n  setTemporaryName(name: string): void {\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n\n  /** Resets the temporary name of this local. */\n  resetTemporaryName(): void {\n    var name = this.originalName;\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.INVALID;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overloading this one, if any. These are unbound. */\n  overloads: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bounds to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FUNCTION_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    var parent = this.parent;\n    return parent.kind == ElementKind.CLASS ||\n           parent.kind == ElementKind.PROPERTY_PROTOTYPE && (\n             parent.parent.kind == ElementKind.CLASS ||\n             parent.parent.kind == ElementKind.INTERFACE\n           );\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var declaration = this.declaration;\n    assert(declaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new FunctionPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.overloads = this.overloads;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Map of locals by name. */\n  localsByName: Map<string,Local> = new Map();\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** List of additional non-parameter locals. */\n  additionalLocals: Type[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Virtual stub for calling overloads. */\n  virtualStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n  /** Counting id of autorelease variables. */\n  nextAutoreleaseId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.FUNCTION,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.RESOLVED;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    var program = prototype.program;\n    this.type = signature.type;\n    if (!prototype.is(CommonFlags.AMBIENT)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        this.localsByName.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        this.localsByName.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n      }\n    }\n    this.flow = Flow.createParent(this);\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    var parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */\n  newStub(postfix: string): Function {\n    var stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.COMPILED | CommonFlags.STUB);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;\n    if (this.is(CommonFlags.INSTANCE)) ++localIndex;\n    var localName = name !== null\n      ? name\n      : \"var$\" + localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    var local = new Local(\n      localName,\n      localIndex,\n      type,\n      this,\n      declaration\n    );\n    if (name) {\n      if (this.localsByName.has(name)) throw new Error(\"duplicate local name\");\n      this.localsByName.set(name, local);\n    }\n    this.localsByIndex[local.index] = local;\n    this.additionalLocals.push(type);\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var locals = this.localsByName;\n    if (locals.has(name)) return assert(locals.get(name));\n    return this.parent.lookup(name);\n  }\n\n  // used by flows to keep track of temporary locals\n  tempI32s: Local[] | null = null;\n  tempI64s: Local[] | null = null;\n  tempF32s: Local[] | null = null;\n  tempF64s: Local[] | null = null;\n  tempV128s: Local[] | null = null;\n  tempFuncrefs: Local[] | null = null;\n  tempExternrefs: Local[] | null = null;\n  tempExnrefs: Local[] | null = null;\n  tempAnyrefs: Local[] | null = null;\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n  breakLabel: string | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    var breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // internal error\n    this.breakStack = breakStack = null;\n    this.breakLabel = null;\n    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n  }\n}\n\n/** A yet unresolved instance field prototype. */\nexport class FieldPrototype extends DeclaredElement {\n\n  /** Constructs a new field prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent class. */\n    parent: ClassPrototype,\n    /** Declaration reference. */\n    declaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FIELD_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.INSTANCE))),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    return (<FieldDeclaration>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<FieldDeclaration>this.declaration).initializer;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    return (<FieldDeclaration>this.declaration).parameterIndex;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A resolved instance field. */\nexport class Field extends VariableLikeElement {\n\n  /** Field prototype reference. */\n  prototype: FieldPrototype;\n  /** Field memory offset, if an instance field. */\n  memoryOffset: i32 = -1;\n  /** Getter function reference, if compiled. */\n  getterRef: FunctionRef = 0;\n  /** Setter function reference, if compiled. */\n  setterRef: FunctionRef = 0;\n\n  /** Constructs a new field. */\n  constructor(\n    /** Respective field prototype. */\n    prototype: FieldPrototype,\n    /** Parent class. */\n    parent: Class,\n    /** Concrete type. */\n    type: Type\n  ) {\n    super(\n      ElementKind.FIELD,\n      prototype.name,\n      parent,\n      <VariableLikeDeclarationStatement>prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    assert(type != Type.void);\n    this.setType(type);\n    registerConcreteElement(this.program, this);\n  }\n\n  /** Gets the internal name of the respective getter function. */\n  get internalGetterName(): string {\n    return this.parent.internalName + INSTANCE_DELIMITER + GETTER_PREFIX + this.name;\n  }\n\n  /** Gets the internal name of the respective setter function. */\n  get internalSetterName(): string {\n    return this.parent.internalName + INSTANCE_DELIMITER + SETTER_PREFIX + this.name;\n  }\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PROPERTY_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.GET | CommonFlags.SET);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    switch (this.parent.kind) {\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: return true;\n    }\n    return false;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new PropertyPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    var getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    var setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.PROPERTY,\n      prototype.name,\n      parent,\n      Node.createVariableDeclaration(\n        prototype.identifierNode,\n        null,\n        prototype.is(CommonFlags.INSTANCE)\n          ? CommonFlags.INSTANCE\n          : CommonFlags.NONE,\n        null, null,\n        prototype.identifierNode.range\n      )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.INSTANCE)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.INDEXSIGNATURE,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extendees: Set<ClassPrototype> = new Set();\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    var arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance !== null\n        && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    var current: ClassPrototype | null = this;\n    var seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current === basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    var originalDeclaration = element.declaration;\n    var instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.EXPORT) && this.is(CommonFlags.MODULE_EXPORT)) {\n      element.set(CommonFlags.MODULE_EXPORT); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\nconst enum AcyclicState {\n  UNKNOWN,\n  ACYCLIC,\n  NOT_ACYCLIC\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if applicable. */\n  base: Class | null = null;\n  /** Implemented interfaces, if applicable. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  overloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Remembers acyclic state. */\n  private _acyclic: AcyclicState = AcyclicState.UNKNOWN;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly extending this class. */\n  extendees: Set<Class> | null = null;\n  /** Classes implementing this interface. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    var lengthField = this.lookupInSelf(\"length\");\n    return lengthField !== null && (\n      lengthField.kind == ElementKind.FIELD ||\n      (\n        lengthField.kind == ElementKind.PROPERTY_PROTOTYPE &&\n        (<PropertyPrototype>lengthField).getterPrototype !== null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||\n      this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null\n    );\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE : ElementKind.CLASS,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    var program = this.program;\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    var typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters !== null && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n    var extendees = base.extendees;\n    if (!extendees) base.extendees = extendees = new Set();\n    extendees.add(this);\n\n    // Inherit contextual type arguments from base class\n    var inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    var interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n    var implementers = iface.implementers;\n    if (!implementers) iface.implementers = implementers = new Set();\n    implementers.add(this);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    var current: Class | null = this;\n    do {\n      if (current == target) return true;\n      if (target.kind == ElementKind.INTERFACE) {\n        let interfaces = current.interfaces;\n        if (interfaces) {\n          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n            let iface = _values[i];\n            if (iface.isAssignableTo(target)) return true;\n          }\n        }\n      }\n      current = current.base;\n    } while (current);\n    return false;\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.INDEXED_GET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.INDEXED_SET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    var instance: Class | null = this;\n    do {\n      let overloads = instance.overloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    var members = assert(this.members);\n    assert(members.has(fieldName));\n    var field = <Element>members.get(fieldName);\n    assert(field.kind == ElementKind.FIELD);\n    return (<Field>field).memoryOffset;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    var size = this.nextMemoryOffset + overhead;\n    var buffer = new Uint8Array(this.program.runtimeHeaderSize + size);\n    assert(!this.program.options.isWasm64); // TODO: WASM64, mmInfo is usize\n    // see: std/assembly/rt/common.ts\n    assert(size < (1 << 28));      // 1 bit BUFFERED + 3 bits color\n    var OBJECT = this.program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", size, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 1, buffer, 0); // RC = 1\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", size, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.runtimeHeaderSize): i32 {\n    var element = this.lookupInSelf(name);\n    if (element !== null && element.kind == ElementKind.FIELD) {\n      let fieldInstance = <Field>element;\n      let offset = baseOffset + fieldInstance.memoryOffset;\n      let typeKind = fieldInstance.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.ISIZE:\n        case TypeKind.USIZE: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.USIZE);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.USIZE);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extends(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    var current: Class | null = this;\n    do {\n      if (current.prototype === extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    var current: Class = this;\n    var program = this.program;\n    var arrayPrototype = program.arrayPrototype;\n    if (this.extends(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    var staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extends(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    var abvInstance = program.arrayBufferViewInstance;\n    while (current.base !== abvInstance) {\n      current = assert(current.base);\n    }\n    var prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is inherently acyclic. */\n  get isAcyclic(): bool {\n    var acyclic = this._acyclic;\n    if (acyclic == AcyclicState.UNKNOWN) {\n      let hasCycle = this.cyclesTo(this);\n      if (hasCycle) this._acyclic = acyclic = AcyclicState.NOT_ACYCLIC;\n      else this._acyclic = acyclic = AcyclicState.ACYCLIC;\n    }\n    return acyclic == AcyclicState.ACYCLIC;\n  }\n\n  /** Tests if this class potentially forms a reference cycle to another one. */\n  private cyclesTo(other: Class, except: Set<Class> = new Set()): bool {\n    // TODO: The pure RC paper describes acyclic data structures as classes that may contain\n    //\n    // - scalars\n    // - references to classes that are both acyclic and final (here: Java); and\n    // - arrays (in our case: also sets, maps) of either of the above\n    //\n    // Our implementation, however, treats all objects that do not reference themselves directly\n    // or indirectly as acylic, allowing them to contain inner cycles of other non-acyclic objects.\n    // This contradicts the second assumption and must be revisited when actually implementing RC.\n\n    if (except.has(this)) return false;\n    except.add(this); // don't recurse indefinitely\n\n    // Find out if any field references 'other' directly or indirectly\n    var current: Class | null;\n    var instanceMembers = this.members;\n    if (instanceMembers) {\n      // TODO: for (let member of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.FIELD) {\n          let fieldType = (<Field>member).type;\n          if (fieldType.isReference) {\n            if ((current = fieldType.getClass()) !== null && (\n              current === other ||\n              current.cyclesTo(other, except)\n            )) return true;\n          }\n        }\n      }\n    }\n\n    // Do the same for non-field data\n    var basePrototype: ClassPrototype | null;\n\n    // Array<T->other?>\n    if ((basePrototype = this.program.arrayPrototype) !== null && this.prototype.extends(basePrototype)) {\n      let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));\n      assert(typeArguments.length == 1);\n      if (\n        (current = typeArguments[0].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n\n    // Set<K->other?>\n    } else if ((basePrototype = this.program.setPrototype) !== null && this.prototype.extends(basePrototype)) {\n      let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));\n      assert(typeArguments.length == 1);\n      if (\n        (current = typeArguments[0].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n\n    // Map<K->other?,V->other?>\n    } else if ((basePrototype = this.program.mapPrototype) !== null && this.prototype.extends(basePrototype)) {\n      let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));\n      assert(typeArguments.length == 2);\n      if (\n        (current = typeArguments[0].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n      if (\n        (current = typeArguments[1].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n    }\n    return false;\n  }\n\n  /** Gets all extendees of this class (that do not have the specified instance member). */\n  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {\n    var extendees = this.extendees;\n    if (extendees) {\n      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {\n        let extendee = _values[i];\n        if (exceptIfMember) {\n          let instanceMembers = extendee.prototype.instanceMembers;\n          if (instanceMembers !== null && instanceMembers.has(exceptIfMember)) continue;\n        }\n        out.add(extendee);\n        extendee.getAllExtendees(exceptIfMember, out);\n      }\n    }\n    return out;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program === newer.program);\n  if (newer.members) return null;\n  var merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FUNCTION_PROTOTYPE: {\n      switch (newer.kind) {\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.CLASS_PROTOTYPE:\n    case ElementKind.ENUM: {\n      if (newer.kind == ElementKind.NAMESPACE) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.NAMESPACE: {\n      switch (newer.kind) {\n        case ElementKind.ENUM:\n        case ElementKind.CLASS_PROTOTYPE:      // TS2434\n        case ElementKind.FUNCTION_PROTOTYPE: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.GLOBAL: {\n      if (newer.kind == ElementKind.TYPEDEFINITION) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TYPEDEFINITION: {\n      switch (newer.kind) {\n        case ElementKind.GLOBAL:\n        case ElementKind.FUNCTION_PROTOTYPE:\n        case ElementKind.NAMESPACE: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);\n    let newerIsExport = newer.is(CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  var srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(name: string, parent: Element, isInstance: bool, asGlobal: bool = false): string {\n  switch (parent.kind) {\n    case ElementKind.FILE: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.FUNCTION: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PROPERTY_PROTOTYPE: // properties are just containers\n    case ElementKind.PROPERTY: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.INSTANCE), asGlobal)\n           + (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name;\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nvar cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(\"$\" + i.toString());\n  }\n  return cachedDefaultParameterNames[index];\n}\n","/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Field,\n  FieldPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  uniqueMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport enum ReportMode {\n  /** Report errors. */\n  REPORT,\n  /** Swallow errors. */\n  SWALLOW\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        return this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        return this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var nameNode = node.name;\n    var typeArgumentNodes = node.typeArguments;\n    var isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes !== null && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    var element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    var shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.ENUM) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, element.name + \"/i32\"\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.CLASS_PROTOTYPE ||\n        element.kind == ElementKind.INTERFACE_PROTOTYPE\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          uniqueMap<string,Type>(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TYPEDEFINITION) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.RESOLVED)) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native) return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof) return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof) return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = uniqueMap(ctxTypes), // inherit\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var explicitThisType = node.explicitThisType;\n    var thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    var parameterNodes = node.parameters;\n    var numParameters = parameterNodes.length;\n    var parameterTypes = new Array<Type>(numParameters);\n    var requiredParameters = 0;\n    var hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.DEFAULT: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.REST: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    var returnTypeNode = node.returnType;\n    var returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n    signature.hasRest = hasRest;\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        let numTypeArguments = 0;\n        if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.ISIZE: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return Type.u32;\n      case TypeKind.USIZE: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.F32: return Type.f32;\n      case TypeKind.F64: return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.VOID: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        let numTypeArguments = 0;\n        if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNodes[0].range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    var overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n    if (overload) {\n      if (overload.is(CommonFlags.STATIC)) {\n        assert(overload.signature.parameterTypes.length == 2);\n        return overload.signature.parameterTypes[1];\n      } else {\n        assert(overload.signature.parameterTypes.length == 1);\n        return overload.signature.parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNodes[0].range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      let numTypeArguments = 0;\n      if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNodes[0].range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        let numTypeArguments = 0;\n        if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNodes[0].range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = ctxElement.lookup(node.identifier.text);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    var prev = node;\n    var next = node.next;\n    while (next) {\n      if (!(element = element.lookupInSelf(next.identifier.text))) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type[] | null {\n    var minParameterCount = 0;\n    var maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    var typeArguments = new Array<Type>(maxParameterCount);\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            ctxTypes,\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            ctxTypes,\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.GENERIC)) {\n      let contextualTypeArguments = uniqueMap<string,Type>(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;\n        if (!argumentExpression) { // missing initializer -> too few arguments\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.SWALLOW);\n          if (type) this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, uniqueMap<string,Type>(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxFlow.actualFunction);\n          if (!classPrototype || classPrototype.kind != ElementKind.CLASS_PROTOTYPE) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (currentType == Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {\n            ctxTypes.set(name, type);\n          }\n        }\n      }\n    } else if (node.kind == NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      if (parameterNodes !== null && parameterNodes.length > 0) {\n        let signatureReference = type.signatureReference;\n        if (signatureReference) {\n          let parameterTypes = signatureReference.parameterTypes;\n          let thisType = signatureReference.thisType;\n          if (parameterTypes.length == parameterNodes.length && !thisType == !functionTypeNode.explicitThisType) {\n            for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n              this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);\n            }\n            this.propagateInferredGenericTypes(functionTypeNode.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);\n            if (thisType) this.propagateInferredGenericTypes(functionTypeNode.explicitThisType!, thisType, ctxFlow, ctxTypes, typeParameterNames);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    var kind = element.kind;\n    if (kind == ElementKind.GLOBAL) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.SWALLOW)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      assert(type != Type.void);\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE:\n      case NodeKind.NULL: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    var name = node.text;\n    var element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookupGlobal(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return Type.bool;\n      case NodeKind.NULL: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, uniqueMap<string,Type>(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.REPORT): bool {\n    if (global.is(CommonFlags.RESOLVED)) return true;\n    var type: Type | null;\n    var typeNode = global.typeNode;\n    if (typeNode) {\n      type = this.resolveType(typeNode, global.parent, null, reportMode);\n    } else {\n      type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, Type.auto, reportMode);\n    }\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetNode = node.expression;\n    var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    var propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.ENUMVALUE:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        assert(type != Type.void);\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.RESOLVED)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.GENERIC)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let members = target.members;\n          if (!members || !members.has(propertyName)) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.CLASS_PROTOTYPE:\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: {\n        do {\n          let members = target.members;\n          if (members !== null && members.has(propertyName)) {\n            let member = assert(members.get(propertyName));\n            if (member.kind == ElementKind.PROPERTY_PROTOTYPE) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.STATIC)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.CLASS_PROTOTYPE ||\n            target.kind == ElementKind.INTERFACE_PROTOTYPE\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.CLASS ||\n            target.kind == ElementKind.INTERFACE\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let members = target.members;\n        if (members !== null && members.has(propertyName)) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return assert(members.get(propertyName)); // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetExpression = node.expression;\n    var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    intValue: i64,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.BOOL: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.ISIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.USIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting native type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NONNULL: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.CLASS && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NONNULL: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.CONST: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operand = node.operand;\n    var operator = node.operator;\n    switch (operator) {\n      case Token.MINUS: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.INTEGER)) {\n          return this.determineIntegerLiteralType(i64_sub(i64_zero, (<IntegerLiteralExpression>operand).value), ctxType);\n        }\n        // fall-through\n      }\n      case Token.PLUS:\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.EXCLAMATION: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.TILDE: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operator = node.operator;\n    switch (operator) {\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var left = node.left;\n    var right = node.right;\n    var operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.EQUALS:\n      case Token.PLUS_EQUALS:\n      case Token.MINUS_EQUALS:\n      case Token.ASTERISK_EQUALS:\n      case Token.ASTERISK_ASTERISK_EQUALS:\n      case Token.SLASH_EQUALS:\n      case Token.PERCENT_EQUALS:\n      case Token.LESSTHAN_LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.AMPERSAND_EQUALS:\n      case Token.BAR_EQUALS:\n      case Token.CARET_EQUALS: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LESSTHAN:\n      case Token.GREATERTHAN:\n      case Token.LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS_EQUALS: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.ASTERISK:\n      case Token.SLASH:\n      case Token.PERCENT: { // mod has special logic, but also behaves like this\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // pow: result is common type of LHS and RHS, preferring overloads\n\n      case Token.ASTERISK_ASTERISK: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.AMPERSAND:\n      case Token.BAR:\n      case Token.CARET: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\n\n      case Token.AMPERSAND_AMPERSAND:\n      case Token.BAR_BAR: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    var parent = ctxFlow.actualFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    var parent: Element | null = ctxFlow.actualFunction.parent;\n    if (parent !== null && parent.kind == ElementKind.CLASS) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.INTEGER: {\n        let intType = this.determineIntegerLiteralType(\n          (<IntegerLiteralExpression>node).value,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.FLOAT: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.STRING: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.ARRAY: {\n        let classReference = ctxType.getClass();\n        if (classReference !== null && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.NULL && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonDenominator(elementType, currentType, false);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            this.error(\n              DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n              node.range, \"T\"\n            );\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var targetExpression = node.expression;\n    var target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!instance) return null;\n        return instance.signature.returnType;\n      }\n      case ElementKind.GLOBAL:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        let varType = (<VariableLikeElement>target).type;\n        let varElement = this.getElementOfType(varType);\n        if (!varElement || varElement.kind != ElementKind.CLASS) {\n          break;\n        }\n        target = varElement;\n        // fall-through\n      }\n      case ElementKind.CLASS: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          let signatureReference = assert(ftype.signatureReference);\n          return signatureReference.returnType;\n        }\n        break;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    var commonType = Type.commonDenominator(thenType, elseType, false);\n    if (!commonType) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = this.resolveTypeName(node.typeName, ctxFlow.actualFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var classInstance: Class | null = null; // if an instance method\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.INSTANCE)) {\n      assert(actualParent.kind == ElementKind.CLASS || actualParent.kind == ElementKind.INTERFACE);\n      classInstance = <Class>actualParent;\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          if (!ctxTypes.has(classTypeParameterName)) {\n            ctxTypes.set(\n              classTypeParameterName,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n    } else {\n      assert(actualParent.kind != ElementKind.CLASS); // must not be pre-bound\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    var signatureNode = prototype.functionTypeNode;\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var numFunctionTypeArguments: i32;\n    if (typeArguments !== null && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes !== null && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    var thisType: Type | null = null;\n    var explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    var signatureParameters = signatureNode.parameters;\n    var numSignatureParameters = signatureParameters.length;\n    var parameterTypes = new Array<Type>(numSignatureParameters);\n    var requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.DEFAULT) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    var returnType: Type;\n    if (prototype.is(CommonFlags.SET)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.CONSTRUCTOR)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n\n    var nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += \"<\" + instanceKey + \">\";\n    var instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.INSTANCE)) {\n        assert(actualParent.kind == ElementKind.CLASS);\n        let classInstance = <Class>actualParent;\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes,\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    var instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    var nameInclTypeParamters = prototype.name;\n    if (instanceKey.length) nameInclTypeParamters += \"<\" + instanceKey + \">\";\n    if (prototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n      instance = new Interface(nameInclTypeParamters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParamters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    var pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes !== null && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    var anyPending = false;\n\n    // Resolve base class if applicable\n    var basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        uniqueMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n    }\n\n    // Resolve interfaces if applicable\n    var interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          uniqueMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.INTERFACE);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    var members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    var pendingClasses = this.resolveClassPending;\n    var unimplemented = new Map<string,DeclaredElement>();\n\n    // Alias interface members\n    var interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(ifaceMembers.get(memberName));\n            if (members.has(memberName)) {\n              let existing = assert(members.get(memberName));\n              if (!member.isCompatibleOverride(existing)) {\n                this.errorRelated(\n                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n                );\n                continue;\n              }\n            }\n            members.set(memberName, member);\n            unimplemented.set(memberName, member);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    var memoryOffset: u32 = 0;\n    var base = instance.base;\n    if (base) {\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(baseMembers.get(memberName));\n          if (members.has(memberName)) {\n            let existing = assert(members.get(memberName));\n            if (!member.isCompatibleOverride(existing)) {\n              this.errorRelated(\n                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n              );\n              continue;\n            }\n          }\n          members.set(memberName, member);\n          if (member.is(CommonFlags.ABSTRACT)) {\n            unimplemented.set(memberName, member);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    var prototype = instance.prototype;\n    var instanceMemberPrototypes = prototype.instanceMembers;\n    var properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        switch (member.kind) {\n\n          case ElementKind.FIELD_PROTOTYPE: {\n            let fieldPrototype = <FieldPrototype>member;\n            let fieldTypeNode = fieldPrototype.typeNode;\n            let fieldType: Type | null = null;\n            // TODO: handle duplicate non-private fields specifically?\n            if (!fieldTypeNode) {\n              if (base) {\n                let baseMembers = base.members;\n                if (baseMembers !== null && baseMembers.has(fieldPrototype.name)) {\n                  let baseField = assert(baseMembers.get(fieldPrototype.name));\n                  if (!baseField.is(CommonFlags.PRIVATE)) {\n                    assert(baseField.kind == ElementKind.FIELD);\n                    fieldType = (<Field>baseField).type;\n                  }\n                }\n              }\n              if (!fieldType) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldPrototype.identifierNode.range.atEnd\n                  );\n                }\n              }\n            } else {\n              fieldType = this.resolveType(\n                fieldTypeNode,\n                prototype.parent, // relative to class\n                instance.contextualTypeArguments,\n                reportMode\n              );\n              if (fieldType == Type.void) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldTypeNode.range\n                  );\n                }\n                break;\n              }\n            }\n            if (!fieldType) break; // did report above\n            let fieldInstance = new Field(fieldPrototype, instance, fieldType);\n            assert(isPowerOf2(fieldType.byteSize));\n            let mask = fieldType.byteSize - 1;\n            if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n            fieldInstance.memoryOffset = memoryOffset;\n            memoryOffset += fieldType.byteSize;\n            instance.add(memberName, fieldInstance); // reports\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.ABSTRACT)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter !== null && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.INTERFACE) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.ABSTRACT) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.lookupInSelf(CommonNames.constructor);\n        if (ctorPrototype !== null && ctorPrototype.parent === instance) {\n          assert(ctorPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    var overloadPrototypes = prototype.overloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.INVALID);\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.INSTANCE)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.overloads;\n      if (!overloads) instance.overloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.INSTANCE)) {\n        switch (overloadKind) {\n          case OperatorKind.PREFIX_INC:\n          case OperatorKind.PREFIX_DEC:\n          case OperatorKind.POSTFIX_INC:\n          case OperatorKind.POSTFIX_DEC: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.REPORT) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.INDEXED_GET || overloadKind == OperatorKind.INDEXED_SET) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.INDEXED_GET) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base === instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface === instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes,\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Property | null {\n    var instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(prototype, prototype);\n    var getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    var setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.RESOLVED)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n}\n","/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimalDigit,\n  isOctalDigit,\n  isKeywordCharacter\n} from \"./util\";\n\n/** Named token types. */\nexport enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  ABSTRACT,\n  AS,\n  ASYNC,\n  AWAIT,        // ES2017\n  BREAK,        // ES2017\n  CASE,         // ES2017\n  CATCH,        // ES2017\n  CLASS,        // ES2017\n  CONST,        // ES2017\n  CONTINUE,     // ES2017\n  CONSTRUCTOR,\n  DEBUGGER,     // ES2017\n  DECLARE,\n  DEFAULT,      // ES2017\n  DELETE,       // ES2017\n  DO,           // ES2017\n  ELSE,         // ES2017\n  ENUM,         // ES2017 future\n  EXPORT,       // ES2017\n  EXTENDS,      // ES2017\n  FALSE,        // ES\n  FINALLY,      // ES2017\n  FOR,          // ES2017\n  FROM,         // AS possible identifier\n  FUNCTION,     // ES2017\n  GET,\n  IF,           // ES2017\n  IMPLEMENTS,   // ES2017 non-lexical\n  IMPORT,       // ES2017\n  IN,           // ES2017\n  INSTANCEOF,   // ES2017\n  INTERFACE,    // ES2017 non-lexical\n  IS,\n  KEYOF,\n  LET,          // ES2017 non-lexical\n  MODULE,       // AS possible identifier\n  NAMESPACE,    // AS possible identifier\n  NEW,          // ES2017\n  NULL,         // ES\n  OF,\n  PACKAGE,      // ES2017 non-lexical\n  PRIVATE,      // ES2017 non-lexical\n  PROTECTED,    // ES2017 non-lexical\n  PUBLIC,       // ES2017 non-lexical\n  READONLY,\n  RETURN,       // ES2017\n  SET,\n  STATIC,       // ES2017 non-lexical\n  SUPER,        // ES2017\n  SWITCH,       // ES2017\n  THIS,         // ES2017\n  THROW,        // ES2017\n  TRUE,         // ES\n  TRY,          // ES2017\n  TYPE,         // AS possible identifier\n  TYPEOF,       // ES2017\n  VAR,          // ES2017\n  VOID,         // ES2017\n  WHILE,        // ES2017\n  WITH,         // ES2017\n  YIELD,        // ES2017\n\n  // punctuation\n\n  OPENBRACE,\n  CLOSEBRACE,\n  OPENPAREN,\n  CLOSEPAREN,\n  OPENBRACKET,\n  CLOSEBRACKET,\n  DOT,\n  DOT_DOT_DOT,\n  SEMICOLON,\n  COMMA,\n  LESSTHAN,\n  GREATERTHAN,\n  LESSTHAN_EQUALS,\n  GREATERTHAN_EQUALS,\n  EQUALS_EQUALS,\n  EXCLAMATION_EQUALS,\n  EQUALS_EQUALS_EQUALS,\n  EXCLAMATION_EQUALS_EQUALS,\n  EQUALS_GREATERTHAN,\n  PLUS,\n  MINUS,\n  ASTERISK_ASTERISK,\n  ASTERISK,\n  SLASH,\n  PERCENT,\n  PLUS_PLUS,\n  MINUS_MINUS,\n  LESSTHAN_LESSTHAN,\n  GREATERTHAN_GREATERTHAN,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN,\n  AMPERSAND,\n  BAR,\n  CARET,\n  EXCLAMATION,\n  TILDE,\n  AMPERSAND_AMPERSAND,\n  BAR_BAR,\n  QUESTION,\n  COLON,\n  EQUALS,\n  PLUS_EQUALS,\n  MINUS_EQUALS,\n  ASTERISK_EQUALS,\n  ASTERISK_ASTERISK_EQUALS,\n  SLASH_EQUALS,\n  PERCENT_EQUALS,\n  LESSTHAN_LESSTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,\n  AMPERSAND_EQUALS,\n  BAR_EQUALS,\n  CARET_EQUALS,\n  AT,\n\n  // literals\n\n  IDENTIFIER,\n  STRINGLITERAL,\n  INTEGERLITERAL,\n  FLOATLITERAL,\n\n  // meta\n\n  INVALID,\n  ENDOFFILE\n}\n\nexport enum IdentifierHandling {\n  DEFAULT,\n  PREFER,\n  ALWAYS\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  assert(text.length);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (text == \"abstract\") return Token.ABSTRACT;\n      if (text == \"as\") return Token.AS;\n      if (text == \"async\") return Token.ASYNC;\n      if (text == \"await\") return Token.AWAIT;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.BREAK;\n      break;\n    }\n    case CharCode.c: {\n      if (text == \"case\") return Token.CASE;\n      if (text == \"catch\") return Token.CATCH;\n      if (text == \"class\") return Token.CLASS;\n      if (text == \"continue\") return Token.CONTINUE;\n      if (text == \"const\") return Token.CONST;\n      if (text == \"constructor\") return Token.CONSTRUCTOR;\n      break;\n    }\n    case CharCode.d: {\n      if (text == \"debugger\") return Token.DEBUGGER;\n      if (text == \"declare\") return Token.DECLARE;\n      if (text == \"default\") return Token.DEFAULT;\n      if (text == \"delete\") return Token.DELETE;\n      if (text == \"do\") return Token.DO;\n      break;\n    }\n    case CharCode.e: {\n      if (text == \"else\") return Token.ELSE;\n      if (text == \"enum\") return Token.ENUM;\n      if (text == \"export\") return Token.EXPORT;\n      if (text == \"extends\") return Token.EXTENDS;\n      break;\n    }\n    case CharCode.f: {\n      if (text == \"false\") return Token.FALSE;\n      if (text == \"finally\") return Token.FINALLY;\n      if (text == \"for\") return Token.FOR;\n      if (text == \"from\") return Token.FROM;\n      if (text == \"function\") return Token.FUNCTION;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.GET;\n      break;\n    }\n    case CharCode.i: {\n      if (text == \"if\") return Token.IF;\n      if (text == \"implements\") return Token.IMPLEMENTS;\n      if (text == \"import\") return Token.IMPORT;\n      if (text == \"in\") return Token.IN;\n      if (text == \"instanceof\") return Token.INSTANCEOF;\n      if (text == \"interface\") return Token.INTERFACE;\n      if (text == \"is\") return Token.IS;\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KEYOF;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.LET;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.MODULE;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"namespace\") return Token.NAMESPACE;\n      if (text == \"new\") return Token.NEW;\n      if (text == \"null\") return Token.NULL;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.OF;\n      break;\n    }\n    case CharCode.p: {\n      if (text == \"package\") return Token.PACKAGE;\n      if (text == \"private\") return Token.PRIVATE;\n      if (text == \"protected\") return Token.PROTECTED;\n      if (text == \"public\") return Token.PUBLIC;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"readonly\") return Token.READONLY;\n      if (text == \"return\") return Token.RETURN;\n      break;\n    }\n    case CharCode.s: {\n      if (text == \"set\") return Token.SET;\n      if (text == \"static\") return Token.STATIC;\n      if (text == \"super\") return Token.SUPER;\n      if (text == \"switch\") return Token.SWITCH;\n      break;\n    }\n    case CharCode.t: {\n      if (text == \"this\") return Token.THIS;\n      if (text == \"throw\") return Token.THROW;\n      if (text == \"true\") return Token.TRUE;\n      if (text == \"try\") return Token.TRY;\n      if (text == \"type\") return Token.TYPE;\n      if (text == \"typeof\") return Token.TYPEOF;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.VAR;\n      if (text == \"void\") return Token.VOID;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.WHILE;\n      if (text == \"with\") return Token.WITH;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.YIELD;\n      break;\n    }\n  }\n  return Token.INVALID;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.ABSTRACT:\n    case Token.AS:\n    case Token.CONSTRUCTOR:\n    case Token.DECLARE:\n    case Token.DELETE:\n    case Token.FROM:\n    case Token.FOR:\n    case Token.GET:\n    case Token.INSTANCEOF:\n    case Token.IS:\n    case Token.KEYOF:\n    case Token.MODULE:\n    case Token.NAMESPACE:\n    case Token.NULL:\n    case Token.READONLY:\n    case Token.SET:\n    case Token.TYPE:\n    case Token.VOID: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.DELETE: return \"delete\";\n    case Token.IN: return \"in\";\n    case Token.INSTANCEOF: return \"instanceof\";\n    case Token.NEW: return \"new\";\n    case Token.TYPEOF: return \"typeof\";\n    case Token.VOID: return \"void\";\n    case Token.YIELD: return \"yield\";\n    case Token.DOT_DOT_DOT: return \"...\";\n    case Token.COMMA: return \",\";\n    case Token.LESSTHAN: return \"<\";\n    case Token.GREATERTHAN: return \">\";\n    case Token.LESSTHAN_EQUALS: return \"<=\";\n    case Token.GREATERTHAN_EQUALS: return \">=\";\n    case Token.EQUALS_EQUALS: return \"==\";\n    case Token.EXCLAMATION_EQUALS: return \"!=\";\n    case Token.EQUALS_EQUALS_EQUALS: return \"===\";\n    case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\n    case Token.PLUS: return \"+\";\n    case Token.MINUS: return \"-\";\n    case Token.ASTERISK_ASTERISK: return \"**\";\n    case Token.ASTERISK: return \"*\";\n    case Token.SLASH: return \"/\";\n    case Token.PERCENT: return \"%\";\n    case Token.PLUS_PLUS: return \"++\";\n    case Token.MINUS_MINUS: return \"--\";\n    case Token.LESSTHAN_LESSTHAN: return \"<<\";\n    case Token.GREATERTHAN_GREATERTHAN: return \">>\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\n    case Token.AMPERSAND: return \"&\";\n    case Token.BAR: return \"|\";\n    case Token.CARET: return \"^\";\n    case Token.EXCLAMATION: return \"!\";\n    case Token.TILDE: return \"~\";\n    case Token.AMPERSAND_AMPERSAND: return \"&&\";\n    case Token.BAR_BAR: return \"||\";\n    case Token.EQUALS: return \"=\";\n    case Token.PLUS_EQUALS: return \"+=\";\n    case Token.MINUS_EQUALS: return \"-=\";\n    case Token.ASTERISK_EQUALS: return \"*=\";\n    case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\n    case Token.SLASH_EQUALS: return \"/=\";\n    case Token.PERCENT_EQUALS: return \"%=\";\n    case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\n    case Token.AMPERSAND_EQUALS: return \"&=\";\n    case Token.BAR_EQUALS: return \"|=\";\n    case Token.CARET_EQUALS: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\nexport class Range {\n\n  start: i32;\n  end: i32;\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(start: i32, end: i32) {\n    this.start = start;\n    this.end = end;\n  }\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return this.source == other.source && this.start == other.start && this.end == other.end;\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: bool = false;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    var text = source.text;\n    var end = text.length;\n    var pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.BYTEORDERMARK\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.HASH &&\n      text.charCodeAt(pos + 1) == CharCode.EXCLAMATION\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LINEFEED\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): Token {\n    this.nextToken = -1;\n    var token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.INVALID);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CARRIAGERETURN: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LINEFEED\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LINEFEED:\n        case CharCode.TAB:\n        case CharCode.VERTICALTAB:\n        case CharCode.FORMFEED:\n        case CharCode.SPACE: {\n          ++pos;\n          break;\n        }\n        case CharCode.EXCLAMATION: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.EQUALS\n            ) {\n              this.pos = pos + 1;\n              return Token.EXCLAMATION_EQUALS_EQUALS;\n            }\n            this.pos = pos;\n            return Token.EXCLAMATION_EQUALS;\n          }\n          this.pos = pos;\n          return Token.EXCLAMATION;\n        }\n        case CharCode.DOUBLEQUOTE:\n        case CharCode.SINGLEQUOTE:\n        case CharCode.BACKTICK: { // TODO\n          this.pos = pos;\n          return Token.STRINGLITERAL; // expects a call to readString\n        }\n        case CharCode.PERCENT: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.PERCENT_EQUALS;\n          }\n          this.pos = pos;\n          return Token.PERCENT;\n        }\n        case CharCode.AMPERSAND: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.AMPERSAND) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_AMPERSAND;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.AMPERSAND;\n        }\n        case CharCode.OPENPAREN: {\n          this.pos = pos + 1;\n          return Token.OPENPAREN;\n        }\n        case CharCode.CLOSEPAREN: {\n          this.pos = pos + 1;\n          return Token.CLOSEPAREN;\n        }\n        case CharCode.ASTERISK: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.ASTERISK_EQUALS;\n            }\n            if (chr == CharCode.ASTERISK) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.ASTERISK_ASTERISK_EQUALS;\n              }\n              this.pos = pos;\n              return Token.ASTERISK_ASTERISK;\n            }\n          }\n          this.pos = pos;\n          return Token.ASTERISK;\n        }\n        case CharCode.PLUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.PLUS) {\n              this.pos = pos + 1;\n              return Token.PLUS_PLUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.PLUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.PLUS;\n        }\n        case CharCode.COMMA: {\n          this.pos = pos + 1;\n          return Token.COMMA;\n        }\n        case CharCode.MINUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.MINUS) {\n              this.pos = pos + 1;\n              return Token.MINUS_MINUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.MINUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.MINUS;\n        }\n        case CharCode.DOT: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimalDigit(chr)) {\n              this.pos = pos - 1;\n              return Token.FLOATLITERAL; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.DOT &&\n              text.charCodeAt(pos + 1) == CharCode.DOT\n            ) {\n              this.pos = pos + 2;\n              return Token.DOT_DOT_DOT;\n            }\n          }\n          this.pos = pos;\n          return Token.DOT;\n        }\n        case CharCode.SLASH: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.SLASH) { // single-line\n              let commentKind = CommentKind.LINE;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.SLASH\n              ) {\n                ++pos;\n                commentKind = CommentKind.TRIPLE;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LINEFEED) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.ASTERISK) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.ASTERISK &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.SLASH\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.BLOCK,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.SLASH_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.SLASH;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.INTEGERLITERAL // expects a call to readInteger\n            : Token.FLOATLITERAL;  // expects a call to readFloat\n        }\n        case CharCode.COLON: {\n          this.pos = pos + 1;\n          return Token.COLON;\n        }\n        case CharCode.SEMICOLON: {\n          this.pos = pos + 1;\n          return Token.SEMICOLON;\n        }\n        case CharCode.LESSTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LESSTHAN) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.LESSTHAN_LESSTHAN_EQUALS;\n              }\n              this.pos = pos;\n              return Token.LESSTHAN_LESSTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.LESSTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.LESSTHAN;\n        }\n        case CharCode.EQUALS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.EQUALS_EQUALS_EQUALS;\n              }\n              this.pos = pos;\n              return Token.EQUALS_EQUALS;\n            }\n            if (chr == CharCode.GREATERTHAN) {\n              this.pos = pos + 1;\n              return Token.EQUALS_GREATERTHAN;\n            }\n          }\n          this.pos = pos;\n          return Token.EQUALS;\n        }\n        case CharCode.GREATERTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GREATERTHAN) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GREATERTHAN) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.EQUALS\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\n                  }\n                  this.pos = pos;\n                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\n                }\n                if (chr == CharCode.EQUALS) {\n                  this.pos = pos + 1;\n                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;\n                }\n              }\n              this.pos = pos;\n              return Token.GREATERTHAN_GREATERTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.GREATERTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.GREATERTHAN;\n        }\n        case CharCode.QUESTION: {\n          this.pos = pos + 1;\n          return Token.QUESTION;\n        }\n        case CharCode.OPENBRACKET: {\n          this.pos = pos + 1;\n          return Token.OPENBRACKET;\n        }\n        case CharCode.CLOSEBRACKET: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACKET;\n        }\n        case CharCode.CARET: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.CARET_EQUALS;\n          }\n          this.pos = pos;\n          return Token.CARET;\n        }\n        case CharCode.OPENBRACE: {\n          this.pos = pos + 1;\n          return Token.OPENBRACE;\n        }\n        case CharCode.BAR: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.BAR) {\n              this.pos = pos + 1;\n              return Token.BAR_BAR;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.BAR_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.BAR;\n        }\n        case CharCode.CLOSEBRACE: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACE;\n        }\n        case CharCode.TILDE: {\n          this.pos = pos + 1;\n          return Token.TILDE;\n        }\n        case CharCode.AT: {\n          this.pos = pos + 1;\n          return Token.AT;\n        }\n        default: {\n          if (isIdentifierStart(c)) {\n            if (isKeywordCharacter(c)) {\n              let posBefore = pos;\n              while (\n                ++pos < end &&\n                isIdentifierPart(c = text.charCodeAt(pos))\n              ) {\n                if (!isKeywordCharacter(c)) {\n                  this.pos = posBefore;\n                  return Token.IDENTIFIER;\n                }\n              }\n              let keywordText = text.substring(posBefore, pos);\n              let keywordToken = tokenFromKeyword(keywordText);\n              if (\n                keywordToken !== Token.INVALID &&\n                identifierHandling !== IdentifierHandling.ALWAYS &&\n                !(\n                  identifierHandling === IdentifierHandling.PREFER &&\n                  tokenIsAlsoIdentifier(keywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return keywordToken;\n              }\n              this.pos = pos = posBefore;\n            }\n            this.pos = pos;\n            return Token.IDENTIFIER; // expects a call to readIdentifier\n          } else if (isWhiteSpace(c)) {\n            ++pos;\n            break;\n          }\n          let start = pos++;\n          if ( // surrogate pair?\n            (c & 0xFC00) == 0xD800 && pos < end &&\n            ((text.charCodeAt(pos)) & 0xFC00) == 0xDC00\n          ) ++pos;\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.INVALID;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.ENDOFFILE;\n  }\n\n  peek(\n    checkOnNewLine: bool = false,\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    if (this.nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      let nextToken: Token;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.INVALID);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      if (checkOnNewLine) {\n        this.nextTokenOnNewLine = false;\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\n          if (isLineBreak(text.charCodeAt(pos))) {\n            this.nextTokenOnNewLine = true;\n            break;\n          }\n        }\n      }\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return this.nextToken;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.PREFER): bool {\n    return this.skip(Token.IDENTIFIER, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): bool {\n    var posBefore = this.pos;\n    var tokenBefore = this.token;\n    var tokenPosBefore = this.tokenPos;\n    var maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GREATERTHAN) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    var nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.INVALID);\n    if (nextToken == token) {\n      this.token = token;\n      this.nextToken = -1;\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    var state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.nextToken = -1;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    var start = pos;\n    while (\n      ++pos < end &&\n      isIdentifierPart(text.charCodeAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readString(): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    var quote = text.charCodeAt(pos++);\n    var start = pos;\n    var result = \"\";\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.BACKSLASH) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence();\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (isLineBreak(c) && quote != CharCode.BACKTICK) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    return result;\n  }\n\n  readEscapeSequence(): string {\n    var end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    var text = this.source.text;\n    var c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: return \"\\0\";\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SINGLEQUOTE: return \"'\";\n      case CharCode.DOUBLEQUOTE: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OPENBRACE\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(); // \\xDD\n      }\n      case CharCode.CARRIAGERETURN: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LINEFEED\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LINEFEED:\n      case CharCode.LINESEPARATOR:\n      case CharCode.PARAGRAPHSEPARATOR: return \"\";\n      default: return String.fromCharCode(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.SLASH) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.DOT || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctalDigit(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    var text = this.source.text;\n    let pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_4 = i64_new(4);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = (value << 4) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        // value = (value << 4) + 10 + c - CharCode.A;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.A)\n        );\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        // value = (value << 4) + 10 + c - CharCode.a;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.a)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_10 = i64_new(10);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = value * 10 + c - CharCode._0;\n        value = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_3 = i64_new(3);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._7) {\n        // value = (value << 3) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_1 = i64_new(1);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value = (value << 1);\n        value = i64_shl(value, i64_1);\n      } else if (c == CharCode._1) {\n        // value = (value << 1) + 1;\n        value = i64_add(\n          i64_shl(value, i64_1),\n          i64_1\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // var text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    var text = this.source.text;\n    var end = this.end;\n    var start = this.pos;\n    var sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.DOT) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.MINUS || c == CharCode.PLUS &&\n          isDecimalDigit(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var start = pos;\n    var end = this.end;\n    var sepEnd = start;\n    var sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimalDigit(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2): string {\n    var value = 0;\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        value = (value << 4) + c + (10 - CharCode.A);\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        value = (value << 4) + c + (10 - CharCode.a);\n      } else {\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        this.pos = pos;\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      this.pos = pos;\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCharCode(value);\n  }\n\n  readUnicodeEscape(): string {\n    return this.readHexadecimalEscape(4);\n  }\n\n  private readExtendedUnicodeEscape(): string {\n    var start = this.pos;\n    var value = this.readHexInteger();\n    var value32 = i64_low(value);\n    var invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      this.error(\n        DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n        this.range(start, this.pos)\n      );\n      invalid = true;\n    }\n\n    var end = this.end;\n    var text = this.source.text;\n    if (this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(start, end)\n      );\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {\n      ++this.pos;\n    } else {\n      this.error(\n        DiagnosticCode.Unterminated_Unicode_escape_sequence,\n        this.range(start, this.pos)\n      );\n      invalid = true;\n    }\n\n    if (invalid) return \"\";\n    return value32 < 0x10000\n      ? String.fromCharCode(value32)\n      : String.fromCharCode(\n        ((value32 - 0x10000) >>> 10) | 0xD800,\n        ((value32 - 0x10000) & 1023) | 0xDC00\n      );\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nvar reusableState: State | null = null;\n","/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  NativeType,\n  createType\n} from \"./module\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  ISIZE,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  USIZE,\n  /** A 1-bit unsigned integer. */\n  BOOL, // sic\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references\n\n  /** Function reference. */\n  FUNCREF,\n  /** External reference. */\n  EXTERNREF,\n  /** Exception reference. */\n  EXNREF,\n  /** Any reference. */\n  ANYREF,\n\n  // other\n\n  /** No return type. */\n  VOID\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  NONE = 0,\n  /** Is a signed type that can represent negative values. */\n  SIGNED = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  UNSIGNED = 1 << 1,\n  /** Is an integer type. */\n  INTEGER = 1 << 2,\n  /** Is a floating point type. */\n  FLOAT = 1 << 3,\n  /** Is a varying (in size) type. */\n  VARYING = 1 << 4,\n  /** Is smaller than 32-bits. */\n  SHORT = 1 << 5,\n  /** Is larger than 32-bits. */\n  LONG = 1 << 6,\n  /** Is a value type. */\n  VALUE = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  REFERENCE = 1 << 8,\n  /** Is a nullable type. */\n  NULLABLE = 1 << 9,\n  /** Is a vector type. */\n  VECTOR = 1 << 10,\n  /** Is an external type. */\n  EXTERNAL = 1 << 11,\n  /** Is a class. */\n  CLASS = 1 << 12,\n  /** Is a function. */\n  FUNCTION = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Size in bytes. */\n  byteSize: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    this.byteSize = <i32>ceil<f64>(<f64>size / 8);\n    this.classReference = null;\n    this.signatureReference = null;\n    if (!(flags & TypeFlags.NULLABLE)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.I8: return Type.i8;\n      case TypeKind.I16: return Type.i16;\n      case TypeKind.F32:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.F64:\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.ISIZE: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8: return Type.u8;\n      case TypeKind.U16: return Type.u16;\n      case TypeKind.U32: return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.USIZE: return this.size == 64 ? Type.usize64 : Type.usize32;\n      case TypeKind.BOOL:\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    if (this.kind == TypeKind.VOID) return Type.auto;\n    return this;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.SHORT | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.LONG | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.SIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.UNSIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.VARYING | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.INTEGER);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.FLOAT | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.VECTOR | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.NULLABLE | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.EXTERNAL | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.isInternalReference\n      ? this.classReference !== null\n      : false;\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.isInternalReference\n      ? this.signatureReference !== null\n      : false;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n      return this.signatureReference !== null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    var classReference = this.classReference;\n    return classReference !== null && classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    var size = this.is(TypeFlags.UNSIGNED) ? this.size : this.size - 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    var nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) return false;\n    if (this.isReference) {\n      return (\n        this.classReference == other.classReference &&\n        this.signatureReference == other.signatureReference &&\n        this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    var currentClass: Class | null;\n    var targetClass: Class | null;\n    var currentFunction: Signature | null;\n    var targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference && (this.kind == target.kind || target.kind == TypeKind.ANYREF)) {\n            return true;\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.INTEGER) && target.is(TypeFlags.INTEGER)) {\n      let size = this.size;\n      return size == target.size && (size >= 32 || this.is(TypeFlags.SIGNED) == target.is(TypeFlags.SIGNED));\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Determines the common denominator type of two types, if there is any. */\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat\n      ? \"|null\"\n      : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? \"(\" + signatureReference.toString(validWat) + \")\" + nullablePostfix\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.EXNREF: return \"exnref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      default: assert(false);\n      case TypeKind.VOID: return \"void\";\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective native type. */\n  toNativeType(): NativeType {\n    switch (this.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return NativeType.I32;\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (this.size != 64) return NativeType.I32;\n      case TypeKind.I64:\n      case TypeKind.U64: return NativeType.I64;\n      case TypeKind.F32: return NativeType.F32;\n      case TypeKind.F64: return NativeType.F64;\n      case TypeKind.V128: return NativeType.V128;\n      case TypeKind.FUNCREF: return NativeType.Funcref;\n      case TypeKind.EXTERNREF: return NativeType.Externref;\n      case TypeKind.EXNREF: return NativeType.Exnref;\n      case TypeKind.ANYREF: return NativeType.Anyref;\n      case TypeKind.VOID: return NativeType.None;\n    }\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.BOOL,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.SIGNED   |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.VECTOR   |\n    TypeFlags.VALUE, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.FUNCREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.EXTERNREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Exception reference. */\n  static readonly exnref: Type = new Type(TypeKind.EXNREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.ANYREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of native types. */\nexport function typesToNativeTypes(types: Type[]): NativeType[] {\n  var numTypes = types.length;\n  var ret = new Array<NativeType>(numTypes);\n  for (let i = 0; i < numTypes; ++i) ret[i] = types[i].toNativeType();\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  var numTypes = types.length;\n  if (!numTypes) return \"\";\n  var sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) sb[i] = types[i].toString(true);\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Unique id representing this signature. */\n  id: u32 = 0;\n  /** Parameter types, if any, excluding `this`. */\n  parameterTypes: Type[];\n  /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n  requiredParameters: i32;\n  /** Return type. */\n  returnType: Type;\n  /** This type, if an instance signature. */\n  thisType: Type | null;\n  /** Whether the last parameter is a rest parameter. */\n  hasRest: bool;\n  /** Respective function type. */\n  type: Type;\n  /** The program that created this signature. */\n  program: Program;\n\n  /** Constructs a new signature. */\n  constructor(\n    program: Program,\n    parameterTypes: Type[] | null = null,\n    returnType: Type | null = null,\n    thisType: Type | null = null\n  ) {\n    this.parameterTypes = parameterTypes ? parameterTypes : [];\n    this.requiredParameters = 0;\n    this.returnType = returnType ? returnType : Type.void;\n    this.thisType = thisType;\n    this.program = program;\n    this.hasRest = false;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    this.type = type;\n    type.signatureReference = this;\n\n    var signatureTypes = program.uniqueSignatures;\n    var length = signatureTypes.length;\n    for (let i = 0; i < length; i++) {\n      let compare = signatureTypes[i];\n      if (this.equals(compare)) {\n        this.id = compare.id;\n        return this;\n      }\n    }\n    this.id = program.nextSignatureId++;\n    program.uniqueSignatures.push(this);\n  }\n\n  get nativeParams(): NativeType {\n    var thisType = this.thisType;\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      if (!thisType) return NativeType.None;\n      return thisType.toNativeType();\n    }\n    if (thisType) {\n      let nativeTypes = new Array<NativeType>(1 + numParameterTypes);\n      nativeTypes[0] = thisType.toNativeType();\n      for (let i = 0; i < numParameterTypes; ++i) {\n        nativeTypes[i + 1] = parameterTypes[i].toNativeType();\n      }\n      return createType(nativeTypes);\n    }\n    return createType(typesToNativeTypes(parameterTypes));\n  }\n\n  get nativeResults(): NativeType {\n    return this.returnType.toNativeType();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var otherThisType = other.thisType;\n    if (thisThisType !== null) {\n      if (otherThisType === null || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var otherParameterTypes = other.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != otherParameterTypes.length) return false;\n    for (let i = 0; i < numParameters; ++i) {\n      if (!thisParameterTypes[i].equals(otherParameterTypes[i])) return false;\n    }\n\n    // check return type\n    return this.returnType.equals(other.returnType);\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, requireSameSize: bool = false): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var targetThisType = target.thisType;\n    if (thisThisType !== null) {\n      if (targetThisType === null || !thisThisType.isAssignableTo(targetThisType)) return false;\n    } else if (targetThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var targetParameterTypes = target.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = thisParameterTypes[i];\n      let targetParameterType = targetParameterTypes[i];\n      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;\n    }\n\n    // check return type\n    var thisReturnType = this.returnType;\n    var targetReturnType = target.returnType;\n    return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    var sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    var index = 0;\n    var thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      assert(!thisType.signatureReference);\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    var parameters = this.parameterTypes;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(): Signature {\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    var cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      cloneParameterTypes[i] = parameterTypes[i];\n    }\n    return new Signature(this.program, cloneParameterTypes, this.returnType, this.thisType);\n  }\n}\n","/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset    ]\n       | buffer[offset + 1] << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset    ]\n       | buffer[offset + 1] << 8\n       | buffer[offset + 2] << 16\n       | buffer[offset + 3] << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  var lo = readI32(buffer, offset);\n  var hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  var valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n","/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Makes a unique map. Typically used to track contextual type arguemnts. */\nexport function uniqueMap<K,V>(original: Map<K,V> | null = null, overrides: Map<K,V> | null = null): Map<K,V> {\n  var cloned = new Map<K,V>();\n  if (original) {\n    // TODO: for (let [k, v] of original) {\n    for (let _keys = Map_keys(original), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(original.get(k));\n      cloned.set(k, v);\n    }\n  }\n  if (overrides) {\n    // TODO: for (let [k, v] of overrides) {\n    for (let _keys = Map_keys(overrides), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(overrides.get(k));\n      cloned.set(k, v);\n    }\n  }\n  return cloned;\n}\n","/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./binary\";\nexport * from \"./collections\";\nexport * from \"./math\";\nexport * from \"./path\";\nexport * from \"./text\";\nexport * from \"./vector\";\n","/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n","/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.SLASH;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  var pos = 0;\n  var len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.DOT &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  var atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.DOT\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.DOT &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.DOT ||\n              path.charCodeAt(ipos + 2) != CharCode.DOT\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.DOT ||\n            path.charCodeAt(1) != CharCode.DOT\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  var pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n","/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  NULL = 0,\n  LINEFEED = 0x0A,\n  CARRIAGERETURN = 0x0D,\n  LINESEPARATOR = 0x2028,\n  PARAGRAPHSEPARATOR = 0x2029,\n  NEXTLINE = 0x0085,\n\n  SPACE = 0x20,\n  NONBREAKINGSPACE = 0xA0,\n  ENQUAD = 0x2000,\n  EMQUAD = 0x2001,\n  ENSPACE = 0x2002,\n  EMSPACE = 0x2003,\n  THREEPEREMSPACE = 0x2004,\n  FOURPEREMSPACE = 0x2005,\n  SIXPEREMSPACE = 0x2006,\n  FIGURESPACE = 0x2007,\n  PUNCTUATIONSPACE = 0x2008,\n  THINSPACE = 0x2009,\n  HAIRSPACE = 0x200A,\n  ZEROWIDTHSPACE = 0x200B,\n  NARROWNOBREAKSPACE = 0x202F,\n  IDEOGRAPHICSPACE = 0x3000,\n  MATHEMATICALSPACE = 0x205F,\n  OGHAM = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  AMPERSAND = 0x26,\n  ASTERISK = 0x2A,\n  AT = 0x40,\n  BACKSLASH = 0x5C,\n  BACKTICK = 0x60,\n  BAR = 0x7C,\n  CARET = 0x5E,\n  CLOSEBRACE = 0x7D,\n  CLOSEBRACKET = 0x5D,\n  CLOSEPAREN = 0x29,\n  COLON = 0x3A,\n  COMMA = 0x2C,\n  DOLLAR = 0x24,\n  DOT = 0x2E,\n  DOUBLEQUOTE = 0x22,\n  EQUALS = 0x3D,\n  EXCLAMATION = 0x21,\n  GREATERTHAN = 0x3E,\n  HASH = 0x23,\n  LESSTHAN = 0x3C,\n  MINUS = 0x2D,\n  OPENBRACE = 0x7B,\n  OPENBRACKET = 0x5B,\n  OPENPAREN = 0x28,\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  QUESTION = 0x3F,\n  SEMICOLON = 0x3B,\n  SINGLEQUOTE = 0x27,\n  SLASH = 0x2F,\n  TILDE = 0x7E,\n\n  BACKSPACE = 0x08,\n  FORMFEED = 0x0C,\n  BYTEORDERMARK = 0xFEFF,\n  TAB = 0x09,\n  VERTICALTAB = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: CharCode): bool {\n  switch (c) {\n    case CharCode.LINEFEED:\n    case CharCode.CARRIAGERETURN:\n    case CharCode.LINESEPARATOR:\n    case CharCode.PARAGRAPHSEPARATOR: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  switch (c) {\n    case CharCode.SPACE:\n    case CharCode.TAB:\n    case CharCode.VERTICALTAB:\n    case CharCode.FORMFEED:\n    case CharCode.NONBREAKINGSPACE:\n    case CharCode.NEXTLINE:\n    case CharCode.OGHAM:\n    case CharCode.NARROWNOBREAKSPACE:\n    case CharCode.MATHEMATICALSPACE:\n    case CharCode.IDEOGRAPHICSPACE:\n    case CharCode.BYTEORDERMARK: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;\n    }\n  }\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimalDigit(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctalDigit(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isTrivialAlphanum(code: i32): bool {\n  return code >= CharCode.a && code <= CharCode.z\n      || code >= CharCode.A && code <= CharCode.Z\n      || code >= CharCode._0 && code <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid start of an identifier. */\nexport function isIdentifierStart(c: i32): bool {\n  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c > 0x7F && isUnicodeIdentifierStart(c);\n}\n\n/** Tests if the specified character code is a valid keyword character. */\nexport function isKeywordCharacter(c: i32): bool {\n  return c >= CharCode.a && c <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid part of an identifier. */\nexport function isIdentifierPart(c: i32): bool {\n  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z\n      || c >= CharCode._0 && c <= CharCode._9\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c > 0x7F && isUnicodeIdentifierPart(c);\n}\n\n// storing as u16 to save memory\nconst unicodeIdentifierStart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\n  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\n  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\n  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\n  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\n  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\n  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\n  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\n  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\n  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\n  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\n  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\n  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\n  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\n  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\n  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\n  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\n  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\n  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\n  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\n  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\n  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\n  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\n  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\n  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\n  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\n  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\n  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\n  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\n  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\n  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\n  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\n  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\n  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\n  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\n  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\n  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\n  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\n  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\n  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\n  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\n  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\n  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\n  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\n  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\n  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\n  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\n  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\n  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\n  65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\nconst unicodeIdentifierPart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\n  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\n  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\n  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\n  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\n  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\n  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\n  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\n  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\n  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\n  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\n  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\n  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\n  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\n  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\n  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\n  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\n  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\n  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\n  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\n  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\n  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\n  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\n  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\n  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\n  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\n  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\n  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\n  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\n  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\n  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\n  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\n  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\n  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\n  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\n  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\n  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\n  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\n  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\n  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\n  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\n  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\n  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\n  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\n  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\n  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\n  8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\n  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\n  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\n  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\n  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\n  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\n  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\n  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\n  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\n  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\n  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\n  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\n  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\n  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\n  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\n  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\n  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\n  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\n  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\n  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\n\nfunction lookupInUnicodeMap(code: u16, map: u16[]): bool {\n  if (code < map[0]) return false;\n\n  var lo = 0;\n  var hi = map.length;\n  var mid: i32;\n  var midVal: u16;\n\n  while (lo + 1 < hi) {\n    mid = lo + ((hi - lo) >> 1);\n    mid -= (mid & 1);\n    midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\nfunction isUnicodeIdentifierStart(code: i32): bool {\n  return code < 170 || code > 65500 ? false :\n         lookupInUnicodeMap(code as u16, unicodeIdentifierStart);\n}\n\nfunction isUnicodeIdentifierPart(code: i32): bool {\n  return code < 170 || code > 65500 ? false :\n         lookupInUnicodeMap(code as u16, unicodeIdentifierPart);\n}\n\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX4 = \"        \";\n\n/** Creates an indentation matching the number of specified levels. */\nexport function indent(sb: string[], level: i32): void {\n  while (level >= 4) {\n    sb.push(indentX4);\n    level -= 4;\n  }\n  if (level >= 2) {\n    sb.push(indentX2);\n    level -= 2;\n  }\n  if (level) {\n    sb.push(indentX1);\n  }\n}\n","/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n","// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  NONE = 0,\n  /** Sign extension operations. */\n  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SIGN_EXTENSION: return \"sign-extension\";\n    case Feature.MUTABLE_GLOBALS: return \"mutable-globals\";\n    case Feature.NONTRAPPING_F2I: return \"nontrapping-f2i\";\n    case Feature.BULK_MEMORY: return \"bulk-memory\";\n    case Feature.SIMD: return \"simd\";\n    case Feature.THREADS: return \"threads\";\n    case Feature.EXCEPTION_HANDLING: return \"exception-handling\";\n    case Feature.TAIL_CALLS: return \"tail-calls\";\n    case Feature.REFERENCE_TYPES: return \"reference-types\";\n    case Feature.MULTI_VALUE: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.MEMORY64: return \"memory64\";\n  }\n  assert(false);\n  return \"\";\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  JS = 0,\n  /** WebAssembly with 32-bit pointers. */\n  WASM32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  WASM64 = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nconst binaryen = global.binaryen || (global.binaryen = require(\"binaryen\"));\n\nmodule.exports = binaryen;\n\nconst { Module } = require(\"../module\");\n\nModule.prototype.toText = function toText(watFormat = true) {\n  if (watFormat) {\n    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences\n    // of unreachable statements not actually emitted by the compiler. Optimizing\n    // StackIR removes these again, but may also suppress useless code emitted by\n    // the compiler that's then no longer visible in tests. Both not ideal.\n    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);\n  } else {\n    return binaryen.wrapModule(this.ref).emitText();\n  }\n};\n\nModule.prototype.toAsmjs = function toAsmjs() {\n  return binaryen.wrapModule(this.ref).emitAsmjs();\n};\n","/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobal.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobal.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobal.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n","/**\n * @fileoverview Floating point glue code for JaavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobal.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobal.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobal.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobal.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n","/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst Long = global.Long || require(\"long\");\n\nglobal.i64_zero    = Long.ZERO;\nglobal.i64_one     = Long.ONE;\nglobal.i64_neg_one = Long.fromInt(-1);\n\nglobal.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobal.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobal.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobal.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobal.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobal.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobal.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobal.i64_pow = function i64_pow(left, right) {\n  var rightLo = right.low;\n  var rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(global.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  var result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobal.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobal.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobal.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobal.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobal.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobal.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobal.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobal.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobal.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobal.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobal.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobal.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobal.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  var mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobal.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobal.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobal.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobal.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobal.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobal.i64_to_f32 = function i64_to_f32(value) {\n  return global.Math.fround(value.toNumber());\n};\n\nglobal.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobal.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n","/** @module std/portable *//***/\n\nvar globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\n\nglobalScope.ASC_TARGET = 0; // Target.JS\nglobalScope.ASC_NO_ASSERT = false;\nglobalScope.ASC_MEMORY_BASE = 0;\nglobalScope.ASC_OPTIMIZE_LEVEL = 3;\nglobalScope.ASC_SHRINK_LEVEL = 0;\nglobalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\nglobalScope.ASC_FEATURE_SIGN_EXTENSION = false;\nglobalScope.ASC_FEATURE_BULK_MEMORY = false;\nglobalScope.ASC_FEATURE_SIMD = false;\nglobalScope.ASC_FEATURE_THREADS = false;\n\nvar F64 = new Float64Array(1);\nvar U64 = new Uint32Array(F64.buffer);\n\nObject.defineProperties(\n  globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n  {\n    \"MIN_VALUE\": { value: -128, writable: false },\n    \"MAX_VALUE\": { value:  127, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n  {\n    \"MIN_VALUE\": { value: -32768, writable: false },\n    \"MAX_VALUE\": { value:  32767, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n  {\n    \"MIN_VALUE\": { value: -2147483648, writable: false },\n    \"MAX_VALUE\": { value:  2147483647, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n  {\n    \"MIN_VALUE\": { value:   0, writable: false },\n    \"MAX_VALUE\": { value: 255, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n  {\n    \"MIN_VALUE\": { value:     0, writable: false },\n    \"MAX_VALUE\": { value: 65535, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n  {\n    \"MIN_VALUE\": { value:          0, writable: false },\n    \"MAX_VALUE\": { value: 4294967295, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"bool\"] = function bool(value) { return !!value; },\n  {\n    \"MIN_VALUE\": { value: false, writable: false },\n    \"MAX_VALUE\": { value: true,  writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n  {\n    \"EPSILON\":   { value: 1.1920928955078125e-07, writable: false },\n    \"MIN_VALUE\": { value: 1.4012984643248170e-45, writable: false },\n    \"MAX_VALUE\": { value: 3.4028234663852886e+38, writable: false },\n    \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38, writable: false },\n    \"MIN_SAFE_INTEGER\":  { value: -16777215, writable: false },\n    \"MAX_SAFE_INTEGER\":  { value:  16777215, writable: false },\n    \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\n    \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\n    \"NaN\": { value: NaN, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"f64\"] = function f64(value) { return +value; },\n  {\n    \"EPSILON\":   { value: 2.2204460492503131e-016, writable: false },\n    \"MIN_VALUE\": { value:                  5e-324, writable: false },\n    \"MAX_VALUE\": { value: 1.7976931348623157e+308, writable: false },\n    \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308, writable: false },\n    \"MIN_SAFE_INTEGER\":  { value: -9007199254740991, writable: false },\n    \"MAX_SAFE_INTEGER\":  { value:  9007199254740991, writable: false },\n    \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\n    \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\n    \"NaN\": { value: NaN, writable: false }\n  }\n);\n\nglobalScope[\"clz\"] = Math.clz32;\n\nglobalScope[\"ctz\"] = function ctz(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n};\n\nglobalScope[\"popcnt\"] = function popcnt(value) {\n  value -= value >>> 1 & 0x55555555;\n  value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n  return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n};\n\nglobalScope[\"rotl\"] = function rotl(value, shift) {\n  shift &= 31;\n  return (value << shift) | (value >>> (32 - shift));\n};\n\nglobalScope[\"rotr\"] = function rotr(value, shift) {\n  shift &= 31;\n  return (value >>> shift) | (value << (32 - shift));\n};\n\nglobalScope[\"abs\"] = Math.abs;\n\nglobalScope[\"max\"] = Math.max;\n\nglobalScope[\"min\"] = Math.min;\n\nglobalScope[\"ceil\"] = Math.ceil;\n\nglobalScope[\"floor\"] = Math.floor;\n\n// Adopt code from https://github.com/rfk/wasm-polyfill\nglobalScope[\"nearest\"] = function nearest(value) {\n  if (Math.abs(value - Math.trunc(value)) === 0.5) {\n    return 2.0 * Math.round(value * 0.5);\n  }\n  return Math.round(value);\n};\n\nglobalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n  return condition ? ifTrue : ifFalse;\n};\n\nglobalScope[\"sqrt\"] = Math.sqrt;\n\nglobalScope[\"trunc\"] = Math.trunc;\n\nglobalScope[\"copysign\"] = function copysign(x, y) {\n  return Math.abs(x) * Math.sign(y);\n};\n\nglobalScope[\"bswap\"] = function bswap(value) {\n  var a = value >> 8 & 0x00FF00FF;\n  var b = (value & 0x00FF00FF) << 8;\n  value = a | b;\n  a = value >> 16 & 0x0000FFFF;\n  b = (value & 0x0000FFFF) << 16;\n  return a | b;\n};\n\nglobalScope[\"bswap16\"] = function bswap16(value) {\n  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\n};\n\nfunction UnreachableError() {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, UnreachableError);\n  } else {\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n  }\n}\nUnreachableError.prototype = Object.create(Error.prototype);\nUnreachableError.prototype.name = \"UnreachableError\";\nUnreachableError.prototype.message = \"unreachable\";\n\nglobalScope[\"unreachable\"] = function unreachable() {\n  throw new UnreachableError();\n};\n\nfunction AssertionError(message) {\n  this.message = message || \"assertion failed\";\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, AssertionError);\n  } else {\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n  }\n}\nAssertionError.prototype = Object.create(Error.prototype);\nAssertionError.prototype.name = \"AssertionError\";\n\nglobalScope[\"assert\"] = function assert(isTrueish, message) {\n  if (isTrueish) return isTrueish;\n  throw new AssertionError(message);\n};\n\nglobalScope[\"changetype\"] = function changetype(value) {\n  return value;\n};\n\nString[\"fromCharCodes\"] = function fromCharCodes(arr) {\n  const CHUNKSIZE = 1 << 13;\n  const len = arr.length;\n  if (len <= CHUNKSIZE) {\n    return String.fromCharCode.apply(String, arr);\n  }\n  let index = 0;\n  let parts = '';\n  while (index < len) {\n    parts += String.fromCharCode.apply(\n      String,\n      arr.slice(index, Math.min(index + CHUNKSIZE, len))\n    );\n    index += CHUNKSIZE;\n  }\n  return parts;\n};\n\nString[\"fromCodePoints\"] = function fromCodePoints(arr) {\n  const CHUNKSIZE = 1 << 13;\n  const len = arr.length;\n  if (len <= CHUNKSIZE) {\n    return String.fromCodePoint.apply(String, arr);\n  }\n  let index = 0;\n  let parts = '';\n  while (index < len) {\n    parts += String.fromCodePoint.apply(\n      String,\n      arr.slice(index, Math.min(index + CHUNKSIZE, len))\n    );\n    index += CHUNKSIZE;\n  }\n  return parts;\n};\n\nif (!String.prototype.replaceAll) {\n  Object.defineProperty(String.prototype, \"replaceAll\", {\n    value: function replaceAll(search, replacment) {\n      var res = this.split(search).join(replacment);\n      if (!search.length) res = replacment + res + replacment;\n      return res;\n    }\n  });\n}\n\nfunction defaultComparator(a, b) {\n  if (a === b) {\n    if (a !== 0) return 0;\n    a = 1 / a, b = 1 / b;\n  } else {\n    var nanA = a != a, nanB = b != b;\n    if (nanA | nanB) return nanA - nanB;\n    if (a == null) a = String(a);\n    if (b == null) b = String(b);\n  }\n  return a > b ? 1 : -1;\n}\n\nconst arraySort = Array.prototype.sort;\nArray.prototype.sort = function sort(comparator) {\n  return arraySort.call(this, comparator || defaultComparator);\n};\n\nglobalScope[\"isInteger\"] = Number.isInteger;\n\nglobalScope[\"isFloat\"] = function isFloat(arg) {\n  return typeof arg === \"number\";\n};\n\nglobalScope[\"isNullable\"] = function isNullable(arg) {\n  return true;\n};\n\nglobalScope[\"isReference\"] = function isReference(arg) {\n  return typeof arg === \"object\" || typeof arg === \"string\";\n};\n\nglobalScope[\"isFunction\"] = function isFunction(arg) {\n  return typeof arg === \"function\";\n};\n\nglobalScope[\"isString\"] = function isString(arg) {\n  return typeof arg === \"string\" || arg instanceof String;\n};\n\nglobalScope[\"isArray\"] = Array.isArray;\nglobalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n  return expr\n    && typeof expr === 'object'\n    && typeof expr.length === 'number'\n    && expr.length >= 0\n    && Math.trunc(expr.length) === expr.length;\n};\n\nglobalScope[\"isDefined\"] = function isDefined(expr) {\n  return typeof expr !== \"undefined\";\n};\n\nglobalScope[\"isConstant\"] = function isConstant(expr) {\n  return false;\n};\n\nglobalScope[\"unchecked\"] = function unchecked(expr) {\n  return expr;\n};\n\nglobalScope[\"fmod\"] = function fmod(x, y) {\n  return x % y;\n};\n\nglobalScope[\"fmodf\"] = function fmodf(x, y) {\n  return Math.fround(x % y);\n};\n\nglobalScope[\"JSMath\"] = Math;\n\nObject.defineProperties(globalScope[\"JSMath\"], {\n  sincos_sin: { value: 0.0, writable: true },\n  sincos_cos: { value: 0.0, writable: true },\n  signbit: {\n    value: function signbit(x) {\n      F64[0] = x; return Boolean(U64[1] >>> 31);\n    }\n  },\n  sincos: {\n    value: function sincos(x) {\n      this.sincos_sin = Math.sin(x);\n      this.sincos_cos = Math.cos(x);\n    }\n  },\n  exp2: {\n    value: function exp2(x) {\n      return Math.pow(2, x);\n    }\n  }\n});\n\nglobalScope[\"unmanaged\"] = function() { /* nop */ };\n\nglobalScope[\"trace\"] = function(message, n) {\n  if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n  console.error(\"trace: \" + message);\n};\n\nObject.defineProperty(Int8Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Int8Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint8Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint8Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint8ClampedArray, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint8ClampedArray(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Int16Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Int16Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint16Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint16Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Int32Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Int32Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint32Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint32Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Float32Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Float32Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Float64Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Float64Array(buffer, byteOffset, length);\n  }\n});\n","module.exports = __WEBPACK_EXTERNAL_MODULE__911__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\n__webpack_require__(308);\nreturn __webpack_require__(780);\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();"],"sourceRoot":""}