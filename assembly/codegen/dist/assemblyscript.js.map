{"version":3,"sources":["webpack://assemblyscript/webpack/universalModuleDefinition","webpack://assemblyscript/./node_modules/long/src/long.js","webpack://assemblyscript/./src/ast.ts","webpack://assemblyscript/./src/builtins.ts","webpack://assemblyscript/./src/common.ts","webpack://assemblyscript/./src/compiler.ts","webpack://assemblyscript/./src/definitions.ts","webpack://assemblyscript/./src/diagnosticMessages.generated.ts","webpack://assemblyscript/./src/diagnostics.ts","webpack://assemblyscript/./src/ext/abi.ts","webpack://assemblyscript/./src/ext/astutil.ts","webpack://assemblyscript/./src/ext/collectionutil.ts","webpack://assemblyscript/./src/ext/generator.ts","webpack://assemblyscript/./src/ext/inserter.ts","webpack://assemblyscript/./src/ext/primitiveutil.ts","webpack://assemblyscript/./src/extra/ast.ts","webpack://assemblyscript/./src/flow.ts","webpack://assemblyscript/./src/glue/js/index.ts","webpack://assemblyscript/./src/index.ts","webpack://assemblyscript/./src/module.ts","webpack://assemblyscript/./src/parser.ts","webpack://assemblyscript/./src/program.ts","webpack://assemblyscript/./src/resolver.ts","webpack://assemblyscript/./src/tokenizer.ts","webpack://assemblyscript/./src/types.ts","webpack://assemblyscript/./src/util/binary.ts","webpack://assemblyscript/./src/util/collections.ts","webpack://assemblyscript/./src/util/index.ts","webpack://assemblyscript/./src/util/math.ts","webpack://assemblyscript/./src/util/path.ts","webpack://assemblyscript/./src/util/text.ts","webpack://assemblyscript/./src/util/vector.ts","webpack://assemblyscript/./std/assembly/shared/feature.ts","webpack://assemblyscript/./std/assembly/shared/target.ts","webpack://assemblyscript/./std/assembly/shared/typeinfo.ts","webpack://assemblyscript/./src/glue/binaryen.js","webpack://assemblyscript/./src/glue/js/collections.js","webpack://assemblyscript/./src/glue/js/float.js","webpack://assemblyscript/./src/glue/js/i64.js","webpack://assemblyscript/./std/portable/index.js","webpack://assemblyscript/external \"binaryen\"","webpack://assemblyscript/webpack/bootstrap","webpack://assemblyscript/webpack/startup","webpack://assemblyscript/webpack/runtime/global"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__911__","Long","wasm","WebAssembly","Instance","Module","Uint8Array","e","low","high","unsigned","isLong","obj","prototype","__isLong__","Object","defineProperty","value","INT_CACHE","UINT_CACHE","fromInt","cachedObj","cache","fromBits","fromNumber","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","pow_dbl","Math","pow","fromString","str","radix","length","Error","RangeError","p","indexOf","substring","radixToPower","result","i","size","min","parseInt","power","mul","add","fromValue","val","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","toNumber","toString","isZero","isNegative","eq","radixLong","div","rem1","sub","rem","remDiv","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","equals","other","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","lte","le","greaterThan","gt","greaterThanOrEqual","gte","ge","compare","thisNeg","otherNeg","negate","not","addend","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","get_high","b00","divide","divisor","approx","res","div_u","div_s","toUnsigned","shru","shr","shl","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","rem_u","rem_s","mod","and","or","xor","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","toSigned","toBytes","toBytesLE","toBytesBE","hi","lo","fromBytes","bytes","fromBytesLE","fromBytesBE","NodeKind","DecoratorKind","LiteralKind","SourceKind","Node","kind","range","name","TypeName","createIdentifierExpression","typeArguments","isNullable","NamedTypeNode","parameters","returnType","explicitThisType","FunctionTypeNode","createSimpleTypeName","extendsType","defaultType","TypeParameterNode","parameterKind","type","initializer","ParameterNode","args","DecoratorNode","fromNode","commentKind","text","CommentNode","isQuoted","IdentifierExpression","elementExpressions","ArrayLiteralExpression","assertionKind","expression","toType","AssertionExpression","operator","left","right","BinaryExpression","CallExpression","declaration","ClassExpression","expressions","CommaExpression","ConstructorExpression","elementExpression","ElementAccessExpression","FalseExpression","FloatLiteralExpression","FunctionExpression","isType","InstanceOfExpression","IntegerLiteralExpression","typeName","NewExpression","NullExpression","names","values","ObjectLiteralExpression","OmittedExpression","ParenthesizedExpression","property","PropertyAccessExpression","pattern","patternFlags","RegexpLiteralExpression","condition","ifThen","ifElse","TernaryExpression","StringLiteralExpression","SuperExpression","ThisExpression","TrueExpression","operand","UnaryPostfixExpression","UnaryPrefixExpression","statements","BlockStatement","label","BreakStatement","decorators","flags","typeParameters","implementsTypes","members","ClassDeclaration","ContinueStatement","statement","DoStatement","EmptyStatement","EnumDeclaration","EnumValueDeclaration","path","isDeclare","ExportStatement","ExportDefaultStatement","externalName","ExportImportStatement","localName","exportedName","ExportMember","ExpressionStatement","ifTrue","ifFalse","IfStatement","declarations","ImportStatement","namespaceName","foreignName","ImportDeclaration","InterfaceDeclaration","FieldDeclaration","incrementor","ForStatement","variable","iterable","ForOfStatement","signature","body","arrowKind","FunctionDeclaration","keyType","valueType","IndexSignatureNode","MethodDeclaration","NamespaceDeclaration","ReturnStatement","cases","SwitchStatement","SwitchCase","ThrowStatement","catchVariable","catchStatements","finallyStatements","TryStatement","TypeDeclaration","VariableStatement","VariableDeclaration","VoidStatement","WhileStatement","literalKind","LITERAL","changetype","FLOAT","INTEGER","STRING","NULL","TRUE","FALSE","node","CALL","PROPERTYACCESS","isAccessOn","THIS","SUPER","TypeNode","super","typeParameterNodes","NAMEDTYPE","namedTypeNode","next","typeArgumentNodes","k","hasGenericComponent","identifier","FUNCTIONTYPE","functionTypeNode","parameterNodes","assert","TYPENAME","TYPEPARAMETER","ParameterKind","PARAMETER","implicitFieldDeclaration","CommonFlags","NONE","flag","nameNode","IDENTIFIER","nameStr","charCodeAt","BUILTIN","CONTRACT","DEPLOYER","EXTERNAL","FINAL","GLOBAL","INLINE","LAZY","MESSAGE","OPERATOR","STORAGE","UNMANAGED","UNSAFE","propertyAccessNode","propStr","OPERATOR_BINARY","OPERATOR_PREFIX","OPERATOR_POSTFIX","CUSTOM","decoratorKind","DECORATOR","CommentKind","COMMENT","Expression","LiteralExpression","ARRAY","AssertionKind","ASSERTION","BINARY","numTypeArguments","Range","join","numArguments","CLASS","COMMA","CONSTRUCTOR","ELEMENTACCESS","FUNCTION","INSTANCEOF","NEW","OBJECT","OMITTED","PARENTHESIZED","REGEXP","TERNARY","UnaryExpression","UNARYPOSTFIX","UNARYPREFIX","Statement","sourceKind","normalizedPath","SOURCE","Array","debugInfoIndex","exportPaths","lineCache","lineColumn","internalPath","mangleInternalPath","pos","lastIndexOf","PATH_DELIMITER","simplePath","source","LIBRARY_SUBST","LIBRARY","LIBRARY_ENTRY","off","end","push","l","r","m","s","unchecked","DeclarationStatement","INDEXSIGNATURE","VariableLikeDeclarationStatement","BLOCK","BREAK","CLASSDECLARATION","indexSignature","CONTINUE","DO","EMPTY","ENUMDECLARATION","ENUMVALUEDECLARATION","EXPORTIMPORT","EXPORTMEMBER","EXPORT","normalizePath","startsWith","resolvePath","LIBRARY_PREFIX","EXPORTDEFAULT","EXPRESSION","parameterIndex","FIELDDECLARATION","FOR","FOROF","ArrowKind","FUNCTIONDECLARATION","IF","IMPORTDECLARATION","IMPORT","INTERFACEDECLARATION","METHODDECLARATION","NAMESPACEDECLARATION","RETURN","SWITCHCASE","SWITCH","THROW","TRY","TYPEDECLARATION","VARIABLEDECLARATION","VARIABLE","VOID","WHILE","len","cur","isTrivialAlphanum","decorator","BuiltinNames","start","started","argumentsLength","setArgumentsLength","abort","trace","seed","isInteger","isFloat","isBoolean","isSigned","isReference","isString","isArray","isArrayLike","isFunction","isDefined","isConstant","isManaged","isVoid","clz","ctz","popcnt","rotl","rotr","abs","copysign","nearest","reinterpret","sqrt","trunc","load","store","atomic_load","atomic_store","atomic_add","atomic_sub","atomic_and","atomic_or","atomic_xor","atomic_xchg","atomic_cmpxchg","atomic_wait","atomic_notify","atomic_fence","sizeof","alignof","offsetof","nameof","lengthof","select","unreachable","call_indirect","instantiate","idof","i8","i16","i32","i64","isize","u8","u16","u32","u64","usize","bool","f32","f64","v128","i32_clz","i64_clz","i32_ctz","i64_ctz","i32_popcnt","i64_popcnt","i32_rotl","i64_rotl","i32_rotr","i64_rotr","f32_abs","f64_abs","f32_max","f64_max","f32_min","f64_min","f32_ceil","f64_ceil","f32_floor","f64_floor","f32_copysign","f64_copysign","f32_nearest","f64_nearest","i32_reinterpret_f32","i64_reinterpret_f64","f32_reinterpret_i32","f64_reinterpret_i64","f32_sqrt","f64_sqrt","f32_trunc","f64_trunc","i32_add","i64_add","f32_add","f64_add","i32_sub","i64_sub","f32_sub","f64_sub","i32_mul","i64_mul","f32_mul","f64_mul","i32_div_s","i32_div_u","i64_div_s","i64_div_u","f32_div","f64_div","i32_load8_s","i32_load8_u","i32_load16_s","i32_load16_u","i32_load","i64_load8_s","i64_load8_u","i64_load16_s","i64_load16_u","i64_load32_s","i64_load32_u","i64_load","f32_load","f64_load","i32_store8","i32_store16","i32_store","i64_store8","i64_store16","i64_store32","i64_store","f32_store","f64_store","i32_atomic_load8_u","i32_atomic_load16_u","i32_atomic_load","i64_atomic_load8_u","i64_atomic_load16_u","i64_atomic_load32_u","i64_atomic_load","i32_atomic_store8","i32_atomic_store16","i32_atomic_store","i64_atomic_store8","i64_atomic_store16","i64_atomic_store32","i64_atomic_store","i32_atomic_rmw8_add_u","i32_atomic_rmw16_add_u","i32_atomic_rmw_add","i64_atomic_rmw8_add_u","i64_atomic_rmw16_add_u","i64_atomic_rmw32_add_u","i64_atomic_rmw_add","i32_atomic_rmw8_sub_u","i32_atomic_rmw16_sub_u","i32_atomic_rmw_sub","i64_atomic_rmw8_sub_u","i64_atomic_rmw16_sub_u","i64_atomic_rmw32_sub_u","i64_atomic_rmw_sub","i32_atomic_rmw8_and_u","i32_atomic_rmw16_and_u","i32_atomic_rmw_and","i64_atomic_rmw8_and_u","i64_atomic_rmw16_and_u","i64_atomic_rmw32_and_u","i64_atomic_rmw_and","i32_atomic_rmw8_or_u","i32_atomic_rmw16_or_u","i32_atomic_rmw_or","i64_atomic_rmw8_or_u","i64_atomic_rmw16_or_u","i64_atomic_rmw32_or_u","i64_atomic_rmw_or","i32_atomic_rmw8_xor_u","i32_atomic_rmw16_xor_u","i32_atomic_rmw_xor","i64_atomic_rmw8_xor_u","i64_atomic_rmw16_xor_u","i64_atomic_rmw32_xor_u","i64_atomic_rmw_xor","i32_atomic_rmw8_xchg_u","i32_atomic_rmw16_xchg_u","i32_atomic_rmw_xchg","i64_atomic_rmw8_xchg_u","i64_atomic_rmw16_xchg_u","i64_atomic_rmw32_xchg_u","i64_atomic_rmw_xchg","i32_atomic_rmw8_cmpxchg_u","i32_atomic_rmw16_cmpxchg_u","i32_atomic_rmw_cmpxchg","i64_atomic_rmw8_cmpxchg_u","i64_atomic_rmw16_cmpxchg_u","i64_atomic_rmw32_cmpxchg_u","i64_atomic_rmw_cmpxchg","i32_wait","i64_wait","v128_splat","v128_extract_lane","v128_replace_lane","v128_shuffle","v128_swizzle","v128_load_splat","v128_load_ext","v128_load","v128_store","v128_add","v128_sub","v128_mul","v128_div","v128_neg","v128_add_saturate","v128_sub_saturate","v128_shl","v128_shr","v128_and","v128_or","v128_xor","v128_andnot","v128_not","v128_bitselect","v128_any_true","v128_all_true","v128_bitmask","v128_min","v128_max","v128_pmin","v128_pmax","v128_dot","v128_avgr","v128_abs","v128_sqrt","v128_ceil","v128_floor","v128_trunc","v128_nearest","v128_eq","v128_ne","v128_lt","v128_le","v128_gt","v128_ge","v128_convert","v128_trunc_sat","v128_narrow","v128_widen_low","v128_widen_high","v128_qfma","v128_qfms","i8x16","i16x8","i32x4","i64x2","f32x4","f64x2","i8x16_splat","i8x16_extract_lane_s","i8x16_extract_lane_u","i8x16_replace_lane","i8x16_add","i8x16_sub","i8x16_mul","i8x16_min_s","i8x16_min_u","i8x16_max_s","i8x16_max_u","i8x16_avgr_u","i8x16_abs","i8x16_neg","i8x16_add_saturate_s","i8x16_add_saturate_u","i8x16_sub_saturate_s","i8x16_sub_saturate_u","i8x16_shl","i8x16_shr_s","i8x16_shr_u","i8x16_any_true","i8x16_all_true","i8x16_bitmask","i8x16_eq","i8x16_ne","i8x16_lt_s","i8x16_lt_u","i8x16_le_s","i8x16_le_u","i8x16_gt_s","i8x16_gt_u","i8x16_ge_s","i8x16_ge_u","i8x16_narrow_i16x8_s","i8x16_narrow_i16x8_u","i16x8_splat","i16x8_extract_lane_s","i16x8_extract_lane_u","i16x8_replace_lane","i16x8_add","i16x8_sub","i16x8_mul","i16x8_min_s","i16x8_min_u","i16x8_max_s","i16x8_max_u","i16x8_avgr_u","i16x8_abs","i16x8_neg","i16x8_add_saturate_s","i16x8_add_saturate_u","i16x8_sub_saturate_s","i16x8_sub_saturate_u","i16x8_shl","i16x8_shr_s","i16x8_shr_u","i16x8_any_true","i16x8_all_true","i16x8_bitmask","i16x8_eq","i16x8_ne","i16x8_lt_s","i16x8_lt_u","i16x8_le_s","i16x8_le_u","i16x8_gt_s","i16x8_gt_u","i16x8_ge_s","i16x8_ge_u","i16x8_narrow_i32x4_s","i16x8_narrow_i32x4_u","i16x8_widen_low_i8x16_s","i16x8_widen_low_i8x16_u","i16x8_widen_high_i8x16_s","i16x8_widen_high_i8x16_u","i16x8_load8x8_s","i16x8_load8x8_u","i32x4_splat","i32x4_extract_lane","i32x4_replace_lane","i32x4_add","i32x4_sub","i32x4_mul","i32x4_min_s","i32x4_min_u","i32x4_max_s","i32x4_max_u","i32x4_dot_i16x8_s","i32x4_abs","i32x4_neg","i32x4_shl","i32x4_shr_s","i32x4_shr_u","i32x4_any_true","i32x4_all_true","i32x4_bitmask","i32x4_eq","i32x4_ne","i32x4_lt_s","i32x4_lt_u","i32x4_le_s","i32x4_le_u","i32x4_gt_s","i32x4_gt_u","i32x4_ge_s","i32x4_ge_u","i32x4_trunc_sat_f32x4_s","i32x4_trunc_sat_f32x4_u","i32x4_widen_low_i16x8_s","i32x4_widen_low_i16x8_u","i32x4_widen_high_i16x8_s","i32x4_widen_high_i16x8_u","i32x4_load16x4_s","i32x4_load16x4_u","i64x2_splat","i64x2_extract_lane","i64x2_replace_lane","i64x2_add","i64x2_sub","i64x2_neg","i64x2_shl","i64x2_shr_s","i64x2_shr_u","i64x2_any_true","i64x2_all_true","i64x2_trunc_sat_f64x2_s","i64x2_trunc_sat_f64x2_u","i64x2_load32x2_s","i64x2_load32x2_u","f32x4_splat","f32x4_extract_lane","f32x4_replace_lane","f32x4_add","f32x4_sub","f32x4_mul","f32x4_div","f32x4_neg","f32x4_min","f32x4_max","f32x4_pmin","f32x4_pmax","f32x4_abs","f32x4_sqrt","f32x4_ceil","f32x4_floor","f32x4_trunc","f32x4_nearest","f32x4_eq","f32x4_ne","f32x4_lt","f32x4_le","f32x4_gt","f32x4_ge","f32x4_convert_i32x4_s","f32x4_convert_i32x4_u","f32x4_qfma","f32x4_qfms","f64x2_splat","f64x2_extract_lane","f64x2_replace_lane","f64x2_add","f64x2_sub","f64x2_mul","f64x2_div","f64x2_neg","f64x2_min","f64x2_max","f64x2_pmin","f64x2_pmax","f64x2_abs","f64x2_sqrt","f64x2_ceil","f64x2_floor","f64x2_trunc","f64x2_nearest","f64x2_eq","f64x2_ne","f64x2_lt","f64x2_le","f64x2_gt","f64x2_ge","f64x2_convert_i64x2_s","f64x2_convert_i64x2_u","f64x2_qfma","f64x2_qfms","v8x16_shuffle","v8x16_swizzle","v8x16_load_splat","v16x8_load_splat","v32x4_load_splat","v64x2_load_splat","heap_base","rtti_base","visit_globals","visit_members","isFinite","ERROR","WARNING","INFO","Function","memory_size","memory_grow","memory_copy","memory_fill","memory_data","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Int64Array","Uint64Array","Float32Array","Float64Array","wasiAbort","wasiTrace","wasiSeed","builtin_clz","ctx","compiler","checkTypeOptional","checkArgsRequired","arg0","compileExpression","operands","Type","currentType","isValue","unary","UnaryOp","ClzI32","options","isWasm64","ClzI64","error","DiagnosticCode","Operation_0_cannot_be_applied_to_type_1","reportNode","typeArgumentsRange","builtin_ctz","CtzI32","CtzI64","builtin_popcnt","PopcntI32","PopcntI64","builtin_rotl","arg1","flow","currentFlow","temp1","getTempLocal","findUsedLocals","setLocalFlag","index","LocalFlags","WRAPPED","temp2","ret","binary","BinaryOp","OrI32","ShlI32","local_tee","AndI32","ShrU32","local_get","NativeType","I32","SubI32","freeTempLocal","RotlI32","RotlI64","builtin_rotr","RotrI32","RotrI64","builtin_abs","auto","XorI32","AddI32","ShrI32","usizeType","XorI64","AddI64","ShrI64","nativeSizeType","I64","AbsF32","AbsF64","builtin_max","isNumericLiteral","op","GtI32","GtU32","GtI64","GtU64","MaxF32","MaxF64","nativeType","toNativeType","builtin_min","LtI32","LtU32","LtI64","LtU64","MinF32","MinF64","builtin_ceil","CeilF32","CeilF64","builtin_floor","FloorF32","FloorF64","builtin_copysign","CopysignF32","CopysignF64","builtin_nearest","NearestF32","NearestF64","builtin_reinterpret","checkTypeRequired","ReinterpretF32","ReinterpretF64","ReinterpretI32","ReinterpretI64","builtin_sqrt","SqrtF32","SqrtF64","builtin_trunc","TruncF32","TruncF64","builtin_load","checkArgsOptional","contextualType","outType","isIntegerValue","numOperands","immOffset","immAlign","byteSize","evaluateImmediateOffset","evaluateImmediateAlign","isSignedIntegerValue","builtin_store","void","contextIsExact","inType","convertExpression","builtin_add","isNumericValue","makeAdd","builtin_sub","makeSub","builtin_mul","makeMul","builtin_div","makeDiv","builtin_atomic_load","checkFeatureEnabled","builtin_atomic_store","builtin_atomic_binary","opName","atomic_rmw","builtin_atomic_add","AtomicRMWOp","Add","builtin_atomic_sub","Sub","builtin_atomic_and","And","builtin_atomic_or","Or","builtin_atomic_xor","Xor","builtin_atomic_xchg","Xchg","builtin_atomic_cmpxchg","arg2","builtin_atomic_wait","builtin_diagnostic","category","checkTypeAbsent","emitDiagnostic","User_defined_0","DiagnosticCategory","nop","builtin_conversion","builtin_i8x16","expr","precomp","runExpression","ExpressionRunnerFlags","PreserveSideeffects","writeI8","getConstValueI32","Expression_must_be_a_compile_time_constant","builtin_v128_splat","SplatI8x16","SplatI16x8","SplatI32x4","SplatI64x2","SplatF32x4","SplatF64x2","builtin_v128_extract_lane","idx","maxIdx","_0_must_be_a_value_between_1_and_2_inclusive","simd_extract","SIMDExtractOp","ExtractLaneI8x16","ExtractLaneU8x16","ExtractLaneI16x8","ExtractLaneU16x8","ExtractLaneI32x4","ExtractLaneI64x2","ExtractLaneF32x4","ExtractLaneF64x2","builtin_v128_replace_lane","simd_replace","SIMDReplaceOp","ReplaceLaneI8x16","ReplaceLaneI16x8","ReplaceLaneI32x4","ReplaceLaneI64x2","ReplaceLaneF32x4","ReplaceLaneF64x2","builtin_v128_shuffle","laneWidth","laneCount","isPowerOf2","mask","argN","off8","idx8","simd_shuffle","builtin_v128_swizzle","SwizzleV8x16","builtin_v128_load_splat","simd_load","SIMDLoadOp","LoadSplatV8x16","LoadSplatV16x8","LoadSplatV32x4","LoadSplatV64x2","builtin_v128_load_ext","LoadI8ToI16x8","LoadU8ToU16x8","LoadI16ToI32x4","LoadU16ToU32x4","LoadI32ToI64x2","LoadU32ToU64x2","builtin_v128_add","AddI8x16","AddI16x8","AddI32x4","AddI64x2","AddF32x4","AddF64x2","builtin_v128_sub","SubI8x16","SubI16x8","SubI32x4","SubI64x2","SubF32x4","SubF64x2","builtin_v128_mul","MulI8x16","MulI16x8","MulI32x4","MulF32x4","MulF64x2","builtin_v128_div","DivF32x4","DivF64x2","builtin_v128_add_saturate","AddSatI8x16","AddSatU8x16","AddSatI16x8","AddSatU16x8","builtin_v128_sub_saturate","SubSatI8x16","SubSatU8x16","SubSatI16x8","SubSatU16x8","builtin_v128_min","MinI8x16","MinU8x16","MinI16x8","MinU16x8","MinI32x4","MinU32x4","MinF32x4","MinF64x2","builtin_v128_max","MaxI8x16","MaxU8x16","MaxI16x8","MaxU16x8","MaxI32x4","MaxU32x4","MaxF32x4","MaxF64x2","builtin_v128_pmin","PminF32x4","PminF64x2","builtin_v128_pmax","PmaxF32x4","PmaxF64x2","builtin_v128_dot","DotI16x8","builtin_v128_avgr","AvgrU8x16","AvgrU16x8","builtin_v128_eq","EqI8x16","EqI16x8","EqI32x4","EqF32x4","EqF64x2","builtin_v128_ne","NeI8x16","NeI16x8","NeI32x4","NeF32x4","NeF64x2","builtin_v128_lt","LtI8x16","LtU8x16","LtI16x8","LtU16x8","LtI32x4","LtU32x4","LtF32x4","LtF64x2","builtin_v128_le","LeI8x16","LeU8x16","LeI16x8","LeU16x8","LeI32x4","LeU32x4","LeF32x4","LeF64x2","builtin_v128_gt","GtI8x16","GtU8x16","GtI16x8","GtU16x8","GtI32x4","GtU32x4","GtF32x4","GtF64x2","builtin_v128_ge","GeI8x16","GeU8x16","GeI16x8","GeU16x8","GeI32x4","GeU32x4","GeF32x4","GeF64x2","builtin_v128_narrow","NarrowI16x8ToI8x16","NarrowU16x8ToU8x16","NarrowI32x4ToI16x8","NarrowU32x4ToU16x8","builtin_v128_neg","NegI8x16","NegI16x8","NegI32x4","NegI64x2","NegF32x4","NegF64x2","builtin_v128_abs","AbsI8x16","AbsI16x8","AbsI32x4","AbsF32x4","AbsF64x2","builtin_v128_sqrt","SqrtF32x4","SqrtF64x2","builtin_v128_ceil","CeilF32x4","CeilF64x2","builtin_v128_floor","FloorF32x4","FloorF64x2","builtin_v128_trunc","TruncF32x4","TruncF64x2","builtin_v128_nearest","NearestF32x4","NearestF64x2","builtin_v128_convert","ConvertI32x4ToF32x4","ConvertU32x4ToF32x4","ConvertI64x2ToF64x2","ConvertU64x2ToF64x2","builtin_v128_trunc_sat","TruncSatF32x4ToI32x4","TruncSatF32x4ToU32x4","TruncSatF64x2ToI64x2","TruncSatF64x2ToU64x2","builtin_v128_widen_low","WidenLowI8x16ToI16x8","WidenLowU8x16ToU16x8","WidenLowI16x8ToI32x4","WidenLowU16x8ToU32x4","builtin_v128_widen_high","WidenHighI8x16ToI16x8","WidenHighU8x16ToU16x8","WidenHighI16x8ToI32x4","WidenHighU16x8ToU32x4","builtin_v128_shl","simd_shift","SIMDShiftOp","ShlI8x16","ShlI16x8","ShlI32x4","ShlI64x2","builtin_v128_shr","ShrI8x16","ShrU8x16","ShrI16x8","ShrU16x8","ShrI32x4","ShrU32x4","ShrI64x2","ShrU64x2","builtin_v128_bitwise_binary","builtin_v128_any_true","AnyTrueI8x16","AnyTrueI16x8","AnyTrueI32x4","AnyTrueI64x2","builtin_v128_all_true","AllTrueI8x16","AllTrueI16x8","AllTrueI32x4","AllTrueI64x2","builtin_v128_bitmask","BitmaskI8x16","BitmaskI16x8","BitmaskI32x4","builtin_v128_qfma","simd_ternary","SIMDTernaryOp","QFMAF32x4","QFMAF64x2","builtin_v128_qfms","QFMSF32x4","QFMSF64x2","ensureVisitMembersOf","instance","visitRef","program","nativeSizeSize","visitInstance","base","call","internalName","None","hasVisitImpl","isDeclaredInLibrary","visitPrototype","lookupInSelf","ElementKind","FUNCTION_PROTOTYPE","resolver","resolveFunction","compileFunction","visitSignature","visitThisType","thisType","parameterTypes","isStrictlyAssignableTo","needsTempValue","_values","Map_values","j","member","FIELD","parent","fieldOffset","memoryOffset","if","addFunction","createType","flatten","typeToRuntimeFlags","alignLog2","is","evaluateConstantType","Expected_0_type_arguments_but_got_1","Expected_0_arguments_but_got_1","argumentsRange","usize64","getConstValueI64High","getConstValueI64Low","usize32","naturalAlign","align","_0_must_be_a_power_of_two","feature","hasFeature","Feature_0_is_not_enabled","featureToString","setCurrentTypeOnError","Type_0_is_not_generic","expected","expectedMinimum","expectedMaximum","Expected_at_least_0_arguments_but_got_1","contextualUsize","i64_is_i32","i64_low","i64_is_u32","i64_high","thisOperand","builtins","Map","function_builtins","set","isFloatValue","isBooleanValue","classReference","getClass","isAssignableTo","stringInstance","extends","arrayPrototype","isNullableReference","element","lookupExpression","ReportMode","SWALLOW","getExpressionId","ExpressionId","Const","signatureReference","Type_0_has_no_call_signatures","i64_new","getClassOrWrapper","firstOperand","isLiteralKind","String_literal_expected","fieldName","classMembers","has","get","Type_0_has_no_property_1","nextMemoryOffset","resultType","isInternalReference","getSignature","ensureStaticString","id","hasDecorator","DecoratorFlags","maybeDropCondition","LocalGet","NeF32","getLocalGetIndex","F32","temp","NeF64","F64","EqF32","SubF32","EqF64","SubF64","isAny","makeIsTrueish","compileCallDirect","offset","elementType","valuesOperand","Array_literal_expected","numElements","exprs","isStatic","makeZero","buf","writeStaticBuffer","byteLength","addAlignedMemorySegment","fromType","isChangeableTo","Type_0_cannot_be_changed_to_type_1","nonNullableType","noAssert","evaled","Default","getExpressionType","getConstValueF32","getConstValueF64","makeAbort","EqzI32","EqzI64","ref_is_null","alreadyUnchecked","unset","indexArg","operandExprs","nativeParamTypes","classInstance","This_expression_is_not_constructable","ctor","ensureConstructor","checkFieldInitialization","compileInstantiate","functionPrototype","ftype","requiredParameters","shift","thisArg","_this_cannot_be_referenced_in_current_location","compileCallIndirect","isizeType","writeI16","writeI32","writeF32","writeF64","AndV128","OrV128","XorV128","AndNotV128","builtin_v128_bitwise_unary","NotV128","builtin_v128_bitwise_ternary","Bitselect","runtimeFeatures","elementsByName","global","COMPILED","INLINED","constantIntegerValue","global_get","block","managedClasses","nextId","_keys","Map_keys","instanceId","return","current","switch","SubI64","count","data","abvInstance","arrayBufferViewInstance","abvPrototype","setPrototype","mapPrototype","staticArrayPrototype","lastId","isAcyclic","getArrayValueType","getTypeArgumentsTo","rttiFlags","segment","addGlobal","instanceofInstance","stmts","instances","PARENT_SUBST","GETTER_PREFIX","SETTER_PREFIX","INSTANCE_DELIMITER","STATIC_DELIMITER","INNER_DELIMITER","INDEX_SUFFIX","STUB_DELIMITER","CommonNames","funcref","externref","exnref","anyref","u8x16","u16x8","u32x4","u64x2","void_","number","boolean","string","native","indexof","valueof","returnof","null_","true_","false_","this_","super_","constructor","ASC_TARGET","ASC_NO_TREESHAKING","ASC_NO_ASSERT","ASC_MEMORY_BASE","ASC_TABLE_BASE","ASC_OPTIMIZE_LEVEL","ASC_SHRINK_LEVEL","ASC_LOW_MEMORY_LIMIT","ASC_WASI","ASC_FEATURE_SIGN_EXTENSION","ASC_FEATURE_MUTABLE_GLOBALS","ASC_FEATURE_NONTRAPPING_F2I","ASC_FEATURE_BULK_MEMORY","ASC_FEATURE_SIMD","ASC_FEATURE_THREADS","ASC_FEATURE_EXCEPTION_HANDLING","ASC_FEATURE_TAIL_CALLS","ASC_FEATURE_REFERENCE_TYPES","ASC_FEATURE_MULTI_VALUE","ASC_FEATURE_GC","ASC_FEATURE_MEMORY64","I8","I16","Isize","U8","U16","U32","U64","Usize","Bool","V128","Funcref","Externref","Exnref","Anyref","String","StaticArray","Set","ArrayBufferView","ArrayBuffer","Mathf","NativeMath","NativeMathf","ipow32","ipow64","alloc","realloc","free","new_","renew","retain","release","collect","typeinfo","instanceof_","visit","newBuffer","newArray","Feature","Target","Typeinfo","TypeinfoFlags","ExportNames","mangleImportName_moduleName","mangleImportName_elementName","target","WASM32","exportMemory","importMemory","initialMemory","maximumMemory","sharedMemory","importTable","exportTable","sourceMap","explicitStart","memoryBase","tableBase","globalAliases","features","noUnsafe","pedantic","lowMemoryLimit","optimizeLevelHint","shrinkLevelHint","WASM64","isize64","isize32","Constraints","RuntimeFeatures","memory","table","Compiler","DiagnosticEmitter","diagnostics","currentParent","memorySegments","stringSegments","functionTable","builtinArgumentsLength","skippedAutoreleases","inlineStack","lazyFunctions","pendingClassInstanceOf","virtualCalls","pendingElements","doneModuleExports","f32ModInstance","f64ModInstance","f32PowInstance","f64PowInstance","i32PowInstance","i64PowInstance","create","setLowMemoryUnused","featureFlags","FeatureFlags","SignExt","MutableGloabls","NontrappingFPToInt","BulkMemory","SIMD128","Atomics","ExceptionHandling","TailCall","ReferenceTypes","MultiValue","GC","Memory64","setFeatures","startFunctionInstance","makeNativeFunction","Signature","currentBody","compile","initialize","actualFunction","startFunctionBody","files","filesByName","file","USER_ENTRY","compileFile","compileExports","startIsEmpty","isWasi","unshift","global_set","funcRef","nativeParams","nativeResults","typesToNativeTypes","additionalLocals","finalize","addFunctionExport","setStart","cyclicClasses","findCyclicClasses","Set_values","Type_0_is_cyclic_Module_will_include_deferred_garbage_collection","identifierNode","registerConstantInteger","functionsToCompile","clear","compileClassInstanceOf","VIRTUAL","INSTANCE","ensureVirtualStub","finalizeVirtualStub","ensureVarargsStub","delete","removeGlobal","compileRTTI","compileVisitGlobals","compileVisitMembers","i64_align","lowMemoryLimit32","i64_gt","Low_memory_limit_exceeded_by_static_data_0_1","i64_to_string","initialPages","i64_shr_u","Module_requires_at_least_0_pages_of_initial_memory","maximumPages","UNLIMITED_MEMORY","Module_requires_at_least_0_pages_of_maximum_memory","isSharedMemory","Shared_memory_requires_maximum_memory_to_be_defined","Shared_memory_requires_feature_threads_to_be_enabled","setMemory","addMemoryImport","functionTableNames","setFunctionTable","UNLIMITED_TABLE","addTableImport","willOptimize","Importing_the_table_disables_some_indirect_call_optimizations","addTableExport","Exporting_the_table_disables_some_indirect_call_optimizations","ensureModuleExports","elementName","ensureModuleExport","exportsStar","prefix","functionInstances","instanceName","GENERIC","fullName","warning","Exported_generic_function_or_class_has_no_concrete_instances","CLASS_PROTOTYPE","classPrototype","classInstances","PROPERTY_PROTOTYPE","propertyInstance","CONST","STATIC","READONLY","addGlobalExport","Cannot_export_a_mutable_global","ENUMVALUE","enumValue","isImmutable","functionInstance","ensureArgumentsLength","PROPERTY","getterInstance","setterInstance","fieldInstance","internalGetterName","internalSetterName","isUnmanaged","ENUM","NAMESPACE","TYPEDEFINITION","subPrefix","implicitExport","SCOPED","memberName","PRIVATE","compileMembers","compileGlobal","compileEnum","resolveClass","compileClass","resolveProperty","compileProperty","compileElement","exportStar","normalizedPathWithoutExtension","pathWithIndex","File_0_not_found","startFunction","startSignature","previousBody","previousFlow","compileTopLevelStatement","finishAutoreleases","locals","localsByIndex","numLocals","varTypes","ERRORED","initExpr","typeNode","initializerNode","RESOLVED","resolvedType","resolveType","Type_expected","setType","checkTypeSupported","atEnd","Type_0_is_not_assignable_to_type_1","AMBIENT","isDeclaredConstant","isDeclaredInline","MODULE_IMPORT","mangleImportName","addGlobalImport","initializeInStart","GlobalGet","fromName","getGlobalGetName","isGlobalMutable","getGlobal","Mutable_value_cannot_be_inlined","constantValueKind","constantFloatValue","compileInlineConstant","Decorator_0_is_not_valid_here","findDecorator","decoratorNodes","makeRetain","previousParent","previousValue","previousValueIsMut","isInline","initInStart","valueNode","In_const_enum_declarations_member_initializer_must_be_constant_expression","Enum_member_must_have_initializer","makeGlobalAssignment","setConstantIntegerValue","MODULE_EXPORT","forceStdAlternative","previousType","bodyNode","declarationNode","checkSignatureSupported","An_implementation_cannot_be_declared_in_ambient_contexts","RETAINED","local_set","compileFunctionBody","performAutoreleases","addFunctionImport","getFunction","ABSTRACT","INTERFACE","Function_implementation_is_missing_or_not_immediately_following_the_declaration","thisLocal","lookupLocal","compileStatements","GET","SET","compileReturnedExpression","indexBefore","canOverflow","nonNull","isNonnull","NONNULL","allocStmts","makeAllocation","makeFieldInitializationInConstructor","firstStmt","LocalSet","getLocalSetIndex","Explicitly_returning_constructor_drops_this_allocation","A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final","isAnyLocalFlag","ANY_RETAINED","unsetLocalFlag","Constructors_for_derived_classes_must_contain_a_super_call","A_function_whose_declared_type_is_not_void_must_return_a_value","staticMembers","instanceMembers","compileField","compileFieldGetter","compileFieldSetter","getterRef","nativeThisType","nativeValueType","valueExpr","setterRef","NeI64","NeI32","drop","makeRelease","compilePropertyGetter","compilePropertySetter","buffer","alignment","MemorySegment","usizeSize","stringValue","stringSegment","rtHeaderSize","runtimeHeaderSize","segments","createBuffer","addRuntimeMemorySegment","ptr","writeI64","arrayBufferInstance","OBJECTInstance","writeField","bufferSegment","arrayInstance","bufferLength","arrayLength","bufferAddress","STUB","memorySegment","rtInstance","memberStatements","getElementByDeclaration","exportStatement","compileFileByPath","importStatement","stmt","compileStatement","Nop","isLastInBody","compileBlockStatement","compileBreakStatement","compileContinueStatement","compileDoStatement","compileEmptyStatement","compileExpressionStatement","compileForStatement","compileForOfStatement","compileIfStatement","compileReturnStatement","compileSwitchStatement","compileThrowStatement","compileTryStatement","compileVariableStatement","compileVoidStatement","compileWhileStatement","Not_implemented_0","addDebugLocation","isBody","numStatements","Block","getBlockName","getBlockChildCount","getBlockChildAt","needsExplicitUnreachable","outerFlow","innerFlow","fork","freeScopedLocals","inherit","labelNode","breakLabel","A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement","br","continueLabel","A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement","doCompileDoStatement","flowAfter","pushBreakLabel","unifyLocalFlags","flowBefore","bodyFlow","bodyStmts","condFlow","condExpr","condKind","evaluateCondition","tcond","Flow","hasIncompatibleLocalStates","popBreakLabel","hasScopedLocals","loop","doCompileForStatement","loopLabel","loopStmts","inheritNonnullIfTrue","inheritBranch","ifStmts","incrFlow","thenStmts","thenFlow","elseStmts","elseFlow","inheritNonnullIfFalse","inheritMutual","valueExpression","constraints","inlineReturnLabel","numCases","context","tempLocal","tempLocalIndex","breaks","breakIndex","defaultIndex","EqI32","currentBlock","commonCategorical","commonConditional","isLast","nextLabel","terminates","message","newArgs","dropped","numDeclarations","initializers","initAutoreleaseSkipped","uniqueMap","contextualTypeArguments","dummy","addScopedDummyLocal","freeScopedDummyLocal","isConst","local","Local","parentFunction","setConstantFloatValue","scopedLocals","existing","errorRelated","Duplicate_identifier_0","_const_declarations_must_be_initialized","LET","existingLocal","getScopedLocal","isNative","addScopedLocal","CONSTANT","addLocal","isShortIntegerValue","CONDITIONALLY_RETAINED","doCompileWhileStatement","computeSmallIntegerShift","computeSmallIntegerMask","compileAssertionExpression","compileBinaryExpression","compileCallExpression","compileCommaExpression","compileElementAccessExpression","compileFunctionExpression","compileIdentifierExpression","compileInstanceOfExpression","compileLiteralExpression","compileNewExpression","compilePropertyAccessExpression","compileTernaryExpression","compileUnaryPostfixExpression","compileUnaryPrefixExpression","wrap","ensureSmallIntegerWrap","tryUndoAutorelease","explicit","makeRuntimeNonNullCheck","isExternalReference","makeRuntimeUpcastCheck","Conversion_from_type_0_to_1_requires_an_explicit_cast","PromoteF32","DemoteF64","isLongIntegerValue","TruncF32ToI64","TruncF32ToI32","TruncF32ToU64","TruncF32ToU32","TruncF64ToI64","TruncF64ToI32","TruncF64ToU64","TruncF64ToU32","ConvertI64ToF32","ConvertU64ToF32","ConvertI32ToF32","ConvertU32ToF32","ConvertI64ToF64","ConvertU64ToF64","ConvertI32ToF64","ConvertU32ToF64","WrapI64","ExtendI32","ExtendU32","isVaryingIntegerValue","Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit","inheritedConstraints","PREFIX","AS","exceptVoid","info","Expression_is_never_null","leftExpr","leftType","rightExpr","rightType","commonType","compound","Token","LESSTHAN","overload","lookupOverload","OperatorKind","LT","compileBinaryOverload","commonDenominator","Operator_0_cannot_be_applied_to_types_1_and_2","makeLt","GREATERTHAN","GT","makeGt","LESSTHAN_EQUALS","LE","makeLe","GREATERTHAN_EQUALS","GE","makeGe","EQUALS_EQUALS_EQUALS","EQUALS_EQUALS","EQ","operatorTokenToString","makeEq","EXCLAMATION_EQUALS_EQUALS","EXCLAMATION_EQUALS","NE","makeNe","EQUALS","compileAssignment","PLUS_EQUALS","PLUS","ADD","The_0_operator_cannot_be_applied_to_type_1","MINUS_EQUALS","MINUS","SUB","ASTERISK_EQUALS","ASTERISK","MUL","ASTERISK_ASTERISK_EQUALS","ASTERISK_ASTERISK","POW","makePow","SLASH_EQUALS","SLASH","DIV","PERCENT_EQUALS","PERCENT","REM","makeRem","LESSTHAN_LESSTHAN_EQUALS","LESSTHAN_LESSTHAN","intType","BITWISE_SHL","makeShl","GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN","BITWISE_SHR","makeShr","GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN_GREATERTHAN","BITWISE_SHR_U","makeShru","AMPERSAND_EQUALS","AMPERSAND","BITWISE_AND","makeAnd","BAR_EQUALS","BAR","BITWISE_OR","makeOr","CARET_EQUALS","CARET","BITWISE_XOR","makeXor","AMPERSAND_AMPERSAND","rightFlow","performAutoreleasesWithValue","leftAutoreleaseSkipped","rightAutoreleaseSkipped","retainLeftInElse","delayAutorelease","rightStmts","cloneExpression","BAR_BAR","retainLeftInThen","targetType","getTypeOfElement","makeAssignment","currentThisExpression","currentElementExpression","LtF32","LtF64","GtF32","GtF64","LeI32","LeI64","LeU32","LeU64","LeF32","LeF64","GeI32","GeI64","GeU32","GeU64","GeF32","GeF64","EqI64","AddF32","AddF64","MulI32","MulI64","MulF32","MulF64","lookupGlobal","Cannot_find_name_0","makeCallDirect","namespace","namespaceMembers","DivI32","DivI64","DivU32","DivU64","DivF32","DivF64","RemI32","RemI64","RemU32","RemU64","ShlI64","ShrU64","AndI64","OrI64","operatorInstance","thisExpression","LOCAL","Variable_0_used_before_its_declaration","checkUnsafe","propertyPrototype","Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property","isUnchecked","indexedSet","INDEXED_SET","INDEXED_GET","Index_signature_in_type_0_only_permits_reading","Index_signature_is_missing_in_type_0","Indexed_access_may_involve_bounds_checking","indexExpression","tee","isLocalFlag","makeLocalAssignment","isConstructor","setThisFieldFlag","FieldFlags","INITIALIZED","fieldParent","makeFieldAssignment","makeAutorelease","thisExpr","nativeReturnType","tempThis","elementExpr","tempTarget","tempElement","localIndex","alreadyRetained","makeReplace","field","fieldType","nativeFieldType","tempValue","Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors","baseClassInstance","baseCtorInstance","superCall","_super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class","compileCallExpressionBuiltin","maybeInferCall","Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures","Expression_cannot_be_represented_by_a_type","resolveTypeArguments","callee","BuiltinContext","fn","methodName","hasThis","The_this_types_of_each_signature_are_incompatible","hasRest","minimum","maximum","relatedReportNode","isLibrary","Operation_is_unsafe","argumentExpressions","checkCallSignature","isAccessOnThis","isAccessOnSuper","includes","makeCallInline","pop","Function_0_cannot_be_inlined_into_itself","numArgumentsInclThis","immediatelyDropped","numParameters","createInline","usedLocals","paramExpr","paramType","argumentLocal","getParameterName","addScopedAlias","initType","checkFieldInitializationInFlow","original","stub","varargsStub","originalSignature","originalParameterTypes","originalParameterDeclarations","isInstance","minArguments","minOperands","maxArguments","maxOperands","numOptional","forwardedOperands","operandIndex","newStub","numNames","ofN","Optional_parameter_must_have_an_initializer","theCall","virtualStub","ref","overloadPrototypes","overloads","tempIndex","builder","SwitchBuilder","unboundOverloadPrototype","isBound","unboundOverloadParent","isProperty","propertyParent","overloadInstance","boundProperty","boundPropertyInstance","boundPrototype","overloadType","originalType","overloadSignature","overloadParameterTypes","overloadNumParameters","paramExprs","n","needsVarargsStub","calledName","addCase","extendees","getAllExtendees","a","b","extendee","removeFunction","render","retainInstance","releaseInstance","newExpr","newType","oldExpr","oldType","getAutoreleaseLocal","isLocalTee","lengthBefore","maybeFinishAutorelease","skipAutorelease","Function_0_is_virtual_and_will_not_be_inlined","theOperands","slice","allOptionalsAreConstant","compilesToConst","resolved","lastOperand","getSideEffects","SideEffects","WritesGlobal","lastOperandType","makeCallIndirect","numExpressions","targetExpression","resolveExpression","indexedGet","contextualSignature","clone","FunctionPrototype","nextAnonymousId","signatureNode","numPresentParameters","parameterNode","isTypeOmitted","thisTypeNode","ensureRuntimeFunction","asNullable","Expression_resolves_to_unusual_type_0","_super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class","scopedThis","superType","_super_can_only_be_referenced_in_a_derived_class","maybeCompileEnclosingSource","lookupIdentifierExpression","localType","globalType","A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums","ref_func","namedType","hasTypeArguments","resolveTypeName","makeInstanceofClass","expectedType","makeInstanceofType","actualType","Expression_compiles_to_a_dynamic_check_at_runtime","implicitlyNegate","compileArrayLiteral","floatValue","intValue","determineIntegerLiteralType","i64_to_f32","i64_to_f64","compileStringLiteral","compileObjectLiteral","contextualClass","compileStaticArrayLiteral","arrayType","tempDataStart","nativeElementType","addStaticBuffer","arraySegment","addStaticArrayHeader","arrayAddress","newArrayInstance","nativeArrayType","dataStartMember","bufferSize","newBufferInstance","classType","Cannot_create_an_instance_of_an_abstract_class","ctorPrototype","constructorPrototype","Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal","hasErrors","nativeClassType","omittedFields","memberKey","Property_0_does_not_exist_on_type_1","Property_0_is_private_and_only_accessible_within_class_1","PROTECTED","Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses","Property_0_is_missing_in_type_1_but_required_in_type_2","resolveClassInclTypeArguments","constructorInstance","baseClass","baseCtor","makeNativeFunctionDeclaration","setResolvedInstance","allocExpr","relatedNode","didCheckFieldInitialization","isThisFieldFlag","DEFINITELY_ASSIGNED","Property_0_is_always_assigned_before_being_used","Unnecessary_definite_assignment","Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned","ctorInstance","ctxType","parentEnum","Property_0_is_used_before_being_assigned","Object_is_possibly_null","ifThenFlow","ifThenExpr","ifThenType","ifThenAutoreleaseSkipped","ifElseFlow","ifElseExpr","ifElseType","ifElseAutoreleaseSkipped","getValue","Unreachable","PLUS_PLUS","POSTFIX_INC","getLocalSetValue","compileUnaryOverload","makeOne","MINUS_MINUS","POSTFIX_DEC","setValue","NegF32","NegF64","PREFIX_INC","PREFIX_DEC","EXCLAMATION","NOT","TILDE","BITWISE_NOT","makeNegOne","TYPEOF","compileTypeof","typeString","REPORT","ExtendI8ToI32","ExtendI16ToI32","addDebugInfoFile","debugInfoRef","debugLocations","supported","parameterReportNode","v128_zero","ref_null","allocInstance","newInstance","thisLocalIndex","fieldPrototype","codeLocation","abortInstance","messageArg","makeStaticAbort","messageExpr","filenameExpr","lineAt","columnAt","mangleInternalName","arg","ExportsWalker","includePrivate","seen","visitFile","visitElement","visitGlobal","visitEnum","visitFunctionInstances","visitClassInstances","visitField","visitFunction","hasCompiledMember","visitNamespace","visitAlias","visitClass","IDLBuilder","sb","indentLevel","build","indent","typeToString","originalName","walk","TSDBuilder","remainingMembers","isInterface","extendsNode","code","diagnosticCategoryToString","PEDANTIC","diagnosticCategoryToColor","COLOR_MAGENTA","COLOR_BLUE","COLOR_YELLOW","COLOR_RED","diagnosticCodeToString","COLOR_RESET","DiagnosticMessage","relatedRange","replace","thisRange","otherRange","thisRelatedRange","otherRelatedRange","formatDiagnosticContext","useColors","isLineBreak","showContext","relatedSource","withRange","seenInSource","seenMessagesAtPos","StructDef","fields","paramters","hasReturnVal","ExportDef","clzName","deployers","messages","className","AbiAliasDef","newTypeName","wasmType","new_type_name","ActionDef","ability","ricardian_contract","AbiHelper","abiTypeLookup","TableDef","indexType","index_type","keys_names","keys_types","AbiDef","version","types","structs","actions","tables","AbiInfo","abiInfo","dispatch","typeAliasSet","structsLookup","elementLookup","exportIndent","Indent","exportDef","insertPointsLookup","resolve","typeNodeAnalyzer","asTypes","getAsTypes","asType","abiType","findSourceAbiType","findElement","getStructFromClzPrototype","clsProto","DATABASE","getExprValue","AbiUtils","checkDatabaseName","getStructFromNode","protoEle","Strings","isAroundQuotation","lookup","AstUtil","getInternalName","ele","struct","basePrototype","impledSerializable","addFieldsFromClassPrototype","fieldDeclare","memberType","haveSpecifyDecorator","TypeNodeAnalyzer","getAbiDeclareType","addField","addAbiTypeAlias","addToStruct","funcPrototype","decoratorNode","getSpecifyDecorator","location","isValidAbility","funcProto","funcName","parameter","typeInfo","getActionAbility","clzPrototype","serializePoints","SerializeInserter","getInsertPoints","InsertPoint","toSortedMap","key","isContractClassPrototype","exportGenerator","ExportGenerator","generateExportDef","isStoreClassPrototype","storeGenerator","StorageGenerator","joinIndents","getBody","declareType","isArrayType","bracketIndex","endIndex","impledInterface","classDeclaration","interfaceName","_type","funcType","tempClz","interfaces","implTypes","AbiTypeEnum","TypeNodeDesc","codecType","defaultVal","subTypes","isMapType","MAP","NUMBER","abiTypeEnum","getArgs","findSourceAsElement","findSourceAsTypeName","argType","Collections","isEmptyArray","asTypeName","sourceTypeName","aliasTypeName","arr","typeWrapperMap","deployDef","isDeployerFnPrototype","method","generateMethod","isActionFnPrototype","instaceName","deployMethod","ExportMethod","params","paramDesc","parameterType","defaultValMap","rtnNodeAnly","returnTypeDesc","wrapType","fieldIndents","methodIndents","resolveInstanceMembers","bodyIndent","FIELD_PROTOTYPE","resolveFieldPrototype","varName","getIndent","getField","setIndent","setFiled","getWrapperType","increase","decrease","insertCode","insertPoints","map","insertPoint","insertPointArr","_","sort","descComparator","console","line","SerializeGenerator","SERIALIZE_METHOD_NAME","DESERIALIZE_METHOD_NAME","PRIMARY_METHOD_NAME","needSerialize","needDeserialize","needPrimaryid","fnName","hasImpl","Verify","verify","serializePoint","SerializePoint","countOfPkDecorator","serialize","deserialize","fieldDeclaration","checkSerializable","addAll","serializeField","deserializeField","PRIMARYID","isPrimaryType","primaryKey","argAbiTypeEnum","getArrayArgAbiTypeEnum","argTypeName","getArrayArg","getDeclareType","getContent","serializeClassname","getSerializePoint","indentity","undefined","beginChar","aChar","DATABASE_CHARSETS","numBlanks","indentX1","indentX2","indentX4","padding","defaultBlank","initPadding","level","row","indents","ASTBuilder","visitNode","finish","visitSource","visitNamedTypeNode","visitFunctionTypeNode","visitTypeParameter","visitIdentifierExpression","visitAssertionExpression","visitBinaryExpression","visitCallExpression","visitClassExpression","visitCommaExpression","visitElementAccessExpression","visitFunctionExpression","visitInstanceOfExpression","visitLiteralExpression","visitNewExpression","visitParenthesizedExpression","visitPropertyAccessExpression","visitTernaryExpression","visitUnaryPostfixExpression","visitUnaryPrefixExpression","visitBlockStatement","visitBreakStatement","visitContinueStatement","visitDoStatement","visitEmptyStatement","visitExportStatement","visitExportDefaultStatement","visitExportImportStatement","visitExpressionStatement","visitForStatement","visitForOfStatement","visitIfStatement","visitImportStatement","visitReturnStatement","visitSwitchStatement","visitThrowStatement","visitTryStatement","visitVariableStatement","visitWhileStatement","visitClassDeclaration","visitEnumDeclaration","visitEnumValueDeclaration","visitFieldDeclaration","visitFunctionDeclaration","visitImportDeclaration","visitInterfaceDeclaration","visitMethodDeclaration","visitNamespaceDeclaration","visitTypeDeclaration","visitVariableDeclaration","serializeDecorator","visitExportMember","serializeParameter","visitSwitchCase","visitIndexSignature","visitNodeAndTerminate","visitTypeName","visitTypeNode","visitStringLiteral","elements","visitArguments","numArgs","visitFunctionCommon","visitFloatLiteralExpression","visitIntegerLiteralExpression","visitStringLiteralExpression","visitRegexpLiteralExpression","visitArrayLiteralExpression","visitObjectLiteralExpression","singleQuoted","quote","last","lastCharPos","isDefault","serializeExternalModifiers","numImplementsTypes","numMembers","numValues","serializeAccessModifiers","numTypeParameters","firstDeclaration","REST","OPTIONAL","DECLARE","PUBLIC","FlowFlags","ConditionKind","localFlags","thisFieldFlags","inlineFunction","initThisFieldFlags","nextInlineId","resetBreakContext","branch","except","temps","tempI32s","tempI64s","tempF32s","tempF64s","tempV128s","tempFuncrefs","tempExternrefs","tempExnrefs","tempAnyrefs","nextAutoreleaseId","resetTemporaryName","scopedLocal","setTemporaryName","scopedDummy","scopedAlias","scope","localsByName","defaultIfInlined","actualParent","actualClass","fieldFlags","nextBreakId","stack","breakStack","otherFlags","conditionKind","thisFlags","newFlags","thisLocalFlags","numThisLocalFlags","otherLocalFlags","numOtherLocalFlags","maxLocalFlags","leftFlags","rightFlags","rightLocalFlags","leftLocalFlags","numLeftLocalFlags","numRightLocalFlags","leftFieldFlags","newFieldFlags","rightFieldFlags","before","after","iff","If","getIfFalse","getIfCondition","getIfTrue","Unary","getUnaryOp","getUnaryValue","Binary","getBinaryOp","getBinaryLeft","getBinaryRight","Call","getCallTarget","getCallOperandAt","exprType","canConversionOverflow","Load","signed","isLoadSigned","getLoadBytes","Select","getSelectThen","getSelectElse","instancesByName","levels","findUsedLocalsVisit","used","traverse","formatDiagnosticMessage","Options","alias","FEATURE_SIGN_EXTENSION","FEATURE_MUTABLE_GLOBALS","FEATURE_NONTRAPPING_F2I","FEATURE_BULK_MEMORY","FEATURE_SIMD","FEATURE_THREADS","FEATURE_EXCEPTION_HANDLING","FEATURE_TAIL_CALLS","FEATURE_REFERENCE_TYPES","FEATURE_MULTI_VALUE","FEATURE_GC","FEATURE_MEMORY64","optimizeLevel","shrinkLevel","Program","diagnosticsOffset","getSource","isEntry","parser","parseFile","nextFile","getDependee","util","Auto","hasTemporaryFunction","cachedStrings","lit","binaryen","_malloc","_BinaryenSizeofLiteral","_BinaryenModuleCreate","cArr","allocU8Array","_BinaryenModuleRead","_free","out","_BinaryenLiteralInt32","_BinaryenConst","valueLow","valueHigh","_BinaryenLiteralInt64","_BinaryenLiteralFloat32","_BinaryenLiteralFloat64","__i32_store8","_BinaryenLiteralVec128","_BinaryenRefNull","_BinaryenUnary","_BinaryenBinary","_BinaryenMemorySize","_BinaryenMemoryGrow","_BinaryenLocalGet","_BinaryenExpressionGetType","_BinaryenLocalTee","cStr","allocStringCached","_BinaryenGlobalGet","_BinaryenLoad","_BinaryenStore","_BinaryenAtomicLoad","_BinaryenAtomicStore","_BinaryenAtomicRMW","replacement","_BinaryenAtomicCmpxchg","timeout","_BinaryenAtomicWait","notifyCount","_BinaryenAtomicNotify","_BinaryenAtomicFence","_BinaryenLocalSet","_BinaryenGlobalSet","children","allocPtrArray","_BinaryenBlock","single","Return","Throw","singleType","_BinaryenBreak","_BinaryenDrop","ReadsLocal","ReadsGlobal","_BinaryenLoop","_BinaryenIf","_BinaryenNop","_BinaryenReturn","_BinaryenSelect","defaultName","strs","_BinaryenSwitch","isReturn","_BinaryenReturnCall","_BinaryenCall","results","_BinaryenReturnCallIndirect","_BinaryenCallIndirect","_BinaryenUnreachable","dest","_BinaryenMemoryCopy","_BinaryenMemoryFill","catchBody","_BinaryenTry","eventName","_BinaryenThrow","_BinaryenRethrow","cStr1","cStr2","_BinaryenBrOnExn","_BinaryenPop","_BinaryenTupleMake","tuple","_BinaryenTupleExtract","vec","_BinaryenSIMDExtract","_BinaryenSIMDReplace","vec1","vec2","_BinaryenSIMDShuffle","c","_BinaryenSIMDTernary","_BinaryenSIMDShift","_BinaryenSIMDLoad","_BinaryenRefIsNull","_BinaryenRefFunc","mutable","_BinaryenAddGlobal","_BinaryenGetGlobal","_BinaryenRemoveGlobal","attribute","_BinaryenAddEvent","_BinaryenGetEvent","_BinaryenRemoveEvent","_BinaryenAddFunction","_BinaryenGetFunction","_BinaryenRemoveFunction","paramTypes","tempName","func","_BinaryenSetStart","_BinaryenAddFunctionExport","_BinaryenAddTableExport","_BinaryenAddMemoryExport","_BinaryenAddGlobalExport","_BinaryenAddEventExport","_BinaryenRemoveExport","externalModuleName","externalBaseName","cStr3","_BinaryenAddFunctionImport","_BinaryenAddTableImport","shared","_BinaryenAddMemoryImport","_BinaryenAddGlobalImport","_BinaryenAddEventImport","initial","exportName","segs","psvs","offs","sizs","cArr1","cArr2","cArr3","cArr4","u32s","__i32_store","allocU32Array","_BinaryenSetMemory","funcs","_BinaryenSetFunctionTable","contents","_BinaryenAddCustomSection","_BinaryenGetOptimizeLevel","_BinaryenSetOptimizeLevel","_BinaryenGetShrinkLevel","_BinaryenSetShrinkLevel","_BinaryenGetDebugInfo","on","_BinaryenSetDebugInfo","_BinaryenGetLowMemoryUnused","_BinaryenSetLowMemoryUnused","_BinaryenGetFastMath","_BinaryenSetFastMath","_BinaryenGetPassArgument","readString","_BinaryenSetPassArgument","_BinaryenClearPassArguments","_BinaryenGetAlwaysInlineMaxSize","_BinaryenSetAlwaysInlineMaxSize","_BinaryenGetFlexibleInlineMaxSize","_BinaryenSetFlexibleInlineMaxSize","_BinaryenGetOneCallerInlineMaxSize","_BinaryenSetOneCallerInlineMaxSize","_BinaryenGetAllowInliningFunctionsWithLoops","enabled","_BinaryenSetAllowInliningFunctionsWithLoops","_BinaryenModuleGetFeatures","_BinaryenModuleSetFeatures","pass","allocString","_BinaryenFunctionRunPasses","_BinaryenModuleRunPasses","passes","cStrs","debugInfo","usesARC","setOptimizeLevel","setShrinkLevel","setDebugInfo","setFastMath","clearPassArguments","setAlwaysInlineMaxSize","setFlexibleInlineMaxSize","setOneCallerInlineMaxSize","setAllowInliningFunctionsWithLoops","getLowMemoryUnused","runPasses","_BinaryenModuleValidate","_BinaryenModuleInterpret","sourceMapUrl","binaryPtr","sourceMapPtr","_BinaryenModuleAllocateAndWrite","__i32_load","binaryLen","BinaryModule","__i32_load8_u","readBuffer","watFormat","_BinaryenModuleDispose","Relooper","noSideEffects","maxDepth","nested1","nested2","_BinaryenExpressionGetId","_BinaryenConstGetValueI32","_BinaryenConstGetValueI64Low","_BinaryenConstGetValueI64High","_BinaryenConstGetValueF32","_BinaryenConstGetValueF64","_BinaryenLocalGetGetIndex","globalName","_BinaryenGlobalGetGetName","_BinaryenLoadGetPtr","_BinaryenLoadIsAtomic","_BinaryenLoadGetBytes","_BinaryenLoadGetOffset","_BinaryenLoadIsSigned","_BinaryenLoadGetAlign","_BinaryenUnaryGetValue","_BinaryenUnaryGetOp","_BinaryenBinaryGetLeft","_BinaryenBinaryGetRight","_BinaryenBinaryGetOp","_BinaryenExpressionCopy","maxLoopIterations","runner","_ExpressionRunnerCreate","_ExpressionRunnerRunAndDispose","_BinaryenModuleAddDebugInfoFileName","_BinaryenModuleGetDebugInfoFileName","fileIndex","lineNumber","columnNumber","_BinaryenFunctionSetDebugLocation","_BinaryenTypeCreate","arity","_BinaryenTypeArity","_BinaryenTypeExpand","_BinaryenLocalSetGetIndex","_BinaryenLocalSetGetValue","_BinaryenLocalSetIsTee","_BinaryenStoreGetBytes","_BinaryenStoreGetOffset","_BinaryenStoreGetPtr","_BinaryenStoreGetValue","_BinaryenBlockGetName","_BinaryenBlockGetNumChildren","_BinaryenBlockGetChildAt","_BinaryenIfGetCondition","_BinaryenIfGetIfTrue","_BinaryenIfGetIfFalse","_BinaryenLoopGetName","_BinaryenLoopGetBody","_BinaryenBreakGetName","_BinaryenBreakGetCondition","_BinaryenSelectGetIfTrue","_BinaryenSelectGetIfFalse","_BinaryenSelectGetCondition","_BinaryenDropGetValue","_BinaryenReturnGetValue","_BinaryenCallGetTarget","_BinaryenCallGetNumOperands","_BinaryenCallGetOperandAt","_BinaryenMemoryGrowGetDelta","_BinaryenFunctionGetBody","_BinaryenFunctionGetName","_BinaryenFunctionGetParams","_BinaryenFunctionGetResults","_BinaryenFunctionGetNumVars","_BinaryenFunctionGetVar","_BinaryenGlobalGetName","_BinaryenGlobalGetType","_BinaryenGlobalIsMutable","_BinaryenGlobalGetInitExpr","event","_BinaryenEventGetName","_BinaryenEventGetAttribute","_BinaryenEventGetParams","_BinaryenEventGetResults","_RelooperCreate","_RelooperAddBlock","from","to","_RelooperAddBranch","_RelooperAddBlockWithSwitch","indexes","i32s","allocI32Array","_RelooperAddBranchForSwitch","entry","labelHelper","_RelooperRenderAndDispose","All","_BinaryenExpressionGetSideEffects","u8s","ptrs","u","stringLengthUTF8","cp","u1","u2","u3","ch","fromCharCodes","labelPostfix","labels","defaultLabel","lastCase","output","Break","numChildren","Loop","Switch","_BinaryenSwitchGetCondition","CallIndirect","_BinaryenCallIndirectGetNumOperands","_BinaryenCallIndirectGetOperandAt","GlobalSet","_BinaryenGlobalSetGetValue","Store","Drop","MemorySize","MemoryGrow","AtomicRMW","_BinaryenAtomicRMWGetPtr","_BinaryenAtomicRMWGetValue","AtomicCmpxchg","_BinaryenAtomicCmpxchgGetPtr","_BinaryenAtomicCmpxchgGetExpected","_BinaryenAtomicCmpxchgGetReplacement","AtomicWait","_BinaryenAtomicWaitGetPtr","_BinaryenAtomicWaitGetExpected","_BinaryenAtomicWaitGetTimeout","AtomicNotify","_BinaryenAtomicNotifyGetPtr","AtomicFence","SIMDExtract","_BinaryenSIMDExtractGetVec","SIMDReplace","_BinaryenSIMDReplaceGetVec","_BinaryenSIMDReplaceGetValue","SIMDShuffle","_BinaryenSIMDShuffleGetLeft","_BinaryenSIMDShuffleGetRight","SIMDTernary","_BinaryenSIMDTernaryGetA","_BinaryenSIMDTernaryGetB","_BinaryenSIMDTernaryGetC","SIMDShift","_BinaryenSIMDShiftGetVec","_BinaryenSIMDShiftGetShift","SIMDLoad","_BinaryenSIMDLoadGetPtr","MemoryInit","_BinaryenMemoryInitGetDest","_BinaryenMemoryInitGetOffset","_BinaryenMemoryInitGetSize","DataDrop","MemoryCopy","_BinaryenMemoryCopyGetDest","_BinaryenMemoryCopyGetSource","_BinaryenMemoryCopyGetSize","MemoryFill","_BinaryenMemoryFillGetDest","_BinaryenMemoryFillGetValue","_BinaryenMemoryFillGetSize","Pop","RefNull","RefIsNull","_BinaryenRefIsNullGetValue","RefFunc","Try","_BinaryenTryGetBody","_BinaryenTryGetCatchBody","_BinaryenThrowGetNumOperands","_BinaryenThrowGetOperandAt","Rethrow","_BinaryenRethrowGetExnref","BrOnExn","_BinaryenBrOnExnGetExnref","TupleMake","_BinaryenTupleMakeGetNumOperands","_BinaryenTupleMakeGetOperandAt","TupleExtract","Dependee","Parser","sources","backlog","seenlog","donelog","onComment","currentSource","dependees","tryParseSignatureIsSignature","parseParametersThis","dependee","Source","USER","tn","Tokenizer","skip","ENDOFFILE","parseTopLevelStatement","skipStatement","startPos","AT","tokenPos","parseDecorator","exportStart","exportEnd","defaultStart","defaultEnd","DEFAULT","declareStart","declareEnd","contextIsAmbient","A_declare_modifier_cannot_be_used_in_an_already_ambient_context","first","peek","nextTokenPos","parseEnum","parseVariable","VAR","parseFunction","state","mark","abstractStart","abstractEnd","nextTokenOnNewLine","reset","parseStatement","_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration","discard","parseClassOrInterface","IdentifierHandling","PREFER","parseNamespace","parseExportImport","parseImport","TYPE","parseTypeDeclaration","skipIdentifier","An_export_assignment_cannot_have_modifiers","parseExportDefaultAlias","parseExport","_0_modifier_cannot_be_used_here","Decorators_are_not_valid_here","createExportDefaultStatement","dependent","readIdentifier","DOT","Identifier_expected","acceptParenthesized","suppressErrors","token","OPENPAREN","isNullableSignature","tryParseFunctionType","CLOSEPAREN","_0_expected","Unexpected_token","innerType","parseType","createNamedType","STRINGLITERAL","parseTypeName","notNullStart","notNull","OPENBRACKET","bracketStart","CLOSEBRACKET","bracketRange","nullable","isSignature","firstParamNameNoType","firstParamKind","paramStart","DOT_DOT_DOT","COLON","QUESTION","A_rest_parameter_cannot_be_optional","param","createParameter","createOmittedType","EQUALS_GREATERTHAN","createFunctionType","createPropertyAccessExpression","createDecorator","parseArguments","isFor","parseVariableDeclaration","createVariableStatement","SEMICOLON","parentFlags","parentDecorators","isIllegalVariableIdentifier","Initializers_are_not_allowed_in_ambient_contexts","parseExpression","A_definite_assignment_assertion_is_not_permitted_in_this_context","createVariableDeclaration","OPENBRACE","CLOSEBRACE","parseEnumValue","createEnumDeclaration","createEnumValueDeclaration","nextToken","createReturnStatement","seenOptional","typeParameter","parseTypeParameter","Required_type_parameters_may_not_follow_optional_type_parameters","Type_parameter_list_cannot_be_empty","EXTENDS","createTypeParameter","seenRest","reportedRest","parseParameter","A_rest_parameter_must_be_last_in_a_parameter_list","A_required_parameter_cannot_follow_an_optional_parameter","isRest","isOptional","startRange","accessFlags","A_parameter_property_cannot_be_declared_using_a_rest_parameter","A_rest_parameter_cannot_have_an_initializer","Parameter_cannot_have_question_mark_and_initializer","signatureStart","parseTypeParameters","parseParameters","isSetter","A_set_accessor_must_have_exactly_one_parameter","A_set_accessor_parameter_cannot_have_an_initializer","A_get_accessor_cannot_have_parameters","parseBlockStatement","createFunctionDeclaration","createEmptyIdentifierExpression","parseFunctionExpressionCommon","explicitThis","bodyExpression","createExpressionStatement","createFunctionExpression","IMPLEMENTS","Interface_declaration_cannot_have_implements_clause","createInterfaceDeclaration","createClassDeclaration","parseClassMember","createClassExpression","accessStart","accessEnd","staticStart","staticEnd","GENERIC_CONTEXT","readonlyStart","readonlyEnd","isGetter","getStart","getEnd","setEnd","isGetterOrSetter","createConstructorExpression","retIndex","parseIndexSignature","ALWAYS","typeParametersStart","Type_parameters_cannot_appear_on_a_constructor_declaration","An_accessor_cannot_have_type_parameters","createFieldDeclaration","_0_keyword_cannot_be_used_here","Type_annotation_cannot_appear_on_a_constructor_declaration","A_set_accessor_cannot_have_a_return_type_annotation","Method_0_cannot_have_an_implementation_because_it_is_marked_abstract","retMethod","createMethodDeclaration","Constructor_implementation_is_missing","Optional_properties_are_not_supported","retField","createIndexSignature","createNamespaceDeclaration","parseExportMember","FROM","createStringLiteralExpression","createExportStatement","asIdentifier","createExportMember","skipFrom","parseImportDeclaration","createImportDeclaration","createWildcardImportStatement","createImportStatement","createExportImportStatement","topLevel","parseBreak","parseContinue","parseDoStatement","parseForStatement","parseIfStatement","A_return_statement_can_only_be_used_within_a_function_body","parseReturn","createEmptyStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVoidStatement","parseWhileStatement","parseExpressionStatement","createBlockStatement","createBreakStatement","createContinueStatement","createDoStatement","OF","parseForOfStatement","The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer","createForStatement","createForOfStatement","elseStatement","ELSE","createIfStatement","switchCases","switchCase","parseSwitchCase","createSwitchStatement","CASE","createSwitchCase","_case_or_default_expected","createThrowStatement","CATCH","FINALLY","createTryStatement","createTypeDeclaration","createVoidStatement","createWhileStatement","YIELD","DELETE","createUnaryPrefixExpression","The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access","arguments_","tryParseTypeArgumentsBeforeArguments","createNewExpression","createNullExpression","createTrueExpression","createFalseExpression","createThisExpression","again","parseFunctionExpression","inner","createParenthesizedExpression","maybeParseCallExpression","createOmittedExpression","createArrayLiteralExpression","createObjectLiteralExpression","createAssertionExpression","identifierText","_super_must_be_followed_by_an_argument_list_or_member_access","createSuperExpression","INTEGERLITERAL","createIntegerLiteralExpression","readInteger","FLOATLITERAL","createFloatLiteralExpression","readFloat","regexpPattern","readRegexpPattern","createRegexpLiteralExpression","readRegexpFlags","parseClassExpression","Unexpected_end_of_text","Expression_expected","Type_argument_list_cannot_be_empty","precedence","parseExpressionStart","nextPrecedence","determinePrecedence","createInstanceOfExpression","createElementAccessExpression","createUnaryPostfixExpression","createTernaryExpression","commaExprs","createCommaExpression","joinPropertyCall","createBinaryExpression","potentiallyGeneric","createCallExpression","skipBlock","depth","IN","Precedence","QueuedImport","localFile","localIdentifier","foreignIdentifier","foreignPath","foreignPathAlt","QueuedExport","QueuedExportStar","pathLiteral","fromDecorator","UNCHECKED_INDEXED_GET","UNCHECKED_INDEXED_SET","INVALID","fromBinaryToken","fromUnaryPrefixToken","fromUnaryPostfixToken","nextClassId","nextSignatureId","initialized","elementsByDeclaration","wrapperClasses","uniqueSignatures","_arrayBufferViewInstance","_arrayBufferInstance","_arrayPrototype","_staticArrayPrototype","_setPrototype","_mapPrototype","_functionPrototype","_int8ArrayPrototype","_int16ArrayPrototype","_int32ArrayPrototype","_int64ArrayPrototype","_uint8ArrayPrototype","_uint8ClampedArrayPrototype","_uint16ArrayPrototype","_uint32ArrayPrototype","_uint64ArrayPrototype","_float32ArrayPrototype","_float64ArrayPrototype","_stringInstance","_allocInstance","_reallocInstance","_freeInstance","_newInstance","_renewInstance","_retainInstance","_releaseInstance","_collectInstance","_visitInstance","_typeinfoInstance","_instanceofInstance","_newBufferInstance","_newArrayInstance","_BLOCKInstance","_OBJECTInstance","_runtimeHeaderSize","nativeDummySignature","nativeSource","Resolver","nativeFile","File","cached","requireClass","lookupFunction","requireFunction","blockOverhead","BLOCKInstance","AL_MASK","headerSize","decoratorFlags","registerNativeType","TypeDefinition","makeNativeTypeDeclaration","queuedImports","queuedExports","queuedExportsStar","queuedExtends","queuedImplements","initializeExports","initializeExportDefault","initializeImports","initializeVariables","initializeClass","initializeEnum","initializeFunction","initializeInterface","initializeNamespace","initializeTypeDefinition","starExports","foreignFile","lookupForeignFile","ensureExportStar","madeProgress","queuedImport","lookupForeign","splice","asAliasNamespace","Module_0_has_no_exported_member_1","exportNames","queuedExport","ensureExport","globalElement","isDeclaredElement","registerWrapperClass","thisPrototype","baseElement","Class_0_is_final_and_cannot_be_extended","Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa","A_class_may_only_extend_another_class","INTERFACE_PROTOTYPE","An_interface_can_only_extend_an_interface","implementsNodes","implementsNode","interfaceElement","interfacePrototype","interfacePrototypes","A_class_can_only_implement_an_interface","markVirtuals","firstChar","markModuleExports","thisInstanceMembers","baseInstanceMembers","thisMember","baseMember","thisMethod","baseMethod","visibilityEquals","Overload_signatures_must_all_be_public_private_or_protected","baseMethodInstances","thisProperty","baseProperty","baseGetter","getterPrototype","thisGetter","baseGetterInstances","baseSetter","setterPrototype","thisSetter","baseSetterInstances","nextPrototype","markModuleExport","classElement","wrappedType","isIntegerInclReference","Global","makeNativeVariableDeclaration","merged","tryMerge","lookupExport","fileQueuedExports","queuedExportForeignPath","acceptedFlags","fromKind","Duplicate_decorator","ClassPrototype","checkDecorators","Unmanaged_classes_cannot_implement_interfaces","memberDeclarations","memberDeclaration","initializeField","methodDeclaration","initializeProperty","initializeMethod","FieldPrototype","addInstance","checkOperatorOverloads","firstArg","_0_is_not_a_valid_operator","Duplicate_function_implementation","operatorKind","parentMembers","PropertyPrototype","Duplicate_property_0","ensureProperty","Enum","initializeEnumValue","EnumValue","initializeExport","queued","endsWith","Export_declaration_conflicts_with_exported_declaration_of_0","initializeImport","validDecorators","InterfacePrototype","initializeFieldAsProperty","Namespace","copyMembers","cyclics","Element","shadowType","FILE","localIdentifierIfImport","originalDeclaration","reportedIdentifier","isPublic","vis","declaredElements","DeclaredElement","selfProperty","selfGetter","selfSetter","AcyclicState","typedElements","TypedElement","aliasNamespaces","ensureGlobal","makeNativeNamespaceDeclaration","ns","copyExportsToNamespace","inSelf","ConstantValueKind","VariableLikeElement","i64_zero","boundPrototypes","bound","instanceKey","nameInclTypeParameters","parameterName","createParent","registerConcreteElement","getDefaultParameterName","postfix","setDebugLocation","toBound","_isInterface","basePtototype","Class","_id","_acyclic","implementers","isBuiltinArray","lengthField","inheritedTypeArguments","baseName","baseType","iface","uncheckedOverload","overhead","baseOffset","typeKind","i64_is","writeI32AsI64","writeI64AsI32","extendedPrototype","float32ArrayPrototype","float64ArrayPrototype","int8ArrayPrototype","int16ArrayPrototype","int32ArrayPrototype","int64ArrayPrototype","uint8ArrayPrototype","uint8ClampedArrayPrototype","uint16ArrayPrototype","uint32ArrayPrototype","uint64ArrayPrototype","acyclic","hasCycle","cyclesTo","exceptIfMember","older","newer","Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local","src","srcMembers","destMembers","asGlobal","cachedDefaultParameterNames","resolveClassPending","ctxElement","ctxTypes","reportMode","resolveNamedType","resolveFunctionType","isSimpleType","simpleName","Type_0_cannot_be_nullable","typeDefinition","resolveBuiltinNativeType","resolveBuiltinIndexofType","resolveBuiltinValueofType","resolveBuiltinReturnTypeType","parameterTypeNode","returnTypeNode","typeArgument","prev","alternativeReportNode","minParameterCount","maxParameterCount","argumentCount","ctxFlow","resolveFunctionInclTypeArguments","typeParameterNames","argumentNodes","argumentExpression","propagateInferredGenericTypes","resolvedTypeArguments","inferredType","Type_argument_expected","ensureResolvedLazyGlobal","isTypedElement","lookupAssertionExpression","lookupBinaryExpression","lookupCallExpression","lookupCommaExpression","lookupElementAccessExpression","lookupFunctionExpression","lookupThisExpression","lookupSuperExpression","lookupInstanceOfExpression","lookupLiteralExpression","lookupNewExpression","lookupPropertyAccessExpression","lookupTernaryExpression","lookupUnaryPostfixExpression","lookupUnaryPrefixExpression","resolveAssertionExpression","resolveBinaryExpression","resolveCallExpression","resolveCommaExpression","resolveElementAccessExpression","resolveFunctionExpression","resolveIdentifierExpression","resolveThisExpression","resolveSuperExpression","resolveInstanceOfExpression","resolveLiteralExpression","resolveNewExpression","resolvePropertyAccessExpression","resolveTernaryExpression","resolveUnaryPostfixExpression","resolveUnaryPrefixExpression","getElementOfType","targetNode","propertyName","variableLikeElement","wrapper","baseInstance","i64_is_i8","i64_is_u8","i64_is_i16","i64_is_u16","i64_is_bool","Type_0_is_illegal_in_this_context","superLocal","fltType","numNullLiterals","The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly","varType","varElement","thenType","elseType","typesToString","resolvedInstance","getResolvedInstance","classTypeArguments","classTypeParameters","numClassTypeArguments","classTypeParameterName","numFunctionTypeArguments","signatureParameters","numSignatureParameters","parameterDeclaration","nameInclTypeParamters","Interface","pendingClasses","anyPending","_0_is_referenced_directly_or_indirectly_in_its_own_base_expression","setBase","addInterface","finishResolveClass","unimplemented","ifaceMembers","isCompatibleOverride","This_overload_signature_is_not_compatible_with_its_implementation_signature","identifierAndSignatureRange","baseMembers","instanceMemberPrototypes","properties","fieldTypeNode","baseField","Field","propertyGetter","propertySetter","Getter_and_setter_accessors_do_not_agree_in_visibility","Property_0_only_has_a_setter_and_is_missing_a_getter","Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2","overloadKind","overloadPrototype","IndexSignature","pending","dependsOnInstance","_values2","Property","tokenFromKeyword","ASYNC","AWAIT","DEBUGGER","IS","KEYOF","MODULE","PACKAGE","WITH","tokenIsAlsoIdentifier","identifierHandling","unsafeNext","maxTokenLength","chr","isDecimalDigit","commentStartPos","LINE","TRIPLE","closed","testInteger","isIdentifierStart","isKeywordCharacter","posBefore","isIdentifierPart","keywordToken","isWhiteSpace","Invalid_character","checkOnNewLine","maxCompoundLength","tokenBefore","tokenPosBefore","reusableState","State","Unterminated_string_literal","readEscapeSequence","readExtendedUnicodeEscape","readUnicodeEscape","readHexadecimalEscape","fromCharCode","escaped","Unterminated_regular_expression_literal","Invalid_regular_expression_flags","readHexInteger","readBinaryInteger","readOctalInteger","isOctalDigit","Octal_literals_are_not_allowed_in_strict_mode","readDecimalInteger","sepEnd","i64_4","i64_shl","Numeric_separators_are_not_allowed_here","Multiple_consecutive_numeric_separators_are_not_permitted","Hexadecimal_digit_expected","i64_10","Digit_expected","i64_3","Octal_digit_expected","i64_1","Binary_digit_expected","readDecimalFloat","sepCount","readDecimalFloatPartial","replaceAll","parseFloat","allowLeadingZeroSep","remain","value32","invalid","An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive","Unterminated_Unicode_escape_sequence","TypeKind","TypeFlags","_nonNullableType","_nullableType","nullableType","signednessIsRelevant","currentClass","targetClass","currentFunction","targetFunction","isVectorValue","signednessIsImportant","validWat","nullablePostfix","numTypes","signatureTypes","numParameterTypes","nativeTypes","thisThisType","otherThisType","thisParameterTypes","otherParameterTypes","requireSameSize","targetThisType","targetParameterTypes","thisParameterType","targetParameterType","thisReturnType","targetReturnType","optionalStart","restIndex","cloneParameterTypes","readI32","readI64","i32_as_f32","f32_as_i32","i64_as_f64","valueI64","f64_as_i64","overrides","cloned","v","x","separator","ipos","dirname","origin","CharCode","c0","lookupInUnicodeMap","unicodeIdentifierStart","unicodeIdentifierPart","mid","midVal","unmanaged","g","toText","wrapModule","emitStackIR","emitText","toAsmjs","emitAsmjs","keys","i64_one","i64_neg_one","i64_pow","rightLo","rightHi","i64_div","i64_rem","i64_rem_u","i64_and","i64_or","i64_xor","i64_shr","i64_not","i64_eq","i64_ne","minSafeF32","MIN_SAFE_INTEGER","maxSafeF32","MAX_SAFE_INTEGER","i64_is_f32","minSafeF64","maxSafeF64","i64_is_f64","fround","globalScope","window","ASC_FEATURE_MUTABLE_GLOBAL","UnreachableError","captureStackTrace","AssertionError","defaultComparator","nanA","nanB","defineProperties","writable","Infinity","NaN","clz32","round","y","sign","isTrueish","CHUNKSIZE","apply","parts","fromCodePoint","search","replacment","split","arraySort","comparator","Number","sincos_sin","sincos_cos","signbit","Boolean","sincos","sin","cos","exp2","arguments","byteOffset","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","globalThis"],"mappings":"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A,uFACA,iGACA,qHACA,qGACA,+DACA,iEACA,iGACA,uFACA,yDACA,uGACA,qHACA,yEACA,yLACA,qIACA,2GACA,6IACA,uIACA,uIACA,+GACA,iGACA,yHACA,2EACA,oEACA,oDACA,oCACA,8FACA,kEACA,8CACA,gHACA,oHACA,8HACA,0GACA,8GACA,4EACA,oFACA,oGACA,0GACA,oHACA,wFACA,gFACA,kIACA,kIACA,4FACA,oHACA,oFACA,kFACA,wKACA,sLACA,kIACA,oDACA,wCACA,oJACA,gDACA,kGACA,wGACA,0CACA,kEACA,0DACA,gDACA,gEACA,sIACA,4IACA,0DACA,4DACA,wEACA,sDACA,4FACA,4FACA,oHACA,wDACA,sDACA,8HACA,gKACA,oKACA,sFACA,wEACA,sKACA,sJACA,8IACA,wFACA,0IACA,0DACA,kDACA,gFACA,gGACA,gGACA,wDACA,kFACA,sFACA,0GACA,8GACA,wMACA,oFACA,8HACA,0NACA,sFACA,0IACA,gMACA,0LACA,wGACA,oIACA,kIACA,0HACA,wGACA,oIACA,wFACA,4KACA,sHACA,gFACA,oKACA,gLACA,4FACA,0MACA,wKACA,0FACA,kQACA,8DACA,kGACA,gKACA,oIACA,kJACA,0GACA,kKACA,4DACA,oJACA,oJACA,0GACA,0EACA,4FACA,oFACA,sNACA,8FACA,0QACA,kLACA,sLACA,gHACA,sFACA,8IACA,sDACA,0HACA,wEACA,8CACA,4FACA,gIACA,iLACA,+MA9KF,CAAY,EAAAA,iBAAA,EAAAA,eAAc,KAkL1B,kCAAuCypD,GACrC,OAAQA,GACN,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,uBACjB,KAAK,IAAK,MAAO,oBACjB,KAAK,IAAK,MAAO,gCACjB,KAAK,IAAK,MAAO,sDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,uDACjB,KAAK,IAAK,MAAO,0DACjB,KAAK,IAAK,MAAO,iEACjB,KAAK,IAAK,MAAO,sGACjB,KAAK,IAAK,MAAO,8C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8BACA,4BAEA,gCACA,4BACA,gCACA,gCACA,kBACA,0BACA,8BACA,0BACA,sBACA,kBACA,sBACA,0BACA,0BACA,8BACA,oCAnDF,CAAYA,EAAA,EAAAA,eAAA,EAAAA,aAAY,KAsDxB,SAAY5f,GACV,uBACA,uBACA,uBACA,uBACA,6BACA,6BACA,uBACA,uBACA,uBACA,uBACA,0BACA,0BACA,4BACA,4BACA,4BACA,4BACA,gCACA,gCACA,0BACA,0BACA,wBACA,wBACA,8BACA,8BACA,0BACA,sCACA,sCACA,sCACA,sCACA,sCACA,sCACA,sCACA,sCACA,wCACA,wCACA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,0CACA,gCACA,8BACA,wCACA,wCAGA,sCACA,wCACA,sCACA,wCACA,wCAGA,4CACA,4CACA,4CACA,4CACA,4CACA,4CACA,4CACA,4CAGA,gCACA,gCACA,gCACA,gCACA,gCACA,gCACA,0BACA,4BACA,4BACA,oCACA,oCACA,oCACA,4BAEA,4BACA,oCACA,oCACA,oCACA,4BACA,4BACA,oCACA,oCACA,oCACA,4BACA,oCACA,oCACA,4BACA,4BACA,8BACA,8BACA,gCACA,gCACA,oCACA,4BACA,4BACA,8BACA,8BACA,gCACA,gCACA,oCACA,qDACA,qDACA,qDACA,qDACA,mDACA,mDACA,mDACA,mDACA,qDACA,uDACA,qDACA,uDACA,qDACA,uDACA,qDACA,uDA1HF,CAAY,EAAAA,UAAA,EAAAA,QAAO,KA6HnB,SAAY8B,GACV,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,uBACA,qBACA,uBACA,wBACA,wBACA,wBACA,0BACA,0BACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,wBACA,sBACA,wBACA,wBACA,wBACA,wBACA,0BACA,0BACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,wBACA,wBACA,wBACA,wBACA,kCACA,wBACA,wBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBACA,wBACA,wBACA,wBACA,wBACA,kCACA,wBACA,wBACA,sBACA,sBACA,sBACA,sBACA,sBACA,sBAGA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,0BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,yBACA,2BACA,iCACA,6BACA,mCACA,mCACA,6BACA,mCACA,mCACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BACA,6BACA,mCACA,mCACA,6BACA,mCACA,mCACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BAMA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BAKA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BACA,+BACA,6BACA,6BACA,6BACA,6BACA,6BACA,6BACA,+BACA,+BACA,iDACA,iDACA,iDACA,iDACA,qCA5LF,CAAYA,EAAA,EAAAA,WAAA,EAAAA,SAAQ,KA+LpB,SAAYwG,GACV,iBACA,iBACA,iBACA,eACA,iBACA,mBANF,CAAY,EAAAA,cAAA,EAAAA,YAAW,KASvB,SAAY4C,GACV,2CACA,2CACA,2CACA,2CACA,2CACA,2CACA,2CACA,2CARF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KAWzB,SAAYW,GACV,2CACA,2CACA,2CACA,2CACA,2CACA,2CANF,CAAY,EAAAA,gBAAA,EAAAA,cAAa,KASzB,SAAYqM,GACV,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,2BACA,4BACA,4BAZF,CAAY,EAAAA,cAAA,EAAAA,YAAW,KAevB,SAAY+B,GACV,6BACA,6BACA,6BACA,6BA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A,kCACA,4BACA,0BACA,0BACA,wBACA,gBACA,oBACA,oBACA,wBACA,0BACA,sBACA,0BACA,kBACA,oBACA,4BACA,kBACA,gBACA,gCACA,wBACA,gBACA,gCACA,8BACA,gBACA,sBACA,kBACA,wBACA,8BACA,kBACA,oBACA,gBACA,0BACA,0BACA,8BACA,wBACA,4BACA,wBACA,kBACA,wBACA,sBACA,wBACA,oBACA,sBACA,oBACA,kBACA,oBACA,wBACA,kBACA,oBACA,sBACA,oBACA,sBAIA,8BACA,gCACA,8BACA,gCACA,kCACA,oCACA,kBACA,kCACA,8BACA,sBACA,4BACA,kCACA,0CACA,gDACA,sCACA,gDACA,oDACA,8DACA,gDACA,oBACA,sBACA,8CACA,4BACA,sBACA,0BACA,8BACA,kCACA,8CACA,0DACA,kFACA,8BACA,kBACA,sBACA,kCACA,sBACA,kDACA,0BACA,4BACA,sBACA,yBACA,mCACA,qCACA,2CACA,6DACA,qCACA,yCACA,6DACA,yEACA,iGACA,6CACA,iCACA,qCACA,iBAIA,iCACA,uCACA,yCACA,qCAIA,2BACA,+BArIF,CAAYA,EAAA,EAAAA,QAAA,EAAAA,MAAK,KAwIjB,SAAY+zC,GACV,yBACA,uBACA,uBAHF,CAAYA,EAAA,EAAAA,qBAAA,EAAAA,mBAAkB,KAM9B,qBAgIA,0BAwBA,uCAA4ChzG,GAE1C,OADAsK,OAAOtK,EAAKrI,QACJqI,EAAKkL,WAAW,IACtB,KAAK,IAAY,MAAe,UAARlL,EACxB,KAAK,IAAY,MAAe,OAARA,EACxB,KAAK,IAAY,MAAe,cAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EACxB,KAAK,IAAY,MAAe,QAARA,EAE1B,OAAO,GAGT,iCAAsCo0G,GACpC,OAAQA,GACN,KAAKn1C,EAAMqgD,OAAQ,MAAO,SAC1B,KAAKrgD,EAAMyjD,GAAI,MAAO,KACtB,KAAKzjD,EAAMxxD,WAAY,MAAO,aAC9B,KAAKwxD,EAAMvxD,IAAK,MAAO,MACvB,KAAKuxD,EAAMsZ,OAAQ,MAAO,SAC1B,KAAKtZ,EAAM1sD,K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M,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAEtCC,EAA+B,CACnC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KACxB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,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","file":"assemblyscript.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__911__) {\nreturn ","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n","/**\n * @fileoverview Abstract syntax tree representing a source file once parsed.\n *\n * Each node in the AST is represented by an instance of a subclass of `Node`,\n * with its `Node#kind` represented by one of the `NodeKind` constants, which\n * dependent code typically switches over. The intended way to create a node\n * is to use the respective `Node.createX` method instead of its constructor.\n *\n * Note that the AST does not contain any type information except type names.\n *\n * @license Apache-2.0\n */\n\n// TODO: Make the AST more easily serializable by refactoring `Node#range` so\n// it doesn't reference the non-serializable `Source` object.\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  LIBRARY_PREFIX,\n  LIBRARY_SUBST\n} from \"./common\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  normalizePath,\n  resolvePath,\n  CharCode,\n  isTrivialAlphanum\n} from \"./util\";\n\n/** Indicates the kind of a node. */\nexport enum NodeKind {\n\n  SOURCE,\n\n  // types\n  NAMEDTYPE,\n  FUNCTIONTYPE,\n  TYPENAME,\n  TYPEPARAMETER,\n  PARAMETER,\n\n  // expressions\n  IDENTIFIER,\n  ASSERTION,\n  BINARY,\n  CALL,\n  CLASS,\n  COMMA,\n  ELEMENTACCESS,\n  FALSE,\n  FUNCTION,\n  INSTANCEOF,\n  LITERAL,\n  NEW,\n  NULL,\n  OMITTED,\n  PARENTHESIZED,\n  PROPERTYACCESS,\n  TERNARY,\n  SUPER,\n  THIS,\n  TRUE,\n  CONSTRUCTOR,\n  UNARYPOSTFIX,\n  UNARYPREFIX,\n\n  // statements\n  BLOCK,\n  BREAK,\n  CONTINUE,\n  DO,\n  EMPTY,\n  EXPORT,\n  EXPORTDEFAULT,\n  EXPORTIMPORT,\n  EXPRESSION,\n  FOR,\n  FOROF,\n  IF,\n  IMPORT,\n  RETURN,\n  SWITCH,\n  THROW,\n  TRY,\n  VARIABLE,\n  VOID,\n  WHILE,\n\n  // declaration statements\n  CLASSDECLARATION,\n  ENUMDECLARATION,\n  ENUMVALUEDECLARATION,\n  FIELDDECLARATION,\n  FUNCTIONDECLARATION,\n  IMPORTDECLARATION,\n  INTERFACEDECLARATION,\n  METHODDECLARATION,\n  NAMESPACEDECLARATION,\n  TYPEDECLARATION,\n  VARIABLEDECLARATION,\n\n  // special\n  DECORATOR,\n  EXPORTMEMBER,\n  SWITCHCASE,\n  INDEXSIGNATURE,\n  COMMENT\n}\n\n/** Base class of all nodes. */\nexport abstract class Node {\n  constructor(\n    /** Kind of this node. */\n    public kind: NodeKind,\n    /** Source range. */\n    public range: Range\n  ) {}\n\n  // types\n\n  static createSimpleTypeName(\n    name: string,\n    range: Range\n  ): TypeName {\n    return new TypeName(Node.createIdentifierExpression(name, range), null, range);\n  }\n\n  static createNamedType(\n    name: TypeName,\n    typeArguments: TypeNode[] | null,\n    isNullable: bool,\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(name, typeArguments, isNullable, range);\n  }\n\n  static createFunctionType(\n    parameters: ParameterNode[],\n    returnType: TypeNode,\n    explicitThisType: NamedTypeNode | null,\n    isNullable: bool,\n    range: Range\n  ): FunctionTypeNode {\n    return new FunctionTypeNode(parameters, returnType, explicitThisType, isNullable, range);\n  }\n\n  static createOmittedType(\n    range: Range\n  ): NamedTypeNode {\n    return new NamedTypeNode(Node.createSimpleTypeName(\"\", range), null, false, range);\n  }\n\n  static createTypeParameter(\n    name: IdentifierExpression,\n    extendsType: NamedTypeNode | null,\n    defaultType: NamedTypeNode | null,\n    range: Range\n  ): TypeParameterNode {\n    return new TypeParameterNode(name, extendsType, defaultType, range);\n  }\n\n  static createParameter(\n    parameterKind: ParameterKind,\n    name: IdentifierExpression,\n    type: TypeNode,\n    initializer: Expression | null,\n    range: Range\n  ): ParameterNode {\n    return new ParameterNode(parameterKind, name, type, initializer, range);\n  }\n\n  // special\n\n  static createDecorator(\n    name: Expression,\n    args: Expression[] | null,\n    range: Range\n  ): DecoratorNode {\n    return new DecoratorNode(DecoratorKind.fromNode(name), name, args, range);\n  }\n\n  static createComment(\n    commentKind: CommentKind,\n    text: string,\n    range: Range\n  ): CommentNode {\n    return new CommentNode(commentKind, text, range);\n  }\n\n  // expressions\n\n  static createIdentifierExpression(\n    text: string,\n    range: Range,\n    isQuoted: bool = false\n  ): IdentifierExpression {\n    return new IdentifierExpression(text, isQuoted, range);\n  }\n\n  static createEmptyIdentifierExpression(\n    range: Range\n  ): IdentifierExpression {\n    return new IdentifierExpression(\"\", false, range);\n  }\n\n  static createArrayLiteralExpression(\n    elementExpressions: Expression[],\n    range: Range\n  ): ArrayLiteralExpression {\n    return new ArrayLiteralExpression(elementExpressions, range);\n  }\n\n  static createAssertionExpression(\n    assertionKind: AssertionKind,\n    expression: Expression,\n    toType: TypeNode | null,\n    range: Range\n  ): AssertionExpression {\n    return new AssertionExpression(assertionKind, expression, toType, range);\n  }\n\n  static createBinaryExpression(\n    operator: Token,\n    left: Expression,\n    right: Expression,\n    range: Range\n  ): BinaryExpression {\n    return new BinaryExpression(operator, left, right, range);\n  }\n\n  static createCallExpression(\n    expression: Expression,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): CallExpression {\n    return new CallExpression(expression, typeArguments, args, range);\n  }\n\n  static createClassExpression(\n    declaration: ClassDeclaration\n  ): ClassExpression {\n    return new ClassExpression(declaration);\n  }\n\n  static createCommaExpression(\n    expressions: Expression[],\n    range: Range\n  ): CommaExpression {\n    return new CommaExpression(expressions, range);\n  }\n\n  static createConstructorExpression(\n    range: Range\n  ): ConstructorExpression {\n    return new ConstructorExpression(range);\n  }\n\n  static createElementAccessExpression(\n    expression: Expression,\n    elementExpression: Expression,\n    range: Range\n  ): ElementAccessExpression {\n    return new ElementAccessExpression(expression, elementExpression, range);\n  }\n\n  static createFalseExpression(\n    range: Range\n  ): FalseExpression {\n    return new FalseExpression(range);\n  }\n\n  static createFloatLiteralExpression(\n    value: f64,\n    range: Range\n  ): FloatLiteralExpression {\n    return new FloatLiteralExpression(value, range);\n  }\n\n  static createFunctionExpression(\n    declaration: FunctionDeclaration\n  ): FunctionExpression {\n    return new FunctionExpression(declaration);\n  }\n\n  static createInstanceOfExpression(\n    expression: Expression,\n    isType: TypeNode,\n    range: Range\n  ): InstanceOfExpression {\n    return new InstanceOfExpression(expression, isType, range);\n  }\n\n  static createIntegerLiteralExpression(\n    value: i64,\n    range: Range\n  ): IntegerLiteralExpression {\n    return new IntegerLiteralExpression(value, range);\n  }\n\n  static createNewExpression(\n    typeName: TypeName,\n    typeArguments: TypeNode[] | null,\n    args: Expression[],\n    range: Range\n  ): NewExpression {\n    return new NewExpression(typeName, typeArguments, args, range);\n  }\n\n  static createNullExpression(\n    range: Range\n  ): NullExpression {\n    return new NullExpression(range);\n  }\n\n  static createObjectLiteralExpression(\n    names: IdentifierExpression[],\n    values: Expression[],\n    range: Range\n  ): ObjectLiteralExpression {\n    return new ObjectLiteralExpression(names, values, range);\n  }\n\n  static createOmittedExpression(\n    range: Range\n  ): OmittedExpression {\n    return new OmittedExpression(range);\n  }\n\n  static createParenthesizedExpression(\n    expression: Expression,\n    range: Range\n  ): ParenthesizedExpression {\n    return new ParenthesizedExpression(expression, range);\n  }\n\n  static createPropertyAccessExpression(\n    expression: Expression,\n    property: IdentifierExpression,\n    range: Range\n  ): PropertyAccessExpression {\n    return new PropertyAccessExpression(expression, property, range);\n  }\n\n  static createRegexpLiteralExpression(\n    pattern: string,\n    patternFlags: string,\n    range: Range\n  ): RegexpLiteralExpression {\n    return new RegexpLiteralExpression(pattern, patternFlags, range);\n  }\n\n  static createTernaryExpression(\n    condition: Expression,\n    ifThen: Expression,\n    ifElse: Expression,\n    range: Range\n  ): TernaryExpression {\n    return new TernaryExpression(condition, ifThen, ifElse, range);\n  }\n\n  static createStringLiteralExpression(\n    value: string,\n    range: Range\n  ): StringLiteralExpression {\n    return new StringLiteralExpression(value, range);\n  }\n\n  static createSuperExpression(\n    range: Range\n  ): SuperExpression {\n    return new SuperExpression(range);\n  }\n\n  static createThisExpression(\n    range: Range\n  ): ThisExpression {\n    return new ThisExpression(range);\n  }\n\n  static createTrueExpression(\n    range: Range\n  ): TrueExpression {\n    return new TrueExpression(range);\n  }\n\n  static createUnaryPostfixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPostfixExpression {\n    return new UnaryPostfixExpression(operator, operand, range);\n  }\n\n  static createUnaryPrefixExpression(\n    operator: Token,\n    operand: Expression,\n    range: Range\n  ): UnaryPrefixExpression {\n    return new UnaryPrefixExpression(operator, operand, range);\n  }\n\n  // statements\n\n  static createBlockStatement(\n    statements: Statement[],\n    range: Range\n  ): BlockStatement {\n    return new BlockStatement(statements, range);\n  }\n\n  static createBreakStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): BreakStatement {\n    return new BreakStatement(label, range);\n  }\n\n  static createClassDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): ClassDeclaration {\n    return new ClassDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createContinueStatement(\n    label: IdentifierExpression | null,\n    range: Range\n  ): ContinueStatement {\n    return new ContinueStatement(label, range);\n  }\n\n  static createDoStatement(\n    statement: Statement,\n    condition: Expression,\n    range: Range\n  ): DoStatement {\n    return new DoStatement(statement, condition, range);\n  }\n\n  static createEmptyStatement(\n    range: Range\n  ): EmptyStatement {\n    return new EmptyStatement(range);\n  }\n\n  static createEnumDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    values: EnumValueDeclaration[],\n    range: Range\n  ): EnumDeclaration {\n    return new EnumDeclaration(name, decorators, flags, values, range);\n  }\n\n  static createEnumValueDeclaration(\n    name: IdentifierExpression,\n    flags: CommonFlags,\n    initializer: Expression | null,\n    range: Range\n  ): EnumValueDeclaration {\n    return new EnumValueDeclaration(name, flags, initializer, range);\n  }\n\n  static createExportStatement(\n    members: ExportMember[] | null,\n    path: StringLiteralExpression | null,\n    isDeclare: bool,\n    range: Range\n  ): ExportStatement {\n    return new ExportStatement(members, path, isDeclare, range);\n  }\n\n  static createExportDefaultStatement(\n    declaration: DeclarationStatement,\n    range: Range\n  ): ExportDefaultStatement {\n    return new ExportDefaultStatement(declaration, range);\n  }\n\n  static createExportImportStatement(\n    name: IdentifierExpression,\n    externalName: IdentifierExpression,\n    range: Range\n  ): ExportImportStatement {\n    return new ExportImportStatement(name, externalName, range);\n  }\n\n  static createExportMember(\n    localName: IdentifierExpression,\n    exportedName: IdentifierExpression | null,\n    range: Range\n  ): ExportMember {\n    if (!exportedName) exportedName = localName;\n    return new ExportMember(localName, exportedName, range);\n  }\n\n  static createExpressionStatement(\n    expression: Expression\n  ): ExpressionStatement {\n    return new ExpressionStatement(expression);\n  }\n\n  static createIfStatement(\n    condition: Expression,\n    ifTrue: Statement,\n    ifFalse: Statement | null,\n    range: Range\n  ): IfStatement {\n    return new IfStatement(condition, ifTrue, ifFalse, range);\n  }\n\n  static createImportStatement(\n    declarations: ImportDeclaration[] | null,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(declarations, null, path, range);\n  }\n\n  static createWildcardImportStatement(\n    namespaceName: IdentifierExpression,\n    path: StringLiteralExpression,\n    range: Range\n  ): ImportStatement {\n    return new ImportStatement(null, namespaceName, path, range);\n  }\n\n  static createImportDeclaration(\n    foreignName: IdentifierExpression,\n    name: IdentifierExpression | null,\n    range: Range\n  ): ImportDeclaration {\n    if (!name) name = foreignName;\n    return new ImportDeclaration(name, foreignName, range);\n  }\n\n  static createInterfaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    extendsType: NamedTypeNode | null,\n    implementsTypes: NamedTypeNode[] | null,\n    members: DeclarationStatement[],\n    range: Range\n  ): InterfaceDeclaration {\n    return new InterfaceDeclaration(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n  }\n\n  static createFieldDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): FieldDeclaration {\n    return new FieldDeclaration(name, decorators, flags, type, initializer, -1, range);\n  }\n\n  static createForStatement(\n    initializer: Statement | null,\n    condition: Expression | null,\n    incrementor: Expression | null,\n    statement: Statement,\n    range: Range\n  ): ForStatement {\n    return new ForStatement(initializer, condition, incrementor, statement, range);\n  }\n\n  static createForOfStatement(\n    variable: Statement,\n    iterable: Expression,\n    statement: Statement,\n    range: Range\n  ): ForOfStatement {\n    return new ForOfStatement(variable, iterable, statement, range);\n  }\n\n  static createFunctionDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    arrowKind: ArrowKind,\n    range: Range\n  ): FunctionDeclaration {\n    return new FunctionDeclaration(name, decorators, flags, typeParameters, signature, body, arrowKind, range);\n  }\n\n  static createIndexSignature(\n    keyType: NamedTypeNode,\n    valueType: TypeNode,\n    flags: CommonFlags,\n    range: Range\n  ): IndexSignatureNode {\n    return new IndexSignatureNode(keyType, valueType, flags, range);\n  }\n\n  static createMethodDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    signature: FunctionTypeNode,\n    body: Statement | null,\n    range: Range\n  ): MethodDeclaration {\n    return new MethodDeclaration(name, decorators, flags, typeParameters, signature, body, range);\n  }\n\n  static createNamespaceDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    members: Statement[],\n    range: Range\n  ): NamespaceDeclaration {\n    return new NamespaceDeclaration(name, decorators, flags, members, range);\n  }\n\n  static createReturnStatement(\n    value: Expression | null,\n    range: Range\n  ): ReturnStatement {\n    return new ReturnStatement(value, range);\n  }\n\n  static createSwitchStatement(\n    condition: Expression,\n    cases: SwitchCase[],\n    range: Range\n  ): SwitchStatement {\n    return new SwitchStatement(condition, cases, range);\n  }\n\n  static createSwitchCase(\n    label: Expression | null,\n    statements: Statement[],\n    range: Range\n  ): SwitchCase {\n    return new SwitchCase(label, statements, range);\n  }\n\n  static createThrowStatement(\n    value: Expression,\n    range: Range\n  ): ThrowStatement {\n    return new ThrowStatement(value, range);\n  }\n\n  static createTryStatement(\n    statements: Statement[],\n    catchVariable: IdentifierExpression | null,\n    catchStatements: Statement[] | null,\n    finallyStatements: Statement[] | null,\n    range: Range\n  ): TryStatement {\n    return new TryStatement(statements, catchVariable, catchStatements, finallyStatements, range);\n  }\n\n  static createTypeDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    typeParameters: TypeParameterNode[] | null,\n    type: TypeNode,\n    range: Range\n  ): TypeDeclaration {\n    return new TypeDeclaration(name, decorators, flags, typeParameters, type, range);\n  }\n\n  static createVariableStatement(\n    decorators: DecoratorNode[] | null,\n    declarations: VariableDeclaration[],\n    range: Range\n  ): VariableStatement {\n    return new VariableStatement(decorators, declarations, range);\n  }\n\n  static createVariableDeclaration(\n    name: IdentifierExpression,\n    decorators: DecoratorNode[] | null,\n    flags: CommonFlags,\n    type: TypeNode | null,\n    initializer: Expression | null,\n    range: Range\n  ): VariableDeclaration {\n    return new VariableDeclaration(name, decorators, flags, type, initializer, range);\n  }\n\n  static createVoidStatement(\n    expression: Expression,\n    range: Range\n  ): VoidStatement {\n    return new VoidStatement(expression, range);\n  }\n\n  static createWhileStatement(\n    condition: Expression,\n    statement: Statement,\n    range: Range\n  ): WhileStatement {\n    return new WhileStatement(condition, statement, range);\n  }\n\n  /** Tests if this node is a literal of the specified kind. */\n  isLiteralKind(literalKind: LiteralKind): bool {\n    return this.kind == NodeKind.LITERAL\n        && (<LiteralExpression>changetype<Node>(this)).literalKind == literalKind; // TS\n  }\n\n  /** Tests if this node is a literal of a numeric kind (float or integer). */\n  get isNumericLiteral(): bool {\n    if (this.kind == NodeKind.LITERAL) {\n      switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n        case LiteralKind.FLOAT:\n        case LiteralKind.INTEGER: return true;\n      }\n    }\n    return false;\n  }\n\n  /** Tests whether this node is guaranteed to compile to a constant value. */\n  get compilesToConst(): bool {\n    switch (this.kind) {\n      case NodeKind.LITERAL: {\n        switch ((<LiteralExpression>changetype<Node>(this)).literalKind) { // TS\n          case LiteralKind.FLOAT:\n          case LiteralKind.INTEGER:\n          case LiteralKind.STRING: return true;\n        }\n        break;\n      }\n      case NodeKind.NULL:\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return true;\n    }\n    return false;\n  }\n\n  private isAccessOn(kind: NodeKind): bool {\n    let node = changetype<Node>(this);\n    if (node.kind == NodeKind.CALL) {\n      node = (<CallExpression>node).expression;\n    }\n    if (node.kind == NodeKind.PROPERTYACCESS) {\n      let target = (<PropertyAccessExpression>node).expression;\n      if (target.kind == kind) return true;\n    }\n    return false;\n  }\n\n  /** Checks if this node accesses a method or property on `this`. */\n  get isAccessOnThis(): bool {\n    return this.isAccessOn(NodeKind.THIS);\n  }\n\n  /** Checks if this node accesses a method or property on `super`. */\n  get isAccessOnSuper(): bool {\n    return this.isAccessOn(NodeKind.SUPER);\n  }\n}\n\n// types\n\nexport abstract class TypeNode extends Node {\n  constructor(\n    /** Kind of the type node. */\n    kind: NodeKind,\n    /** Whether nullable or not. */\n    public isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this type has a generic component matching one of the given type parameters. */\n  hasGenericComponent(typeParameterNodes: TypeParameterNode[]): bool {\n    if (this.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>changetype<TypeNode>(this); // TS\n      if (!namedTypeNode.name.next) {\n        let typeArgumentNodes = namedTypeNode.typeArguments;\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          for (let i = 0, k = typeArgumentNodes.length; i < k; ++i) {\n            if (typeArgumentNodes[i].hasGenericComponent(typeParameterNodes)) return true;\n          }\n        } else {\n          let name = namedTypeNode.name.identifier.text;\n          for (let i = 0, k = typeParameterNodes.length; i < k; ++i) {\n            if (typeParameterNodes[i].name.text == name) return true;\n          }\n        }\n      }\n    } else if (this.kind == NodeKind.FUNCTIONTYPE) {\n      let functionTypeNode = <FunctionTypeNode>changetype<TypeNode>(this); // TS\n      let parameterNodes = functionTypeNode.parameters;\n      for (let i = 0, k = parameterNodes.length; i < k; ++i) {\n        if (parameterNodes[i].type.hasGenericComponent(typeParameterNodes)) return true;\n      }\n      if (functionTypeNode.returnType.hasGenericComponent(typeParameterNodes)) return true;\n      let explicitThisType = functionTypeNode.explicitThisType;\n      if (explicitThisType !== null && explicitThisType.hasGenericComponent(typeParameterNodes)) return true;\n    } else {\n      assert(false);\n    }\n    return false;\n  }\n}\n\n/** Represents a type name. */\nexport class TypeName extends Node {\n  constructor(\n    /** Identifier of this part. */\n    public identifier: IdentifierExpression,\n    /** Next part of the type name or `null` if this is the last part. */\n    public next: TypeName | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPENAME, range);\n  }\n}\n\n/** Represents a named type. */\nexport class NamedTypeNode extends TypeNode {\n  constructor(\n    /** Type name. */\n    public name: TypeName,\n    /** Type argument references. */\n    public typeArguments: TypeNode[] | null,\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMEDTYPE, isNullable, range);\n  }\n\n  /** Checks if this type node has type arguments. */\n  get hasTypeArguments(): bool {\n    var typeArguments = this.typeArguments;\n    return typeArguments !== null && typeArguments.length > 0;\n  }\n}\n\n/** Represents a function type. */\nexport class FunctionTypeNode extends TypeNode {\n  constructor(\n    /** Function parameters. */\n    public parameters: ParameterNode[],\n    /** Return type. */\n    public returnType: TypeNode,\n    /** Explicitly provided this type, if any. */\n    public explicitThisType: NamedTypeNode | null, // can't be a function\n    /** Whether nullable or not. */\n    isNullable: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONTYPE, isNullable, range);\n  }\n}\n\n/** Represents a type parameter. */\nexport class TypeParameterNode extends Node {\n  constructor(\n    /** Identifier reference. */\n    public name: IdentifierExpression,\n    /** Extended type reference, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Default type if omitted, if any. */\n    public defaultType: NamedTypeNode | null, // can't be a function\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEPARAMETER, range);\n  }\n}\n\n/** Represents the kind of a parameter. */\nexport enum ParameterKind {\n  /** No specific flags. */\n  DEFAULT,\n  /** Is an optional parameter. */\n  OPTIONAL,\n  /** Is a rest parameter. */\n  REST\n}\n\n/** Represents a function parameter. */\nexport class ParameterNode extends Node {\n  constructor(\n    /** Parameter kind. */\n    public parameterKind: ParameterKind,\n    /** Parameter name. */\n    public name: IdentifierExpression,\n    /** Parameter type. */\n    public type: TypeNode,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARAMETER, range);\n  }\n\n  /** Implicit field declaration, if applicable. */\n  implicitFieldDeclaration: FieldDeclaration | null = null;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n// special\n\n/** Built-in decorator kinds. */\nexport enum DecoratorKind {\n  CUSTOM,\n  GLOBAL,\n  OPERATOR,\n  OPERATOR_BINARY,\n  OPERATOR_PREFIX,\n  OPERATOR_POSTFIX,\n  UNMANAGED,\n  FINAL,\n  INLINE,\n  EXTERNAL,\n  BUILTIN,\n  LAZY,\n  UNSAFE,\n  /* Extension add START */\n  MESSAGE,\n  STORAGE,\n  DEPLOYER,\n  CONTRACT,\n  DATABASE,\n  PRIMARYID\n  /* Extension add END */\n}\n\nexport namespace DecoratorKind {\n\n  /** Returns the kind of the specified decorator name node. Defaults to {@link DecoratorKind.CUSTOM}. */\n  export function fromNode(nameNode: Expression): DecoratorKind {\n    if (nameNode.kind == NodeKind.IDENTIFIER) {\n      let nameStr = (<IdentifierExpression>nameNode).text;\n      assert(nameStr.length);\n      switch (nameStr.charCodeAt(0)) {\n        case CharCode.b: {\n          if (nameStr == \"builtin\") return DecoratorKind.BUILTIN;\n          break;\n        }\n        /* Extension add START */\n        case CharCode.c: {\n          if (nameStr == 'contract') return DecoratorKind.CONTRACT;\n          break;\n        }\n        case CharCode.d: {\n          if (nameStr == 'deployer') return DecoratorKind.DEPLOYER;\n          break;\n        }\n        /* Extension add END */\n        case CharCode.e: {\n          if (nameStr == \"external\") return DecoratorKind.EXTERNAL;\n          break;\n        }\n        case CharCode.f: {\n          if (nameStr == \"final\") return DecoratorKind.FINAL;\n          break;\n        }\n        case CharCode.g: {\n          if (nameStr == \"global\") return DecoratorKind.GLOBAL;\n          break;\n        }\n        case CharCode.i: {\n          if (nameStr == \"inline\") return DecoratorKind.INLINE;\n          break;\n        }\n        case CharCode.l: {\n          if (nameStr == \"lazy\") return DecoratorKind.LAZY;\n          break;\n        }\n        /* Extension add START */\n        case CharCode.m: {\n          if (nameStr == \"message\") return DecoratorKind.MESSAGE;\n          break;\n        }\n        /* Extension add END */\n        case CharCode.o: {\n          if (nameStr == \"operator\") return DecoratorKind.OPERATOR;\n          break;\n        }\n        /* Extension add START */\n        case CharCode.s: {\n          if (nameStr == \"storage\") return DecoratorKind.STORAGE;\n          break;\n        }\n        /* Extension add END */\n        case CharCode.u: {\n          if (nameStr == \"unmanaged\") return DecoratorKind.UNMANAGED;\n          if (nameStr == \"unsafe\") return DecoratorKind.UNSAFE;\n          break;\n        }\n      }\n    } else if (nameNode.kind == NodeKind.PROPERTYACCESS) {\n      let propertyAccessNode = <PropertyAccessExpression>nameNode;\n      let expression = propertyAccessNode.expression;\n      if (expression.kind == NodeKind.IDENTIFIER) {\n        let nameStr = (<IdentifierExpression>expression).text;\n        assert(nameStr.length);\n        let propStr = propertyAccessNode.property.text;\n        assert(propStr.length);\n        if (nameStr == \"operator\") {\n          switch (propStr.charCodeAt(0)) {\n            case CharCode.b: {\n              if (propStr == \"binary\") return DecoratorKind.OPERATOR_BINARY;\n              break;\n            }\n            case CharCode.p: {\n              if (propStr == \"prefix\") return DecoratorKind.OPERATOR_PREFIX;\n              if (propStr == \"postfix\") return DecoratorKind.OPERATOR_POSTFIX;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return DecoratorKind.CUSTOM;\n  }\n}\n\n/** Represents a decorator. */\nexport class DecoratorNode extends Node {\n  constructor(\n    /** Built-in decorator kind, or custom. */\n    public decoratorKind: DecoratorKind,\n    /** Name expression. */\n    public name: Expression,\n    /** Argument expressions. */\n    public args: Expression[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DECORATOR, range);\n  }\n}\n\n/** Comment kinds. */\nexport enum CommentKind {\n  /** Line comment. */\n  LINE,\n  /** Triple-slash line comment. */\n  TRIPLE,\n  /** Block comment. */\n  BLOCK\n}\n\n/** Represents a comment. */\nexport class CommentNode extends Node {\n  constructor(\n    /** Comment kind. */\n    public commentKind: CommentKind,\n    /** Comment text. */\n    public text: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMENT, range);\n  }\n}\n\n// expressions\n\n/** Base class of all expression nodes. */\nexport abstract class Expression extends Node { }\n\n/** Represents an identifier expression. */\nexport class IdentifierExpression extends Expression {\n  constructor(\n    /** Textual name. */\n    public text: string,\n    /** Whether quoted or not. */\n    public isQuoted: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IDENTIFIER, range);\n  }\n}\n\n/** Indicates the kind of a literal. */\nexport enum LiteralKind {\n  FLOAT,\n  INTEGER,\n  STRING,\n  REGEXP,\n  ARRAY,\n  OBJECT\n}\n\n/** Base class of all literal expressions. */\nexport abstract class LiteralExpression extends Expression {\n  constructor(\n    /** Specific literal kind. */\n    public literalKind: LiteralKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.LITERAL, range);\n  }\n}\n\n/** Represents an `[]` literal expression. */\nexport class ArrayLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Nested element expressions. */\n    public elementExpressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.ARRAY, range);\n  }\n}\n\n/** Indicates the kind of an assertion. */\nexport enum AssertionKind {\n  /** A prefix assertion, i.e. `<T>expr`. */\n  PREFIX,\n  /** An as assertion, i.e. `expr as T`. */\n  AS,\n  /** A non-null assertion, i.e. `!expr`. */\n  NONNULL,\n  /** A const assertion, i.e. `expr as const`. */\n  CONST\n}\n\n/** Represents an assertion expression. */\nexport class AssertionExpression extends Expression {\n  constructor(\n    /** Specific kind of this assertion. */\n    public assertionKind: AssertionKind,\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Target type, if applicable. */\n    public toType: TypeNode | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ASSERTION, range);\n  }\n}\n\n/** Represents a binary expression. */\nexport class BinaryExpression extends Expression {\n  constructor(\n    /** Operator token. */\n    public operator: Token,\n    /** Left-hand side expression */\n    public left: Expression,\n    /** Right-hand side expression. */\n    public right: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BINARY, range);\n  }\n}\n\n/** Represents a call expression. */\nexport class CallExpression extends Expression {\n  constructor(\n    /** Called expression. Usually an identifier or property access expression. */\n    public expression: Expression,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CALL, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments) {\n      if (numTypeArguments = typeArguments.length) {\n        return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n      }\n    }\n    return this.expression.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.expression.range;\n  }\n}\n\n/** Represents a class expression using the 'class' keyword. */\nexport class ClassExpression extends Expression {\n  constructor(\n    /** Inline class declaration. */\n    public declaration: ClassDeclaration\n  ) {\n    super(NodeKind.CLASS, declaration.range);\n  }\n}\n\n/** Represents a comma expression composed of multiple expressions. */\nexport class CommaExpression extends Expression {\n  constructor(\n    /** Sequential expressions. */\n    public expressions: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.COMMA, range);\n  }\n}\n\n/** Represents a `constructor` expression. */\nexport class ConstructorExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"constructor\", false, range);\n    this.kind = NodeKind.CONSTRUCTOR;\n  }\n}\n\n/** Represents an element access expression, e.g., array access. */\nexport class ElementAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Element of the expression being accessed. */\n    public elementExpression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ELEMENTACCESS, range);\n  }\n}\n\n/** Represents a float literal expression. */\nexport class FloatLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Float value. */\n    public value: f64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.FLOAT, range);\n  }\n}\n\n/** Represents a function expression using the 'function' keyword. */\nexport class FunctionExpression extends Expression {\n  constructor(\n    /** Inline function declaration. */\n    public declaration: FunctionDeclaration\n  ) {\n    super(NodeKind.FUNCTION, declaration.range);\n  }\n}\n\n/** Represents an `instanceof` expression. */\nexport class InstanceOfExpression extends Expression {\n  constructor(\n    /** Expression being asserted. */\n    public expression: Expression,\n    /** Type to test for. */\n    public isType: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INSTANCEOF, range);\n  }\n}\n\n/** Represents an integer literal expression. */\nexport class IntegerLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Integer value. */\n    public value: i64,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.INTEGER, range);\n  }\n}\n\n/** Represents a `new` expression. Like a call but with its own kind. */\nexport class NewExpression extends Expression {\n  constructor(\n    /** Type being constructed. */\n    public typeName: TypeName,\n    /** Provided type arguments. */\n    public typeArguments: TypeNode[] | null,\n    /** Provided arguments. */\n    public args: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NEW, range);\n  }\n\n  /** Gets the type arguments range for reporting. */\n  get typeArgumentsRange(): Range {\n    var typeArguments = this.typeArguments;\n    var numTypeArguments: i32;\n    if (typeArguments !== null && (numTypeArguments = typeArguments.length) > 0) {\n      return Range.join(typeArguments[0].range, typeArguments[numTypeArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n\n  /** Gets the arguments range for reporting. */\n  get argumentsRange(): Range {\n    var args = this.args;\n    var numArguments = args.length;\n    if (numArguments) {\n      return Range.join(args[0].range, args[numArguments - 1].range);\n    }\n    return this.typeName.range;\n  }\n}\n\n/** Represents a `null` expression. */\nexport class NullExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"null\", false, range);\n    this.kind = NodeKind.NULL;\n  }\n}\n\n/** Represents an object literal expression. */\nexport class ObjectLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Field names. */\n    public names: IdentifierExpression[],\n    /** Field values. */\n    public values: Expression[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.OBJECT, range);\n  }\n}\n\n/** Represents an omitted expression, e.g. within an array literal. */\nexport class OmittedExpression extends Expression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.OMITTED, range);\n  }\n}\n\n/** Represents a parenthesized expression. */\nexport class ParenthesizedExpression extends Expression {\n  constructor(\n    /** Expression in parenthesis. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PARENTHESIZED, range);\n  }\n}\n\n/** Represents a property access expression. */\nexport class PropertyAccessExpression extends Expression {\n  constructor(\n    /** Expression being accessed. */\n    public expression: Expression,\n    /** Property of the expression being accessed. */\n    public property: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.PROPERTYACCESS, range);\n  }\n}\n\n/** Represents a regular expression literal expression. */\nexport class RegexpLiteralExpression extends LiteralExpression {\n  constructor(\n    /** Regular expression pattern. */\n    public pattern: string,\n    /** Regular expression flags. */\n    public patternFlags: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.REGEXP, range);\n  }\n}\n\n/** Represents a ternary expression, i.e., short if notation. */\nexport class TernaryExpression extends Expression {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Expression executed when condition is `true`. */\n    public ifThen: Expression,\n    /** Expression executed when condition is `false`. */\n    public ifElse: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TERNARY, range);\n  }\n}\n\n/** Represents a string literal expression. */\nexport class StringLiteralExpression extends LiteralExpression {\n  constructor(\n    /** String value without quotes. */\n    public value: string,\n    /** Source range. */\n    range: Range\n  ) {\n    super(LiteralKind.STRING, range);\n  }\n}\n\n/** Represents a `super` expression. */\nexport class SuperExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"super\", false, range);\n    this.kind = NodeKind.SUPER;\n  }\n}\n\n/** Represents a `this` expression. */\nexport class ThisExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"this\", false, range);\n    this.kind = NodeKind.THIS;\n  }\n}\n\n/** Represents a `true` expression. */\nexport class TrueExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"true\", false, range);\n    this.kind = NodeKind.TRUE;\n  }\n}\n\n/** Represents a `false` expression. */\nexport class FalseExpression extends IdentifierExpression {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(\"false\", false, range);\n    this.kind = NodeKind.FALSE;\n  }\n}\n\n/** Base class of all unary expressions. */\nexport abstract class UnaryExpression extends Expression {\n  constructor(\n    /** Unary expression kind. */\n    kind: NodeKind,\n    /** Operator token. */\n    public operator: Token,\n    /** Operand expression. */\n    public operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n}\n\n/** Represents a unary postfix expression, e.g. a postfix increment. */\nexport class UnaryPostfixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPOSTFIX, operator, operand, range);\n  }\n}\n\n/** Represents a unary prefix expression, e.g. a negation. */\nexport class UnaryPrefixExpression extends UnaryExpression {\n  constructor(\n    /** Operator token. */\n    operator: Token,\n    /** Operand expression. */\n    operand: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.UNARYPREFIX, operator, operand, range);\n  }\n}\n\n// statements\n\n/** Base class of all statement nodes. */\nexport abstract class Statement extends Node { }\n\n/** Indicates the specific kind of a source. */\nexport enum SourceKind {\n  /** User-provided file. */\n  USER = 0,\n  /** User-provided entry file. */\n  USER_ENTRY = 1,\n  /** Library-provided file. */\n  LIBRARY = 2,\n  /** Library-provided entry file. */\n  LIBRARY_ENTRY = 3\n}\n\n/** A top-level source node. */\nexport class Source extends Node {\n  constructor(\n    /** Source kind. */\n    public sourceKind: SourceKind,\n    /** Normalized path with file extension. */\n    public normalizedPath: string,\n    /** Full source text. */\n    public text: string\n  ) {\n    super(NodeKind.SOURCE, new Range(0, text.length));\n    var internalPath = mangleInternalPath(normalizedPath);\n    this.internalPath = internalPath;\n    var pos = internalPath.lastIndexOf(PATH_DELIMITER);\n    this.simplePath = pos >= 0 ? internalPath.substring(pos + 1) : internalPath;\n    this.range.source = this;\n  }\n\n  /** Path used internally. */\n  internalPath: string;\n  /** Simple path (last part without extension). */\n  simplePath: string;\n  /** Contained statements. */\n  statements: Statement[] = new Array();\n  /** Source map index. */\n  debugInfoIndex: i32 = -1;\n  /** Re-exported sources. */\n  exportPaths: string[] | null = null;\n\n  /** Checks if this source represents native code. */\n  get isNative(): bool {\n    return this.internalPath == LIBRARY_SUBST;\n  }\n\n  /** Checks if this source is part of the (standard) library. */\n  get isLibrary(): bool {\n    var kind = this.sourceKind;\n    return kind == SourceKind.LIBRARY || kind == SourceKind.LIBRARY_ENTRY;\n  }\n\n  /** Cached line starts. */\n  private lineCache: i32[] | null = null;\n\n  /** Remembered column number. */\n  private lineColumn: i32 = 1;\n\n  /** Determines the line number at the specified position. Starts at `1`. */\n  lineAt(pos: i32): i32 {\n    assert(pos >= 0 && pos < 0x7fffffff);\n    var lineCache = this.lineCache;\n    if (!lineCache) {\n      this.lineCache = lineCache = [0];\n      let text = this.text;\n      let off = 0;\n      let end = text.length;\n      while (off < end) {\n        if (text.charCodeAt(off++) == CharCode.LINEFEED) lineCache.push(off);\n      }\n      lineCache.push(0x7fffffff);\n    }\n    var l = 0;\n    var r = lineCache.length - 1;\n    while (l < r) {\n      let m = l + ((r - l) >> 1);\n      let s = unchecked(lineCache[m]);\n      if (pos < s) r = m;\n      else if (pos < unchecked(lineCache[m + 1])) {\n        this.lineColumn = pos - s + 1;\n        return m + 1;\n      }\n      else l = m + 1;\n    }\n    return assert(0);\n  }\n\n  /** Gets the column number at the last position queried with `lineAt`. Starts at `1`. */\n  columnAt(): i32 {\n    return this.lineColumn;\n  }\n}\n\n/** Base class of all declaration statements. */\nexport abstract class DeclarationStatement extends Statement {\n  constructor(\n    /** Declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    public name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    public decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, range);\n  }\n\n  /** Tests if this node has the specified flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this node has one of the specified flags. */\n  isAny(flag: CommonFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n}\n\n/** Represents an index signature. */\nexport class IndexSignatureNode extends Node {\n  constructor(\n    /** Key type. */\n    public keyType: NamedTypeNode,\n    /** Value type. */\n    public valueType: TypeNode,\n    /** Common flags indicating specific traits. */\n    public flags: CommonFlags,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.INDEXSIGNATURE, range);\n  }\n}\n\n/** Base class of all variable-like declaration statements. */\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\n  constructor(\n    /** Variable-like declaration node kind. */\n    kind: NodeKind,\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    public type: TypeNode | null,\n    /** Initializer expression, if any. */\n    public initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(kind, name, decorators, flags, range);\n  }\n}\n\n/** Represents a block statement. */\nexport class BlockStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BLOCK, range);\n  }\n}\n\n/** Represents a `break` statement. */\nexport class BreakStatement extends Statement {\n  constructor(\n    /** Target label, if any. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.BREAK, range);\n  }\n}\n\n/** Represents a `class` declaration. */\nexport class ClassDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    public extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    public implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    public members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CLASSDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Index signature, if present. */\n  indexSignature: IndexSignatureNode | null = null;\n\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n}\n\n/** Represents a `continue` statement. */\nexport class ContinueStatement extends Statement {\n  constructor(\n    /** Target label, if applicable. */\n    public label: IdentifierExpression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.CONTINUE, range);\n  }\n}\n\n/** Represents a `do` statement. */\nexport class DoStatement extends Statement {\n  constructor(\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Condition when to repeat. */\n    public condition: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.DO, range);\n  }\n}\n\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\nexport class EmptyStatement extends Statement {\n  constructor(\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EMPTY, range);\n  }\n}\n\n/** Represents an `enum` declaration. */\nexport class EnumDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Enum value declarations. */\n    public values: EnumValueDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a value of an `enum` declaration. */\nexport class EnumValueDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.ENUMVALUEDECLARATION, name, null, flags, null, initializer, range);\n  }\n}\n\n/** Represents an `export import` statement of an interface. */\nexport class ExportImportStatement extends Statement {\n  constructor(\n    /** Identifier being imported. */\n    public name: IdentifierExpression,\n    /** Identifier being exported. */\n    public externalName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTIMPORT, range);\n  }\n}\n\n/** Represents a member of an `export` statement. */\nexport class ExportMember extends Node {\n  constructor(\n    /** Local identifier. */\n    public localName: IdentifierExpression,\n    /** Exported identifier. */\n    public exportedName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTMEMBER, range);\n  }\n}\n\n/** Represents an `export` statement. */\nexport class ExportStatement extends Statement {\n  constructor(\n    /** Array of members if a set of named exports, or `null` if a file export. */\n    public members: ExportMember[] | null,\n    /** Path being exported from, if applicable. */\n    public path: StringLiteralExpression | null,\n    /** Whether this is a declared export. */\n    public isDeclare: bool,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORT, range);\n    if (path) {\n      let normalizedPath = normalizePath(path.value);\n      if (path.value.startsWith(\".\")) { // relative\n        normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n      } else { // absolute\n        if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n      }\n      this.internalPath = normalizedPath;\n    } else {\n      this.internalPath = null;\n    }\n  }\n\n  /** Internal path being referenced, if `path` is set. */\n  internalPath: string | null;\n}\n\n/** Represents an `export default` statement. */\nexport class ExportDefaultStatement extends Statement {\n  constructor(\n    /** Declaration being exported as default. */\n    public declaration: DeclarationStatement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.EXPORTDEFAULT, range);\n  }\n}\n\n/** Represents an expression that is used as a statement. */\nexport class ExpressionStatement extends Statement {\n  constructor(\n    /** Expression being used as a statement.*/\n    public expression: Expression\n  ) {\n    super(NodeKind.EXPRESSION, expression.range);\n  }\n}\n\n/** Represents a field declaration within a `class`. */\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Parameter index if declared as a constructor parameter, otherwise `-1`. */\n    public parameterIndex: i32,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FIELDDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a `for` statement. */\nexport class ForStatement extends Statement {\n  constructor(\n    /** Initializer statement, if present. Either a `VariableStatement` or `ExpressionStatement`. */\n    public initializer: Statement | null,\n    /** Condition expression, if present. */\n    public condition: Expression | null,\n    /** Incrementor expression, if present. */\n    public incrementor: Expression | null,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOR, range);\n  }\n}\n\n/** Represents a `for..of` statement. */\nexport class ForOfStatement extends Statement {\n  constructor(\n    /** Variable statement. Either a `VariableStatement` or `ExpressionStatement` of `IdentifierExpression`. */\n    public variable: Statement,\n    /** Iterable expression being iterated. */\n    public iterable: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FOROF, range);\n  }\n}\n\n/** Indicates the kind of an array function. */\nexport const enum ArrowKind {\n  /** Not an arrow function. */\n  NONE,\n  /** Parenthesized parameter list. */\n  ARROW_PARENTHESIZED,\n  /** Single parameter without parenthesis. */\n  ARROW_SINGLE\n}\n\n/** Represents a `function` declaration. */\nexport class FunctionDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    public signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    public body: Statement | null,\n    /** Arrow function kind, if applicable. */\n    public arrowKind: ArrowKind,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.FUNCTIONDECLARATION, name, decorators, flags, range);\n  }\n\n  /** Gets if this function is generic. */\n  get isGeneric(): bool {\n    var typeParameters = this.typeParameters;\n    return typeParameters != null && typeParameters.length > 0;\n  }\n\n  /** Clones this function declaration. */\n  clone(): FunctionDeclaration {\n    return new FunctionDeclaration(\n      this.name,\n      this.decorators,\n      this.flags,\n      this.typeParameters,\n      this.signature,\n      this.body,\n      this.arrowKind,\n      this.range\n    );\n  }\n}\n\n/** Represents an `if` statement. */\nexport class IfStatement extends Statement {\n  constructor(\n    /** Condition. */\n    public condition: Expression,\n    /** Statement executed when condition is `true`. */\n    public ifTrue: Statement,\n    /** Statement executed when condition is `false`. */\n    public ifFalse: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IF, range);\n  }\n}\n\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\nexport class ImportDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Identifier being imported. */\n    public foreignName: IdentifierExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORTDECLARATION, name, null, CommonFlags.NONE, range);\n  }\n}\n\n/** Represents an `import` statement. */\nexport class ImportStatement extends Statement {\n  constructor(\n    /** Array of member declarations or `null` if an asterisk import. */\n    public declarations: ImportDeclaration[] | null,\n    /** Name of the local namespace, if an asterisk import. */\n    public namespaceName: IdentifierExpression | null,\n    /** Path being imported from. */\n    public path: StringLiteralExpression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.IMPORT, range);\n    var normalizedPath = normalizePath(path.value);\n    if (path.value.startsWith(\".\")) { // relative in project\n      normalizedPath = resolvePath(normalizedPath, range.source.internalPath);\n    } else { // absolute in library\n      if (!normalizedPath.startsWith(LIBRARY_PREFIX)) normalizedPath = LIBRARY_PREFIX + normalizedPath;\n    }\n    this.internalPath = normalizedPath;\n  }\n\n  /** Internal path being referenced. */\n  internalPath: string;\n}\n\n/** Represents an `interfarce` declaration. */\nexport class InterfaceDeclaration extends ClassDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Accepted type parameters. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Base class type being extended, if any. */\n    extendsType: NamedTypeNode | null, // can't be a function\n    /** Interface types being implemented, if any. */\n    implementsTypes: NamedTypeNode[] | null, // can't be functions\n    /** Class member declarations. */\n    members: DeclarationStatement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, extendsType, implementsTypes, members, range);\n    this.kind = NodeKind.INTERFACEDECLARATION;\n  }\n}\n\n/** Represents a method declaration within a `class`. */\nexport class MethodDeclaration extends FunctionDeclaration {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    typeParameters: TypeParameterNode[] | null,\n    /** Function signature. */\n    signature: FunctionTypeNode,\n    /** Body statement. Usually a block. */\n    body: Statement | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(name, decorators, flags, typeParameters, signature, body, ArrowKind.NONE, range);\n    this.kind = NodeKind.METHODDECLARATION;\n  }\n}\n\n/** Represents a `namespace` declaration. */\nexport class NamespaceDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Array of namespace members. */\n    public members: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.NAMESPACEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a `return` statement. */\nexport class ReturnStatement extends Statement {\n  constructor(\n    /** Value expression being returned, if present. */\n    public value: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.RETURN, range);\n  }\n}\n\n/** Represents a single `case` within a `switch` statement. */\nexport class SwitchCase extends Node {\n  constructor(\n    /** Label expression. `null` indicates the default case. */\n    public label: Expression | null,\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCHCASE, range);\n  }\n}\n\n/** Represents a `switch` statement. */\nexport class SwitchStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Contained cases. */\n    public cases: SwitchCase[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.SWITCH, range);\n  }\n}\n\n/** Represents a `throw` statement. */\nexport class ThrowStatement extends Statement {\n  constructor(\n    /** Value expression being thrown. */\n    public value: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.THROW, range);\n  }\n}\n\n/** Represents a `try` statement. */\nexport class TryStatement extends Statement {\n  constructor(\n    /** Contained statements. */\n    public statements: Statement[],\n    /** Exception variable name, if a `catch` clause is present. */\n    public catchVariable: IdentifierExpression | null,\n    /** Statements being executed on catch, if a `catch` clause is present. */\n    public catchStatements: Statement[] | null,\n    /** Statements being executed afterwards, if a `finally` clause is present. */\n    public finallyStatements: Statement[] | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TRY, range);\n  }\n}\n\n/** Represents a `type` declaration. */\nexport class TypeDeclaration extends DeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Type parameters, if any. */\n    public typeParameters: TypeParameterNode[] | null,\n    /** Type being aliased. */\n    public type: TypeNode,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.TYPEDECLARATION, name, decorators, flags, range);\n  }\n}\n\n/** Represents a variable declaration part of a {@link VariableStatement}. */\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\n  constructor(\n    /** Simple name being declared. */\n    name: IdentifierExpression,\n    /** Array of decorators, if any. */\n    decorators: DecoratorNode[] | null,\n    /** Common flags indicating specific traits. */\n    flags: CommonFlags,\n    /** Annotated type node, if any. */\n    type: TypeNode | null,\n    /** Initializer expression, if any. */\n    initializer: Expression | null,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLEDECLARATION, name, decorators, flags, type, initializer, range);\n  }\n}\n\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\nexport class VariableStatement extends Statement {\n  constructor(\n    /** Array of decorators. */\n    public decorators: DecoratorNode[] | null,\n    /** Array of member declarations. */\n    public declarations: VariableDeclaration[],\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VARIABLE, range);\n  }\n}\n\n/** Represents a void statement dropping an expression's value. */\nexport class VoidStatement extends Statement {\n  constructor(\n    /** Expression being dropped. */\n    public expression: Expression,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.VOID, range);\n  }\n}\n\n/** Represents a `while` statement. */\nexport class WhileStatement extends Statement {\n  constructor(\n    /** Condition expression. */\n    public condition: Expression,\n    /** Statement being looped over. */\n    public statement: Statement,\n    /** Source range. */\n    range: Range\n  ) {\n    super(NodeKind.WHILE, range);\n  }\n}\n\n/** Finds the first decorator matching the specified kind. */\nexport function findDecorator(kind: DecoratorKind, decorators: DecoratorNode[] | null): DecoratorNode | null {\n  if (decorators) {\n    for (let i = 0, k = decorators.length; i < k; ++i) {\n      let decorator = decorators[i];\n      if (decorator.decoratorKind == kind) return decorator;\n    }\n  }\n  return null;\n}\n\n/** Mangles an external to an internal path. */\nexport function mangleInternalPath(path: string): string {\n  var pos = path.lastIndexOf(\".\");\n  var len = path.length;\n  if (pos >= 0 && len - pos >= 2) { // at least one char plus dot\n    let cur = pos;\n    while (++cur < len) {\n      if (!isTrivialAlphanum(path.charCodeAt(cur))) {\n        assert(false); // not a valid external path\n        return path;\n      }\n    }\n    return path.substring(0, pos);\n  }\n  assert(false); // not an external path\n  return path;\n}\n\n/** Tests if the specified type node represents an omitted type. */\nexport function isTypeOmitted(type: TypeNode): bool {\n  if (type.kind == NodeKind.NAMEDTYPE) {\n    let name = (<NamedTypeNode>type).name;\n    return !(name.next !== null || name.identifier.text.length > 0);\n  }\n  return false;\n}\n","/**\n * @fileoverview Built-in elements providing core WebAssembly functionality.\n *\n * Each builtin is linked to its definition in std/assembly/builtins.ts.\n * When its prototype is called, the compiler recognizes the `@builtin`\n * decorator, looks up the respective handler in the global builtins map\n * and executes it, with the handler directly emitting WebAssembly code\n * according to context.\n *\n * Builtins can be categorized into core builtins that typically are generic\n * and emit code directly and aliases calling core builtins with overridden\n * contexts. The latter is used by inline assembler aliases of WebAssembly\n * instructions, like `i64.load8_u` deferring to `<i64>load<u8>`.\n *\n * The `contextIsExact` modifier is used to force a specific instruction\n * family. A `i32.store8` deferring to `<i32>store<i8>` for example is\n * ambiguous in that the input can still be an i32 or an i64, leading to\n * either an `i32.store8` or an `i64.store8`, so `i32` is forced there.\n * This behavior is indicated by `from i32/i64` in the comments below.\n *\n * @license Apache-2.0\n */\n\n// TODO: Add builtins for `i32.add` etc. that do not have a core builtin.\n\nimport {\n  Compiler,\n  Constraints,\n  RuntimeFeatures\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticCategory\n} from \"./diagnostics\";\n\nimport {\n  Expression,\n  LiteralKind,\n  StringLiteralExpression,\n  CallExpression,\n  NodeKind,\n  LiteralExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  BinaryOp,\n  UnaryOp,\n  AtomicRMWOp,\n  SIMDExtractOp,\n  SIMDReplaceOp,\n  SIMDShiftOp,\n  SIMDTernaryOp,\n  NativeType,\n  ExpressionRef,\n  ExpressionId,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI64High,\n  getConstValueI64Low,\n  getConstValueI32,\n  getConstValueF32,\n  getConstValueF64,\n  SIMDLoadOp,\n  getLocalGetIndex,\n  createType,\n  ExpressionRunnerFlags\n} from \"./module\";\n\nimport {\n  ElementKind,\n  FunctionPrototype,\n  Field,\n  Global,\n  DecoratorFlags,\n  ClassPrototype,\n  Class\n} from \"./program\";\n\nimport {\n  findUsedLocals,\n  FlowFlags,\n  LocalFlags\n} from \"./flow\";\n\nimport {\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  CommonFlags,\n  Feature,\n  featureToString,\n  TypeinfoFlags\n} from \"./common\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  isPowerOf2\n} from \"./util\";\n\n/** Internal names of various compiler built-ins. */\nexport namespace BuiltinNames {\n\n  // compiler-generated\n  export const start = \"~start\";\n  export const started = \"~started\";\n  export const argumentsLength = \"~argumentsLength\";\n  export const setArgumentsLength = \"~setArgumentsLength\";\n\n  // std/builtins.ts\n  export const abort = \"~lib/builtins/abort\";\n  export const trace = \"~lib/builtins/trace\";\n  export const seed = \"~lib/builtins/seed\";\n\n  export const isInteger = \"~lib/builtins/isInteger\";\n  export const isFloat = \"~lib/builtins/isFloat\";\n  export const isBoolean = \"~lib/builtins/isBoolean\";\n  export const isSigned = \"~lib/builtins/isSigned\";\n  export const isReference = \"~lib/builtins/isReference\";\n  export const isString = \"~lib/builtins/isString\";\n  export const isArray = \"~lib/builtins/isArray\";\n  export const isArrayLike = \"~lib/builtins/isArrayLike\";\n  export const isFunction = \"~lib/builtins/isFunction\";\n  export const isNullable = \"~lib/builtins/isNullable\";\n  export const isDefined = \"~lib/builtins/isDefined\";\n  export const isConstant = \"~lib/builtins/isConstant\";\n  export const isManaged = \"~lib/builtins/isManaged\";\n  export const isVoid = \"~lib/builtins/isVoid\";\n\n  export const add = \"~lib/builtins/add\";\n  export const sub = \"~lib/builtins/sub\";\n  export const mul = \"~lib/builtins/mul\";\n  export const div = \"~lib/builtins/div\";\n  export const clz = \"~lib/builtins/clz\";\n  export const ctz = \"~lib/builtins/ctz\";\n  export const popcnt = \"~lib/builtins/popcnt\";\n  export const rotl = \"~lib/builtins/rotl\";\n  export const rotr = \"~lib/builtins/rotr\";\n  export const abs = \"~lib/builtins/abs\";\n  export const max = \"~lib/builtins/max\";\n  export const min = \"~lib/builtins/min\";\n  export const ceil = \"~lib/builtins/ceil\";\n  export const floor = \"~lib/builtins/floor\";\n  export const copysign = \"~lib/builtins/copysign\";\n  export const nearest = \"~lib/builtins/nearest\";\n  export const reinterpret = \"~lib/builtins/reinterpret\";\n  export const sqrt = \"~lib/builtins/sqrt\";\n  export const trunc = \"~lib/builtins/trunc\";\n  export const load = \"~lib/builtins/load\";\n  export const store = \"~lib/builtins/store\";\n  export const atomic_load = \"~lib/builtins/atomic.load\";\n  export const atomic_store = \"~lib/builtins/atomic.store\";\n  export const atomic_add = \"~lib/builtins/atomic.add\";\n  export const atomic_sub = \"~lib/builtins/atomic.sub\";\n  export const atomic_and = \"~lib/builtins/atomic.and\";\n  export const atomic_or = \"~lib/builtins/atomic.or\";\n  export const atomic_xor = \"~lib/builtins/atomic.xor\";\n  export const atomic_xchg = \"~lib/builtins/atomic.xchg\";\n  export const atomic_cmpxchg = \"~lib/builtins/atomic.cmpxchg\";\n  export const atomic_wait = \"~lib/builtins/atomic.wait\";\n  export const atomic_notify = \"~lib/builtins/atomic.notify\";\n  export const atomic_fence = \"~lib/builtins/atomic.fence\";\n\n  export const sizeof = \"~lib/builtins/sizeof\";\n  export const alignof = \"~lib/builtins/alignof\";\n  export const offsetof = \"~lib/builtins/offsetof\";\n  export const nameof = \"~lib/builtins/nameof\";\n  export const lengthof = \"~lib/builtins/lengthof\";\n  export const select = \"~lib/builtins/select\";\n  export const unreachable = \"~lib/builtins/unreachable\";\n  export const changetype = \"~lib/builtins/changetype\";\n  export const assert = \"~lib/builtins/assert\";\n  export const call_indirect = \"~lib/builtins/call_indirect\";\n  export const unchecked = \"~lib/builtins/unchecked\";\n  export const instantiate = \"~lib/builtins/instantiate\";\n  export const idof = \"~lib/builtins/idof\";\n\n  export const i8 = \"~lib/builtins/i8\";\n  export const i16 = \"~lib/builtins/i16\";\n  export const i32 = \"~lib/builtins/i32\";\n  export const i64 = \"~lib/builtins/i64\";\n  export const isize = \"~lib/builtins/isize\";\n  export const u8 = \"~lib/builtins/u8\";\n  export const u16 = \"~lib/builtins/u16\";\n  export const u32 = \"~lib/builtins/u32\";\n  export const u64 = \"~lib/builtins/u64\";\n  export const usize = \"~lib/builtins/usize\";\n  export const bool = \"~lib/builtins/bool\";\n  export const f32 = \"~lib/builtins/f32\";\n  export const f64 = \"~lib/builtins/f64\";\n  export const v128 = \"~lib/builtins/v128\";\n\n  export const i32_clz = \"~lib/builtins/i32.clz\";\n  export const i64_clz = \"~lib/builtins/i64.clz\";\n  export const i32_ctz = \"~lib/builtins/i32.ctz\";\n  export const i64_ctz = \"~lib/builtins/i64.ctz\";\n  export const i32_popcnt = \"~lib/builtins/i32.popcnt\";\n  export const i64_popcnt = \"~lib/builtins/i64.popcnt\";\n  export const i32_rotl = \"~lib/builtins/i32.rotl\";\n  export const i64_rotl = \"~lib/builtins/i64.rotl\";\n  export const i32_rotr = \"~lib/builtins/i32.rotr\";\n  export const i64_rotr = \"~lib/builtins/i64.rotr\";\n\n  export const f32_abs = \"~lib/builtins/f32.abs\";\n  export const f64_abs = \"~lib/builtins/f64.abs\";\n  export const f32_max = \"~lib/builtins/f32.max\";\n  export const f64_max = \"~lib/builtins/f64.max\";\n  export const f32_min = \"~lib/builtins/f32.min\";\n  export const f64_min = \"~lib/builtins/f64.min\";\n  export const f32_ceil = \"~lib/builtins/f32.ceil\";\n  export const f64_ceil = \"~lib/builtins/f64.ceil\";\n  export const f32_floor = \"~lib/builtins/f32.floor\";\n  export const f64_floor = \"~lib/builtins/f64.floor\";\n  export const f32_copysign = \"~lib/builtins/f32.copysign\";\n  export const f64_copysign = \"~lib/builtins/f64.copysign\";\n  export const f32_nearest = \"~lib/builtins/f32.nearest\";\n  export const f64_nearest = \"~lib/builtins/f64.nearest\";\n  export const i32_reinterpret_f32 = \"~lib/builtins/i32.reinterpret_f32\";\n  export const i64_reinterpret_f64 = \"~lib/builtins/i64.reinterpret_f64\";\n  export const f32_reinterpret_i32 = \"~lib/builtins/f32.reinterpret_i32\";\n  export const f64_reinterpret_i64 = \"~lib/builtins/f64.reinterpret_i64\";\n  export const f32_sqrt = \"~lib/builtins/f32.sqrt\";\n  export const f64_sqrt = \"~lib/builtins/f64.sqrt\";\n  export const f32_trunc = \"~lib/builtins/f32.trunc\";\n  export const f64_trunc = \"~lib/builtins/f64.trunc\";\n\n  export const i32_add = \"~lib/builtins/i32.add\";\n  export const i64_add = \"~lib/builtins/i64.add\";\n  export const f32_add = \"~lib/builtins/f32.add\";\n  export const f64_add = \"~lib/builtins/f64.add\";\n  export const i32_sub = \"~lib/builtins/i32.sub\";\n  export const i64_sub = \"~lib/builtins/i64.sub\";\n  export const f32_sub = \"~lib/builtins/f32.sub\";\n  export const f64_sub = \"~lib/builtins/f64.sub\";\n  export const i32_mul = \"~lib/builtins/i32.mul\";\n  export const i64_mul = \"~lib/builtins/i64.mul\";\n  export const f32_mul = \"~lib/builtins/f32.mul\";\n  export const f64_mul = \"~lib/builtins/f64.mul\";\n  export const i32_div_s = \"~lib/builtins/i32.div_s\";\n  export const i32_div_u = \"~lib/builtins/i32.div_u\";\n  export const i64_div_s = \"~lib/builtins/i64.div_s\";\n  export const i64_div_u = \"~lib/builtins/i64.div_u\";\n  export const f32_div = \"~lib/builtins/f32.div\";\n  export const f64_div = \"~lib/builtins/f64.div\";\n\n  export const i32_load8_s = \"~lib/builtins/i32.load8_s\";\n  export const i32_load8_u = \"~lib/builtins/i32.load8_u\";\n  export const i32_load16_s = \"~lib/builtins/i32.load16_s\";\n  export const i32_load16_u = \"~lib/builtins/i32.load16_u\";\n  export const i32_load = \"~lib/builtins/i32.load\";\n  export const i64_load8_s = \"~lib/builtins/i64.load8_s\";\n  export const i64_load8_u = \"~lib/builtins/i64.load8_u\";\n  export const i64_load16_s = \"~lib/builtins/i64.load16_s\";\n  export const i64_load16_u = \"~lib/builtins/i64.load16_u\";\n  export const i64_load32_s = \"~lib/builtins/i64.load32_s\";\n  export const i64_load32_u = \"~lib/builtins/i64.load32_u\";\n  export const i64_load = \"~lib/builtins/i64.load\";\n  export const f32_load = \"~lib/builtins/f32.load\";\n  export const f64_load = \"~lib/builtins/f64.load\";\n  export const i32_store8 = \"~lib/builtins/i32.store8\";\n  export const i32_store16 = \"~lib/builtins/i32.store16\";\n  export const i32_store = \"~lib/builtins/i32.store\";\n  export const i64_store8 = \"~lib/builtins/i64.store8\";\n  export const i64_store16 = \"~lib/builtins/i64.store16\";\n  export const i64_store32 = \"~lib/builtins/i64.store32\";\n  export const i64_store = \"~lib/builtins/i64.store\";\n  export const f32_store = \"~lib/builtins/f32.store\";\n  export const f64_store = \"~lib/builtins/f64.store\";\n\n  export const i32_atomic_load8_u = \"~lib/builtins/i32.atomic.load8_u\";\n  export const i32_atomic_load16_u = \"~lib/builtins/i32.atomic.load16_u\";\n  export const i32_atomic_load = \"~lib/builtins/i32.atomic.load\";\n  export const i64_atomic_load8_u = \"~lib/builtins/i64.atomic.load8_u\";\n  export const i64_atomic_load16_u = \"~lib/builtins/i64.atomic.load16_u\";\n  export const i64_atomic_load32_u = \"~lib/builtins/i64.atomic.load32_u\";\n  export const i64_atomic_load = \"~lib/builtins/i64.atomic.load\";\n  export const i32_atomic_store8 = \"~lib/builtins/i32.atomic.store8\";\n  export const i32_atomic_store16 = \"~lib/builtins/i32.atomic.store16\";\n  export const i32_atomic_store = \"~lib/builtins/i32.atomic.store\";\n  export const i64_atomic_store8 = \"~lib/builtins/i64.atomic.store8\";\n  export const i64_atomic_store16 = \"~lib/builtins/i64.atomic.store16\";\n  export const i64_atomic_store32 = \"~lib/builtins/i64.atomic.store32\";\n  export const i64_atomic_store = \"~lib/builtins/i64.atomic.store\";\n  export const i32_atomic_rmw8_add_u = \"~lib/builtins/i32.atomic.rmw8.add_u\";\n  export const i32_atomic_rmw16_add_u = \"~lib/builtins/i32.atomic.rmw16.add_u\";\n  export const i32_atomic_rmw_add = \"~lib/builtins/i32.atomic.rmw.add\";\n  export const i64_atomic_rmw8_add_u = \"~lib/builtins/i64.atomic.rmw8.add_u\";\n  export const i64_atomic_rmw16_add_u = \"~lib/builtins/i64.atomic.rmw16.add_u\";\n  export const i64_atomic_rmw32_add_u = \"~lib/builtins/i64.atomic.rmw32.add_u\";\n  export const i64_atomic_rmw_add = \"~lib/builtins/i64.atomic.rmw.add\";\n  export const i32_atomic_rmw8_sub_u = \"~lib/builtins/i32.atomic.rmw8.sub_u\";\n  export const i32_atomic_rmw16_sub_u = \"~lib/builtins/i32.atomic.rmw16.sub_u\";\n  export const i32_atomic_rmw_sub = \"~lib/builtins/i32.atomic.rmw.sub\";\n  export const i64_atomic_rmw8_sub_u = \"~lib/builtins/i64.atomic.rmw8.sub_u\";\n  export const i64_atomic_rmw16_sub_u = \"~lib/builtins/i64.atomic.rmw16.sub_u\";\n  export const i64_atomic_rmw32_sub_u = \"~lib/builtins/i64.atomic.rmw32.sub_u\";\n  export const i64_atomic_rmw_sub = \"~lib/builtins/i64.atomic.rmw.sub\";\n  export const i32_atomic_rmw8_and_u = \"~lib/builtins/i32.atomic.rmw8.and_u\";\n  export const i32_atomic_rmw16_and_u = \"~lib/builtins/i32.atomic.rmw16.and_u\";\n  export const i32_atomic_rmw_and = \"~lib/builtins/i32.atomic.rmw.and\";\n  export const i64_atomic_rmw8_and_u = \"~lib/builtins/i64.atomic.rmw8.and_u\";\n  export const i64_atomic_rmw16_and_u = \"~lib/builtins/i64.atomic.rmw16.and_u\";\n  export const i64_atomic_rmw32_and_u = \"~lib/builtins/i64.atomic.rmw32.and_u\";\n  export const i64_atomic_rmw_and = \"~lib/builtins/i64.atomic.rmw.and\";\n  export const i32_atomic_rmw8_or_u = \"~lib/builtins/i32.atomic.rmw8.or_u\";\n  export const i32_atomic_rmw16_or_u = \"~lib/builtins/i32.atomic.rmw16.or_u\";\n  export const i32_atomic_rmw_or = \"~lib/builtins/i32.atomic.rmw.or\";\n  export const i64_atomic_rmw8_or_u = \"~lib/builtins/i64.atomic.rmw8.or_u\";\n  export const i64_atomic_rmw16_or_u = \"~lib/builtins/i64.atomic.rmw16.or_u\";\n  export const i64_atomic_rmw32_or_u = \"~lib/builtins/i64.atomic.rmw32.or_u\";\n  export const i64_atomic_rmw_or = \"~lib/builtins/i64.atomic.rmw.or\";\n  export const i32_atomic_rmw8_xor_u = \"~lib/builtins/i32.atomic.rmw8.xor_u\";\n  export const i32_atomic_rmw16_xor_u = \"~lib/builtins/i32.atomic.rmw16.xor_u\";\n  export const i32_atomic_rmw_xor = \"~lib/builtins/i32.atomic.rmw.xor\";\n  export const i64_atomic_rmw8_xor_u = \"~lib/builtins/i64.atomic.rmw8.xor_u\";\n  export const i64_atomic_rmw16_xor_u = \"~lib/builtins/i64.atomic.rmw16.xor_u\";\n  export const i64_atomic_rmw32_xor_u = \"~lib/builtins/i64.atomic.rmw32.xor_u\";\n  export const i64_atomic_rmw_xor = \"~lib/builtins/i64.atomic.rmw.xor\";\n  export const i32_atomic_rmw8_xchg_u = \"~lib/builtins/i32.atomic.rmw8.xchg_u\";\n  export const i32_atomic_rmw16_xchg_u = \"~lib/builtins/i32.atomic.rmw16.xchg_u\";\n  export const i32_atomic_rmw_xchg = \"~lib/builtins/i32.atomic.rmw.xchg\";\n  export const i64_atomic_rmw8_xchg_u = \"~lib/builtins/i64.atomic.rmw8.xchg_u\";\n  export const i64_atomic_rmw16_xchg_u = \"~lib/builtins/i64.atomic.rmw16.xchg_u\";\n  export const i64_atomic_rmw32_xchg_u = \"~lib/builtins/i64.atomic.rmw32.xchg_u\";\n  export const i64_atomic_rmw_xchg = \"~lib/builtins/i64.atomic.rmw.xchg\";\n  export const i32_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw8.cmpxchg_u\";\n  export const i32_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i32.atomic.rmw16.cmpxchg_u\";\n  export const i32_atomic_rmw_cmpxchg = \"~lib/builtins/i32.atomic.rmw.cmpxchg\";\n  export const i64_atomic_rmw8_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw8.cmpxchg_u\";\n  export const i64_atomic_rmw16_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw16.cmpxchg_u\";\n  export const i64_atomic_rmw32_cmpxchg_u = \"~lib/builtins/i64.atomic.rmw32.cmpxchg_u\";\n  export const i64_atomic_rmw_cmpxchg = \"~lib/builtins/i64.atomic.rmw.cmpxchg\";\n  export const i32_wait = \"~lib/builtins/i32.wait\";\n  export const i64_wait = \"~lib/builtins/i64.wait\";\n\n  export const v128_splat = \"~lib/builtins/v128.splat\";\n  export const v128_extract_lane = \"~lib/builtins/v128.extract_lane\";\n  export const v128_replace_lane = \"~lib/builtins/v128.replace_lane\";\n  export const v128_shuffle = \"~lib/builtins/v128.shuffle\";\n  export const v128_swizzle = \"~lib/builtins/v128.swizzle\";\n  export const v128_load_splat = \"~lib/builtins/v128.load_splat\";\n  export const v128_load_ext = \"~lib/builtins/v128.load_ext\";\n  export const v128_load = \"~lib/builtins/v128.load\";\n  export const v128_store = \"~lib/builtins/v128.store\";\n  export const v128_add = \"~lib/builtins/v128.add\";\n  export const v128_sub = \"~lib/builtins/v128.sub\";\n  export const v128_mul = \"~lib/builtins/v128.mul\";\n  export const v128_div = \"~lib/builtins/v128.div\";\n  export const v128_neg = \"~lib/builtins/v128.neg\";\n  export const v128_add_saturate = \"~lib/builtins/v128.add_saturate\";\n  export const v128_sub_saturate = \"~lib/builtins/v128.sub_saturate\";\n  export const v128_shl = \"~lib/builtins/v128.shl\";\n  export const v128_shr = \"~lib/builtins/v128.shr\";\n  export const v128_and = \"~lib/builtins/v128.and\";\n  export const v128_or = \"~lib/builtins/v128.or\";\n  export const v128_xor = \"~lib/builtins/v128.xor\";\n  export const v128_andnot = \"~lib/builtins/v128.andnot\";\n  export const v128_not = \"~lib/builtins/v128.not\";\n  export const v128_bitselect = \"~lib/builtins/v128.bitselect\";\n  export const v128_any_true = \"~lib/builtins/v128.any_true\";\n  export const v128_all_true = \"~lib/builtins/v128.all_true\";\n  export const v128_bitmask = \"~lib/builtins/v128.bitmask\";\n  export const v128_min = \"~lib/builtins/v128.min\";\n  export const v128_max = \"~lib/builtins/v128.max\";\n  export const v128_pmin = \"~lib/builtins/v128.pmin\";\n  export const v128_pmax = \"~lib/builtins/v128.pmax\";\n  export const v128_dot = \"~lib/builtins/v128.dot\";\n  export const v128_avgr = \"~lib/builtins/v128.avgr\";\n  export const v128_abs = \"~lib/builtins/v128.abs\";\n  export const v128_sqrt = \"~lib/builtins/v128.sqrt\";\n  export const v128_ceil = \"~lib/builtins/v128.ceil\";\n  export const v128_floor = \"~lib/builtins/v128.floor\";\n  export const v128_trunc = \"~lib/builtins/v128.trunc\";\n  export const v128_nearest = \"~lib/builtins/v128.nearest\";\n  export const v128_eq = \"~lib/builtins/v128.eq\";\n  export const v128_ne = \"~lib/builtins/v128.ne\";\n  export const v128_lt = \"~lib/builtins/v128.lt\";\n  export const v128_le = \"~lib/builtins/v128.le\";\n  export const v128_gt = \"~lib/builtins/v128.gt\";\n  export const v128_ge = \"~lib/builtins/v128.ge\";\n  export const v128_convert = \"~lib/builtins/v128.convert\";\n  export const v128_trunc_sat = \"~lib/builtins/v128.trunc_sat\";\n  export const v128_narrow = \"~lib/builtins/v128.narrow\";\n  export const v128_widen_low = \"~lib/builtins/v128.widen_low\";\n  export const v128_widen_high = \"~lib/builtins/v128.widen_high\";\n  export const v128_qfma = \"~lib/builtins/v128.qfma\";\n  export const v128_qfms = \"~lib/builtins/v128.qfms\";\n\n  export const i8x16 = \"~lib/builtins/i8x16\";\n  export const i16x8 = \"~lib/builtins/i16x8\";\n  export const i32x4 = \"~lib/builtins/i32x4\";\n  export const i64x2 = \"~lib/builtins/i64x2\";\n  export const f32x4 = \"~lib/builtins/f32x4\";\n  export const f64x2 = \"~lib/builtins/f64x2\";\n\n  export const i8x16_splat = \"~lib/builtins/i8x16.splat\";\n  export const i8x16_extract_lane_s = \"~lib/builtins/i8x16.extract_lane_s\";\n  export const i8x16_extract_lane_u = \"~lib/builtins/i8x16.extract_lane_u\";\n  export const i8x16_replace_lane = \"~lib/builtins/i8x16.replace_lane\";\n  export const i8x16_add = \"~lib/builtins/i8x16.add\";\n  export const i8x16_sub = \"~lib/builtins/i8x16.sub\";\n  export const i8x16_mul = \"~lib/builtins/i8x16.mul\";\n  export const i8x16_min_s = \"~lib/builtins/i8x16.min_s\";\n  export const i8x16_min_u = \"~lib/builtins/i8x16.min_u\";\n  export const i8x16_max_s = \"~lib/builtins/i8x16.max_s\";\n  export const i8x16_max_u = \"~lib/builtins/i8x16.max_u\";\n  export const i8x16_avgr_u = \"~lib/builtins/i8x16.avgr_u\";\n  export const i8x16_abs = \"~lib/builtins/i8x16.abs\";\n  export const i8x16_neg = \"~lib/builtins/i8x16.neg\";\n  export const i8x16_add_saturate_s = \"~lib/builtins/i8x16.add_saturate_s\";\n  export const i8x16_add_saturate_u = \"~lib/builtins/i8x16.add_saturate_u\";\n  export const i8x16_sub_saturate_s = \"~lib/builtins/i8x16.sub_saturate_s\";\n  export const i8x16_sub_saturate_u = \"~lib/builtins/i8x16.sub_saturate_u\";\n  export const i8x16_shl = \"~lib/builtins/i8x16.shl\";\n  export const i8x16_shr_s = \"~lib/builtins/i8x16.shr_s\";\n  export const i8x16_shr_u = \"~lib/builtins/i8x16.shr_u\";\n  export const i8x16_any_true = \"~lib/builtins/i8x16.any_true\";\n  export const i8x16_all_true = \"~lib/builtins/i8x16.all_true\";\n  export const i8x16_bitmask = \"~lib/builtins/i8x16.bitmask\";\n  export const i8x16_eq = \"~lib/builtins/i8x16.eq\";\n  export const i8x16_ne = \"~lib/builtins/i8x16.ne\";\n  export const i8x16_lt_s = \"~lib/builtins/i8x16.lt_s\";\n  export const i8x16_lt_u = \"~lib/builtins/i8x16.lt_u\";\n  export const i8x16_le_s = \"~lib/builtins/i8x16.le_s\";\n  export const i8x16_le_u = \"~lib/builtins/i8x16.le_u\";\n  export const i8x16_gt_s = \"~lib/builtins/i8x16.gt_s\";\n  export const i8x16_gt_u = \"~lib/builtins/i8x16.gt_u\";\n  export const i8x16_ge_s = \"~lib/builtins/i8x16.ge_s\";\n  export const i8x16_ge_u = \"~lib/builtins/i8x16.ge_u\";\n  export const i8x16_narrow_i16x8_s = \"~lib/builtins/i8x16.narrow_i16x8_s\";\n  export const i8x16_narrow_i16x8_u = \"~lib/builtins/i8x16.narrow_i16x8_u\";\n\n  export const i16x8_splat = \"~lib/builtins/i16x8.splat\";\n  export const i16x8_extract_lane_s = \"~lib/builtins/i16x8.extract_lane_s\";\n  export const i16x8_extract_lane_u = \"~lib/builtins/i16x8.extract_lane_u\";\n  export const i16x8_replace_lane = \"~lib/builtins/i16x8.replace_lane\";\n  export const i16x8_add = \"~lib/builtins/i16x8.add\";\n  export const i16x8_sub = \"~lib/builtins/i16x8.sub\";\n  export const i16x8_mul = \"~lib/builtins/i16x8.mul\";\n  export const i16x8_min_s = \"~lib/builtins/i16x8.min_s\";\n  export const i16x8_min_u = \"~lib/builtins/i16x8.min_u\";\n  export const i16x8_max_s = \"~lib/builtins/i16x8.max_s\";\n  export const i16x8_max_u = \"~lib/builtins/i16x8.max_u\";\n  export const i16x8_avgr_u = \"~lib/builtins/i16x8.avgr_u\";\n  export const i16x8_abs = \"~lib/builtins/i16x8.abs\";\n  export const i16x8_neg = \"~lib/builtins/i16x8.neg\";\n  export const i16x8_add_saturate_s = \"~lib/builtins/i16x8.add_saturate_s\";\n  export const i16x8_add_saturate_u = \"~lib/builtins/i16x8.add_saturate_u\";\n  export const i16x8_sub_saturate_s = \"~lib/builtins/i16x8.sub_saturate_s\";\n  export const i16x8_sub_saturate_u = \"~lib/builtins/i16x8.sub_saturate_u\";\n  export const i16x8_shl = \"~lib/builtins/i16x8.shl\";\n  export const i16x8_shr_s = \"~lib/builtins/i16x8.shr_s\";\n  export const i16x8_shr_u = \"~lib/builtins/i16x8.shr_u\";\n  export const i16x8_any_true = \"~lib/builtins/i16x8.any_true\";\n  export const i16x8_all_true = \"~lib/builtins/i16x8.all_true\";\n  export const i16x8_bitmask = \"~lib/builtins/i16x8.bitmask\";\n  export const i16x8_eq = \"~lib/builtins/i16x8.eq\";\n  export const i16x8_ne = \"~lib/builtins/i16x8.ne\";\n  export const i16x8_lt_s = \"~lib/builtins/i16x8.lt_s\";\n  export const i16x8_lt_u = \"~lib/builtins/i16x8.lt_u\";\n  export const i16x8_le_s = \"~lib/builtins/i16x8.le_s\";\n  export const i16x8_le_u = \"~lib/builtins/i16x8.le_u\";\n  export const i16x8_gt_s = \"~lib/builtins/i16x8.gt_s\";\n  export const i16x8_gt_u = \"~lib/builtins/i16x8.gt_u\";\n  export const i16x8_ge_s = \"~lib/builtins/i16x8.ge_s\";\n  export const i16x8_ge_u = \"~lib/builtins/i16x8.ge_u\";\n  export const i16x8_narrow_i32x4_s = \"~lib/builtins/i16x8.narrow_i32x4_s\";\n  export const i16x8_narrow_i32x4_u = \"~lib/builtins/i16x8.narrow_i32x4_u\";\n  export const i16x8_widen_low_i8x16_s = \"~lib/builtins/i16x8.widen_low_i8x16_s\";\n  export const i16x8_widen_low_i8x16_u = \"~lib/builtins/i16x8.widen_low_i8x16_u\";\n  export const i16x8_widen_high_i8x16_s = \"~lib/builtins/i16x8.widen_high_i8x16_s\";\n  export const i16x8_widen_high_i8x16_u = \"~lib/builtins/i16x8.widen_high_i8x16_u\";\n  export const i16x8_load8x8_s = \"~lib/builtins/i16x8.load8x8_s\";\n  export const i16x8_load8x8_u = \"~lib/builtins/i16x8.load8x8_u\";\n\n  export const i32x4_splat = \"~lib/builtins/i32x4.splat\";\n  export const i32x4_extract_lane = \"~lib/builtins/i32x4.extract_lane\";\n  export const i32x4_replace_lane = \"~lib/builtins/i32x4.replace_lane\";\n  export const i32x4_add = \"~lib/builtins/i32x4.add\";\n  export const i32x4_sub = \"~lib/builtins/i32x4.sub\";\n  export const i32x4_mul = \"~lib/builtins/i32x4.mul\";\n  export const i32x4_min_s = \"~lib/builtins/i32x4.min_s\";\n  export const i32x4_min_u = \"~lib/builtins/i32x4.min_u\";\n  export const i32x4_max_s = \"~lib/builtins/i32x4.max_s\";\n  export const i32x4_max_u = \"~lib/builtins/i32x4.max_u\";\n  export const i32x4_dot_i16x8_s = \"~lib/builtins/i32x4.dot_i16x8_s\";\n  export const i32x4_abs = \"~lib/builtins/i32x4.abs\";\n  export const i32x4_neg = \"~lib/builtins/i32x4.neg\";\n  export const i32x4_shl = \"~lib/builtins/i32x4.shl\";\n  export const i32x4_shr_s = \"~lib/builtins/i32x4.shr_s\";\n  export const i32x4_shr_u = \"~lib/builtins/i32x4.shr_u\";\n  export const i32x4_any_true = \"~lib/builtins/i32x4.any_true\";\n  export const i32x4_all_true = \"~lib/builtins/i32x4.all_true\";\n  export const i32x4_bitmask = \"~lib/builtins/i32x4.bitmask\";\n  export const i32x4_eq = \"~lib/builtins/i32x4.eq\";\n  export const i32x4_ne = \"~lib/builtins/i32x4.ne\";\n  export const i32x4_lt_s = \"~lib/builtins/i32x4.lt_s\";\n  export const i32x4_lt_u = \"~lib/builtins/i32x4.lt_u\";\n  export const i32x4_le_s = \"~lib/builtins/i32x4.le_s\";\n  export const i32x4_le_u = \"~lib/builtins/i32x4.le_u\";\n  export const i32x4_gt_s = \"~lib/builtins/i32x4.gt_s\";\n  export const i32x4_gt_u = \"~lib/builtins/i32x4.gt_u\";\n  export const i32x4_ge_s = \"~lib/builtins/i32x4.ge_s\";\n  export const i32x4_ge_u = \"~lib/builtins/i32x4.ge_u\";\n  export const i32x4_trunc_sat_f32x4_s = \"~lib/builtins/i32x4.trunc_sat_f32x4_s\";\n  export const i32x4_trunc_sat_f32x4_u = \"~lib/builtins/i32x4.trunc_sat_f32x4_u\";\n  export const i32x4_widen_low_i16x8_s = \"~lib/builtins/i32x4.widen_low_i16x8_s\";\n  export const i32x4_widen_low_i16x8_u = \"~lib/builtins/i32x4.widen_low_i16x8_u\";\n  export const i32x4_widen_high_i16x8_s = \"~lib/builtins/i32x4.widen_high_i16x8_s\";\n  export const i32x4_widen_high_i16x8_u = \"~lib/builtins/i32x4.widen_high_i16x8_u\";\n  export const i32x4_load16x4_s = \"~lib/builtins/i32x4.load16x4_s\";\n  export const i32x4_load16x4_u = \"~lib/builtins/i32x4.load16x4_u\";\n\n  export const i64x2_splat = \"~lib/builtins/i64x2.splat\";\n  export const i64x2_extract_lane = \"~lib/builtins/i64x2.extract_lane\";\n  export const i64x2_replace_lane = \"~lib/builtins/i64x2.replace_lane\";\n  export const i64x2_add = \"~lib/builtins/i64x2.add\";\n  export const i64x2_sub = \"~lib/builtins/i64x2.sub\"; // i64x2 has no .mul\n  export const i64x2_neg = \"~lib/builtins/i64x2.neg\";\n  export const i64x2_shl = \"~lib/builtins/i64x2.shl\";\n  export const i64x2_shr_s = \"~lib/builtins/i64x2.shr_s\";\n  export const i64x2_shr_u = \"~lib/builtins/i64x2.shr_u\";\n  export const i64x2_any_true = \"~lib/builtins/i64x2.any_true\";\n  export const i64x2_all_true = \"~lib/builtins/i64x2.all_true\"; // i64x2 has no .eq etc.\n  export const i64x2_trunc_sat_f64x2_s = \"~lib/builtins/i64x2.trunc_sat_f64x2_s\";\n  export const i64x2_trunc_sat_f64x2_u = \"~lib/builtins/i64x2.trunc_sat_f64x2_u\";\n  export const i64x2_load32x2_s = \"~lib/builtins/i64x2.load32x2_s\";\n  export const i64x2_load32x2_u = \"~lib/builtins/i64x2.load32x2_u\";\n\n  export const f32x4_splat = \"~lib/builtins/f32x4.splat\";\n  export const f32x4_extract_lane = \"~lib/builtins/f32x4.extract_lane\";\n  export const f32x4_replace_lane = \"~lib/builtins/f32x4.replace_lane\";\n  export const f32x4_add = \"~lib/builtins/f32x4.add\";\n  export const f32x4_sub = \"~lib/builtins/f32x4.sub\";\n  export const f32x4_mul = \"~lib/builtins/f32x4.mul\";\n  export const f32x4_div = \"~lib/builtins/f32x4.div\";\n  export const f32x4_neg = \"~lib/builtins/f32x4.neg\";\n  export const f32x4_min = \"~lib/builtins/f32x4.min\";\n  export const f32x4_max = \"~lib/builtins/f32x4.max\";\n  export const f32x4_pmin = \"~lib/builtins/f32x4.pmin\";\n  export const f32x4_pmax = \"~lib/builtins/f32x4.pmax\";\n  export const f32x4_abs = \"~lib/builtins/f32x4.abs\";\n  export const f32x4_sqrt = \"~lib/builtins/f32x4.sqrt\";\n  export const f32x4_ceil = \"~lib/builtins/f32x4.ceil\";\n  export const f32x4_floor = \"~lib/builtins/f32x4.floor\";\n  export const f32x4_trunc = \"~lib/builtins/f32x4.trunc\";\n  export const f32x4_nearest = \"~lib/builtins/f32x4.nearest\";\n  export const f32x4_eq = \"~lib/builtins/f32x4.eq\";\n  export const f32x4_ne = \"~lib/builtins/f32x4.ne\";\n  export const f32x4_lt = \"~lib/builtins/f32x4.lt\";\n  export const f32x4_le = \"~lib/builtins/f32x4.le\";\n  export const f32x4_gt = \"~lib/builtins/f32x4.gt\";\n  export const f32x4_ge = \"~lib/builtins/f32x4.ge\";\n  export const f32x4_convert_i32x4_s = \"~lib/builtins/f32x4.convert_i32x4_s\";\n  export const f32x4_convert_i32x4_u = \"~lib/builtins/f32x4.convert_i32x4_u\";\n  export const f32x4_qfma = \"~lib/builtins/f32x4.qfma\";\n  export const f32x4_qfms = \"~lib/builtins/f32x4.qfms\";\n\n  export const f64x2_splat = \"~lib/builtins/f64x2.splat\";\n  export const f64x2_extract_lane = \"~lib/builtins/f64x2.extract_lane\";\n  export const f64x2_replace_lane = \"~lib/builtins/f64x2.replace_lane\";\n  export const f64x2_add = \"~lib/builtins/f64x2.add\";\n  export const f64x2_sub = \"~lib/builtins/f64x2.sub\";\n  export const f64x2_mul = \"~lib/builtins/f64x2.mul\";\n  export const f64x2_div = \"~lib/builtins/f64x2.div\";\n  export const f64x2_neg = \"~lib/builtins/f64x2.neg\";\n  export const f64x2_min = \"~lib/builtins/f64x2.min\";\n  export const f64x2_max = \"~lib/builtins/f64x2.max\";\n  export const f64x2_pmin = \"~lib/builtins/f64x2.pmin\";\n  export const f64x2_pmax = \"~lib/builtins/f64x2.pmax\";\n  export const f64x2_abs = \"~lib/builtins/f64x2.abs\";\n  export const f64x2_sqrt = \"~lib/builtins/f64x2.sqrt\";\n  export const f64x2_ceil = \"~lib/builtins/f64x2.ceil\";\n  export const f64x2_floor = \"~lib/builtins/f64x2.floor\";\n  export const f64x2_trunc = \"~lib/builtins/f64x2.trunc\";\n  export const f64x2_nearest = \"~lib/builtins/f64x2.nearest\";\n  export const f64x2_eq = \"~lib/builtins/f64x2.eq\";\n  export const f64x2_ne = \"~lib/builtins/f64x2.ne\";\n  export const f64x2_lt = \"~lib/builtins/f64x2.lt\";\n  export const f64x2_le = \"~lib/builtins/f64x2.le\";\n  export const f64x2_gt = \"~lib/builtins/f64x2.gt\";\n  export const f64x2_ge = \"~lib/builtins/f64x2.ge\";\n  export const f64x2_convert_i64x2_s = \"~lib/builtins/f64x2.convert_i64x2_s\";\n  export const f64x2_convert_i64x2_u = \"~lib/builtins/f64x2.convert_i64x2_u\";\n  export const f64x2_qfma = \"~lib/builtins/f64x2.qfma\";\n  export const f64x2_qfms = \"~lib/builtins/f64x2.qfms\";\n\n  export const v8x16_shuffle = \"~lib/builtins/v8x16.shuffle\";\n  export const v8x16_swizzle = \"~lib/builtins/v8x16.swizzle\";\n  export const v8x16_load_splat = \"~lib/builtins/v8x16.load_splat\";\n  export const v16x8_load_splat = \"~lib/builtins/v16x8.load_splat\";\n  export const v32x4_load_splat = \"~lib/builtins/v32x4.load_splat\";\n  export const v64x2_load_splat = \"~lib/builtins/v64x2.load_splat\";\n\n  // internals\n  export const heap_base = \"~lib/memory/__heap_base\";\n  export const rtti_base = \"~lib/rt/__rtti_base\";\n  export const visit_globals = \"~lib/rt/__visit_globals\";\n  export const visit_members = \"~lib/rt/__visit_members\";\n\n  // std/number.ts\n  export const isNaN = \"~lib/number/isNaN\";\n  export const isFinite = \"~lib/number/isFinite\";\n\n  // std/diagnostics.ts\n  export const ERROR = \"~lib/diagnostics/ERROR\";\n  export const WARNING = \"~lib/diagnostics/WARNING\";\n  export const INFO = \"~lib/diagnostics/INFO\";\n\n  // std/function.ts\n  export const Function = \"~lib/function/Function\";\n\n  // std/memory.ts\n  export const memory_size = \"~lib/memory/memory.size\";\n  export const memory_grow = \"~lib/memory/memory.grow\";\n  export const memory_copy = \"~lib/memory/memory.copy\";\n  export const memory_fill = \"~lib/memory/memory.fill\";\n  export const memory_data = \"~lib/memory/memory.data\";\n\n  // std/typedarray.ts\n  export const Int8Array = \"~lib/typedarray/Int8Array\";\n  export const Uint8Array = \"~lib/typedarray/Uint8Array\";\n  export const Uint8ClampedArray = \"~lib/typedarray/Uint8ClampedArray\";\n  export const Int16Array = \"~lib/typedarray/Int16Array\";\n  export const Uint16Array = \"~lib/typedarray/Uint16Array\";\n  export const Int32Array = \"~lib/typedarray/Int32Array\";\n  export const Uint32Array = \"~lib/typedarray/Uint32Array\";\n  export const Int64Array = \"~lib/typedarray/Int64Array\";\n  export const Uint64Array = \"~lib/typedarray/Uint64Array\";\n  export const Float32Array = \"~lib/typedarray/Float32Array\";\n  export const Float64Array = \"~lib/typedarray/Float64Array\";\n\n  // std/bindings/wasi.ts\n  export const wasiAbort = \"~lib/wasi/index/abort\";\n  export const wasiTrace = \"~lib/wasi/index/trace\";\n  export const wasiSeed = \"~lib/wasi/index/seed\";\n}\n\n/** Builtin compilation context. */\nexport class BuiltinContext {\n  constructor(\n    /** Compiler reference. */\n    public compiler: Compiler,\n    /** Prototype being called. */\n    public prototype: FunctionPrototype,\n    /** Provided type arguments. */\n    public typeArguments: Type[] | null,\n    /** Provided operands. */\n    public operands: Expression[],\n    /** Provided this operand, if any. */\n    public thisOperand: Expression | null,\n    /** Contextual type. */\n    public contextualType: Type,\n    /** Respective call expression. */\n    public reportNode: CallExpression,\n    /** Whether originating from inline assembly. */\n    public contextIsExact: bool\n  ) {}\n}\n\n/** Global builtins map. */\nexport const builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n/** Function builtins map. */\nexport const function_builtins = new Map<string,(ctx: BuiltinContext) => ExpressionRef>();\n\n// === Static type evaluation =================================================================\n\n// isInteger<T!>() / isInteger<T?>(value: T) -> bool\nfunction builtin_isInteger(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isInteger, builtin_isInteger);\n\n// isFloat<T!>() / isFloat<T?>(value: T) -> bool\nfunction builtin_isFloat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFloatValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFloat, builtin_isFloat);\n\n// isBoolean<T!>() / isBoolean<T?>(value: T) -> bool\nfunction builtin_isBoolean(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isBooleanValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isBoolean, builtin_isBoolean);\n\n// isSigned<T!>() / isSigned<T?>(value: T) -> bool\nfunction builtin_isSigned(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isSignedIntegerValue ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isSigned, builtin_isSigned);\n\n// isReference<T!>() / isReference<T?>(value: T) -> bool\nfunction builtin_isReference(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isReference, builtin_isReference);\n\n// isString<T!>() / isString<T?>(value: T) -> bool\nfunction builtin_isString(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isAssignableTo(compiler.program.stringInstance)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isString, builtin_isString);\n\n// isArray<T!>() / isArray<T?>(value: T) -> bool\nfunction builtin_isArray(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.extends(compiler.program.arrayPrototype)\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArray, builtin_isArray);\n\n// isArrayLike<T!>() / isArrayLike<T?>(value: T) -> bool\nfunction builtin_isArrayLike(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  var classReference = type.getClass();\n  return module.i32(\n    classReference !== null && classReference.isArrayLike\n      ? 1\n      : 0\n  );\n}\nbuiltins.set(BuiltinNames.isArrayLike, builtin_isArrayLike);\n\n// isFunction<T!> / isFunction<T?>(value: T) -> bool\nfunction builtin_isFunction(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isFunction ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isFunction, builtin_isFunction);\n\n// isNullable<T!> / isNullable<T?>(value: T) -> bool\nfunction builtin_isNullable(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isNullableReference ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isNullable, builtin_isNullable);\n\n// isDefined(expression) -> bool\nfunction builtin_isDefined(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var element = compiler.resolver.lookupExpression(\n    ctx.operands[0],\n    compiler.currentFlow,\n    Type.auto,\n    ReportMode.SWALLOW\n  );\n  return module.i32(element !== null ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isDefined, builtin_isDefined);\n\n// isConstant(expression) -> bool\nfunction builtin_isConstant(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.bool;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var expr = compiler.compileExpression(ctx.operands[0], Type.auto);\n  compiler.currentType = Type.bool;\n  return module.i32(getExpressionId(expr) == ExpressionId.Const ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isConstant, builtin_isConstant);\n\n// isManaged<T!>() -> bool\nfunction builtin_isManaged(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.isManaged ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isManaged, builtin_isManaged);\n\n// isVoid<T!>() -> bool\nfunction builtin_isVoid(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.bool;\n  if (!type) return module.unreachable();\n  return module.i32(type.kind == TypeKind.VOID ? 1 : 0);\n}\nbuiltins.set(BuiltinNames.isVoid, builtin_isVoid);\n\n// lengthof<T!>() -> i32\nfunction builtin_lengthof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.i32;\n  if (!type) return module.unreachable();\n  var signatureReference = type.signatureReference;\n  if (!signatureReference) {\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_call_signatures,\n      ctx.reportNode.range, type.toString()\n    );\n    return module.unreachable();\n  }\n  return module.i32(signatureReference.parameterTypes.length);\n}\nbuiltins.set(BuiltinNames.lengthof, builtin_lengthof);\n\n// sizeof<T!>() -> usize*\nfunction builtin_sizeof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!byteSize) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"sizeof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(byteSize), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.sizeof, builtin_sizeof);\n\n// alignof<T!>() -> usize*\nfunction builtin_alignof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  var type = ctx.typeArguments![0];\n  var byteSize = type.byteSize;\n  if (!isPowerOf2(byteSize)) { // implies == 0\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"alignof\", type.toString()\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(ctz<i32>(byteSize)), ctx.contextualType);\n}\nbuiltins.set(BuiltinNames.alignof, builtin_alignof);\n\n// offsetof<T!>(fieldName?: string) -> usize*\nfunction builtin_offsetof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = compiler.options.usizeType;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 0, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var type = ctx.typeArguments![0];\n  var classReference = type.getClassOrWrapper(compiler.program);\n  if (!classReference) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"offsetof\", type.toString()\n    );\n    if (compiler.options.isWasm64) {\n      if (contextualType.isIntegerValue && contextualType.size <= 32) {\n        compiler.currentType = Type.u32;\n      }\n    } else {\n      if (contextualType.isIntegerValue && contextualType.size == 64) {\n        compiler.currentType = Type.u64;\n      }\n    }\n    return module.unreachable();\n  }\n  if (operands.length) {\n    let firstOperand = operands[0];\n    if (!firstOperand.isLiteralKind(LiteralKind.STRING)) {\n      compiler.error(\n        DiagnosticCode.String_literal_expected,\n        operands[0].range\n      );\n      return module.unreachable();\n    }\n    let fieldName = (<StringLiteralExpression>firstOperand).value;\n    let classMembers = classReference.members;\n    if (classMembers !== null && classMembers.has(fieldName)) {\n      let member = assert(classMembers.get(fieldName));\n      if (member.kind == ElementKind.FIELD) {\n        return contextualUsize(compiler, i64_new((<Field>member).memoryOffset), contextualType);\n      }\n    }\n    compiler.error(\n      DiagnosticCode.Type_0_has_no_property_1,\n      firstOperand.range, classReference.internalName, fieldName\n    );\n    return module.unreachable();\n  }\n  return contextualUsize(compiler, i64_new(classReference.nextMemoryOffset), contextualType);\n}\nbuiltins.set(BuiltinNames.offsetof, builtin_offsetof);\n\n// nameof<T> -> string\nfunction builtin_nameof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var resultType = evaluateConstantType(ctx);\n  if (!resultType) {\n    compiler.currentType = compiler.program.stringInstance.type;\n    return module.unreachable();\n  }\n  var value: string;\n  if (resultType.isInternalReference) {\n    let classReference = resultType.getClass();\n    if (classReference) {\n      value = classReference.name;\n    } else {\n      assert(resultType.getSignature());\n      value = \"Function\";\n    }\n  } else {\n    value = resultType.toString();\n  }\n  return compiler.ensureStaticString(value);\n}\nbuiltins.set(BuiltinNames.nameof, builtin_nameof);\n\n// idof<T> -> u32\nfunction builtin_idof(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var type = evaluateConstantType(ctx);\n  compiler.currentType = Type.u32;\n  if (!type) return module.unreachable();\n  let signatureReference = type.getSignature();\n  if (signatureReference) {\n    return module.i32(signatureReference.id);\n  }\n  let classReference = type.getClassOrWrapper(compiler.program);\n  if (classReference !== null && !classReference.hasDecorator(DecoratorFlags.UNMANAGED)) {\n    return module.i32(classReference.id);\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"idof\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.idof, builtin_idof);\n\n// === Math ===================================================================================\n\n// clz<T?>(value: T) -> T\nfunction builtin_clz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(ctx.operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.ClzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ClzI64\n            : UnaryOp.ClzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.ClzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"clz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.clz, builtin_clz);\n\n// ctz<T?>(value: T) -> T\nfunction builtin_ctz(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.BOOL: // not wrapped\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.CtzI32, arg0);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.CtzI64\n            : UnaryOp.CtzI32,\n          arg0\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.CtzI64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ctz\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ctz, builtin_ctz);\n\n// popcnt<T?>(value: T) -> T\nfunction builtin_popcnt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (compiler.currentType.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8: // not wrapped\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16:\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.PopcntI32, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.PopcntI64, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.PopcntI64\n            : UnaryOp.PopcntI32,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"popcnt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.popcnt, builtin_popcnt);\n\n// rotl<T?>(value: T, shift: T) -> T\nfunction builtin_rotl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value << (shift & mask)) | (value >>> ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_tee(temp1.index, arg0),\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1),\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_get(temp1.index, NativeType.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, NativeType.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotlI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotlI64\n            : BinaryOp.RotlI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotlI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotl, builtin_rotl);\n\n// rotr<T?>(value: T, shift: T) -> T\nfunction builtin_rotr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.i32, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // (value >>> (shift & mask)) | (value << ((0 - shift) & mask))\n        let flow = compiler.currentFlow;\n        let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n        flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n        let temp2 = flow.getTempLocal(type);\n        flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n\n        let ret = module.binary(BinaryOp.OrI32,\n          module.binary(\n            BinaryOp.ShrU32,\n            module.local_tee(temp1.index, arg0),\n            module.binary(\n              BinaryOp.AndI32,\n              module.local_tee(temp2.index, arg1),\n              module.i32(type.size - 1)\n            )\n          ),\n          module.binary(\n            BinaryOp.ShlI32,\n            module.local_get(temp1.index, NativeType.I32),\n            module.binary(\n              BinaryOp.AndI32,\n              module.binary(\n                BinaryOp.SubI32,\n                module.i32(0),\n                module.local_get(temp2.index, NativeType.I32)\n              ),\n              module.i32(type.size - 1)\n            )\n          )\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n\n        return ret;\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.RotrI32, arg0, arg1);\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.RotrI64\n            : BinaryOp.RotrI32,\n          arg0, arg1\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.RotrI64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"rotr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.rotr, builtin_rotr);\n\n// abs<T?>(value: T) -> T\nfunction builtin_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: {\n        let flow = compiler.currentFlow;\n\n        // possibly overflows, e.g. abs<i8>(-128) == 128\n        let temp1 = flow.getTempLocal(Type.i32);\n        let temp2 = flow.getTempLocal(Type.i32);\n        // (x + (x >> 31)) ^ (x >> 31)\n        let ret = module.binary(BinaryOp.XorI32,\n          module.binary(BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0),\n                module.i32(31)\n              )\n            ),\n            module.local_get(temp1.index, NativeType.I32)\n          ),\n          module.local_get(temp2.index, NativeType.I32)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.ISIZE: {\n        let options = compiler.options;\n        let flow = compiler.currentFlow;\n        let isWasm64 = options.isWasm64;\n\n        let temp1 = flow.getTempLocal(options.usizeType);\n        let temp2 = flow.getTempLocal(options.usizeType);\n        let ret = module.binary(isWasm64 ? BinaryOp.XorI64 : BinaryOp.XorI32,\n          module.binary(isWasm64 ? BinaryOp.AddI64 : BinaryOp.AddI32,\n            module.local_tee(\n              temp2.index,\n              module.binary(isWasm64 ? BinaryOp.ShrI64 : BinaryOp.ShrI32,\n                module.local_tee(temp1.index, arg0),\n                isWasm64 ? module.i64(63) : module.i32(31)\n              )\n            ),\n            module.local_get(temp1.index, options.nativeSizeType)\n          ),\n          module.local_get(temp2.index, options.nativeSizeType)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.I64: {\n        let flow = compiler.currentFlow;\n\n        let temp1 = flow.getTempLocal(Type.i64);\n        let temp2 = flow.getTempLocal(Type.i64);\n        // (x + (x >> 63)) ^ (x >> 63)\n        let ret = module.binary(BinaryOp.XorI64,\n          module.binary(BinaryOp.AddI64,\n            module.local_tee(\n              temp2.index,\n              module.binary(BinaryOp.ShrI64,\n                module.local_tee(temp1.index, arg0),\n                module.i64(63)\n              )\n            ),\n            module.local_get(temp1.index, NativeType.I64)\n          ),\n          module.local_get(temp2.index, NativeType.I64)\n        );\n        flow.freeTempLocal(temp2);\n        flow.freeTempLocal(temp1);\n        return ret;\n      }\n      case TypeKind.USIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.abs, builtin_abs);\n\n// max<T?>(left: T, right: T) -> T\nfunction builtin_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.GtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.GtU32; break; }\n      case TypeKind.I64: { op = BinaryOp.GtI64; break; }\n      case TypeKind.U64: { op = BinaryOp.GtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtI64\n          : BinaryOp.GtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.GtU64\n          : BinaryOp.GtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64, arg0, arg1);\n    }\n    if (op != -1) {\n      let flow = compiler.currentFlow;\n      let nativeType = type.toNativeType();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0),\n        module.local_tee(temp2.index, arg1),\n        module.binary(op,\n          module.local_get(temp1.index, nativeType),\n          module.local_get(temp2.index, nativeType)\n        )\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.max, builtin_max);\n\n// min<T?>(left: T, right: T) -> T\nfunction builtin_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(left, typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) { // prefer right type\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.MUST_WRAP);\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(left, type = compiler.currentType, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n      }\n    } else {\n      arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP);\n    }\n    let op: BinaryOp = -1;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: { op = BinaryOp.LtI32; break; }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: { op = BinaryOp.LtU32; break; }\n      case TypeKind.I64:  { op = BinaryOp.LtI64; break; }\n      case TypeKind.U64:  { op = BinaryOp.LtU64; break; }\n      case TypeKind.ISIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtI64\n          : BinaryOp.LtI32;\n        break;\n      }\n      case TypeKind.USIZE: {\n        op = compiler.options.isWasm64\n          ? BinaryOp.LtU64\n          : BinaryOp.LtU32;\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64, arg0, arg1);\n    }\n    if (op != -1) {\n      let flow = compiler.currentFlow;\n      let nativeType = type.toNativeType();\n      let temp1 = flow.getTempLocal(type, findUsedLocals(arg1));\n      flow.setLocalFlag(temp1.index, LocalFlags.WRAPPED);\n      let temp2 = flow.getTempLocal(type);\n      flow.setLocalFlag(temp2.index, LocalFlags.WRAPPED);\n      let ret = module.select(\n        module.local_tee(temp1.index, arg0),\n        module.local_tee(temp2.index, arg1),\n        module.binary(op,\n          module.local_get(temp1.index, nativeType),\n          module.local_get(temp2.index, nativeType)\n        )\n      );\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.min, builtin_min);\n\n// ceil<T?>(value: T) -> T\nfunction builtin_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.ceil, builtin_ceil);\n\n// floor<T?>(value: T) -> T\nfunction builtin_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered rounded\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.floor, builtin_floor);\n\n// copysign<T?>(left: T, right: T) -> T\nfunction builtin_copysign(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      // TODO: does an integer version make sense?\n      case TypeKind.F32: return module.binary(BinaryOp.CopysignF32, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.CopysignF64, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"copysign\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.copysign, builtin_copysign);\n\n// nearest<T?>(value: T) -> T\nfunction builtin_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.nearest, builtin_nearest);\n\n// reinterpret<T!>(value: *) -> T\nfunction builtin_reinterpret(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF32, arg0);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.f64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = type;\n        return module.unary(UnaryOp.ReinterpretF64, arg0);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let arg0 = compiler.compileExpression(operands[0],\n          compiler.options.isWasm64\n            ? Type.f64\n            : Type.f32,\n          Constraints.CONV_IMPLICIT\n        );\n        compiler.currentType = type;\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.ReinterpretF64\n            : UnaryOp.ReinterpretF32,\n          arg0\n        );\n      }\n      case TypeKind.F32: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f32;\n        return module.unary(UnaryOp.ReinterpretI32, arg0);\n      }\n      case TypeKind.F64: {\n        let arg0 = compiler.compileExpression(operands[0], Type.i64, Constraints.CONV_IMPLICIT);\n        compiler.currentType = Type.f64;\n        return module.unary(UnaryOp.ReinterpretI64, arg0);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"reinterpret\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.reinterpret, builtin_reinterpret);\n\n// sqrt<T?>(value: T) -> T\nfunction builtin_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.f64, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      // TODO: integer versions (that return f64 or convert)?\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sqrt, builtin_sqrt);\n\n// trunc<T?>(value: T) -> T\nfunction builtin_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto, Constraints.NONE);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.BOOL: return arg0; // considered truncated\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.trunc, builtin_trunc);\n\n// isNaN<T?>(value: T) -> bool\nfunction builtin_isNaN(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // never NaN\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(0));\n      }\n      // (t = arg0) != t\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF32,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), NativeType.F32)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.NeF32,\n          module.local_tee(temp.index, arg0),\n          module.local_get(temp.index, NativeType.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.NeF64,\n            arg0,\n            module.local_get(getLocalGetIndex(arg0), NativeType.F64)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.NeF64,\n          module.local_tee(temp.index, arg0),\n          module.local_get(temp.index, NativeType.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isNaN\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isNaN, builtin_isNaN);\n\n// isFinite<T?>(value: T) -> bool\nfunction builtin_isFinite(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      // always finite\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE: {\n        return module.maybeDropCondition(arg0, module.i32(1));\n      }\n      // (t = arg0) - t == 0\n      case TypeKind.F32: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF32,\n            module.binary(BinaryOp.SubF32,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), NativeType.F32)\n            ),\n            module.f32(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.binary(BinaryOp.EqF32,\n          module.binary(BinaryOp.SubF32,\n            module.local_tee(temp.index, arg0),\n            module.local_get(temp.index, NativeType.F32)\n          ),\n          module.f32(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        if (getExpressionId(arg0) == ExpressionId.LocalGet) {\n          return module.binary(BinaryOp.EqF64,\n            module.binary(BinaryOp.SubF64,\n              arg0,\n              module.local_get(getLocalGetIndex(arg0), NativeType.F64)\n            ),\n            module.f64(0)\n          );\n        }\n        let flow = compiler.currentFlow;\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.binary(BinaryOp.EqF64,\n          module.binary(BinaryOp.SubF64,\n            module.local_tee(temp.index, arg0),\n            module.local_get(temp.index, NativeType.F64)\n          ),\n          module.f64(0)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"isFinite\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.isFinite, builtin_isFinite);\n\n// === Memory access ==========================================================================\n\n// load<T!>(offset: usize, immOffset?: usize, immAlign?: usize) -> T*\nfunction builtin_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    contextualType != Type.auto &&\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = outType;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = outType;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = outType;\n  return module.load(\n    type.byteSize,\n    type.isSignedIntegerValue,\n    arg0,\n    outType.toNativeType(),\n    immOffset,\n    immAlign\n  );\n}\nbuiltins.set(BuiltinNames.load, builtin_load);\n\n// store<T!>(offset: usize, value: T*, offset?: usize, align?: usize) -> void\nfunction builtin_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 3) {\n    immOffset = evaluateImmediateOffset(operands[2], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.void;\n      return module.unreachable();\n    }\n    if (numOperands == 4) {\n      immAlign = evaluateImmediateAlign(operands[3], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.void;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.void;\n  return module.store(type.byteSize, arg0, arg1, inType.toNativeType(), immOffset, immAlign);\n}\nbuiltins.set(BuiltinNames.store, builtin_store);\n\n// add<T?>(left: T, right: T) -> T\nfunction builtin_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeAdd(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"add\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.add, builtin_add);\n\n// sub<T?>(left: T, right: T) -> T\nfunction builtin_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeSub(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"sub\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.sub, builtin_sub);\n\n// mul<T?>(left: T, right: T) -> T\nfunction builtin_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeMul(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"mul\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.mul, builtin_mul);\n\n// div<T?>(left: T, right: T) -> T\nfunction builtin_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (checkTypeOptional(ctx, true) | checkArgsRequired(ctx, 2)) {\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var left = operands[0];\n  var arg0 = typeArguments\n    ? compiler.compileExpression(\n        left,\n        typeArguments[0],\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (type.isValue) {\n    let arg1: ExpressionRef;\n    if (!typeArguments && left.isNumericLiteral) {\n      // prefer right type\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type\n      );\n      if (compiler.currentType != type) {\n        arg0 = compiler.compileExpression(\n          left,\n          (type = compiler.currentType),\n          Constraints.CONV_IMPLICIT\n        );\n      }\n    } else {\n      arg1 = compiler.compileExpression(\n        operands[1],\n        type,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    if (type.isNumericValue) {\n      return compiler.makeDiv(arg0, arg1, type);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"div\",\n    type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.div, builtin_div);\n\n// === Atomics ================================================================================\n\n// atomic.load<T!>(offset: usize, immOffset?: usize) -> T*\nfunction builtin_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  var outType = (\n    type.isIntegerValue &&\n    contextualType.isIntegerValue &&\n    contextualType.size > type.size\n  ) ? contextualType : type;\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.load\", type.toString()\n    );\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var immOffset = operands.length == 2 ? evaluateImmediateOffset(operands[1], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = outType;\n    return module.unreachable();\n  }\n  compiler.currentType = outType;\n  return module.atomic_load(\n    type.byteSize,\n    arg0,\n    outType.toNativeType(),\n    immOffset\n  );\n}\nbuiltins.set(BuiltinNames.atomic_load, builtin_atomic_load);\n\n// atomic.store<T!>(offset: usize, value: T*, immOffset?: usize) -> void\nfunction builtin_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.store\", type.toString()\n    );\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(\n        operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue|| // float to int\n      inType.size < type.size  // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  compiler.currentType = Type.void;\n  return module.atomic_store(type.byteSize, arg0, arg1, inType.toNativeType(), immOffset);\n}\nbuiltins.set(BuiltinNames.atomic_store, builtin_atomic_store);\n\n// any_atomic_binary<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_binary(ctx: BuiltinContext, op: AtomicRMWOp, opName: string): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 2, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, opName, type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    inType = type;\n  }\n  var immOffset = operands.length == 3 ? evaluateImmediateOffset(operands[2], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_rmw(op, type.byteSize, immOffset, arg0, arg1, inType.toNativeType());\n}\n\n// atomic.add<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_add(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Add, \"atomic.add\");\n}\nbuiltins.set(BuiltinNames.atomic_add, builtin_atomic_add);\n\n// atomic.sub<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_sub(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Sub, \"atomic.sub\");\n}\nbuiltins.set(BuiltinNames.atomic_sub, builtin_atomic_sub);\n\n// atomic.and<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.And, \"atomic.and\");\n}\nbuiltins.set(BuiltinNames.atomic_and, builtin_atomic_and);\n\n// atomic.or<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Or, \"atomic.or\");\n}\nbuiltins.set(BuiltinNames.atomic_or, builtin_atomic_or);\n\n// atomic.xor<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xor, \"atomic.xor\");\n}\nbuiltins.set(BuiltinNames.atomic_xor, builtin_atomic_xor);\n\n// atomic.xchg<T!>(ptr, value: T, immOffset?: usize) -> T\nfunction builtin_atomic_xchg(ctx: BuiltinContext): ExpressionRef {\n  return builtin_atomic_binary(ctx, AtomicRMWOp.Xchg, \"atomic.xchg\");\n}\nbuiltins.set(BuiltinNames.atomic_xchg, builtin_atomic_xchg);\n\n// atomic.cmpxchg<T!>(ptr: usize, expected: T, replacement: T, off?: usize) -> T\nfunction builtin_atomic_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 3, 4)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var contextualType = ctx.contextualType;\n  var type = typeArguments![0];\n  if (!type.isIntegerValue || type.size < 8) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"atomic.cmpxchg\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg0 = compiler.compileExpression(operands[0],\n    compiler.options.usizeType,\n    Constraints.CONV_IMPLICIT\n  );\n  var arg1 = ctx.contextIsExact\n    ? compiler.compileExpression(operands[1],\n        contextualType,\n        Constraints.CONV_IMPLICIT\n      )\n    : compiler.compileExpression(\n        operands[1],\n        type,\n        type.isIntegerValue\n          ? Constraints.NONE // no need to convert to small int (but now might result in a float)\n          : Constraints.CONV_IMPLICIT\n      );\n  var inType = compiler.currentType;\n  var arg2 = compiler.compileExpression(operands[2],\n    inType,\n    Constraints.CONV_IMPLICIT\n  );\n  if (\n    type.isIntegerValue &&\n    (\n      !inType.isIntegerValue || // float to int\n      inType.size < type.size   // int to larger int (clear garbage bits)\n    )\n  ) {\n    // either conversion or memory operation clears garbage bits\n    arg1 = compiler.convertExpression(arg1, inType, type, false, operands[1]);\n    arg2 = compiler.convertExpression(arg2, inType, type, false, operands[2]);\n    inType = type;\n  }\n  var immOffset = operands.length == 4 ? evaluateImmediateOffset(operands[3], compiler) : 0; // reports\n  if (immOffset < 0) {\n    compiler.currentType = inType;\n    return module.unreachable();\n  }\n  compiler.currentType = inType;\n  return module.atomic_cmpxchg(type.byteSize, immOffset, arg0, arg1, arg2, inType.toNativeType());\n}\nbuiltins.set(BuiltinNames.atomic_cmpxchg, builtin_atomic_cmpxchg);\n\n// atomic.wait<T!>(ptr: usize, expected: T, timeout: i64) -> i32\nfunction builtin_atomic_wait(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var type = typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.i64, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  switch (type.kind) {\n    case TypeKind.I32:\n    case TypeKind.I64:\n    case TypeKind.ISIZE:\n    case TypeKind.U32:\n    case TypeKind.U64:\n    case TypeKind.USIZE: return module.atomic_wait(arg0, arg1, arg2, type.toNativeType());\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"atomic.wait\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.atomic_wait, builtin_atomic_wait);\n\n// atomic.notify(ptr: usize, count: i32) -> i32\nfunction builtin_atomic_notify(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  return module.atomic_notify(arg0, arg1);\n}\nbuiltins.set(BuiltinNames.atomic_notify, builtin_atomic_notify);\n\n// atomic.fence() -> void\nfunction builtin_atomic_fence(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkFeatureEnabled(ctx, Feature.THREADS) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.atomic_fence();\n}\nbuiltins.set(BuiltinNames.atomic_fence, builtin_atomic_fence);\n\n// === Control flow ===========================================================================\n\n// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\nfunction builtin_select(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT)\n    : compiler.compileExpression(operands[0], Type.auto);\n  var type = compiler.currentType;\n  if (!type.isAny(TypeFlags.VALUE | TypeFlags.REFERENCE)) {\n    compiler.error(\n      DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n      ctx.reportNode.typeArgumentsRange, \"select\", type.toString()\n    );\n    return module.unreachable();\n  }\n  var arg1 = compiler.compileExpression(operands[1], type, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.makeIsTrueish(\n    compiler.compileExpression(operands[2], Type.bool),\n    compiler.currentType, // ^\n    operands[2]\n  );\n  compiler.currentType = type;\n  return module.select(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.select, builtin_select);\n\n// unreachable() -> *\nfunction builtin_unreachable(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  checkArgsRequired(ctx, 0);\n  return ctx.compiler.module.unreachable();\n}\nbuiltins.set(BuiltinNames.unreachable, builtin_unreachable);\n\n// === Memory =================================================================================\n\n// memory.size() -> i32\nfunction builtin_memory_size(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 0)\n  ) return module.unreachable();\n  return module.memory_size();\n}\nbuiltins.set(BuiltinNames.memory_size, builtin_memory_size);\n\n// memory.grow(pages: i32) -> i32\nfunction builtin_memory_grow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  return module.memory_grow(compiler.compileExpression(ctx.operands[0], Type.i32, Constraints.CONV_IMPLICIT));\n}\nbuiltins.set(BuiltinNames.memory_grow, builtin_memory_grow);\n\n// memory.copy(dest: usize, src: usize: n: usize) -> void\nfunction builtin_memory_copy(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], usizeType, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_copy(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_copy, builtin_memory_copy);\n\n// memory.fill(dest: usize, value: u8, n: usize) -> void\nfunction builtin_memory_fill(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.void;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  if (!compiler.options.hasFeature(Feature.BULK_MEMORY)) {\n    // use stdlib alternative if not supported\n    let instance = compiler.resolver.resolveFunction(ctx.prototype, null); // reports\n    compiler.currentType = Type.void;\n    if (!instance || !compiler.compileFunction(instance, true)) return module.unreachable();\n    return compiler.compileCallDirect(instance, operands, ctx.reportNode);\n  }\n  var usizeType = compiler.options.usizeType;\n  var arg0 = compiler.compileExpression(operands[0], usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], usizeType, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.void;\n  return module.memory_fill(arg0, arg1, arg2);\n}\nbuiltins.set(BuiltinNames.memory_fill, builtin_memory_fill);\n\n// memory.data(size[, align]) -> usize\n// memory.data<T>(values[, align]) -> usize\nfunction builtin_memory_data(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  compiler.currentType = Type.i32;\n  if (\n    checkTypeOptional(ctx) |\n    checkArgsOptional(ctx, 1, 2)\n  ) return module.unreachable();\n  var typeArguments = ctx.typeArguments;\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  var usizeType = compiler.options.usizeType;\n  var offset: i64;\n  if (typeArguments !== null && typeArguments.length > 0) { // data<T>(values[, align])\n    let elementType = typeArguments[0];\n    if (!elementType.isValue) {\n      compiler.error(\n        DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n        ctx.reportNode.typeArgumentsRange, \"memory.data\", elementType.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let valuesOperand = operands[0];\n    if (valuesOperand.kind != NodeKind.LITERAL || (<LiteralExpression>valuesOperand).literalKind != LiteralKind.ARRAY) {\n      compiler.error(\n        DiagnosticCode.Array_literal_expected,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let expressions = (<ArrayLiteralExpression>valuesOperand).elementExpressions;\n    let numElements = expressions.length;\n    let exprs = new Array<ExpressionRef>(numElements);\n    let isStatic = true;\n    for (let i = 0; i < numElements; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = compiler.compileExpression(elementExpression, elementType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        exprs[i] = expr;\n      } else {\n        exprs[i] = compiler.makeZero(elementType, elementExpression);\n      }\n    }\n    if (!isStatic) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        valuesOperand.range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = elementType.byteSize;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    let buf = new Uint8Array(numElements * elementType.byteSize);\n    assert(compiler.writeStaticBuffer(buf, 0, elementType, exprs) == buf.byteLength);\n    offset = compiler.addAlignedMemorySegment(buf, align).offset;\n  } else { // data(size[, align])\n    let arg0 = compiler.compileExpression(operands[0], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(arg0, ExpressionRunnerFlags.PreserveSideeffects);\n    if (!precomp) {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[0].range\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let size = getConstValueI32(precomp);\n    if (size < 1) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[0].range, \"1\", i32.MAX_VALUE.toString()\n      );\n      compiler.currentType = usizeType;\n      return module.unreachable();\n    }\n    let align = 16;\n    if (numOperands == 2) {\n      align = evaluateImmediateAlign(operands[1], align, compiler); // reports\n      if (align < 0) {\n        compiler.currentType = usizeType;\n        return module.unreachable();\n      }\n    }\n    offset = compiler.addAlignedMemorySegment(new Uint8Array(size), align).offset;\n  }\n  // FIXME: what if recompiles happen? recompiles are bad.\n  compiler.currentType = usizeType;\n  if (usizeType == Type.usize32) {\n    assert(!i64_high(offset));\n    return module.i32(i64_low(offset));\n  } else {\n    return module.i64(i64_low(offset), i64_high(offset));\n  }\n}\nbuiltins.set(BuiltinNames.memory_data, builtin_memory_data);\n\n// === Helpers ================================================================================\n\n// changetype<T!>(value: *) -> T\nfunction builtin_changetype(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var toType = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.auto);\n  var fromType = compiler.currentType;\n  compiler.currentType = toType;\n  if (!fromType.isChangeableTo(toType)) {\n    compiler.error(\n      DiagnosticCode.Type_0_cannot_be_changed_to_type_1,\n      ctx.reportNode.range, fromType.toString(), toType.toString()\n    );\n    return module.unreachable();\n  }\n  return arg0;\n}\nbuiltins.set(BuiltinNames.changetype, builtin_changetype);\n\n// assert<T?>(isTrueish: T, message?: string) -> T{!= null}\nfunction builtin_assert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  var typeArguments = ctx.typeArguments;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, 2)\n  ) {\n    if (typeArguments) {\n      assert(typeArguments.length); // otherwise invalid, should not been set at all\n      compiler.currentType = typeArguments[0].nonNullableType;\n    }\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var contextualType = ctx.contextualType;\n  var arg0 = typeArguments\n    ? compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP)\n    : compiler.compileExpression(operands[0], Type.bool, Constraints.MUST_WRAP);\n  var type = compiler.currentType;\n  compiler.currentType = type.nonNullableType;\n\n  // omit if assertions are disabled\n  if (compiler.options.noAssert) {\n    return arg0;\n  }\n\n  // omit if the assertion can be proven statically\n  var evaled = module.runExpression(arg0, ExpressionRunnerFlags.Default);\n  if (evaled) {\n    switch (<u32>getExpressionType(evaled)) {\n      case <u32>NativeType.I32: {\n        if (getConstValueI32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>NativeType.I64: {\n        if (getConstValueI64Low(evaled) | getConstValueI64High(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>NativeType.F32: {\n        if (getConstValueF32(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n      case <u32>NativeType.F64: {\n        if (getConstValueF64(evaled)) {\n          return arg0;\n        }\n        break;\n      }\n    }\n  }\n\n  // otherwise call abort if the assertion is false-ish\n  var abort = compiler.makeAbort(operands.length == 2 ? operands[1] : null, ctx.reportNode);\n  compiler.currentType = type.nonNullableType;\n  if (contextualType == Type.void) { // simplify if dropped anyway\n    compiler.currentType = Type.void;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.if(module.unary(UnaryOp.EqzI32, arg0), abort);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.if(module.unary(UnaryOp.EqzI64, arg0), abort);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            arg0\n          ),\n          abort\n        );\n      }\n      // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\n      case TypeKind.F32: return module.if(module.binary(BinaryOp.EqF32, arg0, module.f32(0)), abort);\n      case TypeKind.F64: return module.if(module.binary(BinaryOp.EqF64, arg0, module.f64(0)), abort);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: return module.if(module.ref_is_null(arg0), abort);\n\n    }\n  } else {\n    compiler.currentType = type.nonNullableType;\n    let flow = compiler.currentFlow;\n    switch (compiler.currentType.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: {\n        let temp = flow.getTempLocal(type);\n        flow.setLocalFlag(temp.index, LocalFlags.WRAPPED); // arg0 is wrapped\n        let ret = module.if(\n          module.local_tee(temp.index, arg0),\n          module.local_get(temp.index, NativeType.I32),\n          abort\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let temp = flow.getTempLocal(Type.i64);\n        let ret = module.if(\n          module.unary(UnaryOp.EqzI64,\n            module.local_tee(temp.index, arg0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.I64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let temp = flow.getTempLocal(compiler.options.usizeType);\n        let ret = module.if(\n          module.unary(\n            compiler.options.isWasm64\n              ? UnaryOp.EqzI64\n              : UnaryOp.EqzI32,\n            module.local_tee(temp.index, arg0)\n          ),\n          abort,\n          module.local_get(temp.index, compiler.options.nativeSizeType)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F32: {\n        let temp = flow.getTempLocal(Type.f32);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF32,\n            module.local_tee(temp.index, arg0),\n            module.f32(0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.F32)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.F64: {\n        let temp = flow.getTempLocal(Type.f64);\n        let ret = module.if(\n          module.binary(BinaryOp.EqF64,\n            module.local_tee(temp.index, arg0),\n            module.f64(0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: {\n        let temp = flow.getTempLocal(type);\n        let ret = module.if(\n          module.ref_is_null(\n            module.local_tee(temp.index, arg0)\n          ),\n          abort,\n          module.local_get(temp.index, NativeType.F64)\n        );\n        flow.freeTempLocal(temp);\n        return ret;\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange,\n    \"assert\", compiler.currentType.toString()\n  );\n  return abort;\n}\nbuiltins.set(BuiltinNames.assert, builtin_assert);\n\n// unchecked(expr: *) -> *\nfunction builtin_unchecked(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) return module.unreachable();\n  var flow = compiler.currentFlow;\n  var alreadyUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n  flow.set(FlowFlags.UNCHECKED_CONTEXT);\n  // eliminate unnecessary tees by preferring contextualType(=void)\n  var expr = compiler.compileExpression(ctx.operands[0], ctx.contextualType);\n  if (!alreadyUnchecked) flow.unset(FlowFlags.UNCHECKED_CONTEXT);\n  return expr;\n}\nbuiltins.set(BuiltinNames.unchecked, builtin_unchecked);\n\n// call_indirect<T?>(index: u32, ...args: *[]) -> T\nfunction builtin_call_indirect(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeOptional(ctx, true) |\n    checkArgsOptional(ctx, 1, i32.MAX_VALUE)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  var returnType: Type;\n  if (typeArguments) {\n    assert(typeArguments.length);\n    returnType = typeArguments[0];\n  } else {\n    returnType = ctx.contextualType;\n  }\n  var indexArg = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length - 1;\n  var operandExprs = new Array<ExpressionRef>(numOperands);\n  var nativeParamTypes = new Array<NativeType>(numOperands);\n  for (let i = 0; i < numOperands; ++i) {\n    operandExprs[i] = compiler.compileExpression(operands[1 + i], Type.auto);\n    nativeParamTypes[i] = compiler.currentType.toNativeType();\n  }\n  compiler.currentType = returnType;\n  return module.call_indirect(indexArg, operandExprs, createType(nativeParamTypes), returnType.toNativeType());\n}\nbuiltins.set(BuiltinNames.call_indirect, builtin_call_indirect);\n\n// instantiate<T!>(...args: *[]) -> T\nfunction builtin_instantiate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeRequired(ctx, true)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var typeArgument = typeArguments[0];\n  var classInstance = typeArgument.getClass();\n  if (!classInstance) {\n    compiler.error(\n      DiagnosticCode.This_expression_is_not_constructable,\n      ctx.reportNode.expression.range\n    );\n    return module.unreachable();\n  }\n  compiler.currentType = classInstance.type;\n  var ctor = compiler.ensureConstructor(classInstance, ctx.reportNode);\n  compiler.checkFieldInitialization(classInstance, ctx.reportNode);\n  return compiler.compileInstantiate(ctor, operands, Constraints.NONE, ctx.reportNode);\n}\nbuiltins.set(BuiltinNames.instantiate, builtin_instantiate);\n\n// === User-defined diagnostics ===============================================================\n\nfunction builtin_diagnostic(ctx: BuiltinContext, category: DiagnosticCategory): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  checkTypeAbsent(ctx);\n  var operands = ctx.operands;\n  var reportNode = ctx.reportNode;\n  compiler.emitDiagnostic(\n    DiagnosticCode.User_defined_0,\n    category,\n    reportNode.range,\n    null,\n    operands.length\n      ? operands[0].range.toString()\n      : reportNode.range.toString()\n  );\n  return category == DiagnosticCategory.ERROR\n    ? module.unreachable()\n    : module.nop();\n}\n\n// ERROR(message?)\nfunction builtin_error(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.ERROR);\n}\nbuiltins.set(BuiltinNames.ERROR, builtin_error);\n\n// WARNING(message?)\nfunction builtin_warning(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.WARNING);\n}\nbuiltins.set(BuiltinNames.WARNING, builtin_warning);\n\n// INFO(message?)\nfunction builtin_info(ctx: BuiltinContext): ExpressionRef {\n  return builtin_diagnostic(ctx, DiagnosticCategory.INFO);\n}\nbuiltins.set(BuiltinNames.INFO, builtin_info);\n\n// === Function builtins ======================================================================\n\n// Function<T>#call(thisArg: thisof<T> | null, ...args: *[]) -> returnof<T>\nfunction builtin_function_call(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var parent = ctx.prototype.parent;\n  assert(parent.kind == ElementKind.CLASS);\n  var classInstance = <Class>parent;\n  assert(classInstance.prototype == compiler.program.functionPrototype);\n  var typeArguments = assert(classInstance.typeArguments);\n  assert(typeArguments.length == 1);\n  var ftype = typeArguments[0];\n  var signature = assert(ftype.getSignature());\n  var returnType = signature.returnType;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsOptional(ctx, 1 + signature.requiredParameters, 1 + signature.parameterTypes.length)\n  ) {\n    compiler.currentType = returnType;\n    return compiler.module.unreachable();\n  }\n  var indexArg = compiler.compileExpression(assert(ctx.thisOperand), ftype, Constraints.CONV_IMPLICIT);\n  var thisOperand = assert(ctx.operands.shift());\n  var thisType = signature.thisType;\n  var thisArg: usize = 0;\n  if (thisType) {\n    thisArg = compiler.compileExpression(thisOperand, thisType, Constraints.CONV_IMPLICIT);\n  } else if (thisOperand.kind != NodeKind.NULL) {\n    compiler.error(\n      DiagnosticCode._this_cannot_be_referenced_in_current_location,\n      thisOperand.range\n    );\n    return compiler.module.unreachable();\n  }\n  return compiler.compileCallIndirect(signature, indexArg, ctx.operands, ctx.reportNode, thisArg, ctx.contextualType == Type.void);\n}\nfunction_builtins.set(\"call\", builtin_function_call);\n\n// === Portable type conversions ==============================================================\n\nfunction builtin_conversion(ctx: BuiltinContext, toType: Type): ExpressionRef {\n  var compiler = ctx.compiler;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = toType;\n    return compiler.module.unreachable();\n  }\n  return compiler.compileExpression(ctx.operands[0], toType, Constraints.CONV_EXPLICIT);\n}\n\n// i8(*) -> i8\nfunction builtin_i8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i8);\n}\nbuiltins.set(BuiltinNames.i8, builtin_i8);\n\n// i16(*) -> i16\nfunction builtin_i16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i16);\n}\nbuiltins.set(BuiltinNames.i16, builtin_i16);\n\n// i32(*) -> i32\nfunction builtin_i32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i32);\n}\nbuiltins.set(BuiltinNames.i32, builtin_i32);\n\n// i64(*) -> i64\nfunction builtin_i64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.i64);\n}\nbuiltins.set(BuiltinNames.i64, builtin_i64);\n\n// isize(*) -> isize\nfunction builtin_isize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.isizeType);\n}\nbuiltins.set(BuiltinNames.isize, builtin_isize);\n\n// u8(*) -> u8\nfunction builtin_u8(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u8);\n}\nbuiltins.set(BuiltinNames.u8, builtin_u8);\n\n// u16(*) -> u16\nfunction builtin_u16(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u16);\n}\nbuiltins.set(BuiltinNames.u16, builtin_u16);\n\n// u32(*) -> u32\nfunction builtin_u32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u32);\n}\nbuiltins.set(BuiltinNames.u32, builtin_u32);\n\n// u64(*) -> u64\nfunction builtin_u64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.u64);\n}\nbuiltins.set(BuiltinNames.u64, builtin_u64);\n\n// usize(*) -> usize\nfunction builtin_usize(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, ctx.compiler.options.usizeType);\n}\nbuiltins.set(BuiltinNames.usize, builtin_usize);\n\n// bool(*) -> bool\nfunction builtin_bool(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.bool);\n}\nbuiltins.set(BuiltinNames.bool, builtin_bool);\n\n// f32(*) -> f32\nfunction builtin_f32(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f32);\n}\nbuiltins.set(BuiltinNames.f32, builtin_f32);\n\n// f64(*) -> f64\nfunction builtin_f64(ctx: BuiltinContext): ExpressionRef {\n  return builtin_conversion(ctx, Type.f64);\n}\nbuiltins.set(BuiltinNames.f64, builtin_f64);\n\n// TODO: alias for now, splat input integer perhaps?\nfunction builtin_v128(ctx: BuiltinContext): ExpressionRef {\n  return builtin_i8x16(ctx);\n}\nbuiltins.set(BuiltinNames.v128, builtin_v128);\n\n// === SIMD ===================================================================================\n\n// i8x16(...values: i8[16]) -> v128\nfunction builtin_i8x16(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 16)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 16; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i8, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI8(getConstValueI32(precomp), bytes, i);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i8x16, builtin_i8x16);\n\n// i16x8(...values: i16[8]) -> v128\nfunction builtin_i16x8(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 8)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 8; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i16, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI16(getConstValueI32(precomp), bytes, i << 1);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i16x8, builtin_i16x8);\n\n// i32x4(...values: i32[4]) -> v128\nfunction builtin_i32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeI32(getConstValueI32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i32x4, builtin_i32x4);\n\n// i64x2(...values: i64[2]) -> v128\nfunction builtin_i64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.i64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      let off = i << 3;\n      writeI32(getConstValueI64Low(precomp), bytes, off);\n      writeI32(getConstValueI64High(precomp), bytes, off + 4);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.i64x2, builtin_i64x2);\n\n// f32x4(...values: f32[4]) -> v128\nfunction builtin_f32x4(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 4)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 4; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF32(getConstValueF32(precomp), bytes, i << 2);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f32x4, builtin_f32x4);\n\n// f64x2(...values: f64[2]) -> v128\nfunction builtin_f64x2(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var bytes = new Uint8Array(16);\n  for (let i = 0; i < 2; ++i) {\n    let expr = compiler.compileExpression(operands[i], Type.f64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      writeF64(getConstValueF64(precomp), bytes, i << 3);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        operands[i].range\n      );\n    }\n  }\n  compiler.currentType = Type.v128;\n  return module.v128(bytes);\n}\nbuiltins.set(BuiltinNames.f64x2, builtin_f64x2);\n\n// v128.splat<T!>(x: T) -> v128\nfunction builtin_v128_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.SplatI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.SplatI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.SplatI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.SplatI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.SplatI64x2\n            : UnaryOp.SplatI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.SplatF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SplatF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_splat, builtin_v128_splat);\n\n// v128.extract_lane<T!>(x: v128, idx: u8) -> T\nfunction builtin_v128_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsRequired(ctx, 2)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  compiler.currentType = type;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_extract(SIMDExtractOp.ExtractLaneI8x16, arg0, <u8>idx);\n      case TypeKind.U8: return module.simd_extract(SIMDExtractOp.ExtractLaneU8x16, arg0, <u8>idx);\n      case TypeKind.I16: return module.simd_extract(SIMDExtractOp.ExtractLaneI16x8, arg0, <u8>idx);\n      case TypeKind.U16: return module.simd_extract(SIMDExtractOp.ExtractLaneU16x8, arg0, <u8>idx);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_extract(SIMDExtractOp.ExtractLaneI32x4, arg0, <u8>idx);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_extract(SIMDExtractOp.ExtractLaneI64x2, arg0, <u8>idx);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_extract(\n          compiler.options.isWasm64\n            ? SIMDExtractOp.ExtractLaneI64x2\n            : SIMDExtractOp.ExtractLaneI32x4,\n          arg0, <u8>idx\n        );\n      }\n      case TypeKind.F32: return module.simd_extract(SIMDExtractOp.ExtractLaneF32x4, arg0, <u8>idx);\n      case TypeKind.F64: return module.simd_extract(SIMDExtractOp.ExtractLaneF64x2, arg0, <u8>idx);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.extract_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_extract_lane, builtin_v128_extract_lane);\n\n// v128.replace_lane<T!>(x: v128, idx: u8, value: T) -> v128\nfunction builtin_v128_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u8, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], type, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  var idx = 0;\n  var precomp = module.runExpression(arg1, ExpressionRunnerFlags.PreserveSideeffects);\n  if (precomp) {\n    idx = getConstValueI32(precomp);\n  } else {\n    compiler.error(\n      DiagnosticCode.Expression_must_be_a_compile_time_constant,\n      operands[1].range\n    );\n  }\n  if (type.isValue) {\n    let maxIdx = (16 / assert(type.byteSize)) - 1;\n    if (idx < 0 || idx > maxIdx) {\n      compiler.error(\n        DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n        operands[1].range, \"Lane index\", \"0\", maxIdx.toString()\n      );\n      idx = 0;\n    }\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI8x16, arg0, <u8>idx, arg2);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI16x8, arg0, <u8>idx, arg2);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI32x4, arg0, <u8>idx, arg2);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneI64x2, arg0, <u8>idx, arg2);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_replace(\n          compiler.options.isWasm64\n            ? SIMDReplaceOp.ReplaceLaneI64x2\n            : SIMDReplaceOp.ReplaceLaneI32x4,\n          arg0, <u8>idx, arg2\n        );\n      }\n      case TypeKind.F32: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF32x4, arg0, <u8>idx, arg2);\n      case TypeKind.F64: return module.simd_replace(SIMDReplaceOp.ReplaceLaneF64x2, arg0, <u8>idx, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.replace_lane\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_replace_lane, builtin_v128_replace_lane);\n\n// v128.shuffle<T!>(a: v128, b: v128, ...lanes: u8[]) -> v128\nfunction builtin_v128_shuffle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  if (type.isValue) {\n    let laneWidth = type.byteSize;\n    let laneCount = 16 / laneWidth;\n    assert(isInteger(laneCount) && isPowerOf2(laneCount));\n    if (\n      checkArgsRequired(ctx, 2 + laneCount)\n    ) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    let arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n    let arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.I64:\n      case TypeKind.ISIZE:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.U64:\n      case TypeKind.USIZE:\n      case TypeKind.F32:\n      case TypeKind.F64: {\n        let mask = new Uint8Array(16);\n        let maxIdx = (laneCount << 1) - 1;\n        for (let i = 0; i < laneCount; ++i) {\n          let operand = operands[2 + i];\n          let argN = compiler.compileExpression(operand, Type.u8, Constraints.CONV_IMPLICIT);\n          let precomp = module.runExpression(argN, ExpressionRunnerFlags.PreserveSideeffects);\n          let idx = 0;\n          if (precomp) {\n            idx = getConstValueI32(precomp);\n            if (idx < 0 || idx > maxIdx) {\n              compiler.error(\n                DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n                operand.range, \"Lane index\", \"0\", maxIdx.toString()\n              );\n              idx = 0;\n            }\n          } else {\n            compiler.error(\n              DiagnosticCode.Expression_must_be_a_compile_time_constant,\n              operand.range\n            );\n          }\n          switch (laneWidth) {\n            case 1: {\n              writeI8(idx, mask, i);\n              break;\n            }\n            case 2: {\n              let off8 = i << 1;\n              let idx8 = idx << 1;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              break;\n            }\n            case 4: {\n              let off8 = i << 2;\n              let idx8 = idx << 2;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              break;\n            }\n            case 8: {\n              let off8 = i << 3;\n              let idx8 = idx << 3;\n              writeI8(idx8    , mask, off8);\n              writeI8(idx8 + 1, mask, off8 + 1);\n              writeI8(idx8 + 2, mask, off8 + 2);\n              writeI8(idx8 + 3, mask, off8 + 3);\n              writeI8(idx8 + 4, mask, off8 + 4);\n              writeI8(idx8 + 5, mask, off8 + 5);\n              writeI8(idx8 + 6, mask, off8 + 6);\n              writeI8(idx8 + 7, mask, off8 + 7);\n              break;\n            }\n            default: assert(false);\n          }\n        }\n        compiler.currentType = Type.v128;\n        return module.simd_shuffle(arg0, arg1, mask);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shuffle\", type.toString()\n  );\n  compiler.currentType = Type.v128;\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shuffle, builtin_v128_shuffle);\n\n// v128.swizzle(a: v128, b: v128) -> v128\nfunction builtin_v128_swizzle(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(BinaryOp.SwizzleV8x16, arg0, arg1);\n}\nbuiltins.set(BuiltinNames.v128_swizzle, builtin_v128_swizzle);\n\n// v128.load_splat<T!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_splat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV8x16, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV16x8, arg0, immOffset, immAlign);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32:\n      case TypeKind.F32: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV32x4, arg0, immOffset, immAlign);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.simd_load(SIMDLoadOp.LoadSplatV32x4, arg0, immOffset, immAlign);\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64:\n      case TypeKind.F64: {\n        return module.simd_load(SIMDLoadOp.LoadSplatV64x2, arg0, immOffset, immAlign);\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_splat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_splat, builtin_v128_load_splat);\n\n// v128.load_ext<TFrom!>(ptr: usize, immOffset?: usize, immAlign?: usize) -> v128\nfunction builtin_v128_load_ext(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx, true) |\n    checkArgsOptional(ctx, 1, 3)\n  ) return module.unreachable();\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var numOperands = operands.length;\n  var immOffset = 0;\n  var immAlign = type.byteSize;\n  if (numOperands >= 2) {\n    immOffset = evaluateImmediateOffset(operands[1], compiler); // reports\n    if (immOffset < 0) {\n      compiler.currentType = Type.v128;\n      return module.unreachable();\n    }\n    if (numOperands == 3) {\n      immAlign = evaluateImmediateAlign(operands[2], immAlign, compiler); // reports\n      if (immAlign < 0) {\n        compiler.currentType = Type.v128;\n        return module.unreachable();\n      }\n    }\n  }\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_load(SIMDLoadOp.LoadI8ToI16x8, arg0, immOffset, immAlign);\n      case TypeKind.U8: return module.simd_load(SIMDLoadOp.LoadU8ToU16x8, arg0, immOffset, immAlign);\n      case TypeKind.I16: return module.simd_load(SIMDLoadOp.LoadI16ToI32x4, arg0, immOffset, immAlign);\n      case TypeKind.U16: return module.simd_load(SIMDLoadOp.LoadU16ToU32x4, arg0, immOffset, immAlign);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.simd_load(SIMDLoadOp.LoadI32ToI64x2, arg0, immOffset, immAlign);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.simd_load(SIMDLoadOp.LoadU32ToU64x2, arg0, immOffset, immAlign);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.load_ext\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_load_ext, builtin_v128_load_ext);\n\n// v128.add<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.AddI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.AddI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.AddI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.AddI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.AddI64x2\n            : BinaryOp.AddI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.AddF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.AddF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add, builtin_v128_add);\n\n// v128.sub<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.SubI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.SubI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.SubI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.binary(BinaryOp.SubI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          compiler.options.isWasm64\n            ? BinaryOp.SubI64x2\n            : BinaryOp.SubI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.SubF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.SubF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub, builtin_v128_sub);\n\n// v128.mul<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_mul(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.MulI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.MulI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.MulI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.MulF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MulF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.mul\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_mul, builtin_v128_mul);\n\n// v128.div<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_div(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.DivF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.DivF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.div\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_div, builtin_v128_div);\n\n// v128.add_saturate<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_add_saturate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.AddSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.AddSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.AddSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AddSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.add_saturate\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_add_saturate, builtin_v128_add_saturate);\n\n// v128.sub_saturate<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_sub_saturate(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.SubSatI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.SubSatU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.SubSatI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.SubSatU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sub_saturate\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sub_saturate, builtin_v128_sub_saturate);\n\n// v128.min<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_min(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MinI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MinU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MinI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MinU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MinI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MinU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MinF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MinF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.min\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_min, builtin_v128_min);\n\n// v128.max<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_max(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.MaxI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.MaxU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.MaxI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.MaxU16x8, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.binary(BinaryOp.MaxI32x4, arg0, arg1);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U32: return module.binary(BinaryOp.MaxU32x4, arg0, arg1);\n      case TypeKind.F32: return module.binary(BinaryOp.MaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.MaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.max\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_max, builtin_v128_max);\n\n// v128.pmin<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmin(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PminF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PminF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmin\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmin, builtin_v128_pmin);\n\n// v128.pmax<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_pmax(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.binary(BinaryOp.PmaxF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.PmaxF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.pmax\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_pmax, builtin_v128_pmax);\n\n// v128.dot<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_dot(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.DotI16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.dot\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_dot, builtin_v128_dot);\n\n// v128.avgr<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_avgr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.U8:  return module.binary(BinaryOp.AvgrU8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.AvgrU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.avgr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_avgr, builtin_v128_avgr);\n\n// v128.eq<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_eq(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.EqI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.EqI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.EqI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.EqF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.EqF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.eq\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_eq, builtin_v128_eq);\n\n// v128.ne<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ne(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.binary(BinaryOp.NeI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.binary(BinaryOp.NeI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.NeI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.NeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.NeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ne\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ne, builtin_v128_ne);\n\n// v128.lt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_lt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LtI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LtU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.lt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_lt, builtin_v128_lt);\n\n// v128.le<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_le(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.LeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.LeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.LeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.LeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LeI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.LeU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.LeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.LeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.le\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_le, builtin_v128_le);\n\n// v128.gt<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_gt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GtI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GtU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GtI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GtU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GtI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GtU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GtF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GtF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.gt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_gt, builtin_v128_gt);\n\n// v128.ge<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_ge(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.binary(BinaryOp.GeI8x16, arg0, arg1);\n      case TypeKind.U8: return module.binary(BinaryOp.GeU8x16, arg0, arg1);\n      case TypeKind.I16: return module.binary(BinaryOp.GeI16x8, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.GeU16x8, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n      case TypeKind.ISIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GeI32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.USIZE: {\n        if (!compiler.options.isWasm64) {\n          return module.binary(BinaryOp.GeU32x4, arg0, arg1);\n        }\n        break;\n      }\n      case TypeKind.F32: return module.binary(BinaryOp.GeF32x4, arg0, arg1);\n      case TypeKind.F64: return module.binary(BinaryOp.GeF64x2, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ge\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ge, builtin_v128_ge);\n\n// v128.narrow<T!>(a: v128, b: v128) -> v128\nfunction builtin_v128_narrow(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I16: return module.binary(BinaryOp.NarrowI16x8ToI8x16, arg0, arg1);\n      case TypeKind.U16: return module.binary(BinaryOp.NarrowU16x8ToU8x16, arg0, arg1);\n      case TypeKind.I32: return module.binary(BinaryOp.NarrowI32x4ToI16x8, arg0, arg1);\n      case TypeKind.U32: return module.binary(BinaryOp.NarrowU32x4ToU16x8, arg0, arg1);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.narrow\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_narrow, builtin_v128_narrow);\n\n// v128.neg<T!>(a: v128) -> v128\nfunction builtin_v128_neg(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.NegI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.NegI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.NegI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.NegI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.NegI64x2\n            : UnaryOp.NegI32x4,\n          arg0\n        );\n      }\n      case TypeKind.F32: return module.unary(UnaryOp.NegF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NegF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.neg\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_neg, builtin_v128_neg);\n\n// v128.abs<T!>(a: v128) -> v128\nfunction builtin_v128_abs(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.AbsI8x16, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.AbsI16x8, arg0);\n      case TypeKind.ISIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32: return module.unary(UnaryOp.AbsI32x4, arg0);\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return arg0;\n      case TypeKind.F32: return module.unary(UnaryOp.AbsF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.AbsF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.abs\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_abs, builtin_v128_abs);\n\n// v128.sqrt<T!>(a: v128) -> v128\nfunction builtin_v128_sqrt(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.SqrtF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.SqrtF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.sqrt\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_sqrt, builtin_v128_sqrt);\n\n// v128.ceil<T!>(a: v128) -> v128\nfunction builtin_v128_ceil(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.CeilF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.CeilF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.ceil\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_ceil, builtin_v128_ceil);\n\n// v128.floor<T!>(a: v128) -> v128\nfunction builtin_v128_floor(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.FloorF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.FloorF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.floor\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_floor, builtin_v128_floor);\n\n// v128.trunc<T!>(a: v128) -> v128\nfunction builtin_v128_trunc(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.TruncF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.TruncF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc, builtin_v128_trunc);\n\n// v128.nearest<T!>(a: v128) -> v128\nfunction builtin_v128_nearest(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.unary(UnaryOp.NearestF32x4, arg0);\n      case TypeKind.F64: return module.unary(UnaryOp.NearestF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.nearest\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_nearest, builtin_v128_nearest);\n\n// v128.convert<T!>(a: v128) -> v128\nfunction builtin_v128_convert(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32: return module.unary(UnaryOp.ConvertI32x4ToF32x4, arg0);\n      case TypeKind.U32: return module.unary(UnaryOp.ConvertU32x4ToF32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.ConvertI64x2ToF64x2, arg0);\n      case TypeKind.U64: return module.unary(UnaryOp.ConvertU64x2ToF64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.convert\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_convert, builtin_v128_convert);\n\n// v128.trunc_sat<T!>(a: v128) -> v128\nfunction builtin_v128_trunc_sat(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I32: return module.unary(UnaryOp.TruncSatF32x4ToI32x4, arg0);\n      case TypeKind.U32: return module.unary(UnaryOp.TruncSatF32x4ToU32x4, arg0);\n      case TypeKind.I64: return module.unary(UnaryOp.TruncSatF64x2ToI64x2, arg0);\n      case TypeKind.U64: return module.unary(UnaryOp.TruncSatF64x2ToU64x2, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.trunc_sat\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_trunc_sat, builtin_v128_trunc_sat);\n\n// v128.widen_low<T!>(a: v128) -> v128\nfunction builtin_v128_widen_low(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.WidenLowI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.WidenLowU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.WidenLowI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.WidenLowU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.widen_low\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_widen_low, builtin_v128_widen_low);\n\n// v128.widen_high<T!>(a: v128) -> v128\nfunction builtin_v128_widen_high(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments!;\n  var type = typeArguments[0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.unary(UnaryOp.WidenHighI8x16ToI16x8, arg0);\n      case TypeKind.U8: return module.unary(UnaryOp.WidenHighU8x16ToU16x8, arg0);\n      case TypeKind.I16: return module.unary(UnaryOp.WidenHighI16x8ToI32x4, arg0);\n      case TypeKind.U16: return module.unary(UnaryOp.WidenHighU16x8ToU32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.widen_high\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_widen_high, builtin_v128_widen_high);\n\n// v128.shl<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shl(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShlI8x16, arg0, arg1);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShlI16x8, arg0, arg1);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShlI32x4, arg0, arg1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShlI64x2, arg0, arg1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShlI64x2\n            : SIMDShiftOp.ShlI32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shl\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shl, builtin_v128_shl);\n\n// v128.shr<T!>(a: v128, b: i32) -> v128\nfunction builtin_v128_shr(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.i32, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.v128;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8: return module.simd_shift(SIMDShiftOp.ShrI8x16, arg0, arg1);\n      case TypeKind.U8: return module.simd_shift(SIMDShiftOp.ShrU8x16, arg0, arg1);\n      case TypeKind.I16: return module.simd_shift(SIMDShiftOp.ShrI16x8, arg0, arg1);\n      case TypeKind.U16: return module.simd_shift(SIMDShiftOp.ShrU16x8, arg0, arg1);\n      case TypeKind.I32: return module.simd_shift(SIMDShiftOp.ShrI32x4, arg0, arg1);\n      case TypeKind.U32: return module.simd_shift(SIMDShiftOp.ShrU32x4, arg0, arg1);\n      case TypeKind.I64: return module.simd_shift(SIMDShiftOp.ShrI64x2, arg0, arg1);\n      case TypeKind.U64: return module.simd_shift(SIMDShiftOp.ShrU64x2, arg0, arg1);\n      case TypeKind.ISIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrI64x2\n            : SIMDShiftOp.ShrI32x4,\n          arg0, arg1\n        );\n      }\n      case TypeKind.USIZE: {\n        return module.simd_shift(\n          compiler.options.isWasm64\n            ? SIMDShiftOp.ShrU64x2\n            : SIMDShiftOp.ShrU32x4,\n          arg0, arg1\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.shr\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_shr, builtin_v128_shr);\n\nfunction builtin_v128_bitwise_binary(ctx: BuiltinContext, op: BinaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.binary(op, arg0, arg1);\n}\n\n// v128.and(a: v128, b: v128) -> v128\nfunction builtin_v128_and(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndV128);\n}\nbuiltins.set(BuiltinNames.v128_and, builtin_v128_and);\n\n// v128.or(a: v128, b: v128) -> v128\nfunction builtin_v128_or(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.OrV128);\n}\nbuiltins.set(BuiltinNames.v128_or, builtin_v128_or);\n\n// v128.xor(a: v128, b: v128) -> v128\nfunction builtin_v128_xor(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.XorV128);\n}\nbuiltins.set(BuiltinNames.v128_xor, builtin_v128_xor);\n\n// v128.andnot(a: v128, b: v128) -> v128\nfunction builtin_v128_andnot(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_binary(ctx, BinaryOp.AndNotV128);\n}\nbuiltins.set(BuiltinNames.v128_andnot, builtin_v128_andnot);\n\nfunction builtin_v128_bitwise_unary(ctx: BuiltinContext, op: UnaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.unary(op, arg0);\n}\n\n// v128.not(a: v128) -> v128\nfunction builtin_v128_not(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_unary(ctx, UnaryOp.NotV128);\n}\nbuiltins.set(BuiltinNames.v128_not, builtin_v128_not);\n\nfunction builtin_v128_bitwise_ternary(ctx: BuiltinContext, op: SIMDTernaryOp): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  return module.simd_ternary(op, arg0, arg1, arg2);\n}\n\n// v128.bitselect(v1: v128, v2: v128, c: v128) -> v128\nfunction builtin_v128_bitselect(ctx: BuiltinContext): ExpressionRef {\n  return builtin_v128_bitwise_ternary(ctx, SIMDTernaryOp.Bitselect);\n}\nbuiltins.set(BuiltinNames.v128_bitselect, builtin_v128_bitselect);\n\n// v128.any_true<T!>(a: v128) -> bool\nfunction builtin_v128_any_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AnyTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AnyTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AnyTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AnyTrueI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AnyTrueI64x2\n            : UnaryOp.AnyTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.any_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_any_true, builtin_v128_any_true);\n\n// v128.all_true<T!>(a: v128) -> bool\nfunction builtin_v128_all_true(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.bool;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.bool;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.AllTrueI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.AllTrueI16x8, arg0);\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.AllTrueI32x4, arg0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.unary(UnaryOp.AllTrueI64x2, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.unary(\n          compiler.options.isWasm64\n            ? UnaryOp.AllTrueI64x2\n            : UnaryOp.AllTrueI32x4,\n          arg0\n        );\n      }\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.all_true\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_all_true, builtin_v128_all_true);\n\n// v128.bitmask<T!>(a: v128) -> i32\nfunction builtin_v128_bitmask(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 1)\n  ) {\n    compiler.currentType = Type.i32;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  compiler.currentType = Type.i32;\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.U8: return module.unary(UnaryOp.BitmaskI8x16, arg0);\n      case TypeKind.I16:\n      case TypeKind.U16: return module.unary(UnaryOp.BitmaskI16x8, arg0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (compiler.options.isWasm64) break;\n        // fall-through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: return module.unary(UnaryOp.BitmaskI32x4, arg0);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.bitmask\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_bitmask, builtin_v128_bitmask);\n\n// v128.qfma<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_qfma(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.simd_ternary(SIMDTernaryOp.QFMAF32x4, arg0, arg1, arg2);\n      case TypeKind.F64: return module.simd_ternary(SIMDTernaryOp.QFMAF64x2, arg0, arg1, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.qfma\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_qfma, builtin_v128_qfma);\n\n// v128.qfms<T!>(a: v128, b: v128, c: v128) -> v128\nfunction builtin_v128_qfms(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkFeatureEnabled(ctx, Feature.SIMD) |\n    checkTypeRequired(ctx) |\n    checkArgsRequired(ctx, 3)\n  ) {\n    compiler.currentType = Type.v128;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var type = ctx.typeArguments![0];\n  var arg0 = compiler.compileExpression(operands[0], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.v128, Constraints.CONV_IMPLICIT);\n  var arg2 = compiler.compileExpression(operands[2], Type.v128, Constraints.CONV_IMPLICIT);\n  if (type.isValue) {\n    switch (type.kind) {\n      case TypeKind.F32: return module.simd_ternary(SIMDTernaryOp.QFMSF32x4, arg0, arg1, arg2);\n      case TypeKind.F64: return module.simd_ternary(SIMDTernaryOp.QFMSF64x2, arg0, arg1, arg2);\n    }\n  }\n  compiler.error(\n    DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n    ctx.reportNode.typeArgumentsRange, \"v128.qfms\", type.toString()\n  );\n  return module.unreachable();\n}\nbuiltins.set(BuiltinNames.v128_qfms, builtin_v128_qfms);\n\n// === Internal runtime =======================================================================\n\n// __visit_globals(cookie: u32) -> void\nfunction builtin_visit_globals(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 1) // cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitGlobals;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_globals, [ arg0 ], NativeType.None);\n}\nbuiltins.set(BuiltinNames.visit_globals, builtin_visit_globals);\n\n// __visit_members(ref: usize, cookie: u32) -> void\nfunction builtin_visit_members(ctx: BuiltinContext): ExpressionRef {\n  var compiler = ctx.compiler;\n  var module = compiler.module;\n  if (\n    checkTypeAbsent(ctx) |\n    checkArgsRequired(ctx, 2) // ref, cookie\n  ) {\n    compiler.currentType = Type.void;\n    return module.unreachable();\n  }\n  var operands = ctx.operands;\n  var arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, Constraints.CONV_IMPLICIT);\n  var arg1 = compiler.compileExpression(operands[1], Type.u32, Constraints.CONV_IMPLICIT);\n  compiler.runtimeFeatures |= RuntimeFeatures.visitMembers;\n  compiler.currentType = Type.void;\n  return module.call(BuiltinNames.visit_members, [ arg0, arg1 ], NativeType.None);\n}\nbuiltins.set(BuiltinNames.visit_members, builtin_visit_members);\n\n// === Inline assembler =======================================================================\n\n// TODO: Operators can't be just deferred (don't have a corresponding generic built-in)\n//   add, sub, mul, div_s, div_u, rem_s, rem_u\n//   and, or, xor, shl, shr_u, shr_s\n//   eq, eqz, ne, lt_s, lt_u, le_s, le_u, gt_s, gt_u, ge_s, ge_u\n\n// i32.clz -> clz<i32>\nfunction builtin_i32_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_clz, builtin_i32_clz);\n\n// i64.clz -> clz<i64>\nfunction builtin_i64_clz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_clz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_clz, builtin_i64_clz);\n\n// i32.ctz -> ctz<i32>\nfunction builtin_i32_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i32_ctz, builtin_i32_ctz);\n\n// i64.ctz -> ctz<i64>\nfunction builtin_i64_ctz(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_ctz(ctx);\n}\nbuiltins.set(BuiltinNames.i64_ctz, builtin_i64_ctz);\n\n// i32.popcnt -> popcnt<i32>\nfunction builtin_i32_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i32_popcnt, builtin_i32_popcnt);\n\n// i64.popcnt -> popcnt<i64>\nfunction builtin_i64_popcnt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_popcnt(ctx);\n}\nbuiltins.set(BuiltinNames.i64_popcnt, builtin_i64_popcnt);\n\n// i32.rotl -> rotl<i32>\nfunction builtin_i32_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotl, builtin_i32_rotl);\n\n// i64.rotl -> rotl<i64>\nfunction builtin_i64_rotl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotl(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotl, builtin_i64_rotl);\n\n// i32.rotr -> rotr<i32>\nfunction builtin_i32_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i32_rotr, builtin_i32_rotr);\n\n// i64.rotr -> rotr<i64>\nfunction builtin_i64_rotr(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_rotr(ctx);\n}\nbuiltins.set(BuiltinNames.i64_rotr, builtin_i64_rotr);\n\n// f32.abs -> abs<f32>\nfunction builtin_f32_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32_abs, builtin_f32_abs);\n\n// f64.abs -> abs<f64>\nfunction builtin_f64_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64_abs, builtin_f64_abs);\n\n// f32.max -> max<f32>\nfunction builtin_f32_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32_max, builtin_f32_max);\n\n// f64.max -> max<f64>\nfunction builtin_f64_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64_max, builtin_f64_max);\n\n// f32.min -> min<f32>\nfunction builtin_f32_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32_min, builtin_f32_min);\n\n// f64.min -> min<f64>\nfunction builtin_f64_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64_min, builtin_f64_min);\n\n// f32.ceil -> ceil<f32>\nfunction builtin_f32_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32_ceil, builtin_f32_ceil);\n\n// f64.ceil -> ceil<f64>\nfunction builtin_f64_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64_ceil, builtin_f64_ceil);\n\n// f32.floor -> floor<f32>\nfunction builtin_f32_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32_floor, builtin_f32_floor);\n\n// f64.floor -> floor<f64>\nfunction builtin_f64_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64_floor, builtin_f64_floor);\n\n// f32.copysign -> copysign<f32>\nfunction builtin_f32_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f32_copysign, builtin_f32_copysign);\n\n// f64.copysign -> copysign<f64>\nfunction builtin_f64_copysign(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_copysign(ctx);\n}\nbuiltins.set(BuiltinNames.f64_copysign, builtin_f64_copysign);\n\n// f32.nearest -> nearest<f32>\nfunction builtin_f32_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32_nearest, builtin_f32_nearest);\n\n// f64.nearest -> nearest<f64>\nfunction builtin_f64_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64_nearest, builtin_f64_nearest);\n\n// i32.reinterpret_f32 -> reinterpret<i32>\nfunction builtin_i32_reinterpret_f32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i32_reinterpret_f32, builtin_i32_reinterpret_f32);\n\n// i64.reinterpret_f64 -> reinterpret<i64>\nfunction builtin_i64_reinterpret_f64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.i64_reinterpret_f64, builtin_i64_reinterpret_f64);\n\n// f32.reinterpret_i32 -> reinterpret<f32>\nfunction builtin_f32_reinterpret_i32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f32_reinterpret_i32, builtin_f32_reinterpret_i32);\n\n// f64.reinterpret_i64 -> reinterpret<f64>\nfunction builtin_f64_reinterpret_i64(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_reinterpret(ctx);\n}\nbuiltins.set(BuiltinNames.f64_reinterpret_i64, builtin_f64_reinterpret_i64);\n\n// f32.sqrt -> sqrt<f32>\nfunction builtin_f32_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sqrt, builtin_f32_sqrt);\n\n// f64.sqrt -> sqrt<f64>\nfunction builtin_f64_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sqrt, builtin_f64_sqrt);\n\n// f32.trunc -> trunc<f32>\nfunction builtin_f32_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32_trunc, builtin_f32_trunc);\n\n// f64.trunc -> trunc<f64>\nfunction builtin_f64_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64_trunc, builtin_f64_trunc);\n\n// i32.add -> add<i32>\nfunction builtin_i32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_add, builtin_i32_add);\n\n// i64.add -> add<i64>\nfunction builtin_i64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_add, builtin_i64_add);\n\n// f32.add -> add<f32>\nfunction builtin_f32_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32_add, builtin_f32_add);\n\n// f64.add -> add<f64>\nfunction builtin_f64_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64_add, builtin_f64_add);\n\n// i32.sub -> sub<i32>\nfunction builtin_i32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_sub, builtin_i32_sub);\n\n// i64.sub -> sub<i64>\nfunction builtin_i64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_sub, builtin_i64_sub);\n\n// f32.sub -> sub<f32>\nfunction builtin_f32_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32_sub, builtin_f32_sub);\n\n// f64.sub -> sub<f64>\nfunction builtin_f64_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64_sub, builtin_f64_sub);\n\n// i32.mul -> mul<i32>\nfunction builtin_i32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32_mul, builtin_i32_mul);\n\n// i64.mul -> mul<i64>\nfunction builtin_i64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i64_mul, builtin_i64_mul);\n\n// f32.mul -> mul<f32>\nfunction builtin_f32_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32_mul, builtin_f32_mul);\n\n// f64.mul -> mul<f64>\nfunction builtin_f64_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64_mul, builtin_f64_mul);\n\n// i32.div_s -> div<i32>\nfunction builtin_i32_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_s, builtin_i32_div_s);\n\n// i32.div_u -> div<u32>\nfunction builtin_i32_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.u32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i32_div_u, builtin_i32_div_u);\n\n// i64.div_s -> div_s<i64>\nfunction builtin_i64_div_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_s, builtin_i64_div_s);\n\n// i64.div_u -> div_u<u64>\nfunction builtin_i64_div_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.u64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.i64_div_u, builtin_i64_div_u);\n\n// f32.div -> div<f32>\nfunction builtin_f32_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32_div, builtin_f32_div);\n\n// f64.div -> div<f64>\nfunction builtin_f64_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64_div, builtin_f64_div);\n\n// i32.load8_s -> <i32>load<i8>\nfunction builtin_i32_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_s, builtin_i32_load8_s);\n\n// i32.load8_u -> <i32>load<u8>\nfunction builtin_i32_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load8_u, builtin_i32_load8_u);\n\n// i32.load16_s -> <i32>load<i16>\nfunction builtin_i32_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_s, builtin_i32_load16_s);\n\n// i32.load16_u -> <i32>load<u16>\nfunction builtin_i32_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load16_u, builtin_i32_load16_u);\n\n// i32.load -> <i32>load<i32>\nfunction builtin_i32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_load, builtin_i32_load);\n\n// i64.load8_s -> <i64>load<i8>\nfunction builtin_i64_load8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_s, builtin_i64_load8_s);\n\n// i64.load8_u -> <i64>load<u8>\nfunction builtin_i64_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load8_u, builtin_i64_load8_u);\n\n// i64.load16_s -> <i64>load<i16>\nfunction builtin_i64_load16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_s, builtin_i64_load16_s);\n\n// i64.load16_u -> <i64>load<u16>\nfunction builtin_i64_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load16_u, builtin_i64_load16_u);\n\n// i64.load32_s -> <i64>load<i32>\nfunction builtin_i64_load32_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_s, builtin_i64_load32_s);\n\n// i64.load32_u -> <i64>load<u32>\nfunction builtin_i64_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load32_u, builtin_i64_load32_u);\n\n// i64.load -> <i64>load<i64>\nfunction builtin_i64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_load, builtin_i64_load);\n\n// f32.load -> <f32>load<f32>\nfunction builtin_f32_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f32_load, builtin_f32_load);\n\n// f64.load -> <f64>load<f64>\nfunction builtin_f64_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.f64_load, builtin_f64_load);\n\n// i32.store8 -> store<i8 from i32>\nfunction builtin_i32_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store8, builtin_i32_store8);\n\n// i32.store16 -> store<i16 from i32>\nfunction builtin_i32_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store16, builtin_i32_store16);\n\n// i32.store -> store<i32 from i32>\nfunction builtin_i32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_store, builtin_i32_store);\n\n// i64.store8 -> store<i8 from i64>\nfunction builtin_i64_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store8, builtin_i64_store8);\n\n// i64.store16 -> store<i16 from i64>\nfunction builtin_i64_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store16, builtin_i64_store16);\n\n// i64.store32 -> store<i32 from i64>\nfunction builtin_i64_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store32, builtin_i64_store32);\n\n// i64.store -> store<i64 from i64>\nfunction builtin_i64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_store, builtin_i64_store);\n\n// f32.store -> store<f32 from f64>\nfunction builtin_f32_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f32_store, builtin_f32_store);\n\n// f64.store -> store<f64 from f64>\nfunction builtin_f64_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.f64_store, builtin_f64_store);\n\n// i32.atomic.load8_u -> <i32>atomic.load<u8>\nfunction builtin_i32_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load8_u, builtin_i32_atomic_load8_u);\n\n// i32.atomic.load16_u -> <i32>atomic.load<u16>\nfunction builtin_i32_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load16_u, builtin_i32_atomic_load16_u);\n\n// i32.atomic.load -> <i32>atomic.load<i32>\nfunction builtin_i32_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_load, builtin_i32_atomic_load);\n\n// i64.atomic.load8_u -> <i64>atomic.load<u8>\nfunction builtin_i64_atomic_load8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load8_u, builtin_i64_atomic_load8_u);\n\n// i64.atomic.load16_u -> <i64>atomic.load<u16>\nfunction builtin_i64_atomic_load16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load16_u, builtin_i64_atomic_load16_u);\n\n// i64.atomic.load32_u -> <i64>atomic.load<u32>\nfunction builtin_i64_atomic_load32_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load32_u, builtin_i64_atomic_load32_u);\n\n// i64.atomic.load -> <i64>atomic.load<i64>\nfunction builtin_i64_atomic_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_atomic_load(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_load, builtin_i64_atomic_load);\n\n// i32.atomic.store8 -> atomic.store<i8 from i32>\nfunction builtin_i32_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store8, builtin_i32_atomic_store8);\n\n// i32.atomic.store16 -> atomic.store<i16 from i32>\nfunction builtin_i32_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store16, builtin_i32_atomic_store16);\n\n// i32.atomic.store -> atomic.store<i32 from i32>\nfunction builtin_i32_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_store, builtin_i32_atomic_store);\n\n// i64.atomic.store8 -> atomic.store<i8 from i64>\nfunction builtin_i64_atomic_store8(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store8, builtin_i64_atomic_store8);\n\n// i64.atomic.store16 -> atomic.store<i16 from i64>\nfunction builtin_i64_atomic_store16(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store16, builtin_i64_atomic_store16);\n\n// i64.atomic.store32 -> atomic.store<i32 from i64>\nfunction builtin_i64_atomic_store32(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store32, builtin_i64_atomic_store32);\n\n// i64.atomic.store -> atomic.store<i64 from i64>\nfunction builtin_i64_atomic_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_store(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_store, builtin_i64_atomic_store);\n\n// i32.atomic.rmw8.add_u -> <i32>atomic.add<u8 from i32>\nfunction builtin_i32_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_add_u, builtin_i32_atomic_rmw8_add_u);\n\n// i32.atomic.rmw16.add_u -> <i32>atomic.add<u16 from i32>\nfunction builtin_i32_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_add_u, builtin_i32_atomic_rmw16_add_u);\n\n// i32.atomic.rmw.add -> <i32>atomic.add<i32 from i32>\nfunction builtin_i32_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_add, builtin_i32_atomic_rmw_add);\n\n// i64.atomic.rmw8.add_u -> <i64>atomic.add<u8 from i64>\nfunction builtin_i64_atomic_rmw8_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_add_u, builtin_i64_atomic_rmw8_add_u);\n\n// i64.atomic.rmw16.add_u -> <i64>atomic.add<u16 from i64>\nfunction builtin_i64_atomic_rmw16_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_add_u, builtin_i64_atomic_rmw16_add_u);\n\n// i64.atomic.rmw32.add_u -> <i64>atomic.add<u32 from i64>\nfunction builtin_i64_atomic_rmw32_add_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_add_u, builtin_i64_atomic_rmw32_add_u);\n\n// i64.atomic.rmw.add -> <i64>atomic.add<i64 from i64>\nfunction builtin_i64_atomic_rmw_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_add, builtin_i64_atomic_rmw_add);\n\n// i32.atomic.rmw8.sub_u -> <i32>atomic.sub<u8 from i32>\nfunction builtin_i32_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_sub_u, builtin_i32_atomic_rmw8_sub_u);\n\n// i32.atomic.rmw16.sub_u -> <i32>atomic.sub<u16 from i32>\nfunction builtin_i32_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_sub_u, builtin_i32_atomic_rmw16_sub_u);\n\n// i32.atomic.rmw.sub -> <i32>atomic.sub<i32 from i32>\nfunction builtin_i32_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_sub, builtin_i32_atomic_rmw_sub);\n\n// i64.atomic.rmw8.sub_u -> <i64>atomic.sub<u8 from i64>\nfunction builtin_i64_atomic_rmw8_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_sub_u, builtin_i64_atomic_rmw8_sub_u);\n\n// i64.atomic.rmw16.sub_u -> <i64>atomic.sub<u16 from i64>\nfunction builtin_i64_atomic_rmw16_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_sub_u, builtin_i64_atomic_rmw16_sub_u);\n\n// i64.atomic.rmw32.sub_u -> <i64>atomic.sub<u32 from i64>\nfunction builtin_i64_atomic_rmw32_sub_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_sub_u, builtin_i64_atomic_rmw32_sub_u);\n\n// i64.atomic.rmw.sub -> <i64>atomic.sub<i64 from i64>\nfunction builtin_i64_atomic_rmw_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_sub, builtin_i64_atomic_rmw_sub);\n\n// i32.atomic.rmw8.and_u -> <i32>atomic.and<u8 from i32>\nfunction builtin_i32_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_and_u, builtin_i32_atomic_rmw8_and_u);\n\n// i32.atomic.rmw16.and_u -> <i32>atomic.and<u16 from i32>\nfunction builtin_i32_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_and_u, builtin_i32_atomic_rmw16_and_u);\n\n// i32.atomic.rmw.and -> <i32>atomic.and<i32 from i32>\nfunction builtin_i32_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_and, builtin_i32_atomic_rmw_and);\n\n// i64.atomic.rmw8.and_u -> <i64>atomic.and<u8 from i64>\nfunction builtin_i64_atomic_rmw8_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_and_u, builtin_i64_atomic_rmw8_and_u);\n\n// i64.atomic.rmw16.and_u -> <i64>atomic.and<u16 from i64>\nfunction builtin_i64_atomic_rmw16_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_and_u, builtin_i64_atomic_rmw16_and_u);\n\n// i64.atomic.rmw32.and_u -> <i64>atomic.and<u32 from i64>\nfunction builtin_i64_atomic_rmw32_and_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_and_u, builtin_i64_atomic_rmw32_and_u);\n\n// i64.atomic.rmw.and -> <i64>atomic.and<i64 from i64>\nfunction builtin_i64_atomic_rmw_and(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_and(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_and, builtin_i64_atomic_rmw_and);\n\n// i32.atomic.rmw8.or_u -> <i32>atomic.or<u8 from i32>\nfunction builtin_i32_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_or_u, builtin_i32_atomic_rmw8_or_u);\n\n// i32.atomic.rmw16.or_u -> <i32atomic.or<u16 from i32>\nfunction builtin_i32_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_or_u, builtin_i32_atomic_rmw16_or_u);\n\n// i32.atomic.rmw.or -> <i32>atomic.or<i32 from i32>\nfunction builtin_i32_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_or, builtin_i32_atomic_rmw_or);\n\n// i64.atomic.rmw8.or_u -> <i64>atomic.or<u8 from i64>\nfunction builtin_i64_atomic_rmw8_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_or_u, builtin_i64_atomic_rmw8_or_u);\n\n// i64.atomic.rmw16.or_u -> <i64>atomic.or<u16 from i64>\nfunction builtin_i64_atomic_rmw16_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_or_u, builtin_i64_atomic_rmw16_or_u);\n\n// i64.atomic.rmw32.or_u -> <i64>atomic.or<u32 from i64>\nfunction builtin_i64_atomic_rmw32_or_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_or_u, builtin_i64_atomic_rmw32_or_u);\n\n// i64.atomic.rmw.or -> <i64>atomic.or<i64 from i64>\nfunction builtin_i64_atomic_rmw_or(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_or(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_or, builtin_i64_atomic_rmw_or);\n\n// i32.atomic.rmw8.xor_u -> <i32>atomic.xor<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xor_u, builtin_i32_atomic_rmw8_xor_u);\n\n// i32.atomic.rmw16.xor_u -> <i32>atomic.xor<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xor_u, builtin_i32_atomic_rmw16_xor_u);\n\n// i32.atomic.rmw.xor -> <i32>atomic.xor<i32 from i32>\nfunction builtin_i32_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xor, builtin_i32_atomic_rmw_xor);\n\n// i64.atomic.rmw8.xor_u -> <i64>atomic.xor<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xor_u, builtin_i64_atomic_rmw8_xor_u);\n\n// i64.atomic.rmw16.xor_u -> <i64>atomic.xor<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xor_u, builtin_i64_atomic_rmw16_xor_u);\n\n// i64.atomic.rmw32.xor_u -> <i64>atomic.xor<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xor_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xor_u, builtin_i64_atomic_rmw32_xor_u);\n\n// i64.atomic.rmw.xor -> <i64>atomic.xor<i64 from i64>\nfunction builtin_i64_atomic_rmw_xor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xor(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xor, builtin_i64_atomic_rmw_xor);\n\n// i32.atomic.rmw8.xchg_u -> <i32>atomic.xchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_xchg_u, builtin_i32_atomic_rmw8_xchg_u);\n\n// i32.atomic.rmw16.xchg_u -> <i32>atomic.xchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_xchg_u, builtin_i32_atomic_rmw16_xchg_u);\n\n// i32.atomic.rmw.xchg -> <i32>atomic.xchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_xchg, builtin_i32_atomic_rmw_xchg);\n\n// i64.atomic.rmw8.xchg_u -> <i64>atomic.xchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_xchg_u, builtin_i64_atomic_rmw8_xchg_u);\n\n// i64.atomic.rmw16.xchg_u -> <i64>atomic.xchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_xchg_u, builtin_i64_atomic_rmw16_xchg_u);\n\n// i64.atomic.rmw32.xchg_u -> <i64>atomic.xchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_xchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_xchg_u, builtin_i64_atomic_rmw32_xchg_u);\n\n// i64.atomic.rmw.xchg -> <i64>atomic.xchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_xchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_xchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_xchg, builtin_i64_atomic_rmw_xchg);\n\n// i32.atomic.rmw8.cmpxchg_u -> <i32>atomic.cmpxchg<u8 from i32>\nfunction builtin_i32_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw8_cmpxchg_u, builtin_i32_atomic_rmw8_cmpxchg_u);\n\n// i32.atomic.rmw16.cmpxchg_u -> <i32>atomic.cmpxchg<u16 from i32>\nfunction builtin_i32_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw16_cmpxchg_u, builtin_i32_atomic_rmw16_cmpxchg_u);\n\n// i32.atomic.rmw.cmpxchg -> <i32>atomic.cmpxchg<i32 from i32>\nfunction builtin_i32_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i32_atomic_rmw_cmpxchg, builtin_i32_atomic_rmw_cmpxchg);\n\n// i64.atomic.rmw8.cmpxchg_u -> <i64>atomic.cmpxchg<u8 from i64>\nfunction builtin_i64_atomic_rmw8_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw8_cmpxchg_u, builtin_i64_atomic_rmw8_cmpxchg_u);\n\n// i64.atomic.rmw16.cmpxchg_u -> <i64>atomic.cmpxchg<u16 from i64>\nfunction builtin_i64_atomic_rmw16_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw16_cmpxchg_u, builtin_i64_atomic_rmw16_cmpxchg_u);\n\n// i64.atomic.rmw32.cmpxchg_u -> <i64>atomic.cmpxchg<u32 from i64>\nfunction builtin_i64_atomic_rmw32_cmpxchg_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw32_cmpxchg_u, builtin_i64_atomic_rmw32_cmpxchg_u);\n\n// i64.atomic.rmw.cmpxchg -> <i64>atomic.cmpxchg<i64 from i64>\nfunction builtin_i64_atomic_rmw_cmpxchg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  ctx.contextIsExact = true;\n  return builtin_atomic_cmpxchg(ctx);\n}\nbuiltins.set(BuiltinNames.i64_atomic_rmw_cmpxchg, builtin_i64_atomic_rmw_cmpxchg);\n\n// i32.wait -> atomic.wait<i32>\nfunction builtin_i32_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i32_wait, builtin_i32_wait);\n\n// i64.wait -> atomic.wait<i64>\nfunction builtin_i64_wait(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_atomic_wait(ctx);\n}\nbuiltins.set(BuiltinNames.i64_wait, builtin_i64_wait);\n\n// v128.load -> load<v128>\nfunction builtin_v128_load(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  return builtin_load(ctx);\n}\nbuiltins.set(BuiltinNames.v128_load, builtin_v128_load);\n\n// v128.store -> store<v128 from v128>\nfunction builtin_v128_store(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.v128 ];\n  ctx.contextualType = Type.v128;\n  ctx.contextIsExact = true;\n  return builtin_store(ctx);\n}\nbuiltins.set(BuiltinNames.v128_store, builtin_v128_store);\n\n// i8x16_splat -> v128.splat<i8>\nfunction builtin_i8x16_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_splat, builtin_i8x16_splat);\n\n// i8x16.extract_lane_s -> <i32>v128.extract_lane<i8>\nfunction builtin_i8x16_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_s, builtin_i8x16_extract_lane_s);\n\n// i8x16.extract_lane_u -> <i32>v128.extract_lane<u8>\nfunction builtin_i8x16_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_extract_lane_u, builtin_i8x16_extract_lane_u);\n\n// i8x16.replace_lane -> v128.replace_lane<i8>\nfunction builtin_i8x16_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_replace_lane, builtin_i8x16_replace_lane);\n\n// i8x16.add -> v128.add<i8>\nfunction builtin_i8x16_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add, builtin_i8x16_add);\n\n// i8x16.sub -> v128.sub<i8>\nfunction builtin_i8x16_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub, builtin_i8x16_sub);\n\n// i8x16.mul -> v128.mul<i8>\nfunction builtin_i8x16_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_mul, builtin_i8x16_mul);\n\n// i8x16.min_s -> v128.min<i8>\nfunction builtin_i8x16_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_s, builtin_i8x16_min_s);\n\n// i8x16.min_u -> v128.min<u8>\nfunction builtin_i8x16_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_min_u, builtin_i8x16_min_u);\n\n// i8x16.max_s -> v128.max<i8>\nfunction builtin_i8x16_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_s, builtin_i8x16_max_s);\n\n// i8x16.max_u -> v128.max<u8>\nfunction builtin_i8x16_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_max_u, builtin_i8x16_max_u);\n\n// i8x16.avgr_u -> v128.avgr<u8>\nfunction builtin_i8x16_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_avgr_u, builtin_i8x16_avgr_u);\n\n// i8x16.abs -> v128.abs<i8>\nfunction builtin_i8x16_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_abs, builtin_i8x16_abs);\n\n// i8x16.neg -> v128.neg<i8>\nfunction builtin_i8x16_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_neg, builtin_i8x16_neg);\n\n// i8x16.add_saturate_s -> v128.add_saturate<i8>\nfunction builtin_i8x16_add_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_saturate_s, builtin_i8x16_add_saturate_s);\n\n// i8x16.add_saturate_u -> v128.add_saturate<u8>\nfunction builtin_i8x16_add_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_add_saturate_u, builtin_i8x16_add_saturate_u);\n\n// i8x16.sub_saturate_s -> v128.sub_saturate<i8>\nfunction builtin_i8x16_sub_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_saturate_s, builtin_i8x16_sub_saturate_s);\n\n// i8x16.sub_saturate_u -> v128.sub_saturate<u8>\nfunction builtin_i8x16_sub_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_sub_saturate_u, builtin_i8x16_sub_saturate_u);\n\n// i8x16.shl -> v128.shl<i8>\nfunction builtin_i8x16_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shl, builtin_i8x16_shl);\n\n// i8x16.shr_s -> v128.shr<i8>\nfunction builtin_i8x16_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_s, builtin_i8x16_shr_s);\n\n// i8x16.shr_u -> v128.shr<u8>\nfunction builtin_i8x16_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_shr_u, builtin_i8x16_shr_u);\n\n// i8x16.any_true -> v128.any_true<i8>\nfunction builtin_i8x16_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_any_true, builtin_i8x16_any_true);\n\n// i8x16.all_true -> v128.all_true<i8>\nfunction builtin_i8x16_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_all_true, builtin_i8x16_all_true);\n\n// i8x16.bitmask -> v128.bitmask<i8>\nfunction builtin_i8x16_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_bitmask, builtin_i8x16_bitmask);\n\n// i8x16.eq -> v128.eq<i8>\nfunction builtin_i8x16_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_eq, builtin_i8x16_eq);\n\n// i8x16.ne -> v128.ne<i8>\nfunction builtin_i8x16_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ne, builtin_i8x16_ne);\n\n// i8x16.lt_s -> v128.lt<i8>\nfunction builtin_i8x16_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_s, builtin_i8x16_lt_s);\n\n// i8x16.lt_u -> v128.lt<u8>\nfunction builtin_i8x16_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_lt_u, builtin_i8x16_lt_u);\n\n// i8x16.le_s -> v128.le<i8>\nfunction builtin_i8x16_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_s, builtin_i8x16_le_s);\n\n// i8x16.le_u -> v128.le<u8>\nfunction builtin_i8x16_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_le_u, builtin_i8x16_le_u);\n\n// i8x16.gt_s -> v128.gt<i8>\nfunction builtin_i8x16_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_s, builtin_i8x16_gt_s);\n\n// i8x16.gt_u -> v128.gt<u8>\nfunction builtin_i8x16_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_gt_u, builtin_i8x16_gt_u);\n\n// i8x16.ge_s -> v128.ge<i8>\nfunction builtin_i8x16_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_s, builtin_i8x16_ge_s);\n\n// i8x16.ge_u -> v128.ge<u8>\nfunction builtin_i8x16_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_ge_u, builtin_i8x16_ge_u);\n\n// i8x16.narrow_i16x8_s -> v128.narrow<i16>\nfunction builtin_i8x16_narrow_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_s, builtin_i8x16_narrow_i16x8_s);\n\n// i8x16.narrow_i16x8_u -> v128.narrow<u16>\nfunction builtin_i8x16_narrow_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i8x16_narrow_i16x8_u, builtin_i8x16_narrow_i16x8_u);\n\n// i16x8.splat -> v128.splat<i16>\nfunction builtin_i16x8_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_splat, builtin_i16x8_splat);\n\n// i16x8.extract_lane_s -> v128.extract_lane<i16>\nfunction builtin_i16x8_extract_lane_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_s, builtin_i16x8_extract_lane_s);\n\n// i16x8..extract_lane_u -> v128.extract_lane<u16>\nfunction builtin_i16x8_extract_lane_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_extract_lane_u, builtin_i16x8_extract_lane_u);\n\n// i16x8.replace_lane -> v128.replace_lane<i16>\nfunction builtin_i16x8_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_replace_lane, builtin_i16x8_replace_lane);\n\n// i16x8.add -> v128.add<i16>\nfunction builtin_i16x8_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add, builtin_i16x8_add);\n\n// i16x8.sub -> v128.sub<i16>\nfunction builtin_i16x8_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub, builtin_i16x8_sub);\n\n// i16x8.mul -> v128.mul<i16>\nfunction builtin_i16x8_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_mul, builtin_i16x8_mul);\n\n// i16x8.min_s -> v128.min<i16>\nfunction builtin_i16x8_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_s, builtin_i16x8_min_s);\n\n// i16x8.min_u -> v128.min<u16>\nfunction builtin_i16x8_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_min_u, builtin_i16x8_min_u);\n\n// i16x8.max_s -> v128.max<i16>\nfunction builtin_i16x8_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_s, builtin_i16x8_max_s);\n\n// i16x8.max_u -> v128.max<u16>\nfunction builtin_i16x8_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_max_u, builtin_i16x8_max_u);\n\n// i16x8.avgr_u -> v128.avgr<u16>\nfunction builtin_i16x8_avgr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_avgr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_avgr_u, builtin_i16x8_avgr_u);\n\n// i16x8.abs -> v128.abs<i16>\nfunction builtin_i16x8_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_abs, builtin_i16x8_abs);\n\n// i16x8.neg -> v128.neg<i16>\nfunction builtin_i16x8_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_neg, builtin_i16x8_neg);\n\n// i16x8.add_saturate_s -> v128.add_saturate<i16>\nfunction builtin_i16x8_add_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_saturate_s, builtin_i16x8_add_saturate_s);\n\n// i16x8.add_saturate_u -> v128.add_saturate<u16>\nfunction builtin_i16x8_add_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_add_saturate_u, builtin_i16x8_add_saturate_u);\n\n// i16x8.sub_saturate_s -> v128.sub_saturate<i16>\nfunction builtin_i16x8_sub_saturate_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_saturate_s, builtin_i16x8_sub_saturate_s);\n\n// i16x8.sub_saturate_u -> v128.sub_saturate<u16>\nfunction builtin_i16x8_sub_saturate_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub_saturate(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_sub_saturate_u, builtin_i16x8_sub_saturate_u);\n\n// i16x8.shl -> v128.shl<i16>\nfunction builtin_i16x8_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shl, builtin_i16x8_shl);\n\n// i16x8.shr_s -> v128.shr<i16>\nfunction builtin_i16x8_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_s, builtin_i16x8_shr_s);\n\n// i16x8.shr_u -> v128.shr<u16>\nfunction builtin_i16x8_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_shr_u, builtin_i16x8_shr_u);\n\n// i16x8.any_true -> v128.any_true<i16>\nfunction builtin_i16x8_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_any_true, builtin_i16x8_any_true);\n\n// i16x8.all_true -> v128.all_true<i16>\nfunction builtin_i16x8_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_all_true, builtin_i16x8_all_true);\n\n// i16x8.bitmask -> v128.bitmask<i16>\nfunction builtin_i16x8_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_bitmask, builtin_i16x8_bitmask);\n\n// i16x8.eq -> v128.eq<i16>\nfunction builtin_i16x8_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_eq, builtin_i16x8_eq);\n\n// i16x8.ne -> v128.ne<i16>\nfunction builtin_i16x8_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ne, builtin_i16x8_ne);\n\n// i16x8.lt_s -> v128.lt<i16>\nfunction builtin_i16x8_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_s, builtin_i16x8_lt_s);\n\n// i16x8.lt_u -> v128.lt<u16>\nfunction builtin_i16x8_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_lt_u, builtin_i16x8_lt_u);\n\n// i16x8.le_s -> v128.le<i16>\nfunction builtin_i16x8_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_s, builtin_i16x8_le_s);\n\n// i16x8.le_u -> v128.le<u16>\nfunction builtin_i16x8_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_le_u, builtin_i16x8_le_u);\n\n// i16x8.gt_s -> v128.gt<i16>\nfunction builtin_i16x8_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_s, builtin_i16x8_gt_s);\n\n// i16x8.gt_u -> v128.gt<u16>\nfunction builtin_i16x8_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_gt_u, builtin_i16x8_gt_u);\n\n// i16x8.ge_s -> v128.ge<i16>\nfunction builtin_i16x8_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_s, builtin_i16x8_ge_s);\n\n// i16x8.ge_u -> v128.ge<u16>\nfunction builtin_i16x8_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_ge_u, builtin_i16x8_ge_u);\n\n// i16x8.narrow_i32x4_s -> v128.narrow<i32>\nfunction builtin_i16x8_narrow_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_s, builtin_i16x8_narrow_i32x4_s);\n\n// i16x8.narrow_i32x4_u -> v128.narrow<u32>\nfunction builtin_i16x8_narrow_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_narrow(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_narrow_i32x4_u, builtin_i16x8_narrow_i32x4_u);\n\n// i16x8.widen_low_i8x16_s -> v128.widen_low<i8>\nfunction builtin_i16x8_widen_low_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_low_i8x16_s, builtin_i16x8_widen_low_i8x16_s);\n\n// i16x8.widen_low_i8x16_u -> v128.widen_low<u8>\nfunction builtin_i16x8_widen_low_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_low_i8x16_u, builtin_i16x8_widen_low_i8x16_u);\n\n// i16x8.widen_high_i8x16_s -> v128.widen_high<i8>\nfunction builtin_i16x8_widen_high_i8x16_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_high_i8x16_s, builtin_i16x8_widen_high_i8x16_s);\n\n// i16x8.widen_high_i8x16_u -> v128.widen_high<u8>\nfunction builtin_i16x8_widen_high_i8x16_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_widen_high_i8x16_u, builtin_i16x8_widen_high_i8x16_u);\n\n// i16x8.load8x8_s -> v128.load_ext<i8>\nfunction builtin_i16x8_load8x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_load8x8_s, builtin_i16x8_load8x8_s);\n\n// i16x8.load8x8_u -> v128.load_ext<u8>\nfunction builtin_i16x8_load8x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i16x8_load8x8_u, builtin_i16x8_load8x8_u);\n\n// i32x4.splat -> v128.splat<i32>\nfunction builtin_i32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_splat, builtin_i32x4_splat);\n\n// i32x4.extract_lane -> <i32>v128.extract_lane<i32>\nfunction builtin_i32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_extract_lane, builtin_i32x4_extract_lane);\n\n// i32x4.replace_lane -> v128.replace_lane<i32>\nfunction builtin_i32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_replace_lane, builtin_i32x4_replace_lane);\n\n// i32x4.add -> v128.add<i32>\nfunction builtin_i32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_add, builtin_i32x4_add);\n\n// i32x4.sub -> v128.sub<i32>\nfunction builtin_i32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_sub, builtin_i32x4_sub);\n\n// i32x4.mul -> v128.mul<i32>\nfunction builtin_i32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_mul, builtin_i32x4_mul);\n\n// i32x4.min_s -> v128.min<i32>\nfunction builtin_i32x4_min_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_s, builtin_i32x4_min_s);\n\n// i32x4.min_u -> v128.min<u32>\nfunction builtin_i32x4_min_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_min_u, builtin_i32x4_min_u);\n\n// i32x4.max_s -> v128.max<i32>\nfunction builtin_i32x4_max_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_s, builtin_i32x4_max_s);\n\n// i32x4.max_u -> v128.max<u32>\nfunction builtin_i32x4_max_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_max_u, builtin_i32x4_max_u);\n\n// i32x4.dot_i16x8_s -> v128.dot<i16>\nfunction builtin_i32x4_dot_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_dot(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_dot_i16x8_s, builtin_i32x4_dot_i16x8_s);\n\n// i32x4.abs -> v128.abs<i32>\nfunction builtin_i32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_abs, builtin_i32x4_abs);\n\n// i32x4.neg -> v128.neg<i32>\nfunction builtin_i32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_neg, builtin_i32x4_neg);\n\n// i32x4.shl -> v128.shl<i32>\nfunction builtin_i32x4_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shl, builtin_i32x4_shl);\n\n// i32x4.shr_s -> v128.shr<i32>\nfunction builtin_i32x4_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_s, builtin_i32x4_shr_s);\n\n// i32x4.shr_u -> v128.shr<u32>\nfunction builtin_i32x4_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_shr_u, builtin_i32x4_shr_u);\n\n// i32x4.any_true -> v128.any_true<i32>\nfunction builtin_i32x4_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_any_true, builtin_i32x4_any_true);\n\n// i32x4.all_true -> v128.all_true<i32>\nfunction builtin_i32x4_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_all_true, builtin_i32x4_all_true);\n\n// i32x4.bitmask -> v128.bitmask<i32>\nfunction builtin_i32x4_bitmask(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_bitmask(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_bitmask, builtin_i32x4_bitmask);\n\n// i32x4.eq -> v128.eq<i32>\nfunction builtin_i32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_eq, builtin_i32x4_eq);\n\n// i32x4.ne -> v128.ne<i32>\nfunction builtin_i32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ne, builtin_i32x4_ne);\n\n// i32x4.lt_s -> v128.lt<i32>\nfunction builtin_i32x4_lt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_s, builtin_i32x4_lt_s);\n\n// i32x4.lt_u -> v128.lt<u32>\nfunction builtin_i32x4_lt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_lt_u, builtin_i32x4_lt_u);\n\n// i32x4.le_s -> v128.le<i32>\nfunction builtin_i32x4_le_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_s, builtin_i32x4_le_s);\n\n// i32x4.le_u -> v128.le<u32>\nfunction builtin_i32x4_le_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_le_u, builtin_i32x4_le_u);\n\n// i32x4.gt_s -> v128.gt<i32>\nfunction builtin_i32x4_gt_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_s, builtin_i32x4_gt_s);\n\n// i32x4.gt_u -> v128.gt<u32>\nfunction builtin_i32x4_gt_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_gt_u, builtin_i32x4_gt_u);\n\n// i32x4.ge_s -> v128.ge<i32>\nfunction builtin_i32x4_ge_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_s, builtin_i32x4_ge_s);\n\n// i32x4.ge_u -> v128.ge<u32>\nfunction builtin_i32x4_ge_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_ge_u, builtin_i32x4_ge_u);\n\n// i32x4.trunc_sat_f32x4_s -> v128.trunc_sat<i32>\nfunction builtin_i32x4_trunc_sat_f32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_s, builtin_i32x4_trunc_sat_f32x4_s);\n\n// i32x4.trunc_sat_f32x4_u -> v128.trunc_sat<u32>\nfunction builtin_i32x4_trunc_sat_f32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_trunc_sat_f32x4_u, builtin_i32x4_trunc_sat_f32x4_u);\n\n// i32x4.widen_low_i16x8_s -> // v128.widen_low<i16>\nfunction builtin_i32x4_widen_low_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_low_i16x8_s, builtin_i32x4_widen_low_i16x8_s);\n\n// i32x4.widen_low_i16x8_u -> v128.widen_low<u16>\nfunction builtin_i32x4_widen_low_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_low(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_low_i16x8_u, builtin_i32x4_widen_low_i16x8_u);\n\n// i32x4.widen_high_i16x8_s -> v128.widen_high<i16>\nfunction builtin_i32x4_widen_high_i16x8_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_high_i16x8_s, builtin_i32x4_widen_high_i16x8_s);\n\n// i32x4.widen_high_i16x8_u -> v128.widen_high<u16>\nfunction builtin_i32x4_widen_high_i16x8_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_widen_high(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_widen_high_i16x8_u, builtin_i32x4_widen_high_i16x8_u);\n\n// i32x4.load16x4_s -> v128.load_ext<i16>\nfunction builtin_i32x4_load16x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_load16x4_s, builtin_i32x4_load16x4_s);\n\n// i32x4.load16x4_u -> v128.load_ext<u16>\nfunction builtin_i32x4_load16x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i32x4_load16x4_u, builtin_i32x4_load16x4_u);\n\n// i64x2.splat -> v128.splat<i64>\nfunction builtin_i64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_splat, builtin_i64x2_splat);\n\n// i64x2.extract_lane -> <i64>v128.extract_lane<i64>\nfunction builtin_i64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_extract_lane, builtin_i64x2_extract_lane);\n\n// i64x2.replace_lane -> v128.replace_lane<i64>\nfunction builtin_i64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_replace_lane, builtin_i64x2_replace_lane);\n\n// i64x2.add -> v128.add<i64>\nfunction builtin_i64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_add, builtin_i64x2_add);\n\n// i64x2.sub -> v128.sub<i64>\nfunction builtin_i64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_sub, builtin_i64x2_sub);\n\n// i64x2.neg -> v128.neg<i64>\nfunction builtin_i64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_neg, builtin_i64x2_neg);\n\n// i64x2.shl -> v128.shl<i64>\nfunction builtin_i64x2_shl(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shl(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shl, builtin_i64x2_shl);\n\n// i64x2.shr_s -> v128.shr<i64>\nfunction builtin_i64x2_shr_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_s, builtin_i64x2_shr_s);\n\n// i64x2.shr_u -> v128.shr<u64>\nfunction builtin_i64x2_shr_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shr(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_shr_u, builtin_i64x2_shr_u);\n\n// i64x2.any_true -> v128.any_true<i64>\nfunction builtin_i64x2_any_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_any_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_any_true, builtin_i64x2_any_true);\n\n// i64x2.all_true -> v128.all_true<i64>\nfunction builtin_i64x2_all_true(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.i32;\n  return builtin_v128_all_true(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_all_true, builtin_i64x2_all_true);\n\n// i64x2.trunc_sat_f64x2_s -> v128.trunc_sat<i64>\nfunction builtin_i64x2_trunc_sat_f64x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_trunc_sat_f64x2_s, builtin_i64x2_trunc_sat_f64x2_s);\n\n// i64x2.trunc_sat_f64x2_u -> v128.trunc_sat<u64>\nfunction builtin_i64x2_trunc_sat_f64x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc_sat(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_trunc_sat_f64x2_u, builtin_i64x2_trunc_sat_f64x2_u);\n\n// i64x2.load32x2_s -> v128.load_ext<i32>\nfunction builtin_i64x2_load32x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_load32x2_s, builtin_i64x2_load32x2_s);\n\n// i64x2.load32x2_u -> v128.load_ext<u32>\nfunction builtin_i64x2_load32x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_ext(ctx);\n}\nbuiltins.set(BuiltinNames.i64x2_load32x2_u, builtin_i64x2_load32x2_u);\n\n// f32x4.splat -> v128.splat<f32>\nfunction builtin_f32x4_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_splat, builtin_f32x4_splat);\n\n// f32x4.extract_lane -> <f32>v128.extract_lane<f32>\nfunction builtin_f32x4_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.f32;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_extract_lane, builtin_f32x4_extract_lane);\n\n// f32x4.replace_lane -> v128.replace_lane<f32>\nfunction builtin_f32x4_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_replace_lane, builtin_f32x4_replace_lane);\n\n// f32x4.add -> v128.add<f32>\nfunction builtin_f32x4_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_add, builtin_f32x4_add);\n\n// f32x4.sub -> v128.sub<f32>\nfunction builtin_f32x4_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sub, builtin_f32x4_sub);\n\n// f32x4.mul -> v128.mul<f32>\nfunction builtin_f32x4_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_mul, builtin_f32x4_mul);\n\n// f32x4.div -> v128.div<f32>\nfunction builtin_f32x4_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_div, builtin_f32x4_div);\n\n// f32x4.neg -> v128.neg<f32>\nfunction builtin_f32x4_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_neg, builtin_f32x4_neg);\n\n// f32x4.min -> v128.min<f32>\nfunction builtin_f32x4_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_min, builtin_f32x4_min);\n\n// f32x4.max -> v128.max<f32>\nfunction builtin_f32x4_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_max, builtin_f32x4_max);\n\n// f32x4.pmin -> v128.pmin<f32>\nfunction builtin_f32x4_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmin, builtin_f32x4_pmin);\n\n// f32x4.pmax -> v128.pmax<f32>\nfunction builtin_f32x4_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_pmax, builtin_f32x4_pmax);\n\n// f32x4.abs -> v128.abs<f32>\nfunction builtin_f32x4_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_abs, builtin_f32x4_abs);\n\n// f32x4.sqrt -> v128.sqrt<f32>\nfunction builtin_f32x4_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_sqrt, builtin_f32x4_sqrt);\n\n// f32x4.ceil -> v128.ceil<f32>\nfunction builtin_f32x4_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ceil, builtin_f32x4_ceil);\n\n// f32x4.floor -> v128.floor<f32>\nfunction builtin_f32x4_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_floor, builtin_f32x4_floor);\n\n// f32x4.trunc -> v128.trunc<f32>\nfunction builtin_f32x4_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_trunc, builtin_f32x4_trunc);\n\n// f32x4.nearest -> v128.nearest<f32>\nfunction builtin_f32x4_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_nearest, builtin_f32x4_nearest);\n\n// f32x4.eq -> v128.eq<f32>\nfunction builtin_f32x4_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_eq, builtin_f32x4_eq);\n\n// f32x4.ne -> v128.ne<f32>\nfunction builtin_f32x4_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ne, builtin_f32x4_ne);\n\n// f32x4.lt -> v128.lt<f32>\nfunction builtin_f32x4_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_lt, builtin_f32x4_lt);\n\n// f32x4.le -> v128.le<f32>\nfunction builtin_f32x4_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_le, builtin_f32x4_le);\n\n// f32x4.gt -> v128.gt<f32>\nfunction builtin_f32x4_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_gt, builtin_f32x4_gt);\n\n// f32x4.ge -> v128.ge<f32>\nfunction builtin_f32x4_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_ge, builtin_f32x4_ge);\n\n// f32x4.convert_i32x4_s -> v128.convert<i32>\nfunction builtin_f32x4_convert_i32x4_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_s, builtin_f32x4_convert_i32x4_s);\n\n// f32x4.convert_i32x4_u -> v128.convert<u32>\nfunction builtin_f32x4_convert_i32x4_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_convert_i32x4_u, builtin_f32x4_convert_i32x4_u);\n\n// f32x4.qfma -> v128.qfma<f32>\nfunction builtin_f32x4_qfma(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfma(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_qfma, builtin_f32x4_qfma);\n\n// f32x4.qfms -> v128.qfms<f32>\nfunction builtin_f32x4_qfms(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfms(ctx);\n}\nbuiltins.set(BuiltinNames.f32x4_qfms, builtin_f32x4_qfms);\n\n// f64x2.splat -> v128.splat<f64>\nfunction builtin_f64x2_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_splat(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_splat, builtin_f64x2_splat);\n\n// f64x2.extract_lane -> <f64>v128.extract_lane<f64>\nfunction builtin_f64x2_extract_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.f64;\n  return builtin_v128_extract_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_extract_lane, builtin_f64x2_extract_lane);\n\n// f64x2.replace_lane -> v128.replace_lane\nfunction builtin_f64x2_replace_lane(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_replace_lane(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_replace_lane, builtin_f64x2_replace_lane);\n\n// f64x2.add -> v128.add<f64>\nfunction builtin_f64x2_add(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_add(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_add, builtin_f64x2_add);\n\n// f64x2.sub -> v128.sub<f64>\nfunction builtin_f64x2_sub(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sub(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sub, builtin_f64x2_sub);\n\n// f64x2.mul -> v128.mul<f64>\nfunction builtin_f64x2_mul(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_mul(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_mul, builtin_f64x2_mul);\n\n// f64x2.div -> v128.div<f64>\nfunction builtin_f64x2_div(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_div(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_div, builtin_f64x2_div);\n\n// f64x2.neg -> v128.neg<f64>\nfunction builtin_f64x2_neg(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_neg(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_neg, builtin_f64x2_neg);\n\n// f64x2.min -> v128.min<f64>\nfunction builtin_f64x2_min(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_min(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_min, builtin_f64x2_min);\n\n// f64x2.max -> v128.max<f64>\nfunction builtin_f64x2_max(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_max(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_max, builtin_f64x2_max);\n\n// f64x2.pmin -> v128.pmin<f64>\nfunction builtin_f64x2_pmin(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmin(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmin, builtin_f64x2_pmin);\n\n// f64x2.pmax -> v128.pmax<f64>\nfunction builtin_f64x2_pmax(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_pmax(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_pmax, builtin_f64x2_pmax);\n\n// f64x2.abs -> v128.abs<f64>\nfunction builtin_f64x2_abs(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_abs(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_abs, builtin_f64x2_abs);\n\n// f64x2.sqrt -> v128.sqrt<f64>\nfunction builtin_f64x2_sqrt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_sqrt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_sqrt, builtin_f64x2_sqrt);\n\n// f64x2.ceil -> v128.ceil<f64>\nfunction builtin_f64x2_ceil(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ceil(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ceil, builtin_f64x2_ceil);\n\n// f64x2.floor -> v128.floor<f64>\nfunction builtin_f64x2_floor(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_floor(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_floor, builtin_f64x2_floor);\n\n// f64x2.trunc -> v128.trunc<f64>\nfunction builtin_f64x2_trunc(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_trunc(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_trunc, builtin_f64x2_trunc);\n\n// f64x2.nearest -> v128.nearest<f64>\nfunction builtin_f64x2_nearest(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_nearest(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_nearest, builtin_f64x2_nearest);\n\n// f64x2.eq -> v128.eq<f64>\nfunction builtin_f64x2_eq(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_eq(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_eq, builtin_f64x2_eq);\n\n// f64x2.ne -> v128.ne<f64>\nfunction builtin_f64x2_ne(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ne(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ne, builtin_f64x2_ne);\n\n// f64x2.lt -> v128.lt<f64>\nfunction builtin_f64x2_lt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_lt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_lt, builtin_f64x2_lt);\n\n// f64x2.le -> v128.le<f64>\nfunction builtin_f64x2_le(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_le(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_le, builtin_f64x2_le);\n\n// f64x2.gt -> v128.gt<f64>\nfunction builtin_f64x2_gt(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_gt(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_gt, builtin_f64x2_gt);\n\n// f64x2.ge -> v128.ge<f64>\nfunction builtin_f64x2_ge(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_ge(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_ge, builtin_f64x2_ge);\n\n// f64x2.convert_i64x2_s -> v128.convert<i64>\nfunction builtin_f64x2_convert_i64x2_s(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_i64x2_s, builtin_f64x2_convert_i64x2_s);\n\n// f64x2.convert_i64x2_u -> v128.convert<u64>\nfunction builtin_f64x2_convert_i64x2_u(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_convert(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_convert_i64x2_u, builtin_f64x2_convert_i64x2_u);\n\n// f64x2.qfma -> v128.qfma<f64>\nfunction builtin_f64x2_qfma(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfma(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_qfma, builtin_f64x2_qfma);\n\n// f64x2.qfms -> v128.qfms<f64>\nfunction builtin_f64x2_qfms(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.f64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_qfms(ctx);\n}\nbuiltins.set(BuiltinNames.f64x2_qfms, builtin_f64x2_qfms);\n\n// v8x16.shuffle -> v128.shuffle<i8>\nfunction builtin_v8x16_shuffle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.i8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_shuffle(ctx);\n}\nbuiltins.set(BuiltinNames.v8x16_shuffle, builtin_v8x16_shuffle);\n\n// v8x16.swizzle -> v128.swizzle\nfunction builtin_v8x16_swizzle(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = null;\n  ctx.contextualType = Type.v128;\n  return builtin_v128_swizzle(ctx);\n}\nbuiltins.set(BuiltinNames.v8x16_swizzle, builtin_v8x16_swizzle);\n\n// v8x16.load_splat -> v128.load_splat<u8>\nfunction builtin_v8x16_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u8 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v8x16_load_splat, builtin_v8x16_load_splat);\n\n// v16x8.load_splat -> v128.load_splat<u16>\nfunction builtin_v16x8_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u16 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v16x8_load_splat, builtin_v16x8_load_splat);\n\n// v32x4.load_splat -> v128.load_splat<u32>\nfunction builtin_v32x4_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u32 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v32x4_load_splat, builtin_v32x4_load_splat);\n\n// v64x2.load_splat -> v128.load_splat<u64>\nfunction builtin_v64x2_load_splat(ctx: BuiltinContext): ExpressionRef {\n  checkTypeAbsent(ctx);\n  ctx.typeArguments = [ Type.u64 ];\n  ctx.contextualType = Type.v128;\n  return builtin_v128_load_splat(ctx);\n}\nbuiltins.set(BuiltinNames.v64x2_load_splat, builtin_v64x2_load_splat);\n\n// === Internal helpers =======================================================================\n\n/** Compiles the `visit_globals` function. */\nexport function compileVisitGlobals(compiler: Compiler): void {\n  var module = compiler.module;\n  var exprs = new Array<ExpressionRef>();\n  var nativeSizeType = compiler.options.nativeSizeType;\n  var visitInstance = assert(compiler.program.visitInstance);\n\n  // this function is @lazy: make sure it exists\n  compiler.compileFunction(visitInstance, true);\n\n  // TODO: for (let element of compiler.program.elementsByName.values()) {\n  for (let _values = Map_values(compiler.program.elementsByName), i = 0, k = _values.length; i < k; ++i) {\n    let element = unchecked(_values[i]);\n    if (element.kind != ElementKind.GLOBAL) continue;\n    let global = <Global>element;\n    let globalType = global.type;\n    let classReference = globalType.getClass();\n    if (\n      classReference !== null &&\n      !classReference.hasDecorator(DecoratorFlags.UNMANAGED) &&\n      global.is(CommonFlags.COMPILED)\n    ) {\n      if (global.is(CommonFlags.INLINED)) {\n        let value = global.constantIntegerValue;\n        if (i64_low(value) || i64_high(value)) {\n          exprs.push(\n            module.call(visitInstance.internalName, [\n              compiler.options.isWasm64\n                ? module.i64(i64_low(value), i64_high(value))\n                : module.i32(i64_low(value))\n            ], NativeType.None)\n          );\n        }\n      } else {\n        exprs.push(\n          module.if(\n            module.local_tee(1,\n              module.global_get(global.internalName, nativeSizeType)\n            ),\n            module.call(visitInstance.internalName, [\n              module.local_get(1, nativeSizeType), // tempRef != null\n              module.local_get(0, NativeType.I32) // cookie\n            ], NativeType.None)\n          )\n        );\n      }\n    }\n  }\n  module.addFunction(BuiltinNames.visit_globals,\n    NativeType.I32,  // cookie\n    NativeType.None, // => void\n    [ nativeSizeType ],\n    exprs.length\n      ? module.block(null, exprs)\n      : module.nop()\n  );\n}\n\n/** Ensures that the visitor function of the specified class is compiled. */\nfunction ensureVisitMembersOf(compiler: Compiler, instance: Class): void {\n  assert(instance.type.isManaged);\n  if (instance.visitRef) return;\n\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var nativeSizeType = usizeType.toNativeType();\n  var nativeSizeSize = usizeType.byteSize;\n  var visitInstance = assert(program.visitInstance);\n  var body = new Array<ExpressionRef>();\n\n  // If the class has a base class, call its visitor first\n  var base = instance.base;\n  if (base) {\n    body.push(\n      module.call(base.internalName + \"~visit\", [\n        module.local_get(0, nativeSizeType), // this\n        module.local_get(1, NativeType.I32)  // cookie\n      ], NativeType.None)\n    );\n  }\n\n  // Some standard library components provide a custom visitor implementation,\n  // for example to visit all members of a collection, e.g. arrays and maps.\n  var hasVisitImpl = false;\n  if (instance.isDeclaredInLibrary) {\n    let visitPrototype = instance.lookupInSelf(\"__visit\");\n    if (visitPrototype) {\n      assert(visitPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n      let visitInstance = program.resolver.resolveFunction(<FunctionPrototype>visitPrototype, null);\n      if (!visitInstance || !compiler.compileFunction(visitInstance)) {\n        body.push(\n          module.unreachable()\n        );\n      } else {\n        let visitSignature = visitInstance.signature;\n        let visitThisType = assert(visitSignature.thisType);\n        assert(\n          visitSignature.parameterTypes.length == 1 &&\n          visitSignature.parameterTypes[0] == Type.u32 &&\n          visitSignature.returnType == Type.void &&\n          instance.type.isStrictlyAssignableTo(visitThisType) // incl. implemented on super\n        );\n        body.push(\n          module.call(visitInstance.internalName, [\n            module.local_get(0, nativeSizeType), // this\n            module.local_get(1, NativeType.I32)  // cookie\n          ], NativeType.None)\n        );\n      }\n      hasVisitImpl = true;\n    }\n  }\n\n  // Otherwise, if there is no custom visitor, generate a visitor function\n  // according to class layout, visiting all _own_ managed members.\n  var needsTempValue = false;\n  if (!hasVisitImpl) {\n    let members = instance.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), j = 0, l = _values.length; j < l; ++j) {\n        let member = unchecked(_values[j]);\n        if (member.kind == ElementKind.FIELD) {\n          if ((<Field>member).parent === instance) {\n            let fieldType = (<Field>member).type;\n            if (fieldType.isManaged) {\n              let fieldOffset = (<Field>member).memoryOffset;\n              assert(fieldOffset >= 0);\n              needsTempValue = true;\n              body.push(\n                // if ($2 = value) __visit($2, $1)\n                module.if(\n                  module.local_tee(2,\n                    module.load(nativeSizeSize, false,\n                      module.local_get(0, nativeSizeType),\n                      nativeSizeType, fieldOffset\n                    )\n                  ),\n                  module.call(visitInstance.internalName, [\n                    module.local_get(2, nativeSizeType), // value\n                    module.local_get(1, NativeType.I32)  // cookie\n                  ], NativeType.None)\n                )\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Create the visitor function\n  instance.visitRef = module.addFunction(instance.internalName + \"~visit\",\n    createType([nativeSizeType, NativeType.I32]),\n    NativeType.None,\n    needsTempValue ? [ nativeSizeType ] : null,\n    module.flatten(body, NativeType.None)\n  );\n\n  // And make sure the base visitor function exists\n  if (base) ensureVisitMembersOf(compiler, base);\n}\n\n/** Compiles the `__visit_members` function. */\nexport function compileVisitMembers(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var usizeType = program.options.usizeType;\n  var nativeSizeType = usizeType.toNativeType();\n  var managedClasses = program.managedClasses;\n  var visitInstance = assert(program.visitInstance);\n  compiler.compileFunction(visitInstance, true); // is lazy, make sure it is compiled\n\n  // Prepare a mapping of class names to visitor calls. Each name corresponds to\n  // the respective sequential (0..N) class id.\n  var names = new Array<string>();\n  var cases = new Array<ExpressionRef>();\n  var nextId = 0;\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = _keys[i];\n    assert(instanceId == nextId++);\n    let instance = assert(managedClasses.get(instanceId));\n    names[i] = instance.internalName;\n    cases[i] = module.block(null, [\n      module.call(instance.internalName + \"~visit\", [\n        module.local_get(0, nativeSizeType), // this\n        module.local_get(1, NativeType.I32)  // cookie\n      ], NativeType.None),\n      module.return()\n    ], NativeType.None);\n    ensureVisitMembersOf(compiler, instance);\n  }\n\n  // Make a br_table of the mapping, calling visitor functions by unique class id\n  var current = module.block(names[0], [\n    module.switch(names, \"invalid\",\n      // load<u32>(changetype<usize>(this) - 8)\n      module.load(4, false,\n        nativeSizeType == NativeType.I64\n          ? module.binary(BinaryOp.SubI64,\n              module.local_get(0, nativeSizeType),\n              module.i64(8)\n            )\n          : module.binary(BinaryOp.SubI32,\n              module.local_get(0, nativeSizeType),\n              module.i32(8) // rtId is at -8\n            ),\n        NativeType.I32, 0\n      )\n    )\n  ], NativeType.None);\n\n  // Wrap blocks in order\n  for (let i = 0, k = names.length - 1; i < k; ++i) {\n    current = module.block(names[i + 1], [\n      current,\n      cases[i]\n    ], NativeType.None);\n  }\n\n  // Wrap the last id in an 'invalid' block to break out of on invalid ids\n  current = module.block(\"invalid\", [\n    current,\n    cases[names.length - 1]\n  ], NativeType.None);\n\n  // Add the function, executing an unreachable if breaking to 'invalid'\n  module.addFunction(BuiltinNames.visit_members,\n    createType([ nativeSizeType, NativeType.I32 ]), // this, cookie\n    NativeType.None, // => void\n    null,\n    module.flatten([\n      current,\n      module.unreachable()\n    ])\n  );\n}\n\nfunction typeToRuntimeFlags(type: Type): TypeinfoFlags {\n  var flags = TypeinfoFlags.VALUE_ALIGN_0 * (1 << type.alignLog2);\n  if (type.is(TypeFlags.SIGNED)) flags |= TypeinfoFlags.VALUE_SIGNED;\n  if (type.is(TypeFlags.FLOAT)) flags |= TypeinfoFlags.VALUE_FLOAT;\n  if (type.is(TypeFlags.NULLABLE)) flags |= TypeinfoFlags.VALUE_NULLABLE;\n  if (type.isManaged) flags |= TypeinfoFlags.VALUE_MANAGED;\n  return flags / TypeinfoFlags.VALUE_ALIGN_0;\n}\n\n/** Compiles runtime type information for use by stdlib. */\nexport function compileRTTI(compiler: Compiler): void {\n  var program = compiler.program;\n  var module = compiler.module;\n  var managedClasses = program.managedClasses;\n  var count = managedClasses.size;\n  var size = 4 + 8 * count;\n  var data = new Uint8Array(size);\n  writeI32(count, data, 0);\n  var off = 4;\n  var abvInstance = program.arrayBufferViewInstance;\n  var abvPrototype = abvInstance.prototype;\n  var arrayPrototype = program.arrayPrototype;\n  var setPrototype = program.setPrototype;\n  var mapPrototype = program.mapPrototype;\n  var staticArrayPrototype = program.staticArrayPrototype;\n  var lastId = 0;\n  // TODO: for (let [instanceId, instance] of managedClasses) {\n  for (let _keys = Map_keys(managedClasses), i = 0, k = _keys.length; i < k; ++i) {\n    let instanceId = unchecked(_keys[i]);\n    let instance = assert(managedClasses.get(instanceId));\n    assert(instanceId == lastId++);\n    let flags: TypeinfoFlags = 0;\n    if (instance.isAcyclic) flags |= TypeinfoFlags.ACYCLIC;\n    if (instance !== abvInstance && instance.extends(abvPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAYBUFFERVIEW;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(arrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.ARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    } else if (instance.extends(setPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(setPrototype));\n      assert(typeArguments.length == 1);\n      flags |= TypeinfoFlags.SET;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n    } else if (instance.extends(mapPrototype)) {\n      let typeArguments = assert(instance.getTypeArgumentsTo(mapPrototype));\n      assert(typeArguments.length == 2);\n      flags |= TypeinfoFlags.MAP;\n      flags |= TypeinfoFlags.KEY_ALIGN_0 * typeToRuntimeFlags(typeArguments[0]);\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(typeArguments[1]);\n    } else if (instance.extends(staticArrayPrototype)) {\n      let valueType = instance.getArrayValueType();\n      flags |= TypeinfoFlags.STATICARRAY;\n      flags |= TypeinfoFlags.VALUE_ALIGN_0 * typeToRuntimeFlags(valueType);\n    }\n    writeI32(flags, data, off); off += 4;\n    instance.rttiFlags = flags;\n    let base = instance.base;\n    writeI32(base ? base.id : 0, data, off); off += 4;\n  }\n  assert(off == size);\n  var usizeType = program.options.usizeType;\n  var segment = compiler.addAlignedMemorySegment(data);\n  if (usizeType.size == 8) {\n    let offset = segment.offset;\n    module.addGlobal(BuiltinNames.rtti_base, NativeType.I64, false, module.i64(i64_low(offset), i64_high(offset)));\n  } else {\n    module.addGlobal(BuiltinNames.rtti_base, NativeType.I32, false, module.i32(i64_low(segment.offset)));\n  }\n}\n\n/** Compiles a class-specific instanceof helper, checking a ref against all concrete instances. */\nexport function compileClassInstanceOf(compiler: Compiler, prototype: ClassPrototype): void {\n  var module = compiler.module;\n  var nativeSizeType = compiler.options.nativeSizeType;\n  var instanceofInstance = assert(prototype.program.instanceofInstance);\n  compiler.compileFunction(instanceofInstance);\n\n  var stmts = new Array<ExpressionRef>();\n\n  // if (!ref) return false\n  stmts.push(\n    module.if(\n      module.unary(\n        nativeSizeType == NativeType.I64\n          ? UnaryOp.EqzI64\n          : UnaryOp.EqzI32,\n        module.local_get(0, nativeSizeType)\n      ),\n      module.return(\n        module.i32(0)\n      )\n    )\n  );\n\n  // if (__instanceof(ref, ID[i])) return true\n  var instances = prototype.instances;\n  if (instances !== null && instances.size > 0) {\n    // TODO: for (let instance of instances.values()) {\n    for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      stmts.push(\n        module.if(\n          module.call(instanceofInstance.internalName, [\n            module.local_get(0, nativeSizeType),\n            module.i32(instance.id)\n          ], NativeType.I32),\n          module.return(\n            module.i32(1)\n          )\n        )\n      );\n    }\n  }\n\n  // return false\n  stmts.push(\n    module.return(\n      module.i32(0)\n    )\n  );\n\n  module.addFunction(prototype.internalName + \"~instanceof\", nativeSizeType, NativeType.I32, null, module.flatten(stmts));\n}\n\n// Helpers\n\n/** Evaluates the constant type of a type argument *or* expression. */\nfunction evaluateConstantType(ctx: BuiltinContext): Type | null {\n  var compiler = ctx.compiler;\n  var operands = ctx.operands;\n  var typeArguments = ctx.typeArguments;\n  if (operands.length == 0) { // requires type argument\n    if (!typeArguments || typeArguments.length != 1) {\n      compiler.error(\n        DiagnosticCode.Expected_0_type_arguments_but_got_1,\n        ctx.reportNode.typeArgumentsRange, \"1\", typeArguments ? typeArguments.length.toString() : \"0\"\n      );\n      return null;\n    }\n    return typeArguments[0];\n  }\n  if (operands.length == 1) { // optional type argument\n    if (typeArguments !== null && typeArguments.length > 0) {\n      if (typeArguments.length > 1) {\n        compiler.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n        );\n        return null;\n      }\n      compiler.compileExpression(operands[0], typeArguments[0], Constraints.CONV_IMPLICIT);\n    } else {\n      compiler.compileExpression(operands[0], Type.auto);\n    }\n    return compiler.currentType;\n  }\n  if (typeArguments !== null && typeArguments.length > 1) {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", typeArguments.length.toString()\n    );\n  }\n  compiler.error(\n    DiagnosticCode.Expected_0_arguments_but_got_1,\n    ctx.reportNode.argumentsRange, \"1\", operands.length.toString()\n  );\n  return null;\n}\n\n/** Evaluates a compile-time constant immediate offset argument.*/\nfunction evaluateImmediateOffset(expression: Expression, compiler: Compiler): i32 {\n  var module = compiler.module;\n  var value: i32;\n  if (compiler.options.isWasm64) {\n    let expr = compiler.compileExpression(expression, Type.usize64, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      assert(getConstValueI64High(precomp) == 0); // TODO\n      value = getConstValueI64Low(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  } else {\n    let expr = compiler.compileExpression(expression, Type.usize32, Constraints.CONV_IMPLICIT);\n    let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n    if (precomp) {\n      value = getConstValueI32(precomp);\n    } else {\n      compiler.error(\n        DiagnosticCode.Expression_must_be_a_compile_time_constant,\n        expression.range\n      );\n      value = -1;\n    }\n  }\n  return value;\n}\n\n/** Evaluates a compile-time constant immediate align argument. */\nfunction evaluateImmediateAlign(expression: Expression, naturalAlign: i32, compiler: Compiler): i32 {\n  var align = evaluateImmediateOffset(expression, compiler);\n  if (align < 0) return align;\n  if (align < 1 || naturalAlign > 16) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_value_between_1_and_2_inclusive,\n      expression.range, \"Alignment\", \"1\", naturalAlign.toString()\n    );\n    return -1;\n  }\n  if (!isPowerOf2(align)) {\n    compiler.error(\n      DiagnosticCode._0_must_be_a_power_of_two,\n      expression.range, \"Alignment\"\n    );\n    return -1;\n  }\n  return align;\n}\n\n/** Checks that the specified feature is enabled. */\nfunction checkFeatureEnabled(ctx: BuiltinContext, feature: Feature): i32 {\n  var compiler = ctx.compiler;\n  if (!compiler.options.hasFeature(feature)) {\n    compiler.error(\n      DiagnosticCode.Feature_0_is_not_enabled,\n      ctx.reportNode.range, featureToString(feature)\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call with a single required type argument. Returns `1` on error. */\nfunction checkTypeRequired(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var compiler = ctx.compiler;\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n  } else {\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.range, \"1\", \"0\"\n    );\n  }\n  return 1;\n}\n\n/** Checks a call with a single optional type argument. Returns `1` on error. */\nfunction checkTypeOptional(ctx: BuiltinContext, setCurrentTypeOnError: bool = false): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let compiler = ctx.compiler;\n    let numTypeArguments = typeArguments.length;\n    if (numTypeArguments == 1) return 0;\n    assert(numTypeArguments); // invalid if 0, must not be set at all instead\n    if (setCurrentTypeOnError) compiler.currentType = typeArguments[0];\n    compiler.error(\n      DiagnosticCode.Expected_0_type_arguments_but_got_1,\n      ctx.reportNode.typeArgumentsRange, \"1\", numTypeArguments.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that is not generic. Returns `1` on error. */\nfunction checkTypeAbsent(ctx: BuiltinContext): i32 {\n  var typeArguments = ctx.typeArguments;\n  if (typeArguments) {\n    let prototype = ctx.prototype;\n    prototype.program.error(\n      DiagnosticCode.Type_0_is_not_generic,\n      ctx.reportNode.typeArgumentsRange, prototype.internalName\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a fixed number of arguments. Returns `1` on error. */\nfunction checkArgsRequired(ctx: BuiltinContext, expected: i32): i32 {\n  var operands = ctx.operands;\n  if (operands.length != expected) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expected.toString(), operands.length.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Checks a call that requires a variable number of arguments. Returns `1` on error. */\nfunction checkArgsOptional(ctx: BuiltinContext, expectedMinimum: i32, expectedMaximum: i32): i32 {\n  var operands = ctx.operands;\n  var numOperands = operands.length;\n  if (numOperands < expectedMinimum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMinimum.toString(), numOperands.toString()\n    );\n    return 1;\n  } else if (numOperands > expectedMaximum) {\n    ctx.compiler.error(\n      DiagnosticCode.Expected_0_arguments_but_got_1,\n      ctx.reportNode.range, expectedMaximum.toString(), numOperands.toString()\n    );\n    return 1;\n  }\n  return 0;\n}\n\n/** Makes an usize constant matching contextual type if reasonable. */\nfunction contextualUsize(compiler: Compiler, value: i64, contextualType: Type): ExpressionRef {\n  var module = compiler.module;\n  // Check if contextual type fits\n  if (contextualType != Type.auto && contextualType.isIntegerValue) {\n    switch (contextualType.kind) {\n      case TypeKind.I32: {\n        if (i64_is_i32(value)) {\n          compiler.currentType = Type.i32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.U32: {\n        if (i64_is_u32(value)) {\n          compiler.currentType = Type.u32;\n          return module.i32(i64_low(value));\n        }\n        break;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        compiler.currentType = contextualType;\n        return module.i64(i64_low(value), i64_high(value));\n      }\n      // isize/usize falls through\n      // small int is probably not intended\n    }\n  }\n  // Default to usize\n  if (compiler.options.isWasm64) {\n    compiler.currentType = Type.usize64;\n    return module.i64(i64_low(value), i64_high(value));\n  } else {\n    compiler.currentType = Type.usize32;\n    assert(!i64_high(value));\n    return module.i32(i64_low(value));\n  }\n}\n","/**\n * @fileoverview Common constants used by various parts of the compiler.\n * @license Apache-2.0\n */\n\n/** Indicates traits of a {@link Node} or {@link Element}. */\nexport enum CommonFlags {\n  /** No flags set. */\n  NONE = 0,\n\n  // Basic modifiers\n\n  /** Has an `import` modifier. */\n  IMPORT = 1 << 0,\n  /** Has an `export` modifier. */\n  EXPORT = 1 << 1,\n  /** Has a `declare` modifier. */\n  DECLARE = 1 << 2,\n  /** Has a `const` modifier. */\n  CONST = 1 << 3,\n  /** Has a `let` modifier. */\n  LET = 1 << 4,\n  /** Has a `static` modifier. */\n  STATIC = 1 << 5,\n  /** Has a `readonly` modifier. */\n  READONLY = 1 << 6,\n  /** Has an `abstract` modifier. */\n  ABSTRACT = 1 << 7,\n  /** Has a `public` modifier. */\n  PUBLIC = 1 << 8,\n  /** Has a `private` modifier. */\n  PRIVATE = 1 << 9,\n  /** Has a `protected` modifier. */\n  PROTECTED = 1 << 10,\n  /** Has a `get` modifier. */\n  GET = 1 << 11,\n  /** Has a `set` modifier. */\n  SET = 1 << 12,\n  /** Has a definite assignment assertion `!` as in `x!: i32;`. */\n  DEFINITELY_ASSIGNED = 1 << 13,\n\n  // Extended modifiers usually derived from basic modifiers\n\n  /** Is ambient, that is either declared or nested in a declared element. */\n  AMBIENT = 1 << 14,\n  /** Is generic. */\n  GENERIC = 1 << 15,\n  /** Is part of a generic context. */\n  GENERIC_CONTEXT = 1 << 16,\n  /** Is an instance member. */\n  INSTANCE = 1 << 17,\n  /** Is a constructor. */\n  CONSTRUCTOR = 1 << 18,\n  /** Is a module export. */\n  MODULE_EXPORT = 1 << 19,\n  /** Is a module import. */\n  MODULE_IMPORT = 1 << 20,\n\n  // Compilation states\n\n  /** Is resolved. */\n  RESOLVED = 1 << 21,\n  /** Is compiled. */\n  COMPILED = 1 << 22,\n  /** Did error. */\n  ERRORED = 1 << 23,\n  /** Has a constant value and is therefore inlined. */\n  INLINED = 1 << 24,\n  /** Is scoped. */\n  SCOPED = 1 << 25,\n  /** Is a stub. */\n  STUB = 1 << 26,\n  /** Is a virtual method. */\n  VIRTUAL = 1 << 27,\n  /** Is (part of) a closure. */\n  CLOSURE = 1 << 28,\n\n  // Other\n\n  /** Is quoted. */\n  QUOTED = 1 << 29\n}\n\n/** Path delimiter inserted between file system levels. */\nexport const PATH_DELIMITER = \"/\";\n/** Substitution used to indicate the parent directory. */\nexport const PARENT_SUBST = \"..\";\n/** Function name prefix used for getters. */\nexport const GETTER_PREFIX = \"get:\";\n/** Function name prefix used for setters. */\nexport const SETTER_PREFIX = \"set:\";\n/** Delimiter used between class names and instance members. */\nexport const INSTANCE_DELIMITER = \"#\";\n/** Delimiter used between class and namespace names and static members. */\nexport const STATIC_DELIMITER = \".\";\n/** Delimiter used between a function and its inner elements. */\nexport const INNER_DELIMITER = \"~\";\n/** Substitution used to indicate a library directory. */\nexport const LIBRARY_SUBST = \"~lib\";\n/** Library directory prefix. */\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\n/** Path index suffix. */\nexport const INDEX_SUFFIX = PATH_DELIMITER + \"index\";\n/** Stub function delimiter. */\nexport const STUB_DELIMITER = \"@\";\n\n/** Common names. */\nexport namespace CommonNames {\n  // special\n  export const EMPTY = \"\";\n  // types\n  export const i8 = \"i8\";\n  export const i16 = \"i16\";\n  export const i32 = \"i32\";\n  export const i64 = \"i64\";\n  export const isize = \"isize\";\n  export const u8 = \"u8\";\n  export const u16 = \"u16\";\n  export const u32 = \"u32\";\n  export const u64 = \"u64\";\n  export const usize = \"usize\";\n  export const bool = \"bool\";\n  export const f32 = \"f32\";\n  export const f64 = \"f64\";\n  export const v128 = \"v128\";\n  export const funcref = \"funcref\";\n  export const externref = \"externref\";\n  export const exnref = \"exnref\";\n  export const anyref = \"anyref\";\n  export const i8x16 = \"i8x16\";\n  export const u8x16 = \"u8x16\";\n  export const i16x8 = \"i16x8\";\n  export const u16x8 = \"u16x8\";\n  export const i32x4 = \"i32x4\";\n  export const u32x4 = \"u32x4\";\n  export const i64x2 = \"i64x2\";\n  export const u64x2 = \"u64x2\";\n  export const f32x4 = \"f32x4\";\n  export const f64x2 = \"f64x2\";\n  export const void_ = \"void\";\n  export const number = \"number\";\n  export const boolean = \"boolean\";\n  export const string = \"string\";\n  export const native = \"native\";\n  export const indexof = \"indexof\";\n  export const valueof = \"valueof\";\n  export const returnof = \"returnof\";\n  // aliases\n  export const null_ = \"null\";\n  export const true_ = \"true\";\n  export const false_ = \"false\";\n  // objects\n  export const this_ = \"this\";\n  export const super_ = \"super\";\n  export const constructor = \"constructor\";\n  // constants\n  export const ASC_TARGET = \"ASC_TARGET\";\n  export const ASC_NO_TREESHAKING = \"ASC_NO_TREESHAKING\";\n  export const ASC_NO_ASSERT = \"ASC_NO_ASSERT\";\n  export const ASC_MEMORY_BASE = \"ASC_MEMORY_BASE\";\n  export const ASC_TABLE_BASE = \"ASC_TABLE_BASE\";\n  export const ASC_OPTIMIZE_LEVEL = \"ASC_OPTIMIZE_LEVEL\";\n  export const ASC_SHRINK_LEVEL = \"ASC_SHRINK_LEVEL\";\n  export const ASC_LOW_MEMORY_LIMIT = \"ASC_LOW_MEMORY_LIMIT\";\n  export const ASC_WASI = \"ASC_WASI\";\n  export const ASC_FEATURE_SIGN_EXTENSION = \"ASC_FEATURE_SIGN_EXTENSION\";\n  export const ASC_FEATURE_MUTABLE_GLOBALS = \"ASC_FEATURE_MUTABLE_GLOBALS\";\n  export const ASC_FEATURE_NONTRAPPING_F2I = \"ASC_FEATURE_NONTRAPPING_F2I\";\n  export const ASC_FEATURE_BULK_MEMORY = \"ASC_FEATURE_BULK_MEMORY\";\n  export const ASC_FEATURE_SIMD = \"ASC_FEATURE_SIMD\";\n  export const ASC_FEATURE_THREADS = \"ASC_FEATURE_THREADS\";\n  export const ASC_FEATURE_EXCEPTION_HANDLING = \"ASC_FEATURE_EXCEPTION_HANDLING\";\n  export const ASC_FEATURE_TAIL_CALLS = \"ASC_FEATURE_TAIL_CALLS\";\n  export const ASC_FEATURE_REFERENCE_TYPES = \"ASC_FEATURE_REFERENCE_TYPES\";\n  export const ASC_FEATURE_MULTI_VALUE = \"ASC_FEATURE_MULTI_VALUE\";\n  export const ASC_FEATURE_GC = \"ASC_FEATURE_GC\";\n  export const ASC_FEATURE_MEMORY64 = \"ASC_FEATURE_MEMORY64\";\n  // classes\n  export const I8 = \"I8\";\n  export const I16 = \"I16\";\n  export const I32 = \"I32\";\n  export const I64 = \"I64\";\n  export const Isize = \"Isize\";\n  export const U8 = \"U8\";\n  export const U16 = \"U16\";\n  export const U32 = \"U32\";\n  export const U64 = \"U64\";\n  export const Usize = \"Usize\";\n  export const Bool = \"Bool\";\n  export const F32 = \"F32\";\n  export const F64 = \"F64\";\n  export const V128 = \"V128\";\n  export const Funcref = \"Funcref\";\n  export const Externref = \"Externref\";\n  export const Exnref = \"Exnref\";\n  export const Anyref = \"Anyref\";\n  export const String = \"String\";\n  export const Array = \"Array\";\n  export const StaticArray = \"StaticArray\";\n  export const Set = \"Set\";\n  export const Map = \"Map\";\n  export const Function = \"Function\";\n  export const ArrayBufferView = \"ArrayBufferView\";\n  export const ArrayBuffer = \"ArrayBuffer\";\n  export const Math = \"Math\";\n  export const Mathf = \"Mathf\";\n  export const NativeMath = \"NativeMath\";\n  export const NativeMathf = \"NativeMathf\";\n  export const Int8Array = \"Int8Array\";\n  export const Int16Array = \"Int16Array\";\n  export const Int32Array = \"Int32Array\";\n  export const Int64Array = \"Int64Array\";\n  export const Uint8Array = \"Uint8Array\";\n  export const Uint8ClampedArray = \"Uint8ClampedArray\";\n  export const Uint16Array = \"Uint16Array\";\n  export const Uint32Array = \"Uint32Array\";\n  export const Uint64Array = \"Uint64Array\";\n  export const Float32Array = \"Float32Array\";\n  export const Float64Array = \"Float64Array\";\n  export const Error = \"Error\";\n  // runtime\n  export const abort = \"abort\";\n  export const trace = \"trace\";\n  export const seed = \"seed\";\n  export const pow = \"pow\";\n  export const ipow32 = \"ipow32\";\n  export const ipow64 = \"ipow64\";\n  export const mod = \"mod\";\n  export const alloc = \"__alloc\";\n  export const realloc = \"__realloc\";\n  export const free = \"__free\";\n  export const new_ = \"__new\";\n  export const renew = \"__renew\";\n  export const retain = \"__retain\";\n  export const release = \"__release\";\n  export const collect = \"__collect\";\n  export const typeinfo = \"__typeinfo\";\n  export const instanceof_ = \"__instanceof\";\n  export const visit = \"__visit\";\n  export const newBuffer = \"__newBuffer\";\n  export const newArray = \"__newArray\";\n  export const BLOCK = \"~lib/rt/common/BLOCK\";\n  export const OBJECT = \"~lib/rt/common/OBJECT\";\n}\n\n// shared\nexport { Feature, featureToString } from \"../std/assembly/shared/feature\";\nexport { Target } from \"../std/assembly/shared/target\";\nexport { Typeinfo, TypeinfoFlags } from \"../std/assembly/shared/typeinfo\";\n","/**\n * @fileoverview The AssemblyScript compiler.\n * @license Apache-2.0\n */\n\nimport {\n  BuiltinNames,\n  BuiltinContext,\n  builtins,\n  function_builtins,\n  compileVisitGlobals,\n  compileVisitMembers,\n  compileRTTI,\n  compileClassInstanceOf\n} from \"./builtins\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Module,\n  MemorySegment,\n  ExpressionRef,\n  UnaryOp,\n  BinaryOp,\n  NativeType,\n  FunctionRef,\n  ExpressionId,\n  GlobalRef,\n  FeatureFlags,\n  Index,\n  getExpressionId,\n  getExpressionType,\n  getConstValueI32,\n  getConstValueI64Low,\n  getConstValueI64High,\n  getConstValueF32,\n  getConstValueF64,\n  getBlockChildCount,\n  getBlockChildAt,\n  getBlockName,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetIndex,\n  needsExplicitUnreachable,\n  getLocalSetValue,\n  getGlobalGetName,\n  isGlobalMutable,\n  createType,\n  getSideEffects,\n  SideEffects,\n  SwitchBuilder,\n  ExpressionRunnerFlags\n} from \"./module\";\n\nimport {\n  CommonFlags,\n  INSTANCE_DELIMITER,\n  STATIC_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INDEX_SUFFIX,\n  CommonNames,\n  Feature,\n  Target,\n  featureToString\n} from \"./common\";\n\nimport {\n  Program,\n  ClassPrototype,\n  Class,\n  Element,\n  ElementKind,\n  Enum,\n  Field,\n  FunctionPrototype,\n  Function,\n  Global,\n  Local,\n  EnumValue,\n  Property,\n  VariableLikeElement,\n  ConstantValueKind,\n  OperatorKind,\n  DecoratorFlags,\n  PropertyPrototype,\n  IndexSignature,\n  File,\n  mangleInternalName,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  FlowFlags,\n  Flow,\n  LocalFlags,\n  FieldFlags,\n  ConditionKind,\n  findUsedLocals\n} from \"./flow\";\n\nimport {\n  Resolver,\n  ReportMode\n} from \"./resolver\";\n\nimport {\n  Token,\n  Range,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  DecoratorKind,\n  AssertionKind,\n  SourceKind,\n  FunctionTypeNode,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DoStatement,\n  EmptyStatement,\n  EnumDeclaration,\n  ExportDefaultStatement,\n  ExportStatement,\n  ExpressionStatement,\n  FieldDeclaration,\n  ForStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  NamespaceDeclaration,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  VoidStatement,\n  WhileStatement,\n\n  Expression,\n  AssertionExpression,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FloatLiteralExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  IntegerLiteralExpression,\n  LiteralExpression,\n  LiteralKind,\n  NewExpression,\n  ObjectLiteralExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  ArrayLiteralExpression,\n  StringLiteralExpression,\n  UnaryPostfixExpression,\n  UnaryPrefixExpression,\n\n  NamedTypeNode,\n\n  findDecorator,\n  isTypeOmitted\n} from \"./ast\";\n\nimport {\n  Type,\n  TypeKind,\n  TypeFlags,\n  Signature,\n  typesToNativeTypes\n} from \"./types\";\n\nimport {\n  writeI8,\n  writeI16,\n  writeI32,\n  writeI64,\n  writeF32,\n  writeF64,\n  uniqueMap,\n  isPowerOf2,\n  v128_zero\n} from \"./util\";\n\n/** Compiler options. */\nexport class Options {\n\n  /** WebAssembly target. Defaults to {@link Target.WASM32}. */\n  target: Target = Target.WASM32;\n  /** If true, replaces assertions with nops. */\n  noAssert: bool = false;\n  /** It true, exports the memory to the embedder. */\n  exportMemory: bool = true;\n  /** If true, imports the memory provided by the embedder. */\n  importMemory: bool = false;\n  /** Initial memory size, in pages. */\n  initialMemory: u32 = 0;\n  /** Maximum memory size, in pages. */\n  maximumMemory: u32 = 0;\n  /** If true, memory is declared as shared. */\n  sharedMemory: bool = false;\n  /** If true, imports the function table provided by the embedder. */\n  importTable: bool = false;\n  /** If true, exports the function table. */\n  exportTable: bool = false;\n  /** If true, generates information necessary for source maps. */\n  sourceMap: bool = false;\n  /** If true, generates an explicit start function. */\n  explicitStart: bool = false;\n  /** Static memory start offset. */\n  memoryBase: u32 = 0;\n  /** Static table start offset. */\n  tableBase: u32 = 0;\n  /** Global aliases, mapping alias names as the key to internal names to be aliased as the value. */\n  globalAliases: Map<string,string> | null = null;\n  /** Features to activate by default. These are the finished proposals. */\n  features: Feature = Feature.MUTABLE_GLOBALS;\n  /** If true, disallows unsafe features in user code. */\n  noUnsafe: bool = false;\n  /** If true, enables pedantic diagnostics. */\n  pedantic: bool = false;\n  /** Indicates a very low (<64k) memory limit. */\n  lowMemoryLimit: u32 = 0;\n\n  /** Hinted optimize level. Not applied by the compiler itself. */\n  optimizeLevelHint: i32 = 0;\n  /** Hinted shrink level. Not applied by the compiler itself. */\n  shrinkLevelHint: i32 = 0;\n\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\n  get isWasm64(): bool {\n    return this.target == Target.WASM64;\n  }\n\n  /** Gets the unsigned size type matching the target. */\n  get usizeType(): Type {\n    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;\n  }\n\n  /** Gets the signed size type matching the target. */\n  get isizeType(): Type {\n    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;\n  }\n\n  /** Gets the native size type matching the target. */\n  get nativeSizeType(): NativeType {\n    return this.target == Target.WASM64 ? NativeType.I64 : NativeType.I32;\n  }\n\n  /** Gets if any optimizations will be performed. */\n  get willOptimize(): bool {\n    return this.optimizeLevelHint > 0 || this.shrinkLevelHint > 0;\n  }\n\n  /** Tests if a specific feature is activated. */\n  hasFeature(feature: Feature): bool {\n    return (this.features & feature) != 0;\n  }\n}\n\n/** Various constraints in expression compilation. */\nexport const enum Constraints {\n  NONE = 0,\n\n  /** Must implicitly convert to the target type. */\n  CONV_IMPLICIT = 1 << 0,\n  /** Must explicitly convert to the target type. */\n  CONV_EXPLICIT = 1 << 1,\n  /** Must wrap small integer values to match the target type. */\n  MUST_WRAP = 1 << 2,\n\n  /** Indicates that the value will be dropped immediately. */\n  WILL_DROP = 1 << 3,\n  /** Indicates that the value will be retained immediately. */\n  WILL_RETAIN = 1 << 4,\n  /** Indicates that static data is preferred. */\n  PREFER_STATIC = 1 << 5,\n  /** Indicates that the value will become `this` of a property access or instance call. */\n  IS_THIS = 1 << 6\n}\n\n/** Runtime features to be activated by the compiler. */\nexport const enum RuntimeFeatures {\n  NONE = 0,\n  /** Requires heap setup. */\n  HEAP = 1 << 0,\n  /** Requires runtime type information setup. */\n  RTTI = 1 << 1,\n  /** Requires the built-in globals visitor. */\n  visitGlobals = 1 << 2,\n  /** Requires the built-in members visitor. */\n  visitMembers = 1 << 3,\n  /** Requires the setArgumentsLength export. */\n  setArgumentsLength = 1 << 4\n}\n\n/** Exported names of compiler-generated elements. */\nexport namespace ExportNames {\n  /** Name of the explicit start function, if applicable. */\n  export const start = \"_start\"; // match WASI\n  /** Name of the argumentsLength varargs helper global. */\n  export const argumentsLength = \"__argumentsLength\";\n  /** Name of the alternative argumentsLength setter function. */\n  export const setArgumentsLength = \"__setArgumentsLength\";\n  /** Name of the memory instance, if exported. */\n  export const memory = \"memory\";\n  /** Name of the table instance, if exported. */\n  export const table = \"table\";\n}\n\n/** Compiler interface. */\nexport class Compiler extends DiagnosticEmitter {\n\n  /** Program reference. */\n  program: Program;\n  /** Resolver reference. */\n  get resolver(): Resolver { return this.program.resolver; }\n  /** Provided options. */\n  get options(): Options { return this.program.options; }\n  /** Module instance being compiled. */\n  module: Module;\n\n  /** Current control flow. */\n  currentFlow: Flow;\n  /** Current parent element if not a function, i.e. an enum or namespace. */\n  currentParent: Element | null = null;\n  /** Current type in compilation. */\n  currentType: Type = Type.void;\n  /** Start function statements. */\n  currentBody: ExpressionRef[];\n  /** Counting memory offset. */\n  memoryOffset: i64;\n  /** Memory segments being compiled. */\n  memorySegments: MemorySegment[] = [];\n  /** Map of already compiled static string segments. */\n  stringSegments: Map<string,MemorySegment> = new Map();\n  /** Function table being compiled. First elem is blank. */\n  functionTable: Function[] = [];\n  /** Arguments length helper global. */\n  builtinArgumentsLength: GlobalRef = 0;\n  /** Requires runtime features. */\n  runtimeFeatures: RuntimeFeatures = RuntimeFeatures.NONE;\n  /** Expressions known to have skipped an autorelease. Usually function returns. */\n  skippedAutoreleases: Set<ExpressionRef> = new Set();\n  /** Current inline functions stack. */\n  inlineStack: Function[] = [];\n  /** Lazily compiled functions. */\n  lazyFunctions: Set<Function> = new Set();\n  /** Pending class-specific instanceof helpers. */\n  pendingClassInstanceOf: Set<ClassPrototype> = new Set();\n  /** Functions potentially involving a virtual call. */\n  virtualCalls: Set<Function> = new Set();\n  /** Elements currently undergoing compilation. */\n  pendingElements: Set<Element> = new Set();\n  /** Elements, that are module exports, already processed */\n  doneModuleExports: Set<Element> = new Set();\n\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\n  static compile(program: Program): Module {\n    return new Compiler(program).compile();\n  }\n\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\n  constructor(program: Program) {\n    super(program.diagnostics);\n    this.program = program;\n    var options = program.options;\n    var module = Module.create();\n    this.module = module;\n    if (options.memoryBase) {\n      this.memoryOffset = i64_new(options.memoryBase);\n      module.setLowMemoryUnused(false);\n    } else {\n      if (!options.lowMemoryLimit && options.optimizeLevelHint >= 2) {\n        this.memoryOffset = i64_new(1024);\n        module.setLowMemoryUnused(true);\n      } else {\n        this.memoryOffset = i64_new(8);\n        module.setLowMemoryUnused(false);\n      }\n    }\n    var featureFlags: FeatureFlags = 0;\n    if (options.hasFeature(Feature.SIGN_EXTENSION)) featureFlags |= FeatureFlags.SignExt;\n    if (options.hasFeature(Feature.MUTABLE_GLOBALS)) featureFlags |= FeatureFlags.MutableGloabls;\n    if (options.hasFeature(Feature.NONTRAPPING_F2I)) featureFlags |= FeatureFlags.NontrappingFPToInt;\n    if (options.hasFeature(Feature.BULK_MEMORY)) featureFlags |= FeatureFlags.BulkMemory;\n    if (options.hasFeature(Feature.SIMD)) featureFlags |= FeatureFlags.SIMD128;\n    if (options.hasFeature(Feature.THREADS)) featureFlags |= FeatureFlags.Atomics;\n    if (options.hasFeature(Feature.EXCEPTION_HANDLING)) featureFlags |= FeatureFlags.ExceptionHandling;\n    if (options.hasFeature(Feature.TAIL_CALLS)) featureFlags |= FeatureFlags.TailCall;\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) featureFlags |= FeatureFlags.ReferenceTypes;\n    if (options.hasFeature(Feature.MULTI_VALUE)) featureFlags |= FeatureFlags.MultiValue;\n    if (options.hasFeature(Feature.GC)) featureFlags |= FeatureFlags.GC;\n    if (options.hasFeature(Feature.MEMORY64)) featureFlags |= FeatureFlags.Memory64;\n    module.setFeatures(featureFlags);\n\n    // set up the main start function\n    var startFunctionInstance = program.makeNativeFunction(BuiltinNames.start, new Signature(program, [], Type.void));\n    startFunctionInstance.internalName = BuiltinNames.start;\n    this.currentFlow = startFunctionInstance.flow;\n    this.currentBody = new Array<ExpressionRef>();\n  }\n\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\n  compile(): Module {\n    var options = this.options;\n    var module = this.module;\n    var program = this.program;\n\n    // initialize lookup maps, built-ins, imports, exports, etc.\n    this.program.initialize();\n\n    // obtain the main start function\n    var startFunctionInstance = this.currentFlow.actualFunction;\n    assert(startFunctionInstance.internalName == BuiltinNames.start);\n    var startFunctionBody = this.currentBody;\n    assert(startFunctionBody.length == 0);\n\n    // add mutable heap and rtti base dummies\n    if (options.isWasm64) {\n      module.addGlobal(BuiltinNames.heap_base, NativeType.I64, true, module.i64(0));\n      module.addGlobal(BuiltinNames.rtti_base, NativeType.I64, true, module.i64(0));\n    } else {\n      module.addGlobal(BuiltinNames.heap_base, NativeType.I32, true, module.i32(0));\n      module.addGlobal(BuiltinNames.rtti_base, NativeType.I32, true, module.i32(0));\n    }\n\n    // compile entry file(s) while traversing reachable elements\n    var files = program.filesByName;\n    // TODO: for (let file of files.values()) {\n    for (let _values = Map_values(files), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.compileFile(file);\n        this.compileExports(file);\n      }\n    }\n\n    // compile the start function if not empty or if explicitly requested\n    var startIsEmpty = !startFunctionBody.length;\n    var explicitStart = program.isWasi || options.explicitStart;\n    if (!startIsEmpty || explicitStart) {\n      let signature = startFunctionInstance.signature;\n      if (!startIsEmpty && explicitStart) {\n        module.addGlobal(BuiltinNames.started, NativeType.I32, true, module.i32(0));\n        startFunctionBody.unshift(\n          module.if(\n            module.global_get(BuiltinNames.started, NativeType.I32),\n            module.return(),\n            module.global_set(BuiltinNames.started, module.i32(1))\n          )\n        );\n      }\n      let funcRef = module.addFunction(\n        startFunctionInstance.internalName,\n        signature.nativeParams,\n        signature.nativeResults,\n        typesToNativeTypes(startFunctionInstance.additionalLocals),\n        module.flatten(startFunctionBody)\n      );\n      startFunctionInstance.finalize(module, funcRef);\n      if (!explicitStart) module.setStart(funcRef);\n      else module.addFunctionExport(startFunctionInstance.internalName, ExportNames.start);\n    }\n\n    // check if the entire program is acyclic\n    var cyclicClasses = program.findCyclicClasses();\n    if (cyclicClasses.size) {\n      if (options.pedantic) {\n        // TODO: for (let classInstance of cyclicClasses) {\n        for (let _values = Set_values(cyclicClasses), i = 0, k = _values.length; i < k; ++i) {\n          let classInstance = unchecked(_values[i]);\n          this.pedantic(\n            DiagnosticCode.Type_0_is_cyclic_Module_will_include_deferred_garbage_collection,\n            classInstance.identifierNode.range, classInstance.internalName\n          );\n        }\n      }\n    } else {\n      program.registerConstantInteger(\"__GC_ALL_ACYCLIC\", Type.bool, i64_new(1, 0));\n    }\n\n    // compile lazy functions\n    var lazyFunctions = this.lazyFunctions;\n    do {\n      let functionsToCompile = new Array<Function>();\n      // TODO: for (let instance of lazyLibraryFunctions) {\n      for (let _values = Set_values(lazyFunctions), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        functionsToCompile.push(instance);\n      }\n      lazyFunctions.clear();\n      for (let i = 0, k = functionsToCompile.length; i < k; ++i) {\n        this.compileFunction(unchecked(functionsToCompile[i]), true);\n      }\n    } while (lazyFunctions.size);\n\n    // compile pending class-specific instanceof helpers\n    // TODO: for (let prototype of this.pendingClassInstanceOf.values()) {\n    for (let _values = Set_values(this.pendingClassInstanceOf), i = 0, k = _values.length; i < k; ++i) {\n      let prototype = unchecked(_values[i]);\n      compileClassInstanceOf(this, prototype);\n    }\n\n    // set up virtual lookup tables\n    var functionTable = this.functionTable;\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      let instance = functionTable[i];\n      if (instance.is(CommonFlags.VIRTUAL)) {\n        assert(instance.is(CommonFlags.INSTANCE));\n        functionTable[i] = this.ensureVirtualStub(instance); // incl. varargs\n        this.finalizeVirtualStub(instance);\n      } else if (instance.signature.requiredParameters < instance.signature.parameterTypes.length) {\n        functionTable[i] = this.ensureVarargsStub(instance);\n      }\n    }\n    var virtualCalls = this.virtualCalls;\n    while (virtualCalls.size) {\n      // finalizing a stub may discover more virtual calls, so do this in a loop\n      for (let _values = Set_values(virtualCalls), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        this.finalizeVirtualStub(instance);\n        virtualCalls.delete(instance);\n      }\n    }\n\n    // finalize runtime features\n    module.removeGlobal(BuiltinNames.rtti_base);\n    if (this.runtimeFeatures & RuntimeFeatures.RTTI) compileRTTI(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitGlobals) compileVisitGlobals(this);\n    if (this.runtimeFeatures & RuntimeFeatures.visitMembers) compileVisitMembers(this);\n\n    // update the heap base pointer\n    var memoryOffset = this.memoryOffset;\n    memoryOffset = i64_align(memoryOffset, options.usizeType.byteSize);\n    var lowMemoryLimit32 = this.options.lowMemoryLimit;\n    if (lowMemoryLimit32) {\n      let lowMemoryLimit = i64_new(lowMemoryLimit32 & ~15);\n      if (i64_gt(memoryOffset, lowMemoryLimit)) {\n        this.error(\n          DiagnosticCode.Low_memory_limit_exceeded_by_static_data_0_1,\n          null, i64_to_string(memoryOffset), i64_to_string(lowMemoryLimit)\n        );\n      }\n    }\n    this.memoryOffset = memoryOffset;\n    module.removeGlobal(BuiltinNames.heap_base);\n    if (this.runtimeFeatures & RuntimeFeatures.HEAP) {\n      if (options.isWasm64) {\n        module.addGlobal(\n          BuiltinNames.heap_base,\n          NativeType.I64,\n          false,\n          module.i64(i64_low(memoryOffset), i64_high(memoryOffset))\n        );\n      } else {\n        module.addGlobal(\n          BuiltinNames.heap_base,\n          NativeType.I32,\n          false,\n          module.i32(i64_low(memoryOffset))\n        );\n      }\n    }\n\n    // set up memory\n    var initialPages: u32 = 0;\n    if (this.options.memoryBase /* is specified */ || this.memorySegments.length) {\n      initialPages = u32(i64_low(i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16))));\n    }\n    if (options.initialMemory) {\n      if (options.initialMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_initial_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        initialPages = options.initialMemory;\n      }\n    }\n    var maximumPages = Module.UNLIMITED_MEMORY;\n    if (options.maximumMemory) {\n      if (options.maximumMemory < initialPages) {\n        this.error(\n          DiagnosticCode.Module_requires_at_least_0_pages_of_maximum_memory,\n          null,\n          initialPages.toString()\n        );\n      } else {\n        maximumPages = options.maximumMemory;\n      }\n    }\n    var isSharedMemory = false;\n    if (options.sharedMemory) {\n      isSharedMemory = true;\n      if (!options.maximumMemory) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_maximum_memory_to_be_defined,\n          null\n        );\n        isSharedMemory = false;\n      }\n      if (!options.hasFeature(Feature.THREADS)) {\n        this.error(\n          DiagnosticCode.Shared_memory_requires_feature_threads_to_be_enabled,\n          null\n        );\n        isSharedMemory = false;\n      }\n    }\n    module.setMemory(\n      initialPages,\n      maximumPages,\n      this.memorySegments,\n      options.target,\n      options.exportMemory ? ExportNames.memory : null,\n      isSharedMemory\n    );\n\n    // import memory if requested (default memory is named '0' by Binaryen)\n    if (options.importMemory) module.addMemoryImport(\"0\", \"env\", \"memory\", isSharedMemory);\n\n    // set up function table (first elem is blank)\n    var tableBase = this.options.tableBase;\n    if (!tableBase) tableBase = 1; // leave first elem blank\n    var functionTableNames = new Array<string>(functionTable.length);\n    for (let i = 0, k = functionTable.length; i < k; ++i) {\n      functionTableNames[i] = functionTable[i].internalName;\n    }\n    module.setFunctionTable(tableBase + functionTable.length, Module.UNLIMITED_TABLE, functionTableNames, module.i32(tableBase));\n\n    // import and/or export table if requested (default table is named '0' by Binaryen)\n    if (options.importTable) {\n      module.addTableImport(\"0\", \"env\", \"table\");\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Importing_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n    if (options.exportTable) {\n      module.addTableExport(\"0\", ExportNames.table);\n      if (options.pedantic && options.willOptimize) {\n        this.pedantic(\n          DiagnosticCode.Exporting_the_table_disables_some_indirect_call_optimizations,\n          null\n        );\n      }\n    }\n\n    // set up module exports\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.ensureModuleExports(file);\n    }\n\n    // expose the arguments length helper if there are varargs exports\n    if (this.runtimeFeatures & RuntimeFeatures.setArgumentsLength) {\n      module.addFunction(BuiltinNames.setArgumentsLength, NativeType.I32, NativeType.None, null,\n        module.global_set(BuiltinNames.argumentsLength, module.local_get(0, NativeType.I32))\n      );\n      module.addFunctionExport(BuiltinNames.setArgumentsLength, ExportNames.setArgumentsLength);\n    }\n    return module;\n  }\n\n  // === Exports ==================================================================================\n\n  /** Applies the respective module exports for the specified file. */\n  private ensureModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [elementName, element] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let elementName = unchecked(_keys[i]);\n        let element = assert(exports.get(elementName));\n        this.ensureModuleExport(elementName, element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar)  {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.ensureModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Applies the respective module export(s) for the specified element. */\n  private ensureModuleExport(name: string, element: Element, prefix: string = \"\"): void {\n    switch (element.kind) {\n\n      // traverse instances\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>element;\n        let functionInstances = functionPrototype.instances;\n        if (functionInstances !== null && functionInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(functionInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (functionPrototype.is(CommonFlags.GENERIC)) {\n          this.warning(\n            DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n            functionPrototype.identifierNode.range\n          );\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        let classPrototype = <ClassPrototype>element;\n        let classInstances = classPrototype.instances;\n        if (classInstances !== null && classInstances.size > 0) {\n          // TODO: for (let instance of instances.values()) {\n          for (let _values = Map_values(classInstances), i = 0, k = _values.length; i < k; ++i) {\n            let instance = unchecked(_values[i]);\n            let instanceName = name;\n            if (instance.is(CommonFlags.GENERIC)) {\n              let fullName = instance.internalName;\n              instanceName += fullName.substring(fullName.lastIndexOf(\"<\"));\n            }\n            this.ensureModuleExport(instanceName, instance, prefix);\n          }\n        } else if (classPrototype.is(CommonFlags.GENERIC)) {\n          this.warning(\n            DiagnosticCode.Exported_generic_function_or_class_has_no_concrete_instances,\n            classPrototype.identifierNode.range\n          );\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (propertyInstance) this.ensureModuleExport(name, propertyInstance, prefix);\n        break;\n      }\n\n      // export concrete elements\n      case ElementKind.GLOBAL: {\n        let global = <Global>element;\n        let isConst = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n        if (!isConst && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            global.identifierNode.range\n          );\n        } else {\n          if (element.is(CommonFlags.COMPILED)) this.module.addGlobalExport(element.internalName, prefix + name);\n        }\n        break;\n      }\n      case ElementKind.ENUMVALUE: {\n        let enumValue = <EnumValue>element;\n        if (!enumValue.isImmutable && !this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n          this.error(\n            DiagnosticCode.Cannot_export_a_mutable_global,\n            enumValue.identifierNode.range\n          );\n        } else {\n          this.module.addGlobalExport(element.internalName, prefix + name);\n        }\n        break;\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>element;\n        if (!functionInstance.hasDecorator(DecoratorFlags.BUILTIN)) {\n          let signature = functionInstance.signature;\n          if (signature.requiredParameters < signature.parameterTypes.length) {\n            // utilize varargs stub to fill in omitted arguments\n            functionInstance = this.ensureVarargsStub(functionInstance);\n            this.ensureArgumentsLength();\n            this.runtimeFeatures |= RuntimeFeatures.setArgumentsLength;\n          }\n          if (functionInstance.is(CommonFlags.COMPILED)) this.module.addFunctionExport(functionInstance.internalName, prefix + name);\n        }\n        break;\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.ensureModuleExport(GETTER_PREFIX + name, getterInstance, prefix);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.ensureModuleExport(SETTER_PREFIX + name, setterInstance, prefix);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (element.is(CommonFlags.COMPILED)) {\n          let module = this.module;\n          module.addFunctionExport(fieldInstance.internalGetterName, prefix + GETTER_PREFIX + name);\n          if (!element.is(CommonFlags.READONLY)) {\n            module.addFunctionExport(fieldInstance.internalSetterName, prefix + SETTER_PREFIX + name);\n          }\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>element;\n        // make the class name itself represent its runtime id\n        if (!classInstance.type.isUnmanaged) {\n          let module = this.module;\n          let internalName = classInstance.internalName;\n\n          if (!this.doneModuleExports.has(element)) {\n            module.addGlobal(internalName, NativeType.I32, false, module.i32(classInstance.id));\n            this.doneModuleExports.add(element);\n          }\n          module.addGlobalExport(internalName, prefix + name);\n        }\n        break;\n      }\n\n      // just traverse members below\n      case ElementKind.ENUM:\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.INDEXSIGNATURE: break;\n\n      default: assert(false); // unexpected module export\n    }\n\n    // traverse members\n    var members = element.members;\n    if (members) {\n      let subPrefix = prefix + name + (element.kind == ElementKind.CLASS\n        ? INSTANCE_DELIMITER\n        : STATIC_DELIMITER\n      );\n      if (element.kind == ElementKind.NAMESPACE) {\n        let implicitExport = element.is(CommonFlags.SCOPED);\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (implicitExport || member.is(CommonFlags.EXPORT)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      } else {\n        // TODO: for (let [memberName, member] of members) {\n        for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(members.get(memberName));\n          if (!member.is(CommonFlags.PRIVATE)) {\n            this.ensureModuleExport(memberName, member, subPrefix);\n          }\n        }\n      }\n    }\n  }\n\n  // === Elements =================================================================================\n\n  /** Compiles any element. */\n  compileElement(element: Element, compileMembers: bool = true): void {\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        this.compileGlobal(<Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        this.compileEnum(<Enum>element);\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n          if (functionInstance) this.compileFunction(functionInstance);\n        }\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        if (!element.is(CommonFlags.GENERIC)) {\n          let classInstance = this.resolver.resolveClass(<ClassPrototype>element, null);\n          if (classInstance) this.compileClass(classInstance);\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n        if (propertyInstance) this.compileProperty(propertyInstance);\n        break;\n      }\n      case ElementKind.NAMESPACE:\n      case ElementKind.TYPEDEFINITION:\n      case ElementKind.ENUMVALUE:\n      case ElementKind.INDEXSIGNATURE: break;\n      default: assert(false);\n    }\n    if (compileMembers) {\n      let members = element.members;\n      if (members) {\n        // TODO: for (let element of members.values()) {\n        for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n          let element = unchecked(_values[i]);\n          this.compileElement(element);\n        }\n      }\n    }\n  }\n\n  /** Compiles a file's exports. */\n  compileExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileElement(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.compileFile(exportStar);\n        this.compileExports(exportStar);\n      }\n    }\n  }\n\n  // files\n\n  /** Compiles the file matching the specified path. */\n  compileFileByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\n    var file: File;\n    var filesByName = this.program.filesByName;\n    var pathWithIndex: string;\n    if (filesByName.has(normalizedPathWithoutExtension)) {\n      file = assert(filesByName.get(normalizedPathWithoutExtension));\n    } else if (filesByName.has(pathWithIndex = normalizedPathWithoutExtension + INDEX_SUFFIX)) {\n      file = assert(filesByName.get(pathWithIndex));\n    } else {\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        reportNode.range, normalizedPathWithoutExtension\n      );\n      return;\n    }\n    this.compileFile(file);\n  }\n\n  /** Compiles the specified file. */\n  compileFile(file: File): void {\n    if (file.is(CommonFlags.COMPILED)) return;\n    file.set(CommonFlags.COMPILED);\n\n    // compile top-level statements within the file's start function\n    var startFunction = file.startFunction;\n    var startSignature = startFunction.signature;\n    var previousBody = this.currentBody;\n    var startFunctionBody = new Array<ExpressionRef>();\n    this.currentBody = startFunctionBody;\n\n    // compile top-level statements\n    var previousFlow = this.currentFlow;\n    var flow = startFunction.flow;\n    this.currentFlow = flow;\n    for (let statements = file.source.statements, i = 0, k = statements.length; i < k; ++i) {\n      this.compileTopLevelStatement(statements[i], startFunctionBody);\n    }\n    this.finishAutoreleases(flow, startFunctionBody);\n    // no need to insert unreachable since last statement should have done that\n    this.currentFlow = previousFlow;\n    this.currentBody = previousBody;\n\n    // if top-level statements are present, make the per-file start function and call it in start\n    if (startFunctionBody.length) {\n      let module = this.module;\n      let locals = startFunction.localsByIndex;\n      let numLocals = locals.length;\n      let varTypes = new Array<NativeType>(numLocals);\n      for (let i = 0; i < numLocals; ++i) varTypes[i] = locals[i].type.toNativeType();\n      module.addFunction(\n        startFunction.internalName,\n        startSignature.nativeParams,\n        startSignature.nativeResults,\n        varTypes,\n        module.flatten(startFunctionBody)\n      );\n      previousBody.push(\n        module.call(startFunction.internalName, null, NativeType.None)\n      );\n    }\n  }\n\n  // === Globals ==================================================================================\n\n  /** Compiles a global variable. */\n  compileGlobal(global: Global): bool {\n    if (global.is(CommonFlags.COMPILED)) return !global.is(CommonFlags.ERRORED);\n    global.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(global);\n\n    var module = this.module;\n    var initExpr: ExpressionRef = 0;\n    var typeNode = global.typeNode;\n    var initializerNode = global.initializerNode;\n\n    if (!global.is(CommonFlags.RESOLVED)) {\n\n      // Resolve type if annotated\n      if (typeNode) {\n        let resolvedType = this.resolver.resolveType(typeNode, global.parent); // reports\n        if (!resolvedType) {\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        if (resolvedType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(resolvedType);\n        this.checkTypeSupported(global.type, typeNode);\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, Type.auto, // reports\n          Constraints.MUST_WRAP | Constraints.WILL_RETAIN | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            initializerNode.range, this.currentType.toString(), \"<auto>\"\n          );\n          global.set(CommonFlags.ERRORED);\n          pendingElements.delete(global);\n          return false;\n        }\n        global.setType(this.currentType);\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          global.identifierNode.range.atEnd\n        );\n        global.set(CommonFlags.ERRORED);\n        pendingElements.delete(global);\n        return false;\n      }\n    }\n\n    // Handle ambient builtins like '__heap_base' that need to be resolved but are added explicitly\n    if (global.is(CommonFlags.AMBIENT) && global.hasDecorator(DecoratorFlags.BUILTIN)) {\n      if (global.internalName == BuiltinNames.heap_base) this.runtimeFeatures |= RuntimeFeatures.HEAP;\n      else if (global.internalName == BuiltinNames.rtti_base) this.runtimeFeatures |= RuntimeFeatures.RTTI;\n      pendingElements.delete(global);\n      return true;\n    }\n\n    var type = global.type;\n    var nativeType = type.toNativeType();\n    var isDeclaredConstant = global.is(CommonFlags.CONST) || global.is(CommonFlags.STATIC | CommonFlags.READONLY);\n    var isDeclaredInline = global.hasDecorator(DecoratorFlags.INLINE);\n\n    // Handle imports\n    if (global.is(CommonFlags.AMBIENT)) {\n\n      // Constant global or mutable globals enabled\n      if (isDeclaredConstant || this.options.hasFeature(Feature.MUTABLE_GLOBALS)) {\n        global.set(CommonFlags.MODULE_IMPORT);\n        mangleImportName(global, global.declaration);\n        module.addGlobalImport(\n          global.internalName,\n          mangleImportName_moduleName,\n          mangleImportName_elementName,\n          nativeType,\n          !isDeclaredConstant\n        );\n        pendingElements.delete(global);\n        return true;\n      }\n\n      // Importing mutable globals is not supported in the MVP\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        global.declaration.range, \"mutable-globals\"\n      );\n      global.set(CommonFlags.ERRORED);\n      pendingElements.delete(global);\n      return false;\n    }\n\n    // The MVP does not yet support initializer expressions other than constants and gets of\n    // imported immutable globals, hence such initializations must be performed in the start.\n    var initializeInStart = false;\n\n    // Evaluate initializer if present\n    if (initializerNode) {\n      if (!initExpr) {\n        let previousFlow = this.currentFlow;\n        if (global.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = global.file.startFunction.flow;\n        }\n        initExpr = this.compileExpression(initializerNode, type,\n          Constraints.CONV_IMPLICIT | Constraints.MUST_WRAP | Constraints.WILL_RETAIN | Constraints.PREFER_STATIC\n        );\n        this.currentFlow = previousFlow;\n      }\n\n      // If not a constant, attempt to precompute\n      if (getExpressionId(initExpr) != ExpressionId.Const) {\n        if (isDeclaredConstant) {\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              initializeInStart = true;\n            }\n          }\n          if (this.skippedAutoreleases.has(initExpr)) this.skippedAutoreleases.add(initExpr);\n        } else {\n          initializeInStart = true;\n        }\n      }\n\n      // Handle special case of initializing from imported immutable global\n      if (initializeInStart && getExpressionId(initExpr) == ExpressionId.GlobalGet) {\n        let fromName = assert(getGlobalGetName(initExpr));\n        if (!isGlobalMutable(module.getGlobal(fromName))) {\n          let elementsByName = this.program.elementsByName;\n          if (elementsByName.has(fromName)) {\n            let global = assert(elementsByName.get(fromName));\n            if (global.is(CommonFlags.AMBIENT)) initializeInStart = false;\n          }\n        }\n      }\n\n      // Explicitly inline if annotated\n      if (isDeclaredInline) {\n        if (initializeInStart) {\n          this.warning(\n            DiagnosticCode.Mutable_value_cannot_be_inlined,\n            initializerNode.range\n          );\n        } else {\n          assert(getExpressionId(initExpr) == ExpressionId.Const);\n          let exprType = getExpressionType(initExpr);\n          switch (<u32>exprType) {\n            case <u32>NativeType.I32: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(getConstValueI32(initExpr), 0);\n              break;\n            }\n            case <u32>NativeType.I64: {\n              global.constantValueKind = ConstantValueKind.INTEGER;\n              global.constantIntegerValue = i64_new(\n                getConstValueI64Low(initExpr),\n                getConstValueI64High(initExpr)\n              );\n              break;\n            }\n            case <u32>NativeType.F32: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF32(initExpr);\n              break;\n            }\n            case <u32>NativeType.F64: {\n              global.constantValueKind = ConstantValueKind.FLOAT;\n              global.constantFloatValue = getConstValueF64(initExpr);\n              break;\n            }\n            default: {\n              assert(false);\n              global.set(CommonFlags.ERRORED);\n              pendingElements.delete(global);\n              return false;\n            }\n          }\n          global.set(CommonFlags.INLINED); // inline the value from now on\n        }\n      }\n\n    // Initialize to zero if there's no initializer\n    } else {\n      if (global.is(CommonFlags.INLINED)) {\n        initExpr = this.compileInlineConstant(global, global.type, Constraints.PREFER_STATIC | Constraints.WILL_RETAIN);\n      } else {\n        initExpr = this.makeZero(type, global.declaration);\n      }\n    }\n\n    var internalName = global.internalName;\n\n    if (initializeInStart) { // initialize to mutable zero and set the actual value in start\n      if (isDeclaredInline) {\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          findDecorator(DecoratorKind.INLINE, global.decoratorNodes)!.range, \"inline\"\n        );\n      }\n      module.addGlobal(internalName, nativeType, true, this.makeZero(type, global.declaration));\n      if (type.isManaged && !this.skippedAutoreleases.has(initExpr)) initExpr = this.makeRetain(initExpr, type);\n      this.currentBody.push(\n        module.global_set(internalName, initExpr)\n      );\n    } else if (!isDeclaredInline) { // compile normally\n      module.addGlobal(internalName, nativeType, !isDeclaredConstant, initExpr);\n    }\n    pendingElements.delete(global);\n    return true;\n  }\n\n  // === Enums ====================================================================================\n\n  /** Compiles an enum. */\n  compileEnum(element: Enum): bool {\n    if (element.is(CommonFlags.COMPILED)) return !element.is(CommonFlags.ERRORED);\n    element.set(CommonFlags.COMPILED);\n\n    var pendingElements = this.pendingElements;\n    pendingElements.add(element);\n\n    var module = this.module;\n    var previousParent = this.currentParent;\n    this.currentParent = element;\n    var previousValue: EnumValue | null = null;\n    var previousValueIsMut = false;\n    var isInline = element.is(CommonFlags.CONST) || element.hasDecorator(DecoratorFlags.INLINE);\n\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of element.members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace\n        let initInStart = false;\n        let enumValue = <EnumValue>member;\n        let valueNode = enumValue.valueNode;\n        enumValue.set(CommonFlags.COMPILED);\n        let previousFlow = this.currentFlow;\n        if (element.hasDecorator(DecoratorFlags.LAZY)) {\n          this.currentFlow = element.file.startFunction.flow;\n        }\n        let initExpr: ExpressionRef;\n        if (valueNode) {\n          initExpr = this.compileExpression(valueNode, Type.i32,\n            Constraints.CONV_IMPLICIT // autorelease is not applicable in i32 context\n          );\n          if (getExpressionId(initExpr) != ExpressionId.Const) {\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  valueNode.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        } else if (previousValue == null) {\n          initExpr = module.i32(0);\n        } else {\n          if (previousValueIsMut) {\n            this.error(\n              DiagnosticCode.Enum_member_must_have_initializer,\n              enumValue.identifierNode.range.atEnd\n            );\n          }\n          if (isInline) {\n            let value = i64_add(previousValue.constantIntegerValue, i64_new(1));\n            assert(!i64_high(value));\n            initExpr = module.i32(i64_low(value));\n          } else {\n            initExpr = module.binary(BinaryOp.AddI32,\n              module.global_get(previousValue.internalName, NativeType.I32),\n              module.i32(1)\n            );\n            let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n            if (precomp) {\n              initExpr = precomp;\n            } else {\n              if (element.is(CommonFlags.CONST)) {\n                this.error(\n                  DiagnosticCode.In_const_enum_declarations_member_initializer_must_be_constant_expression,\n                  member.declaration.range\n                );\n              }\n              initInStart = true;\n            }\n          }\n        }\n        this.currentFlow = previousFlow;\n        if (initInStart) {\n          module.addGlobal(enumValue.internalName, NativeType.I32, true, module.i32(0));\n          this.currentBody.push(\n            this.makeGlobalAssignment(enumValue, initExpr, Type.i32, false)\n          );\n          previousValueIsMut = true;\n        } else {\n          if (isInline) {\n            enumValue.setConstantIntegerValue(i64_new(getConstValueI32(initExpr)), Type.i32);\n            if (enumValue.is(CommonFlags.MODULE_EXPORT)) {\n              module.addGlobal(enumValue.internalName, NativeType.I32, false, initExpr);\n            }\n          } else {\n            module.addGlobal(enumValue.internalName, NativeType.I32, false, initExpr);\n          }\n          enumValue.isImmutable = true;\n          previousValueIsMut = false;\n        }\n        previousValue = enumValue;\n      }\n    }\n    this.currentParent = previousParent;\n    pendingElements.delete(element);\n    return true;\n  }\n\n  // === Functions ================================================================================\n\n  /** Compiles a priorly resolved function. */\n  compileFunction(\n    /** Function to compile. */\n    instance: Function,\n    /** Force compilation of stdlib alternative if a builtin. */\n    forceStdAlternative: bool = false\n  ): bool {\n    if (instance.is(CommonFlags.COMPILED)) return !instance.is(CommonFlags.ERRORED);\n\n    if (!forceStdAlternative) {\n      if (instance.hasDecorator(DecoratorFlags.BUILTIN)) return true;\n      if (instance.hasDecorator(DecoratorFlags.LAZY)) {\n        this.lazyFunctions.add(instance);\n        return true;\n      }\n    }\n\n    instance.set(CommonFlags.COMPILED);\n    var pendingElements = this.pendingElements;\n    pendingElements.add(instance);\n\n    var previousType = this.currentType;\n    var module = this.module;\n    var signature = instance.signature;\n    var bodyNode = instance.prototype.bodyNode;\n    var declarationNode = instance.declaration;\n    assert(declarationNode.kind == NodeKind.FUNCTIONDECLARATION || declarationNode.kind == NodeKind.METHODDECLARATION);\n    this.checkSignatureSupported(instance.signature, (<FunctionDeclaration>declarationNode).signature);\n\n    var funcRef: FunctionRef;\n\n    // concrete function\n    if (bodyNode) {\n\n      // must not be ambient\n      if (instance.is(CommonFlags.AMBIENT)) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          instance.identifierNode.range\n        );\n      }\n\n      // cannot have an annotated external name\n      if (instance.hasDecorator(DecoratorFlags.EXTERNAL)) {\n        let decoratorNodes = instance.decoratorNodes;\n        let decorator = assert(findDecorator(DecoratorKind.EXTERNAL, decoratorNodes));\n        this.error(\n          DiagnosticCode.Decorator_0_is_not_valid_here,\n          decorator.range, \"external\"\n        );\n      }\n\n      // compile body in this function's context\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n      let stmts = new Array<ExpressionRef>();\n\n      // retain each argument for as long as the function lives\n      let index = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        // In normal instance functions, `this` is effectively a constant\n        // retained elsewhere so does not need to be retained.\n        if (instance.is(CommonFlags.CONSTRUCTOR)) {\n          // Constructors, however, can allocate their own memory, and as such\n          // must refcount the allocation in case something else is `return`ed.\n          flow.setLocalFlag(index, LocalFlags.RETAINED);\n        }\n        ++index;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i, ++index) {\n        let type = parameterTypes[i];\n        if (type.isManaged) {\n          stmts.push(\n            module.local_set(index,\n              this.makeRetain(\n                module.local_get(index, type.toNativeType()),\n                type\n              )\n            )\n          );\n          flow.setLocalFlag(index, LocalFlags.RETAINED);\n        }\n      }\n\n      let body: ExpressionRef;\n      if (this.compileFunctionBody(instance, stmts)) {\n        if (!flow.is(FlowFlags.TERMINATES)) {\n          this.performAutoreleases(flow, stmts);\n          this.finishAutoreleases(flow, stmts);\n        }\n        body = module.flatten(stmts, instance.signature.returnType.toNativeType());\n      } else {\n        body = module.unreachable();\n      }\n      this.currentFlow = previousFlow;\n\n      // create the function\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.nativeParams,\n        signature.nativeResults,\n        typesToNativeTypes(instance.additionalLocals),\n        body\n      );\n\n    // imported function\n    } else if (instance.is(CommonFlags.AMBIENT)) {\n      instance.set(CommonFlags.MODULE_IMPORT);\n      mangleImportName(instance, declarationNode); // TODO: check for duplicates\n      module.addFunctionImport(\n        instance.internalName,\n        mangleImportName_moduleName,\n        mangleImportName_elementName,\n        signature.nativeParams,\n        signature.nativeResults\n      );\n      funcRef = module.getFunction(instance.internalName);\n\n    // abstract or interface function\n    } else if (instance.is(CommonFlags.ABSTRACT) || instance.parent.kind == ElementKind.INTERFACE) {\n      funcRef = module.addFunction(\n        instance.internalName,\n        signature.nativeParams,\n        signature.nativeResults,\n        null,\n        module.unreachable()\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        instance.identifierNode.range\n      );\n      funcRef = 0; // TODO?\n      instance.set(CommonFlags.ERRORED);\n    }\n\n    instance.finalize(module, funcRef);\n    this.currentType = previousType;\n    pendingElements.delete(instance);\n    return true;\n  }\n\n  /** Compiles the body of a function within the specified flow. */\n  private compileFunctionBody(\n    /** Function to compile. */\n    instance: Function,\n    /** Target array of statements also being returned. Creates a new array if omitted. */\n    stmts: ExpressionRef[]\n  ): bool {\n    var module = this.module;\n    var bodyNode = assert(instance.prototype.bodyNode);\n    var returnType = instance.signature.returnType;\n    var flow = this.currentFlow;\n    var thisLocal = instance.signature.thisType\n      ? assert(flow.lookupLocal(CommonNames.this_))\n      : null;\n\n    // compile statements\n    if (bodyNode.kind == NodeKind.BLOCK) {\n      stmts = this.compileStatements((<BlockStatement>bodyNode).statements, true, stmts);\n    } else {\n      // must be an expression statement if not a block\n      assert(bodyNode.kind == NodeKind.EXPRESSION);\n\n      // must be an arrow function\n      assert(instance.prototype.arrowKind);\n\n      // none of the following can be an arrow function\n      assert(!instance.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.GET | CommonFlags.SET));\n\n      // take special care of properly retaining the returned value\n      let expr = this.compileReturnedExpression((<ExpressionStatement>bodyNode).expression, returnType, Constraints.CONV_IMPLICIT);\n\n      if (!stmts) stmts = [ expr ];\n      else stmts.push(expr);\n\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        let indexBefore = stmts.length;\n        this.performAutoreleases(flow, stmts);\n        this.finishAutoreleases(flow, stmts);\n        let canOverflow = flow.canOverflow(expr, returnType);\n        let nonNull = flow.isNonnull(expr, returnType);\n        if (stmts.length > indexBefore) {\n          let temp = flow.getTempLocal(returnType);\n          if (!canOverflow) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n          if (nonNull) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n          stmts[indexBefore - 1] = module.local_set(temp.index, expr);\n          stmts.push(module.local_get(temp.index, returnType.toNativeType()));\n          flow.freeTempLocal(temp);\n        }\n        if (!canOverflow) flow.set(FlowFlags.RETURNS_WRAPPED);\n        if (nonNull) flow.set(FlowFlags.RETURNS_NONNULL);\n        flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n      }\n    }\n\n    // Make constructors return their instance pointer, and prepend a conditional\n    // allocation if any code path accesses `this`.\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\n      let nativeSizeType = this.options.nativeSizeType;\n      assert(instance.is(CommonFlags.INSTANCE));\n      thisLocal = assert(thisLocal);\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n\n      if (flow.isAny(FlowFlags.ACCESSES_THIS | FlowFlags.CONDITIONALLY_ACCESSES_THIS) || !flow.is(FlowFlags.TERMINATES)) {\n        // Allocate `this` if not a super call, and initialize fields\n        let allocStmts = new Array<ExpressionRef>();\n        allocStmts.push(\n          module.if(\n            module.unary(nativeSizeType == NativeType.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n              module.local_get(thisLocal.index, nativeSizeType)\n            ),\n            module.local_set(thisLocal.index,\n              this.makeRetain(\n                this.makeAllocation(classInstance),\n                classInstance.type\n              )\n            )\n          )\n        );\n        this.makeFieldInitializationInConstructor(classInstance, allocStmts);\n        if (flow.isInline) {\n          let firstStmt = stmts[0]; // `this` alias assignment\n          assert(getExpressionId(firstStmt) == ExpressionId.LocalSet);\n          assert(getLocalSetIndex(firstStmt) == thisLocal.index);\n          allocStmts.unshift(firstStmt);\n          stmts[0] = module.flatten(allocStmts, NativeType.None);\n        } else {\n          stmts.unshift(\n            module.flatten(allocStmts, NativeType.None)\n          );\n        }\n\n        // Just prepended allocation is dropped when returning non-'this'\n        if (flow.is(FlowFlags.MAY_RETURN_NONTHIS)) {\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Explicitly_returning_constructor_drops_this_allocation,\n              instance.identifierNode.range\n            );\n          }\n        }\n      }\n\n      // Returning something else than 'this' would break 'super()' calls\n      if (flow.is(FlowFlags.MAY_RETURN_NONTHIS) && !classInstance.hasDecorator(DecoratorFlags.FINAL)) {\n        this.error(\n          DiagnosticCode.A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final,\n          classInstance.identifierNode.range\n        );\n      }\n\n      // Implicitly return `this` if the flow falls through\n      if (!flow.is(FlowFlags.TERMINATES)) {\n        assert(flow.isAnyLocalFlag(thisLocal.index, LocalFlags.ANY_RETAINED));\n        flow.unsetLocalFlag(thisLocal.index, LocalFlags.ANY_RETAINED); // undo\n        this.performAutoreleases(flow, stmts);\n        this.finishAutoreleases(flow, stmts);\n        stmts.push(module.local_get(thisLocal.index, this.options.nativeSizeType));\n        flow.set(FlowFlags.RETURNS | FlowFlags.RETURNS_NONNULL | FlowFlags.TERMINATES);\n      }\n\n      // check that super has been called if this is a derived class\n      if (classInstance.base !== null && !flow.is(FlowFlags.CALLS_SUPER)) {\n        this.error(\n          DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call,\n          instance.prototype.declaration.range\n        );\n      }\n\n    // if this is a normal function, make sure that all branches terminate\n    } else if (returnType != Type.void && !flow.is(FlowFlags.TERMINATES)) {\n      this.error(\n        DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\n        instance.prototype.functionTypeNode.returnType.range\n      );\n      return false; // not recoverable\n    }\n\n    return true;\n  }\n\n  // === Classes ==================================================================================\n\n  /** Compiles a priorly resolved class. */\n  compileClass(instance: Class): bool {\n    if (instance.is(CommonFlags.COMPILED)) return true;\n    instance.set(CommonFlags.COMPILED);\n    var prototype = instance.prototype;\n    var staticMembers = (<ClassPrototype>prototype).members;\n    if (staticMembers) {\n      // TODO: for (let element of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.GLOBAL: {\n            this.compileGlobal(<Global>element);\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    this.ensureConstructor(instance, instance.identifierNode);\n    this.checkFieldInitialization(instance);\n\n    var instanceMembers = instance.members;\n    if (instanceMembers) {\n      // TODO: for (let element of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let element = unchecked(_values[i]);\n        switch (element.kind) {\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            if (element.is(CommonFlags.GENERIC)) break;\n            let functionInstance = this.resolver.resolveFunction(<FunctionPrototype>element, null);\n            if (!functionInstance) break;\n            element = functionInstance;\n            // fall-through\n          }\n          case ElementKind.FUNCTION: {\n            this.compileFunction(<Function>element);\n            break;\n          }\n          case ElementKind.FIELD: {\n            this.compileField(<Field>element);\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>element);\n            if (!propertyInstance) break;\n            element = propertyInstance;\n            // fall-through\n          }\n          case ElementKind.PROPERTY: {\n            this.compileProperty(<Property>element);\n            break;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Compiles an instance field to a getter and a setter. */\n  compileField(instance: Field): bool {\n    this.compileFieldGetter(instance);\n    this.compileFieldSetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /** Compiles the getter of the specified instance field. */\n  compileFieldGetter(instance: Field): bool {\n    // A getter retains, while a load, as of a field access, does not.\n    if (instance.getterRef) return true;\n    var type = instance.type;\n    var nativeThisType = this.options.nativeSizeType;\n    var nativeValueType = type.toNativeType();\n    var module = this.module;\n    var valueExpr = module.load(type.byteSize, type.isSignedIntegerValue,\n      module.local_get(0, nativeThisType),\n      nativeValueType, instance.memoryOffset\n    );\n    if (type.isManaged) valueExpr = this.makeRetain(valueExpr, type);\n    instance.getterRef = module.addFunction(instance.internalGetterName, nativeThisType, nativeValueType, null, valueExpr);\n    if (instance.setterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles the setter of the specified instance field. */\n  compileFieldSetter(instance: Field): bool {\n    if (instance.setterRef) return true;\n    var type = instance.type;\n    var nativeThisType = this.options.nativeSizeType;\n    var nativeValueType = type.toNativeType();\n    var module = this.module;\n    var valueExpr: ExpressionRef;\n    var varTypes: NativeType[] | null = null;\n    if (type.isManaged) {\n      // Can't use makeReplace here since there's no corresponding flow, so\n      // 0: this, 1: value, 2: oldValue (temp)\n      valueExpr = module.block(null, [\n        module.if(\n          module.binary(nativeValueType == NativeType.I64 ? BinaryOp.NeI64 : BinaryOp.NeI32,\n            // value != (oldValue = this.field)\n            module.local_get(1, nativeValueType),\n            module.local_tee(2,\n              module.load(type.byteSize, false,\n                module.local_get(0, nativeThisType),\n                nativeValueType, instance.memoryOffset\n              )\n            )\n          ),\n          module.block(null, [\n            module.drop(\n              this.makeRetain(module.local_get(1, nativeValueType), type)\n            ),\n            this.makeRelease(module.local_get(2, nativeValueType), type)\n          ])\n        ),\n        module.local_get(1, nativeValueType)\n      ], nativeValueType);\n      varTypes = [ nativeValueType ];\n    } else {\n      valueExpr = module.local_get(1, nativeValueType);\n    }\n    instance.setterRef = module.addFunction(instance.internalSetterName, createType([ nativeThisType, nativeValueType ]), NativeType.None, varTypes,\n      module.store(type.byteSize,\n        module.local_get(0, nativeThisType),\n        valueExpr,\n        nativeValueType, instance.memoryOffset\n      )\n    );\n    if (instance.getterRef) {\n      instance.set(CommonFlags.COMPILED);\n    } else {\n      let typeNode = instance.typeNode;\n      if (typeNode) this.checkTypeSupported(instance.type, typeNode);\n    }\n    return true;\n  }\n\n  /** Compiles a property to a getter and potentially a setter. */\n  compileProperty(instance: Property): bool {\n    this.compilePropertyGetter(instance);\n    this.compilePropertySetter(instance);\n    return instance.is(CommonFlags.COMPILED);\n  }\n\n  /* Compiles the getter of the specified property. */\n  compilePropertyGetter(instance: Property): bool {\n    var getterInstance = instance.getterInstance;\n    if (getterInstance) {\n      let ret = this.compileFunction(getterInstance);\n      let setterInstance = instance.setterInstance;\n      if (getterInstance.is(CommonFlags.COMPILED) && (!setterInstance || setterInstance.is(CommonFlags.COMPILED))) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  /** Compiles the setter of the specified property. */\n  compilePropertySetter(instance: Property): bool {\n    var setterInstance = instance.setterInstance;\n    if (setterInstance) {\n      let ret = this.compileFunction(setterInstance);\n      let getterInstance = instance.getterInstance;\n      if (getterInstance !== null && getterInstance.is(CommonFlags.COMPILED) && setterInstance.is(CommonFlags.COMPILED)) {\n        instance.set(CommonFlags.COMPILED);\n      }\n      return ret;\n    }\n    return false;\n  }\n\n  // === Memory ===================================================================================\n\n  /** Adds a static memory segment with the specified data. */\n  addAlignedMemorySegment(buffer: Uint8Array, alignment: i32 = 16): MemorySegment {\n    assert(isPowerOf2(alignment));\n    var memoryOffset = i64_align(this.memoryOffset, alignment);\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));\n    return segment;\n  }\n\n  /** Adds a static memory segment representing a runtime object. */\n  addRuntimeMemorySegment(buffer: Uint8Array): MemorySegment {\n    // Runtime objects imply a full BLOCK and OBJECT header, see rt/common.ts\n    // ((memoryOffset + sizeof_usize + AL_MASK) & ~AL_MASK) - sizeof_usize\n    var usizeSize = this.options.usizeType.byteSize;\n    var memoryOffset = i64_sub(i64_align(i64_add(this.memoryOffset, i64_new(usizeSize)), 16), i64_new(usizeSize));\n    var segment = new MemorySegment(buffer, memoryOffset);\n    this.memorySegments.push(segment);\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));\n    return segment;\n  }\n\n  /** Ensures that a string exists in static memory and returns a pointer to it. Deduplicates. */\n  ensureStaticString(stringValue: string): ExpressionRef {\n    var program = this.program;\n    var rtHeaderSize = program.runtimeHeaderSize;\n    var stringInstance = assert(program.stringInstance);\n    var stringSegment: MemorySegment;\n    var segments = this.stringSegments;\n    if (segments.has(stringValue)) {\n      stringSegment = assert(segments.get(stringValue)); // reuse\n    } else {\n      let len = stringValue.length;\n      let buf = stringInstance.createBuffer(len << 1);\n      for (let i = 0; i < len; ++i) {\n        writeI16(stringValue.charCodeAt(i), buf, rtHeaderSize + (i << 1));\n      }\n      stringSegment = this.addRuntimeMemorySegment(buf);\n      segments.set(stringValue, stringSegment);\n    }\n    var ptr = i64_add(stringSegment.offset, i64_new(rtHeaderSize));\n    this.currentType = stringInstance.type;\n    if (this.options.isWasm64) {\n      return this.module.i64(i64_low(ptr), i64_high(ptr));\n    } else {\n      assert(i64_is_u32(ptr));\n      return this.module.i32(i64_low(ptr));\n    }\n  }\n\n  /** Writes a series of static values of the specified type to a buffer. */\n  writeStaticBuffer(buf: Uint8Array, pos: i32, elementType: Type, values: ExpressionRef[]): i32 {\n    var length = values.length;\n    var byteSize = elementType.byteSize;\n    var nativeType = elementType.toNativeType();\n    switch (<u32>nativeType) {\n      case <u32>NativeType.I32: {\n        switch (byteSize) {\n          case 1: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == nativeType);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI8(getConstValueI32(value), buf, pos);\n              pos += 1;\n            }\n            break;\n          }\n          case 2: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == nativeType);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI16(getConstValueI32(value), buf, pos);\n              pos += 2;\n            }\n            break;\n          }\n          case 4: {\n            for (let i = 0; i < length; ++i) {\n              let value = values[i];\n              assert(getExpressionType(value) == nativeType);\n              assert(getExpressionId(value) == ExpressionId.Const);\n              writeI32(getConstValueI32(value), buf, pos);\n              pos += 4;\n            }\n            break;\n          }\n          default: assert(false);\n        }\n        break;\n      }\n      case <u32>NativeType.I64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == nativeType);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeI64(i64_new(getConstValueI64Low(value), getConstValueI64High(value)), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      case <u32>NativeType.F32: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == nativeType);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF32(getConstValueF32(value), buf, pos);\n          pos += 4;\n        }\n        break;\n      }\n      case <u32>NativeType.F64: {\n        for (let i = 0; i < length; ++i) {\n          let value = values[i];\n          assert(getExpressionType(value) == nativeType);\n          assert(getExpressionId(value) == ExpressionId.Const);\n          writeF64(getConstValueF64(value), buf, pos);\n          pos += 8;\n        }\n        break;\n      }\n      default: assert(false);\n    }\n    return pos;\n  }\n\n  /** Adds a buffer to static memory and returns the created segment. */\n  addStaticBuffer(elementType: Type, values: ExpressionRef[], id: u32 = this.program.arrayBufferInstance.id): MemorySegment {\n    var program = this.program;\n    var arrayBufferInstance = program.arrayBufferInstance;\n    var buf = arrayBufferInstance.createBuffer(values.length * elementType.byteSize);\n    this.program.OBJECTInstance.writeField(\"rtId\", id, buf, 0); // use specified rtId\n    assert(this.writeStaticBuffer(buf, program.runtimeHeaderSize, elementType, values) == buf.length);\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  /** Adds an array header to static memory and returns the created segment. */\n  private addStaticArrayHeader(elementType: Type, bufferSegment: MemorySegment): MemorySegment {\n    var program = this.program;\n    var runtimeHeaderSize = program.runtimeHeaderSize;\n    var arrayPrototype = assert(program.arrayPrototype);\n    var arrayInstance = assert(this.resolver.resolveClass(arrayPrototype, [ elementType ]));\n    var bufferLength = bufferSegment.buffer.length - runtimeHeaderSize;\n    var arrayLength = i32(bufferLength / elementType.byteSize);\n    var bufferAddress = i64_add(bufferSegment.offset, i64_new(runtimeHeaderSize));\n\n    var buf = arrayInstance.createBuffer();\n    assert(arrayInstance.writeField(\"buffer\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"dataStart\", bufferAddress, buf));\n    assert(arrayInstance.writeField(\"byteLength\", bufferLength, buf));\n    assert(arrayInstance.writeField(\"length_\", arrayLength, buf));\n    return this.addRuntimeMemorySegment(buf);\n  }\n\n  // === Table ====================================================================================\n\n  /** Ensures that a runtime counterpart of the specified function exists and returns its address. */\n  ensureRuntimeFunction(instance: Function): i64 {\n    assert(instance.is(CommonFlags.COMPILED) && !instance.is(CommonFlags.STUB));\n    var program = this.program;\n    var memorySegment = instance.memorySegment;\n    if (!memorySegment) {\n\n      // Add to the function table\n      let functionTable = this.functionTable;\n      let tableBase = this.options.tableBase;\n      if (!tableBase) tableBase = 1; // leave first elem blank\n      let index = tableBase + functionTable.length;\n      functionTable.push(instance);\n\n      // Create runtime function\n      let rtInstance = assert(this.resolver.resolveClass(program.functionPrototype, [ instance.type ]));\n      let buf = rtInstance.createBuffer();\n      assert(rtInstance.writeField(\"_index\", index, buf));\n      assert(rtInstance.writeField(\"_env\", 0, buf));\n      instance.memorySegment = memorySegment = this.addRuntimeMemorySegment(buf);\n    }\n    return i64_add(memorySegment.offset, i64_new(program.runtimeHeaderSize));\n  }\n\n  // === Statements ===============================================================================\n\n  /** Compiles a top level statement (incl. function declarations etc.) to the specified body. */\n  compileTopLevelStatement(statement: Statement, body: ExpressionRef[]): void {\n    switch (statement.kind) {\n      case NodeKind.CLASSDECLARATION: {\n        let memberStatements = (<ClassDeclaration>statement).members;\n        for (let i = 0, k = memberStatements.length; i < k; ++i) {\n          this.compileTopLevelStatement(memberStatements[i], body);\n        }\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        let element = this.program.getElementByDeclaration(<EnumDeclaration>statement);\n        if (element) {\n          assert(element.kind == ElementKind.ENUM);\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileEnum(<Enum>element);\n        }\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        let declaration = <NamespaceDeclaration>statement;\n        let element = this.program.getElementByDeclaration(declaration);\n        if (element) {\n          // any potentiall merged element\n          let previousParent = this.currentParent;\n          this.currentParent = element;\n          let memberStatements = declaration.members;\n          for (let i = 0, k = memberStatements.length; i < k; ++i) {\n            this.compileTopLevelStatement(memberStatements[i], body);\n          }\n          this.currentParent = previousParent;\n        }\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        let declarations = (<VariableStatement>statement).declarations;\n        for (let i = 0, k = declarations.length; i < k; ++i) {\n          let element = this.program.getElementByDeclaration(declarations[i]);\n          if (element) {\n            assert(element.kind == ElementKind.GLOBAL);\n            if (\n              !element.is(CommonFlags.AMBIENT) && // delay imports\n              !element.hasDecorator(DecoratorFlags.LAZY)\n            ) this.compileGlobal(<Global>element);\n          }\n        }\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        let element = this.program.getElementByDeclaration(<FieldDeclaration>statement);\n        if (element !== null && element.kind == ElementKind.GLOBAL) { // static\n          if (!element.hasDecorator(DecoratorFlags.LAZY)) this.compileGlobal(<Global>element);\n        }\n        break;\n      }\n      case NodeKind.EXPORT: {\n        let exportStatement = <ExportStatement>statement;\n        let internalPath = exportStatement.internalPath;\n        if (internalPath !== null) {\n          this.compileFileByPath(internalPath, assert(exportStatement.path));\n        }\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.compileTopLevelStatement((<ExportDefaultStatement>statement).declaration, body);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        let importStatement = <ImportStatement>statement;\n        this.compileFileByPath(importStatement.internalPath, importStatement.path);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION:\n      case NodeKind.METHODDECLARATION:\n      case NodeKind.INTERFACEDECLARATION:\n      case NodeKind.INDEXSIGNATURE:\n      case NodeKind.TYPEDECLARATION: break;\n      default: { // otherwise a top-level statement that is part of the start function's body\n        let stmt = this.compileStatement(statement);\n        if (getExpressionId(stmt) != ExpressionId.Nop) body.push(stmt);\n        break;\n      }\n    }\n  }\n\n  /** Compiles a statement. */\n  compileStatement(\n    /** Statement to compile. */\n    statement: Statement,\n    /** Whether this is the last statement of the body, if known. */\n    isLastInBody: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var stmt: ExpressionRef;\n    switch (statement.kind) {\n      case NodeKind.BLOCK: {\n        stmt = this.compileBlockStatement(<BlockStatement>statement);\n        break;\n      }\n      case NodeKind.BREAK: {\n        stmt = this.compileBreakStatement(<BreakStatement>statement);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        stmt = this.compileContinueStatement(<ContinueStatement>statement);\n        break;\n      }\n      case NodeKind.DO: {\n        stmt = this.compileDoStatement(<DoStatement>statement);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        stmt = this.compileEmptyStatement(<EmptyStatement>statement);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        stmt = this.compileExpressionStatement(<ExpressionStatement>statement);\n        break;\n      }\n      case NodeKind.FOR: {\n        stmt = this.compileForStatement(<ForStatement>statement);\n        break;\n      }\n      case NodeKind.FOROF: {\n        stmt = this.compileForOfStatement(<ForOfStatement>statement);\n        break;\n      }\n      case NodeKind.IF: {\n        stmt = this.compileIfStatement(<IfStatement>statement);\n        break;\n      }\n      case NodeKind.RETURN: {\n        stmt = this.compileReturnStatement(<ReturnStatement>statement, isLastInBody);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        stmt = this.compileSwitchStatement(<SwitchStatement>statement);\n        break;\n      }\n      case NodeKind.THROW: {\n        stmt = this.compileThrowStatement(<ThrowStatement>statement);\n        break;\n      }\n      case NodeKind.TRY: {\n        stmt = this.compileTryStatement(<TryStatement>statement);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        stmt = this.compileVariableStatement(<VariableStatement>statement);\n        if (!stmt) stmt = module.nop();\n        break;\n      }\n      case NodeKind.VOID: {\n        stmt = this.compileVoidStatement(<VoidStatement>statement);\n        break;\n      }\n      case NodeKind.WHILE: {\n        stmt = this.compileWhileStatement(<WhileStatement>statement);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        // TODO: integrate inner type declaration into flow\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          statement.range,\n          \"Inner type alias\"\n        );\n        stmt = module.unreachable();\n        break;\n      }\n      default: {\n        assert(false);\n        stmt = module.unreachable();\n      }\n    }\n    if (this.options.sourceMap) this.addDebugLocation(stmt, statement.range);\n    return stmt;\n  }\n\n  /** Compiles a series of statements. */\n  compileStatements(\n    /** Statements to compile. */\n    statements: Statement[],\n    /** Whether this is an immediate body statement. */\n    isBody: bool = false,\n    /** Statements to append to that is also returned. Created if omitted. */\n    stmts: ExpressionRef[] | null = null\n  ): ExpressionRef[] {\n    var numStatements = statements.length;\n    if (!stmts) {\n      stmts = new Array<ExpressionRef>(numStatements);\n      stmts.length = 0;\n    }\n    var module = this.module;\n    var flow = this.currentFlow;\n    for (let i = 0; i < numStatements; ++i) {\n      let stmt = this.compileStatement(statements[i], isBody && i == numStatements - 1);\n      switch (getExpressionId(stmt)) {\n        case ExpressionId.Block: {\n          if (!getBlockName(stmt)) {\n            for (let j: Index = 0, k = getBlockChildCount(stmt); j < k; ++j) stmts.push(getBlockChildAt(stmt, j));\n            break;\n          }\n          // fall-through\n        }\n        default: stmts.push(stmt);\n        case ExpressionId.Nop:\n      }\n      if (flow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n        if (needsExplicitUnreachable(stmt)) stmts.push(module.unreachable());\n        break;\n      }\n    }\n    return stmts;\n  }\n\n  private compileBlockStatement(\n    statement: BlockStatement\n  ): ExpressionRef {\n    var statements = statement.statements;\n    var outerFlow = this.currentFlow;\n    var innerFlow = outerFlow.fork();\n    this.currentFlow = innerFlow;\n\n    var stmts = this.compileStatements(statements);\n    if (!innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) this.performAutoreleases(innerFlow, stmts);\n    innerFlow.freeScopedLocals();\n    outerFlow.inherit(innerFlow);\n    this.currentFlow = outerFlow;\n    return this.module.flatten(stmts);\n  }\n\n  private compileBreakStatement(\n    statement: BreakStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var labelNode = statement.label;\n    if (labelNode) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        labelNode.range,\n        \"Break label\"\n      );\n      return module.unreachable();\n    }\n    var flow = this.currentFlow;\n    var breakLabel = flow.breakLabel;\n    if (breakLabel == null) {\n      this.error(\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    var stmts = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, stmts);\n    var parent = flow.parent;\n    while (parent !== null && parent.breakLabel == breakLabel) {\n      this.performAutoreleases(parent, stmts, /* finalize */ false);\n      parent = parent.parent;\n    }\n    flow.freeScopedLocals();\n    stmts.push(module.br(breakLabel));\n    flow.set(FlowFlags.BREAKS);\n    return module.flatten(stmts);\n  }\n\n  private compileContinueStatement(\n    statement: ContinueStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var label = statement.label;\n    if (label) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        label.range,\n        \"Continue label\"\n      );\n      return module.unreachable();\n    }\n    // Check if 'continue' is allowed here\n    var flow = this.currentFlow;\n    var continueLabel = flow.continueLabel;\n    if (continueLabel == null) {\n      this.error(\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\n        statement.range\n      );\n      return module.unreachable();\n    }\n    flow.set(FlowFlags.CONTINUES | FlowFlags.TERMINATES);\n    var stmts = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, stmts);\n    var current: Flow | null = flow.parent;\n    while (current !== null && current.continueLabel === continueLabel) {\n      this.performAutoreleases(current, stmts, /* finalize */ false);\n      current = current.parent;\n    }\n    flow.freeScopedLocals();\n    stmts.push(module.br(continueLabel));\n    return module.flatten(stmts);\n  }\n\n  private compileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement\n  ): ExpressionRef {\n    return this.doCompileDoStatement(statement, null);\n  }\n\n  private doCompileDoStatement(\n    /** Statement to compile. */\n    statement: DoStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                           flow\n    //  (loop $continue                          recompile?\n    //   (body)                                  bodyFlow \n    //   [autorelease]                                    \n    //                                                   breaks or terminates?\n    //   (local.set $tcond (condition))         condFlow \n    //   [autorelease]                                   \n    //   (br_if (local.get $tcond) $continue)  condition?\n    //  )                                     \n    // )                                      \n\n    var label = outerFlow.pushBreakLabel();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"do-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"do-continue|\" + label;\n    flow.continueLabel = continueLabel;\n\n    // Compile the body (always executes)\n    var bodyFlow = flow.fork();\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Shortcut if body never falls through\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      flow.inherit(bodyFlow);\n\n    // Otherwise evaluate the condition\n    } else {\n      this.performAutoreleases(bodyFlow, bodyStmts);\n\n      let condFlow = flow.fork();\n      this.currentFlow = condFlow;\n      let condExpr = this.makeIsTrueish(\n        this.compileExpression(statement.condition, Type.i32),\n        this.currentType,\n        statement.condition\n      );\n      let condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false\n      if (condKind == ConditionKind.FALSE) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        this.performAutoreleases(condFlow, bodyStmts);\n        flow.inherit(bodyFlow);\n\n      // Terminate if condition is always true and body never breaks\n      } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        bodyStmts.push(\n          module.drop(condExpr)\n        );\n        this.performAutoreleases(condFlow, bodyStmts);\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n        flow.set(FlowFlags.TERMINATES);\n\n      } else {\n        let tcond = condFlow.getTempLocal(Type.bool);\n        bodyStmts.push(\n          module.local_set(tcond.index, condExpr)\n        );\n        this.performAutoreleases(condFlow, bodyStmts);\n        bodyStmts.push(\n          module.br(continueLabel,\n            module.local_get(tcond.index, NativeType.I32)\n          )\n        );\n        condFlow.freeTempLocal(tcond);\n        flow.inherit(condFlow);\n\n        // Detect if local flags are incompatible before and after looping, and\n        // if so recompile by unifying local flags between iterations. Note that\n        // this may be necessary multiple times where locals depend on each other.\n        if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n          outerFlow.popBreakLabel();\n          this.currentFlow = outerFlow;\n          return this.doCompileDoStatement(statement, flow);\n        }\n      }\n    }\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(bodyStmts)\n      )\n    ]);\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  private compileEmptyStatement(\n    statement: EmptyStatement\n  ): ExpressionRef {\n    return this.module.nop();\n  }\n\n  private compileExpressionStatement(\n    statement: ExpressionStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void, Constraints.CONV_IMPLICIT);\n  }\n\n  private compileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement\n  ): ExpressionRef {\n    return this.doCompileForStatement(statement, null);\n  }\n\n  private doCompileForStatement(\n    /** Statement to compile. */\n    statement: ForStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (initializer)                   flow\n    // (block $break                    \n    //  (loop $loop                      recompile?\n    //   (local.set $tcond (condition))  condFlow \n    //   [autorelease]                            \n    //   (if (local.get $tcond)                    condition?\n    //    (block $continue                         \n    //     (body)                       bodyFlow \n    //     [autorelease]                         \n    //    )                                      breaks or terminates?\n    //    (incrementor)                 incrFlow \n    //    [autorelease]                          \n    //                                 \n    //    (br $loop)                  \n    //   )                              \n    //  )                               \n    // )                                \n    // [autorelease]                  \n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    this.currentFlow = flow;\n\n    var breakLabel = \"for-break\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"for-continue|\" + label;\n    flow.continueLabel = continueLabel;\n    var loopLabel = \"for-loop|\" + label;\n\n    // Compile initializer if present (but wait with autoreleases)\n    var initializer = statement.initializer;\n    if (initializer) {\n      assert(\n        initializer.kind == NodeKind.EXPRESSION ||\n        initializer.kind == NodeKind.VARIABLE\n      );\n      stmts.push(this.compileStatement(initializer));\n    }\n\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr: ExpressionRef;\n    var condKind: ConditionKind;\n    var condition = statement.condition;\n    if (condition) {\n      condExpr = this.makeIsTrueish(\n        this.compileExpression(condition, Type.bool),\n        this.currentType,\n        condition\n      );\n      condKind = this.evaluateCondition(condExpr);\n\n      // Shortcut if condition is always false (body never runs)\n      if (condKind == ConditionKind.FALSE) {\n        stmts.push(\n          module.drop(condExpr)\n        );\n        this.performAutoreleases(condFlow, stmts);\n        condFlow.freeScopedLocals();\n        flow.inherit(condFlow);\n        this.performAutoreleases(flow, stmts);\n        flow.freeScopedLocals();\n        outerFlow.inherit(flow);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return module.flatten(stmts);\n      }\n    } else {\n      condExpr = module.i32(1);\n      condKind = ConditionKind.TRUE;\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp while we autorelease\n    var tcond = flow.getTempLocal(Type.bool);\n    var loopStmts = new Array<ExpressionRef>();\n    loopStmts.push(\n      module.local_set(tcond.index, condExpr)\n    );\n    this.performAutoreleases(condFlow, loopStmts);\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Check if body terminates\n    if (bodyFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n      bodyStmts.push(module.unreachable());\n    } else {\n      this.performAutoreleases(bodyFlow, bodyStmts);\n    }\n    if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n    else flow.inheritBranch(bodyFlow);\n    bodyFlow.freeScopedLocals();\n\n    var ifStmts = new Array<ExpressionRef>();\n    ifStmts.push(\n      module.block(continueLabel, bodyStmts)\n    );\n\n    // Compile the incrementor if it runs\n    // Can still fall through to here if body continues, hence is already known to terminate\n    if (!bodyFlow.is(FlowFlags.TERMINATES) || bodyFlow.isAny(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES)) {\n      let incrementor = statement.incrementor;\n      if (incrementor) {\n        let incrFlow = flow.fork();\n        this.currentFlow = incrFlow;\n        ifStmts.push(\n          this.compileExpression(incrementor, Type.void, Constraints.CONV_IMPLICIT | Constraints.WILL_DROP)\n        );\n        this.performAutoreleases(incrFlow, ifStmts);\n        incrFlow.freeScopedLocals();\n        flow.inherit(incrFlow); // mostly local flags, also covers late termination by throwing\n        this.currentFlow = flow;\n      }\n\n      ifStmts.push(\n        module.br(loopLabel)\n      );\n\n      // Detect if local flags are incompatible before and after looping, and if\n      // so recompile by unifying local flags between iterations. Note that this\n      // may be necessary multiple times where locals depend on each other.\n      if (Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        assert(!bodyFlow.hasScopedLocals);\n        flow.freeScopedLocals();\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileForStatement(statement, flow);\n      }\n    }\n    loopStmts.push(\n      module.if(module.local_get(tcond.index, NativeType.I32),\n        module.flatten(ifStmts)\n      )\n    );\n\n    stmts.push(\n      module.block(breakLabel, [\n        module.loop(loopLabel,\n          module.flatten(loopStmts)\n        )\n      ])\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    flow.freeScopedLocals();\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    if (outerFlow.is(FlowFlags.TERMINATES)) {\n      stmts.push(module.unreachable());\n    } else {\n      this.performAutoreleases(flow, stmts);\n    }\n    this.currentFlow = outerFlow;\n    return module.flatten(stmts);\n  }\n\n  private compileForOfStatement(\n    statement: ForOfStatement\n  ): ExpressionRef {\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Iterators\"\n    );\n    return this.module.unreachable();\n  }\n\n  private compileIfStatement(\n    statement: IfStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var ifTrue = statement.ifTrue;\n    var ifFalse = statement.ifFalse;\n\n    // (if               flow\n    //  (condition)       condition?\n    //  (block                       \n    //   (ifTrue)         thenFlow \n    //   [autorelease]             \n    //  )                          \n    //  (block                      present?\n    //   (ifFalse)                   elseFlow\n    //   [autorelease]              \n    //  )                           \n    // )                 \n    // ...              \n    // [autorelease]               incl. condition\n\n    // Precompute the condition (always executes)\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if the condition is constant\n    switch (condKind) {\n      case ConditionKind.TRUE: {\n        return module.block(null, [\n          module.drop(condExpr),\n          this.compileStatement(ifTrue)\n        ]);\n      }\n      case ConditionKind.FALSE: {\n        return ifFalse\n          ? module.block(null, [\n              module.drop(condExpr),\n              this.compileStatement(ifFalse)\n            ])\n          : module.drop(condExpr);\n      }\n    }\n\n    // From here on condition is always unknown\n\n    var flow = this.currentFlow;\n\n    // Compile ifTrue assuming the condition turned out true\n    var thenStmts = new Array<ExpressionRef>();\n    var thenFlow = flow.fork();\n    this.currentFlow = thenFlow;\n    thenFlow.inheritNonnullIfTrue(condExpr);\n    if (ifTrue.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>ifTrue).statements, false, thenStmts);\n    } else {\n      thenStmts.push(this.compileStatement(ifTrue));\n    }\n    var thenTerminates = thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n    if (thenTerminates) {\n      thenStmts.push(module.unreachable());\n    } else {\n      this.performAutoreleases(thenFlow, thenStmts);\n    }\n    thenFlow.freeScopedLocals();\n    this.currentFlow = flow;\n\n    // Compile ifFalse assuming the condition turned out false, if present\n    if (ifFalse) {\n      let elseStmts = new Array<ExpressionRef>();\n      let elseFlow = flow.fork();\n      this.currentFlow = elseFlow;\n      elseFlow.inheritNonnullIfFalse(condExpr);\n      if (ifFalse.kind == NodeKind.BLOCK) {\n        this.compileStatements((<BlockStatement>ifFalse).statements, false, elseStmts);\n      } else {\n        elseStmts.push(this.compileStatement(ifFalse));\n      }\n      let elseTerminates = elseFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS);\n      if (elseTerminates) {\n        elseStmts.push(module.unreachable());\n      } else {\n        this.performAutoreleases(elseFlow, elseStmts);\n      }\n      elseFlow.freeScopedLocals();\n      this.currentFlow = flow;\n      flow.inheritMutual(thenFlow, elseFlow);\n      return module.if(condExpr,\n        module.flatten(thenStmts),\n        module.flatten(elseStmts)\n      );\n    } else {\n      flow.inheritBranch(thenFlow);\n      flow.inheritNonnullIfFalse(condExpr,\n        thenFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)\n          ? null     // thenFlow terminates: just inherit\n          : thenFlow // must become nonnull in thenFlow otherwise\n      );\n      return module.if(condExpr,\n        module.flatten(thenStmts)\n      );\n    }\n  }\n\n  private compileReturnStatement(\n    statement: ReturnStatement,\n    isLastInBody: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var expr: ExpressionRef = 0;\n    var flow = this.currentFlow;\n    var returnType = flow.returnType;\n\n    var valueExpression = statement.value;\n    if (valueExpression) {\n      if (returnType == Type.void) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n          valueExpression.range, this.currentType.toString(), returnType.toString()\n        );\n        this.currentType = Type.void;\n        return module.unreachable();\n      }\n      let constraints = Constraints.CONV_IMPLICIT;\n      if (flow.actualFunction.is(CommonFlags.MODULE_EXPORT)) constraints |= Constraints.MUST_WRAP;\n\n      // take special care of properly retaining the returned value\n      expr = this.compileReturnedExpression(valueExpression, returnType, constraints);\n      if (flow.actualFunction.is(CommonFlags.CONSTRUCTOR) && valueExpression.kind != NodeKind.THIS) {\n        flow.set(FlowFlags.MAY_RETURN_NONTHIS);\n      }\n    } else if (returnType != Type.void) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        statement.range, \"void\", returnType.toString()\n      );\n      expr = module.unreachable();\n    }\n\n    var stmts = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, stmts);\n    this.finishAutoreleases(flow, stmts);\n\n    if (returnType != Type.void && stmts.length > 0) {\n      let temp = flow.getTempLocal(returnType);\n      if (flow.isNonnull(expr, returnType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n      stmts.unshift(\n        module.local_set(temp.index, expr)\n      );\n      expr = module.local_get(temp.index, returnType.toNativeType());\n      flow.freeTempLocal(temp);\n    }\n    flow.freeScopedLocals();\n\n    // Remember that this flow returns\n    flow.set(FlowFlags.RETURNS | FlowFlags.TERMINATES);\n\n    // If the last statement anyway, make it the block's return value\n    if (isLastInBody && expr != 0 && returnType != Type.void) {\n      if (!stmts.length) return expr;\n      stmts.push(expr);\n      return module.flatten(stmts, returnType.toNativeType());\n    }\n\n    // When inlining, break to the end of the inlined function's block (no need to wrap)\n    if (flow.isInline) {\n      if (!stmts.length) return module.br(assert(flow.inlineReturnLabel), 0, expr);\n      stmts.push(module.br(assert(flow.inlineReturnLabel), 0, expr));\n      // stmts.push(module.createUnreachable());\n      return module.flatten(stmts);\n    }\n\n    // Otherwise emit a normal return\n    if (!stmts.length) return module.return(expr);\n    stmts.push(module.return(expr));\n    return module.flatten(stmts);\n  }\n\n  private compileSwitchStatement(\n    statement: SwitchStatement\n  ): ExpressionRef {\n    var module = this.module;\n\n    var cases = statement.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return this.compileExpression(statement.condition, Type.void,\n        Constraints.CONV_IMPLICIT\n      );\n    }\n\n    // Everything within a switch uses the same break context\n    var outerFlow = this.currentFlow;\n    var context = outerFlow.pushBreakLabel();\n\n    // introduce a local for evaluating the condition (exactly once)\n    var tempLocal = outerFlow.getTempLocal(Type.u32);\n    var tempLocalIndex = tempLocal.index;\n\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\n    var breaks = new Array<ExpressionRef>(1 + numCases);\n    breaks[0] = module.local_set( // initializer\n      tempLocalIndex,\n      this.compileExpression(statement.condition, Type.u32,\n        Constraints.CONV_IMPLICIT\n      )\n    );\n\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\n    var breakIndex = 1;\n    var defaultIndex = -1;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let label = case_.label;\n      if (label) {\n        breaks[breakIndex++] = module.br(\"case\" + i.toString() + \"|\" + context,\n          module.binary(BinaryOp.EqI32,\n            module.local_get(tempLocalIndex, NativeType.I32),\n            this.compileExpression(label, Type.u32,\n              Constraints.CONV_IMPLICIT\n            )\n          )\n        );\n      } else {\n        defaultIndex = i;\n      }\n    }\n\n    outerFlow.freeTempLocal(tempLocal);\n\n    // otherwise br to default respectively out of the switch if there is no default case\n    breaks[breakIndex] = module.br((defaultIndex >= 0\n      ? \"case\" + defaultIndex.toString()\n      : \"break\"\n    ) + \"|\" + context);\n\n    // nest blocks in order\n    var currentBlock = module.block(\"case0|\" + context, breaks, NativeType.None);\n    var commonCategorical = FlowFlags.ANY_CATEGORICAL;\n    var commonConditional = 0;\n    for (let i = 0; i < numCases; ++i) {\n      let case_ = cases[i];\n      let statements = case_.statements;\n      let numStatements = statements.length;\n\n      // Each switch case initiates a new branch\n      let innerFlow = outerFlow.fork();\n      this.currentFlow = innerFlow;\n      let breakLabel = \"break|\" + context;\n      innerFlow.breakLabel = breakLabel;\n\n      let isLast = i == numCases - 1;\n      let nextLabel = isLast ? breakLabel : \"case\" + (i + 1).toString() + \"|\" + context;\n      let stmts = new Array<ExpressionRef>(1 + numStatements);\n      stmts[0] = currentBlock;\n      let count = 1;\n      let terminates = false;\n      for (let j = 0; j < numStatements; ++j) {\n        let stmt = this.compileStatement(statements[j]);\n        if (getExpressionId(stmt) != ExpressionId.Nop) {\n          stmts[count++] = stmt;\n        }\n        if (innerFlow.isAny(FlowFlags.TERMINATES | FlowFlags.BREAKS)) {\n          if (innerFlow.is(FlowFlags.TERMINATES)) terminates = true;\n          break;\n        }\n      }\n      stmts.length = count;\n      if (terminates || isLast || innerFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        commonCategorical &= innerFlow.flags;\n      }\n      commonConditional |= innerFlow.flags & FlowFlags.ANY_CONDITIONAL;\n\n      // Switch back to the parent flow\n      if (!terminates) this.performAutoreleases(innerFlow, stmts);\n      innerFlow.unset(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS\n      );\n      innerFlow.freeScopedLocals();\n      this.currentFlow = outerFlow;\n      currentBlock = module.block(nextLabel, stmts, NativeType.None); // must be a labeled block\n    }\n    outerFlow.popBreakLabel();\n\n    // If the switch has a default (guaranteed to handle any value), propagate common flags\n    if (defaultIndex >= 0) outerFlow.flags |= commonCategorical & ~FlowFlags.BREAKS;\n    outerFlow.flags |= commonConditional & ~FlowFlags.CONDITIONALLY_BREAKS;\n    // TODO: what about local states?\n    return currentBlock;\n  }\n\n  private compileThrowStatement(\n    statement: ThrowStatement\n  ): ExpressionRef {\n    // TODO: requires exception-handling spec.\n    var flow = this.currentFlow;\n\n    // Remember that this branch throws\n    flow.set(FlowFlags.THROWS | FlowFlags.TERMINATES);\n\n    var stmts = new Array<ExpressionRef>();\n    var value = statement.value;\n    var message: Expression | null = null;\n    if (value.kind == NodeKind.NEW) {\n      let newArgs = (<NewExpression>value).args;\n      if (newArgs.length) message = newArgs[0]; // FIXME: naively assumes type string\n    }\n    stmts.push(\n      this.makeAbort(message, statement)\n    );\n    // generates dead code (after unreachable) but still updates state\n    var dropped = new Array<ExpressionRef>();\n    this.performAutoreleases(flow, dropped);\n    this.finishAutoreleases(flow, dropped);\n    flow.freeScopedLocals();\n\n    return this.module.flatten(stmts);\n  }\n\n  private compileTryStatement(\n    statement: TryStatement\n  ): ExpressionRef {\n    // TODO: can't yet support something like: try { return ... } finally { ... }\n    // worthwhile to investigate lowering returns to block results (here)?\n    this.error(\n      DiagnosticCode.Not_implemented_0,\n      statement.range,\n      \"Exceptions\"\n    );\n    return this.module.unreachable();\n  }\n\n  /** Compiles a variable statement. Returns `0` if an initializer is not necessary. */\n  private compileVariableStatement(\n    statement: VariableStatement\n  ): ExpressionRef {\n    var module = this.module;\n    var declarations = statement.declarations;\n    var numDeclarations = declarations.length;\n    var flow = this.currentFlow;\n    var initializers = new Array<ExpressionRef>();\n    var resolver = this.resolver;\n\n    for (let i = 0; i < numDeclarations; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let type: Type | null = null;\n      let initExpr: ExpressionRef = 0;\n      let initAutoreleaseSkipped = false;\n\n      // Resolve type if annotated\n      let typeNode = declaration.type;\n      let initializerNode = declaration.initializer;\n      if (typeNode) {\n        type = resolver.resolveType( // reports\n          typeNode,\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!type) continue;\n        this.checkTypeSupported(type, typeNode);\n\n        if (initializerNode) {\n          let pendingElements = this.pendingElements;\n          let dummy = flow.addScopedDummyLocal(name, type); // pending dummy\n          pendingElements.add(dummy);\n          initExpr = this.compileExpression(initializerNode, type, // reports\n            Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n          );\n          initAutoreleaseSkipped = this.skippedAutoreleases.has(initExpr);\n          pendingElements.delete(dummy);\n          flow.freeScopedDummyLocal(name);\n        }\n\n      // Otherwise infer type from initializer\n      } else if (initializerNode) {\n        let pendingElements = this.pendingElements;\n        let temp = flow.addScopedDummyLocal(name, Type.auto); // pending dummy\n        pendingElements.add(temp);\n        initExpr = this.compileExpression(initializerNode, Type.auto,\n          Constraints.WILL_RETAIN\n        ); // reports\n        initAutoreleaseSkipped = this.skippedAutoreleases.has(initExpr);\n        pendingElements.delete(temp);\n        flow.freeScopedDummyLocal(name);\n\n        if (this.currentType == Type.void) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            declaration.range, this.currentType.toString(), \"<auto>\"\n          );\n          continue;\n        }\n        type = this.currentType;\n\n      // Error if there's neither a type nor an initializer\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          declaration.name.range.atEnd\n        );\n        continue;\n      }\n\n      // Handle constants, and try to inline if value is static\n      let isConst = declaration.is(CommonFlags.CONST);\n      let isStatic = false;\n      if (isConst) {\n        if (initExpr) {\n          let precomp = module.runExpression(initExpr, ExpressionRunnerFlags.PreserveSideeffects);\n          if (precomp) {\n            initExpr = precomp; // always use precomputed initExpr\n            let local: Local | null = null;\n            switch (<u32>getExpressionType(initExpr)) {\n              case <u32>NativeType.I32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI32(initExpr),\n                    0\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>NativeType.I64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantIntegerValue(\n                  i64_new(\n                    getConstValueI64Low(initExpr),\n                    getConstValueI64High(initExpr)\n                  ),\n                  type\n                );\n                break;\n              }\n              case <u32>NativeType.F32: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(<f64>getConstValueF32(initExpr), type);\n                break;\n              }\n              case <u32>NativeType.F64: {\n                local = new Local(name, -1, type, flow.parentFunction);\n                local.setConstantFloatValue(getConstValueF64(initExpr), type);\n                break;\n              }\n            }\n            if (local) {\n              // Add as a virtual local that doesn't actually exist in WebAssembly\n              let scopedLocals = flow.scopedLocals;\n              if (!scopedLocals) flow.scopedLocals = scopedLocals = new Map();\n              else if (scopedLocals.has(name)) {\n                let existing = assert(scopedLocals.get(name));\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  declaration.name.range,\n                  existing.declaration.name.range,\n                  name\n                );\n                return this.module.unreachable();\n              }\n              scopedLocals.set(name, local);\n              isStatic = true;\n            }\n          }\n        } else {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            declaration.range\n          );\n        }\n      }\n\n      // Otherwise compile as mutable\n      if (!isStatic) {\n        let local: Local;\n        if (\n          declaration.isAny(CommonFlags.LET | CommonFlags.CONST) ||\n          flow.isInline\n        ) { // here: not top-level\n          let existingLocal = flow.getScopedLocal(name);\n          if (existingLocal) {\n            if (!existingLocal.declaration.range.source.isNative) {\n              this.errorRelated(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range,\n                existingLocal.declaration.name.range,\n                name\n              );\n            } else { // scoped locals are shared temps that don't track declarations\n              this.error(\n                DiagnosticCode.Duplicate_identifier_0,\n                declaration.name.range, name\n              );\n            }\n            local = existingLocal;\n          } else {\n            local = flow.addScopedLocal(name, type);\n          }\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        } else {\n          let existing = flow.lookupLocal(name);\n          if (existing) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              declaration.name.range,\n              existing.declaration.name.range,\n              name\n            );\n            continue;\n          }\n          local = flow.parentFunction.addLocal(type, name, declaration);\n          if (isConst) flow.setLocalFlag(local.index, LocalFlags.CONSTANT);\n        }\n        let isManaged = type.isManaged;\n        if (initExpr) {\n          if (flow.isNonnull(initExpr, type)) flow.setLocalFlag(local.index, LocalFlags.NONNULL);\n          if (isManaged) {\n            flow.setLocalFlag(local.index, LocalFlags.RETAINED);\n            initializers.push(\n              module.local_set(local.index,\n                initAutoreleaseSkipped\n                  ? initExpr\n                  : this.makeRetain(initExpr, type)\n              )\n            );\n          } else {\n            initializers.push(\n              module.local_set(local.index, initExpr)\n            );\n            if (local.type.isShortIntegerValue) {\n              if (!flow.canOverflow(initExpr, type)) flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\n              else flow.unsetLocalFlag(local.index, LocalFlags.WRAPPED);\n            }\n          }\n        } else {\n          if (isManaged) {\n            // This is necessary because the first use (and assign) of the local could be taking place\n            // in a loop, subsequently marking it retained, but the second iteration of the loop\n            // still wouldn't release whatever is assigned in the first. Likewise, if the variable wasn't\n            // initialized but becomes released later on, whatever was stored before would be released.\n            // TODO: Detect this condition inside of a loop instead?\n            initializers.push(\n              module.local_set(local.index,\n                this.makeZero(type, declaration)\n              )\n            );\n            flow.setLocalFlag(local.index, LocalFlags.CONDITIONALLY_RETAINED);\n          } else if (local.type.isShortIntegerValue) {\n            flow.setLocalFlag(local.index, LocalFlags.WRAPPED);\n          }\n        }\n      }\n    }\n    return initializers.length == 0\n      ? 0\n      : module.flatten(initializers);\n  }\n\n  private compileVoidStatement(\n    statement: VoidStatement\n  ): ExpressionRef {\n    return this.compileExpression(statement.expression, Type.void,\n      Constraints.CONV_EXPLICIT | Constraints.WILL_DROP\n    );\n  }\n\n  private compileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement\n  ): ExpressionRef {\n    return this.doCompileWhileStatement(statement, null);\n  }\n\n  private doCompileWhileStatement(\n    /** Statement to compile. */\n    statement: WhileStatement,\n    /** If recompiling, the flow with differing local flags that triggered it. */\n    flowAfter: Flow | null\n  ): ExpressionRef {\n    var module = this.module;\n    var outerFlow = this.currentFlow;\n\n    // (block $break                   flow\n    //  (loop $continue                  recompile?\n    //   (local.set $tcond (condition))  condFlow \n    //   [autorelease]                            \n    //   (if (local.get $tcond)                    condition?\n    //    (body)                        bodyFlow \n    //    [autorelease]                          \n    //                                           breaks or terminates?\n    //    (br $continue)               \n    //   )                            \n    //  )                               \n    // )                              \n\n    var label = outerFlow.pushBreakLabel();\n    var stmts = new Array<ExpressionRef>();\n    var flow = outerFlow.fork(/* resetBreakContext */ true);\n    if (flowAfter) flow.unifyLocalFlags(flowAfter);\n    var flowBefore = flow.fork();\n    this.currentFlow = flow;\n\n    var breakLabel = \"while-break|\" + label;\n    flow.breakLabel = breakLabel;\n    var continueLabel = \"while-continue|\" + label;\n    flow.continueLabel = continueLabel;\n\n    // Precompute the condition\n    var condFlow = flow.fork();\n    this.currentFlow = condFlow;\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(statement.condition, Type.bool),\n      this.currentType,\n      statement.condition\n    );\n    var condKind = this.evaluateCondition(condExpr);\n\n    // Shortcut if condition is always false (body never runs)\n    if (condKind == ConditionKind.FALSE) {\n      stmts.push(\n        module.drop(condExpr)\n      );\n      this.performAutoreleases(condFlow, stmts);\n      assert(!flow.hasScopedLocals);\n      outerFlow.popBreakLabel();\n      this.currentFlow = outerFlow;\n      return module.flatten(stmts);\n    }\n\n    // From here on condition is either always true or unknown\n\n    // Store condition result in a temp while we autorelease\n    var tcond = flow.getTempLocal(Type.bool);\n    stmts.push(\n      module.local_set(tcond.index, condExpr)\n    );\n    this.performAutoreleases(condFlow, stmts);\n    condFlow.freeScopedLocals();\n\n    flow.inherit(condFlow); // always executes\n    this.currentFlow = flow;\n\n    // Compile the body assuming the condition turned out true\n    var bodyFlow = flow.fork();\n    bodyFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = bodyFlow;\n    var bodyStmts = new Array<ExpressionRef>();\n    var body = statement.statement;\n    if (body.kind == NodeKind.BLOCK) {\n      this.compileStatements((<BlockStatement>body).statements, false, bodyStmts);\n    } else {\n      bodyStmts.push(this.compileStatement(body));\n    }\n\n    // Simplify if body always terminates\n    if (bodyFlow.is(FlowFlags.TERMINATES)) {\n      bodyStmts.push(\n        module.unreachable()\n      );\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n    // Terminate if condition is always true and body never breaks\n    } else if (condKind == ConditionKind.TRUE && !bodyFlow.isAny(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n      this.performAutoreleases(bodyFlow, bodyStmts);\n      bodyStmts.push(\n        module.br(continueLabel)\n      );\n      flow.set(FlowFlags.TERMINATES);\n\n    } else {\n      let breaks = bodyFlow.is(FlowFlags.BREAKS);\n      if (breaks) {\n        bodyStmts.push(\n          module.unreachable()\n        );\n      } else {\n        this.performAutoreleases(bodyFlow, bodyStmts);\n        bodyStmts.push(\n          module.br(continueLabel)\n        );\n      }\n      if (condKind == ConditionKind.TRUE) flow.inherit(bodyFlow);\n      else flow.inheritBranch(bodyFlow);\n\n      // Detect if local flags are incompatible before and after looping, and\n      // if so recompile by unifying local flags between iterations. Note that\n      // this may be necessary multiple times where locals depend on each other.\n      // Here: Only relevant if flow does not always break.\n      if (!breaks && Flow.hasIncompatibleLocalStates(flowBefore, flow)) {\n        flow.freeTempLocal(tcond);\n        outerFlow.popBreakLabel();\n        this.currentFlow = outerFlow;\n        return this.doCompileWhileStatement(statement, flow);\n      }\n    }\n    stmts.push(\n      module.if(module.local_get(tcond.index, NativeType.I32),\n        module.flatten(bodyStmts)\n      )\n    );\n    flow.freeTempLocal(tcond);\n    this.currentFlow = flow;\n\n    // Finalize\n    assert(!flow.hasScopedLocals);\n    outerFlow.inherit(flow);\n    outerFlow.popBreakLabel();\n    this.currentFlow = outerFlow;\n    var expr = module.block(breakLabel, [\n      module.loop(continueLabel,\n        module.flatten(stmts)\n      )\n    ]);\n    if (condKind == ConditionKind.TRUE && outerFlow.is(FlowFlags.TERMINATES)) {\n      expr = module.block(null, [ expr, module.unreachable() ]);\n    }\n    return expr;\n  }\n\n  // === Expressions ==============================================================================\n\n  /** Compiles the value of an inlined constant element. */\n  compileInlineConstant(\n    element: VariableLikeElement,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    assert(element.is(CommonFlags.INLINED | CommonFlags.RESOLVED));\n    var type = element.type;\n    switch (\n      !(constraints & (Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT)) &&\n      type.isIntegerValue &&\n      contextualType.isIntegerValue &&\n      type.size < contextualType.size\n        ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension\n        : (this.currentType = type).kind\n    ) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        let shift = type.computeSmallIntegerShift(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) << shift >> shift\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        let mask = element.type.computeSmallIntegerMask(Type.i32);\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue) & mask\n            : 0\n        ); // recognized by canOverflow\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return this.module.i32(\n          element.constantValueKind == ConstantValueKind.INTEGER\n            ? i64_low(element.constantIntegerValue)\n            : 0\n        );\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        if (!element.program.options.isWasm64) {\n          return this.module.i32(\n            element.constantValueKind == ConstantValueKind.INTEGER\n              ? i64_low(element.constantIntegerValue)\n              : 0\n          );\n        }\n        // fall-through\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return element.constantValueKind == ConstantValueKind.INTEGER\n          ? this.module.i64(\n              i64_low(element.constantIntegerValue),\n              i64_high(element.constantIntegerValue)\n            )\n          : this.module.i64(0);\n      }\n      case TypeKind.F64: {\n        // monkey-patch for converting built-in floats to f32 implicitly\n        if (!(element.hasDecorator(DecoratorFlags.BUILTIN) && contextualType == Type.f32)) {\n          return this.module.f64(element.constantFloatValue);\n        }\n        // otherwise fall-through: basically precomputes f32.demote/f64 of NaN / Infinity\n        this.currentType = Type.f32;\n      }\n      case TypeKind.F32: {\n        return this.module.f32(<f32>element.constantFloatValue);\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n  }\n\n  compileExpression(\n    expression: Expression,\n    contextualType: Type,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    while (expression.kind == NodeKind.PARENTHESIZED) { // skip\n      expression = (<ParenthesizedExpression>expression).expression;\n    }\n    this.currentType = contextualType;\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var expr: ExpressionRef;\n    switch (expression.kind) {\n      case NodeKind.ASSERTION: {\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.BINARY: {\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.CALL: {\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.COMMA: {\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType.signatureReference, constraints);\n        break;\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.THIS:\n      case NodeKind.SUPER:\n      case NodeKind.TRUE: {\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        expr = this.compileInstanceOfExpression(<InstanceOfExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.NEW: {\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType, constraints);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, constraints);\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    // ensure conversion and wrapping in case the respective function doesn't on its own\n    var currentType = this.currentType;\n    var wrap = (constraints & Constraints.MUST_WRAP) != 0;\n    if (currentType != contextualType.nonNullableType) { // allow assigning non-nullable to nullable\n      if (constraints & Constraints.CONV_EXPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, true, expression);\n        this.currentType = contextualType;\n      } else if (constraints & Constraints.CONV_IMPLICIT) {\n        expr = this.convertExpression(expr, currentType, contextualType, false, expression);\n        this.currentType = contextualType;\n      }\n    }\n    if (wrap) expr = this.ensureSmallIntegerWrap(expr, currentType);\n    // debug location is added here so the caller doesn't have to. means: compilation of an expression\n    // must go through this function, with the respective per-kind functions not being used directly.\n    if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n    return expr;\n  }\n\n  /** Compiles an expression that is about to be returned, taking special care of retaining and setting flow states. */\n  private compileReturnedExpression(\n    /** Expression to compile. */\n    expression: Expression,\n    /** Return type of the function. */\n    returnType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    // pretend to retain the expression immediately so the autorelease, if any, is skipped\n    var expr = this.compileExpression(expression, returnType, constraints | Constraints.WILL_RETAIN);\n    var flow = this.currentFlow;\n    if (returnType.isManaged) {\n      // check if that worked, and if it didn't, keep the reference alive\n      if (!this.skippedAutoreleases.has(expr)) {\n        let index = this.tryUndoAutorelease(expr, flow);\n        if (index == -1) expr = this.makeRetain(expr, returnType);\n        this.skippedAutoreleases.add(expr);\n      }\n    }\n    // remember return states\n    if (!flow.canOverflow(expr, returnType)) flow.set(FlowFlags.RETURNS_WRAPPED);\n    if (flow.isNonnull(expr, returnType)) flow.set(FlowFlags.RETURNS_NONNULL);\n    return expr;\n  }\n\n  /** Converts an expression's result from one type to another. */\n  convertExpression(\n    expr: ExpressionRef,\n    /** Original type. */\n    fromType: Type,\n    /** New type. */\n    toType: Type,\n    /** Whether the conversion is explicit. */\n    explicit: bool,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n\n    // void to any\n    if (fromType.kind == TypeKind.VOID) {\n      assert(toType.kind != TypeKind.VOID); // convertExpression should not be called with void -> void\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      return module.unreachable();\n    }\n\n    // any to void\n    if (toType.kind == TypeKind.VOID) return module.drop(expr);\n\n    // reference involved\n    if (fromType.isReference || toType.isReference) {\n      if (this.currentFlow.isNonnull(expr, fromType)) {\n        fromType = fromType.nonNullableType;\n      } else if (explicit && fromType.isNullableReference && !toType.isNullableReference) {\n        // explicit conversion from nullable to non-nullable requires a runtime\n        // check here because nonnull state above already didn't know better\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, fromType, reportNode);\n        }\n        fromType = fromType.nonNullableType;\n      }\n      if (fromType.isAssignableTo(toType)) { // downcast or same\n        assert(toType.isExternalReference || fromType.kind == toType.kind);\n        this.currentType = toType;\n        return expr;\n      }\n      if (explicit && toType.nonNullableType.isAssignableTo(fromType)) { // upcast\n        // <Cat | null>(<Animal>maybeCat)\n        if (toType.isExternalReference) {\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            reportNode.range,\n            \"ref.cast\"\n          );\n          this.currentType = toType;\n          return module.unreachable();\n        }\n        assert(fromType.kind == toType.kind);\n        if (!this.options.noAssert) {\n          expr = this.makeRuntimeUpcastCheck(expr, fromType, toType, reportNode);\n        }\n        this.currentType = toType;\n        return expr;\n      }\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        reportNode.range, fromType.toString(), toType.toString()\n      );\n      this.currentType = toType;\n      return module.unreachable();\n    }\n\n    // not dealing with references from here on\n    assert(!fromType.isReference && !toType.isReference);\n\n    if (!fromType.isAssignableTo(toType)) {\n      if (!explicit) {\n        this.error(\n          DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\n          reportNode.range, fromType.toString(), toType.toString()\n        ); // recoverable\n      }\n    }\n\n    if (fromType.isFloatValue) {\n\n      // float to float\n      if (toType.isFloatValue) {\n        if (fromType.kind == TypeKind.F32) {\n\n          // f32 to f64\n          if (toType.kind == TypeKind.F64) {\n            expr = module.unary(UnaryOp.PromoteF32, expr);\n          }\n\n          // otherwise f32 to f32\n\n        // f64 to f32\n        } else if (toType.kind == TypeKind.F32) {\n          expr = module.unary(UnaryOp.DemoteF64, expr);\n        }\n\n        // otherwise f64 to f64\n\n      // float to int\n      } else if (toType.isIntegerValue) {\n\n        // f32 to int\n        if (fromType.kind == TypeKind.F32) {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f32, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF32ToI64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF32ToI32, expr);\n            }\n          } else {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF32ToU64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF32ToU32, expr);\n            }\n          }\n\n        // f64 to int\n        } else {\n          if (toType.isBooleanValue) {\n            expr = this.makeIsTrueish(expr, Type.f64, reportNode);\n          } else if (toType.isSignedIntegerValue) {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF64ToI64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF64ToI32, expr);\n            }\n          } else {\n            if (toType.isLongIntegerValue) {\n              expr = module.unary(UnaryOp.TruncF64ToU64, expr);\n            } else {\n              expr = module.unary(UnaryOp.TruncF64ToU32, expr);\n            }\n          }\n        }\n\n      // float to void\n      } else {\n        assert(toType.flags == TypeFlags.NONE, \"void type expected\");\n        expr = module.drop(expr);\n      }\n\n    // int to float\n    } else if (fromType.isIntegerValue && toType.isFloatValue) {\n\n      // int to f32\n      if (toType.kind == TypeKind.F32) {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF32\n              : UnaryOp.ConvertU64ToF32,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF32\n              : UnaryOp.ConvertU32ToF32,\n            expr\n          );\n        }\n\n      // int to f64\n      } else {\n        if (fromType.isLongIntegerValue) {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI64ToF64\n              : UnaryOp.ConvertU64ToF64,\n            expr\n          );\n        } else {\n          expr = module.unary(\n            fromType.isSignedIntegerValue\n              ? UnaryOp.ConvertI32ToF64\n              : UnaryOp.ConvertU32ToF64,\n            expr\n          );\n        }\n      }\n\n    // int to int\n    } else {\n      // i64 to ...\n      if (fromType.isLongIntegerValue) {\n\n        // i64 to i32 or smaller\n        if (toType.isBooleanValue) {\n          expr = module.binary(BinaryOp.NeI64, expr, module.i64(0));\n        } else if (!toType.isLongIntegerValue) {\n          expr = module.unary(UnaryOp.WrapI64, expr); // discards upper bits\n        }\n\n      // i32 or smaller to i64\n      } else if (toType.isLongIntegerValue) {\n        expr = module.unary(\n          fromType.isSignedIntegerValue ? UnaryOp.ExtendI32 : UnaryOp.ExtendU32,\n          this.ensureSmallIntegerWrap(expr, fromType) // must clear garbage bits\n        );\n\n      // i32 to i32\n      } else {\n        // small i32 to ...\n        if (fromType.isShortIntegerValue) {\n          // small i32 to larger i32\n          if (fromType.size < toType.size) {\n            expr = this.ensureSmallIntegerWrap(expr, fromType); // must clear garbage bits\n          }\n        // same size\n        } else {\n          if (!explicit && !this.options.isWasm64 && fromType.isVaryingIntegerValue && !toType.isVaryingIntegerValue) {\n            this.warning(\n              DiagnosticCode.Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit,\n              reportNode.range, fromType.toString(), toType.toString()\n            );\n          }\n        }\n      }\n    }\n\n    this.currentType = toType;\n    return expr;\n  }\n\n  private compileAssertionExpression(\n    expression: AssertionExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var inheritedConstraints = constraints & ~(Constraints.CONV_IMPLICIT | Constraints.CONV_EXPLICIT);\n    switch (expression.assertionKind) {\n      case AssertionKind.PREFIX:\n      case AssertionKind.AS: {\n        let flow = this.currentFlow;\n        let toType = this.resolver.resolveType( // reports\n          assert(expression.toType),\n          flow.actualFunction,\n          uniqueMap(flow.contextualTypeArguments)\n        );\n        if (!toType) return this.module.unreachable();\n        return this.compileExpression(expression.expression, toType, inheritedConstraints | Constraints.CONV_EXPLICIT);\n      }\n      case AssertionKind.NONNULL: {\n        assert(!expression.toType);\n        let expr = this.compileExpression(expression.expression, contextualType.exceptVoid, inheritedConstraints);\n        let type = this.currentType;\n        if (this.currentFlow.isNonnull(expr, type)) {\n          this.info(\n            DiagnosticCode.Expression_is_never_null,\n            expression.expression.range\n          );\n        } else if (!this.options.noAssert) {\n          expr = this.makeRuntimeNonNullCheck(expr, type, expression);\n        }\n        this.currentType = type.nonNullableType;\n        return expr;\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let operand = expression.expression;\n        // if (operand.kind == NodeKind.LITERAL && (<LiteralExpression>operand).literalKind == LiteralKind.ARRAY) {\n        //   let element = this.resolver.lookupExpression(expression /* ! */, this.currentFlow, contextualType);\n        //   if (!element) return this.module.unreachable();\n        //   if (element.kind == ElementKind.CLASS) {\n        //     let arrayInstance = <Class>element;\n        //     if (arrayInstance.extends(this.program.readonlyArrayPrototype)) {\n        //       return this.compileStaticArrayLiteral(<ArrayLiteralExpression>operand, arrayInstance.type, constraints);\n        //     }\n        //   }\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Const assertion\"\n        );\n        return this.module.unreachable();\n      }\n      default: assert(false);\n    }\n    return this.module.unreachable();\n  }\n\n  private f32ModInstance: Function | null = null;\n  private f64ModInstance: Function | null = null;\n  private f32PowInstance: Function | null = null;\n  private f64PowInstance: Function | null = null;\n  private i32PowInstance: Function | null = null;\n  private i64PowInstance: Function | null = null;\n\n  private compileBinaryExpression(\n    expression: BinaryExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var left = expression.left;\n    var right = expression.right;\n\n    var leftExpr: ExpressionRef;\n    var leftType: Type;\n    var rightExpr: ExpressionRef;\n    var rightType: Type;\n    var commonType: Type | null;\n\n    var expr: ExpressionRef;\n    var compound = false;\n\n    var operator = expression.operator;\n    switch (operator) {\n      case Token.LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GT);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGt(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.LESSTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.LE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"<=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeLe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.GREATERTHAN_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.GE);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, true);\n        if (!commonType || !commonType.isNumericValue) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \">=\", leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeGe(leftExpr, rightExpr, commonType);\n        this.currentType = Type.bool;\n        break;\n      }\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EQUALS_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EQUALS_EQUALS) { // can't overload '==='\n          let classReference = leftType.getClassOrWrapper(this.program);\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.EQ);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeEq(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EXCLAMATION_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        if (operator == Token.EXCLAMATION_EQUALS) { // can't overload '!=='\n          let classReference = leftType.getClass();\n          if (classReference) {\n            let overload = classReference.lookupOverload(OperatorKind.NE);\n            if (overload) {\n              expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n              break;\n            }\n          }\n          // fall back to compare by value\n        }\n\n        rightExpr = this.compileExpression(right, leftType);\n        rightType = this.currentType;\n        commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, operatorTokenToString(expression.operator), leftType.toString(), rightType.toString()\n          );\n          this.currentType = contextualType;\n          return module.unreachable();\n        }\n\n        leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n        leftType = commonType;\n        rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n        rightType = commonType;\n\n        expr = this.makeNe(leftExpr, rightExpr, commonType, expression);\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.EQUALS: {\n        return this.compileAssignment(left, right, contextualType);\n      }\n      case Token.PLUS_EQUALS: compound = true;\n      case Token.PLUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.ADD);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"+\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"+\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAdd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.MINUS_EQUALS: compound = true;\n      case Token.MINUS: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.SUB);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"-\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeSub(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MUL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"*\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"*\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeMul(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.ASTERISK_ASTERISK_EQUALS: compound = true;\n      case Token.ASTERISK_ASTERISK: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POW);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"**\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"**\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makePow(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.SLASH_EQUALS: compound = true;\n      case Token.SLASH: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.DIV);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"/\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"/\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeDiv(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.PERCENT_EQUALS: compound = true;\n      case Token.PERCENT: {\n        leftExpr = this.compileExpression(left, contextualType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.REM);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isNumericValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"%\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isNumericValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"%\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeRem(leftExpr, rightExpr, commonType, expression);\n        break;\n      }\n      case Token.LESSTHAN_LESSTHAN_EQUALS: compound = true;\n      case Token.LESSTHAN_LESSTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHL);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"<<\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShl(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>\", leftType.toString()\n          );\n          return this.module.unreachable();\n        }\n\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShr(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: compound = true;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_SHR_U);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n        if (!leftType.isIntegerValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \">>>\", leftType.toString()\n          );\n          return module.unreachable();\n        }\n        rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n        rightType = this.currentType;\n\n        expr = this.makeShru(leftExpr, rightExpr, rightType);\n        break;\n      }\n      case Token.AMPERSAND_EQUALS: compound = true;\n      case Token.AMPERSAND: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overloadd\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_AND);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"&\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"&\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeAnd(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.BAR_EQUALS: compound = true;\n      case Token.BAR: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_OR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"|\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"|\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeOr(leftExpr, rightExpr, commonType);\n        break;\n      }\n      case Token.CARET_EQUALS: compound = true;\n      case Token.CARET: {\n        leftExpr = this.compileExpression(left, contextualType.intType);\n        leftType = this.currentType;\n\n        // check operator overload\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_XOR);\n          if (overload) {\n            expr = this.compileBinaryOverload(overload, left, leftExpr, right, expression);\n            break;\n          }\n        }\n\n        if (compound) {\n          if (!leftType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"^\", leftType.toString()\n            );\n            return module.unreachable();\n          }\n          rightExpr = this.compileExpression(right, leftType, Constraints.CONV_IMPLICIT);\n          rightType = commonType = this.currentType;\n        } else {\n          rightExpr = this.compileExpression(right, leftType);\n          rightType = this.currentType;\n          commonType = Type.commonDenominator(leftType, rightType, false);\n          if (!commonType || !commonType.isIntegerValue) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              expression.range, \"^\", leftType.toString(), rightType.toString()\n            );\n            this.currentType = contextualType;\n            return module.unreachable();\n          }\n          leftExpr = this.convertExpression(leftExpr, leftType, commonType, false, left);\n          leftType = commonType;\n          rightExpr = this.convertExpression(rightExpr, rightType, commonType, false, right);\n          rightType = commonType;\n        }\n        expr = this.makeXor(leftExpr, rightExpr, commonType);\n        break;\n      }\n\n      // logical (no overloading)\n\n      case Token.AMPERSAND_AMPERSAND: { // left && right -> (t = left) ? right : t\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & (Constraints.WILL_RETAIN | Constraints.MUST_WRAP);\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfTrue(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n          expr = module.if(\n            this.makeIsTrueish(leftExpr, leftType, left),\n            this.makeIsTrueish(rightExpr, rightType, right),\n            module.i32(0)\n          );\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n\n          // references must properly retain and release, with the same outcome independent of the branch taken\n          if (leftType.isManaged) {\n            let leftAutoreleaseSkipped = this.skippedAutoreleases.has(leftExpr);\n            let rightAutoreleaseSkipped = this.skippedAutoreleases.has(rightExpr);\n            let temp = flow.getTempLocal(leftType);\n            leftExpr = module.local_tee(temp.index, leftExpr);\n\n            // instead of retaining left and releasing it again in right when right\n            // is taken, we can also just retain left if right is not taken\n            let retainLeftInElse = false;\n            if (leftAutoreleaseSkipped != rightAutoreleaseSkipped) { // xor\n              if (!leftAutoreleaseSkipped) {\n                retainLeftInElse = true;\n              } else {\n                rightExpr = this.makeRetain(rightExpr, rightType);\n                rightAutoreleaseSkipped = true;\n              }\n            } else if (!(constraints & Constraints.WILL_RETAIN)) { // otherwise keep right alive a little longer\n              rightExpr = this.delayAutorelease(rightExpr, rightType, rightFlow, flow);\n            }\n\n            let rightStmts = new Array<ExpressionRef>();\n            if (leftAutoreleaseSkipped) { // left turned out to be true'ish and is dropped\n              rightStmts.unshift(\n                this.makeRelease(\n                  module.local_get(temp.index, leftType.toNativeType()),\n                  leftType\n                )\n              );\n            }\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType, rightStmts);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              rightExpr,\n              retainLeftInElse\n                ? this.makeRetain(\n                    module.local_get(temp.index, leftType.toNativeType()),\n                    leftType\n                  )\n                : module.local_get(temp.index, leftType.toNativeType())\n            );\n            if (leftAutoreleaseSkipped || rightAutoreleaseSkipped) this.skippedAutoreleases.add(expr);\n            if (temp) flow.freeTempLocal(temp);\n\n          // basic values can use more aggressive optimizations\n          } else {\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            // simplify if cloning left without side effects is possible\n            if (expr = module.cloneExpression(leftExpr, true, 0)) {\n              expr = module.if(\n                this.makeIsTrueish(leftExpr, this.currentType, left),\n                rightExpr,\n                expr\n              );\n\n            // if not possible, tee left to a temp\n            } else {\n              let tempLocal = flow.getTempLocal(leftType);\n              if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.WRAPPED);\n              if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(tempLocal.index, LocalFlags.NONNULL);\n              expr = module.if(\n                this.makeIsTrueish(module.local_tee(tempLocal.index, leftExpr), leftType, left),\n                rightExpr,\n                module.local_get(tempLocal.index, leftType.toNativeType())\n              );\n              flow.freeTempLocal(tempLocal);\n            }\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      case Token.BAR_BAR: { // left || right -> ((t = left) ? t : right)\n        let flow = this.currentFlow;\n        let inheritedConstraints = constraints & (Constraints.WILL_RETAIN | Constraints.MUST_WRAP);\n        leftExpr = this.compileExpression(left, contextualType.exceptVoid, inheritedConstraints);\n        leftType = this.currentType;\n\n        let rightFlow = flow.fork();\n        this.currentFlow = rightFlow;\n        rightFlow.inheritNonnullIfFalse(leftExpr);\n\n        // simplify if only interested in true or false\n        if (contextualType == Type.bool || contextualType == Type.void) {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints);\n          rightType = this.currentType;\n          rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, leftType);\n          rightFlow.freeScopedLocals();\n          this.currentFlow = flow;\n          expr = module.if(\n            this.makeIsTrueish(leftExpr, leftType, left),\n            module.i32(1),\n            this.makeIsTrueish(rightExpr, rightType, right)\n          );\n          this.currentType = Type.bool;\n\n        } else {\n          rightExpr = this.compileExpression(right, leftType, inheritedConstraints | Constraints.CONV_IMPLICIT);\n          rightType = this.currentType;\n\n          // references must properly retain and release, with the same outcome independent of the branch taken\n          if (leftType.isManaged) {\n            let leftAutoreleaseSkipped = this.skippedAutoreleases.has(leftExpr);\n            let rightAutoreleaseSkipped = this.skippedAutoreleases.has(rightExpr);\n            let temp = flow.getTempLocal(leftType);\n            leftExpr = module.local_tee(temp.index, leftExpr);\n\n            // instead of retaining left and releasing it again in right when right\n            // is taken, we can also just retain left if right is not taken\n            let retainLeftInThen = false;\n            if (leftAutoreleaseSkipped != rightAutoreleaseSkipped) { // xor\n              if (!leftAutoreleaseSkipped) {\n                retainLeftInThen = true;\n              } else {\n                rightExpr = this.makeRetain(rightExpr, rightType);\n                rightAutoreleaseSkipped = true;\n              }\n            } else if (!(constraints & Constraints.WILL_RETAIN)) { // otherwise keep right alive a little longer\n              rightExpr = this.delayAutorelease(rightExpr, rightType, rightFlow, flow);\n            }\n\n            let rightStmts = new Array<ExpressionRef>();\n            if (leftAutoreleaseSkipped) { // left turned out to be false'ish and is dropped\n              // TODO: usually, false'ish means left is null, but this might not hold\n              // once implicit conversion with strings is performed and left is \"\", so:\n              rightStmts.unshift(\n                this.makeRelease(\n                  module.local_get(temp.index, leftType.toNativeType()),\n                  leftType\n                )\n              );\n            }\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType, rightStmts);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            expr = module.if(\n              this.makeIsTrueish(leftExpr, leftType, left),\n              retainLeftInThen\n                ? this.makeRetain(\n                    module.local_get(temp.index, leftType.toNativeType()),\n                    leftType\n                  )\n                : module.local_get(temp.index, leftType.toNativeType()),\n              rightExpr\n            );\n            if (leftAutoreleaseSkipped || rightAutoreleaseSkipped) this.skippedAutoreleases.add(expr);\n            if (temp) flow.freeTempLocal(temp);\n\n          // basic values can use more aggressive optimizations\n          } else {\n            rightExpr = this.performAutoreleasesWithValue(rightFlow, rightExpr, rightType);\n            rightFlow.freeScopedLocals();\n            this.currentFlow = flow;\n\n            // simplify if cloning left without side effects is possible\n            if (expr = module.cloneExpression(leftExpr, true, 0)) {\n              expr = module.if(\n                this.makeIsTrueish(leftExpr, leftType, left),\n                expr,\n                rightExpr\n              );\n\n            // if not possible, tee left to a temp. local\n            } else {\n              let temp = flow.getTempLocal(leftType);\n              if (!flow.canOverflow(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n              if (flow.isNonnull(leftExpr, leftType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n              expr = module.if(\n                this.makeIsTrueish(module.local_tee(temp.index, leftExpr), leftType, left),\n                module.local_get(temp.index, leftType.toNativeType()),\n                rightExpr\n              );\n              flow.freeTempLocal(temp);\n            }\n          }\n          this.currentType = leftType;\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        expr = this.module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(left, this.currentFlow);\n    if (!target) return module.unreachable();\n    var targetType = resolver.getTypeOfElement(target);\n    if (!targetType) targetType = Type.void;\n    if (!this.currentType.isStrictlyAssignableTo(targetType)) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, this.currentType.toString(), targetType.toString()\n      );\n      return module.unreachable();\n    }\n    return this.makeAssignment(\n      target,\n      expr, // TODO: delay release above if possible?\n      this.currentType,\n      right,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  makeLt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtI64\n            : BinaryOp.LtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LtU64\n            : BinaryOp.LtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGt(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GtI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtI64\n            : BinaryOp.GtI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GtI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GtU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GtU64\n            : BinaryOp.GtU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GtU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GtF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GtF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeLe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.LeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeI64\n            : BinaryOp.LeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.LeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.LeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.LeU64\n            : BinaryOp.LeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.LeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.LeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.LeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeGe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.GeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeI64\n            : BinaryOp.GeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.GeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.GeU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.GeU64\n            : BinaryOp.GeU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.GeU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.GeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.GeF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeEq(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.EqI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.EqI64\n            : BinaryOp.EqI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.EqI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.EqF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.EqF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AllTrueI8x16,\n          module.binary(BinaryOp.EqI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeNe(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.NeI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.NeF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.NeF64, leftExpr, rightExpr);\n      }\n      case TypeKind.V128: {\n        return module.unary(UnaryOp.AnyTrueI8x16,\n          module.binary(BinaryOp.NeI8x16, leftExpr, rightExpr)\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF: {\n        this.error(\n          DiagnosticCode.Operation_0_cannot_be_applied_to_type_1,\n          reportNode.range,\n          \"ref.eq\",\n          type.toString()\n        );\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAdd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AddI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AddI64\n            : BinaryOp.AddI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AddI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.AddF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.AddF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeSub(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.SubI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.SubI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.SubF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.SubF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeMul(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.MulI32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.MulI64\n            : BinaryOp.MulI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.MulI64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.MulF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.MulF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makePow(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits\n    let module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: {\n        return module.select(\n          module.i32(1),\n          module.binary(BinaryOp.EqI32, rightExpr, module.i32(0)),\n          leftExpr\n        );\n      }\n      case TypeKind.I8:\n      case TypeKind.U8:\n      case TypeKind.I16:\n      case TypeKind.U16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        let instance = this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookupGlobal(CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        let expr = this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n        if (type.size < 32) {\n          // TODO: this is necessary because i32PowInstance is generic, and deals with 32-bit integers,\n          // so its flow does not indicate whether returned SMIs are wrapped. worth to avoid?\n          expr = this.ensureSmallIntegerWrap(expr, type);\n        }\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        let instance = this.i64PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookupGlobal(CommonNames.ipow64);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"ipow64\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.i64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        let isWasm64 = this.options.isWasm64;\n        let instance = isWasm64 ? this.i64PowInstance : this.i32PowInstance;\n        if (!instance) {\n          let prototype = this.program.lookupGlobal(isWasm64 ? CommonNames.ipow64 : CommonNames.ipow32);\n          if (!prototype) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, isWasm64 ? \"ipow64\" : \"ipow32\"\n            );\n            return module.unreachable();\n          }\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n          if (isWasm64) {\n            this.i64PowInstance = instance;\n          } else {\n            this.i32PowInstance = instance;\n          }\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      // Math.pow otherwise (result is f64)\n      case TypeKind.F64: {\n        let instance = this.f64PowInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.pow)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.pow\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.pow));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64PowInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeDiv(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.DivI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivI64\n            : BinaryOp.DivI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.DivI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.DivU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.DivU64\n            : BinaryOp.DivU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.DivU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        return module.binary(BinaryOp.DivF32, leftExpr, rightExpr);\n      }\n      case TypeKind.F64: {\n        return module.binary(BinaryOp.DivF64, leftExpr, rightExpr);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeRem(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    // Cares about garbage bits and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.RemI32, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemI64\n            : BinaryOp.RemI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.RemI64, leftExpr, rightExpr);\n      }\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        leftExpr = this.ensureSmallIntegerWrap(leftExpr, type);\n        rightExpr = this.ensureSmallIntegerWrap(rightExpr, type);\n        // falls through\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.RemU32, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.RemU64\n            : BinaryOp.RemU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.RemU64, leftExpr, rightExpr);\n      }\n      case TypeKind.F32: {\n        let instance = this.f32ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Mathf);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Mathf.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f32ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n      case TypeKind.F64: {\n        let instance = this.f64ModInstance;\n        if (!instance) {\n          let namespace = this.program.lookupGlobal(CommonNames.Math);\n          if (!namespace) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math\"\n            );\n            return module.unreachable();\n          }\n          let namespaceMembers = namespace.members;\n          if (!namespaceMembers || !namespaceMembers.has(CommonNames.mod)) {\n            this.error(\n              DiagnosticCode.Cannot_find_name_0,\n              reportNode.range, \"Math.mod\"\n            );\n            return module.unreachable();\n          }\n          let prototype = assert(namespaceMembers.get(CommonNames.mod));\n          assert(prototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          this.f64ModInstance = instance = this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n        }\n        if (!instance || !this.compileFunction(instance)) {\n          return module.unreachable();\n        }\n        return this.makeCallDirect(instance, [ leftExpr, rightExpr ], reportNode);\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShl(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the RHS, but only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr << (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShlI32,\n          leftExpr,\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShlI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShlI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShlI64\n            : BinaryOp.ShlI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits,\n    // and signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16: {\n        // leftExpr >> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrI32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32: {\n        return module.binary(BinaryOp.ShrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64: {\n        return module.binary(BinaryOp.ShrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrI64\n            : BinaryOp.ShrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeShru(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Cares about garbage bits on the LHS, but on the RHS only for types smaller than 5 bits\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.BOOL: return leftExpr;\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        // leftExpr >>> (rightExpr & (7|15))\n        return module.binary(\n          BinaryOp.ShrU32,\n          this.ensureSmallIntegerWrap(leftExpr, type),\n          module.binary(BinaryOp.AndI32, rightExpr, module.i32(type.size - 1))\n        );\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.ShrU32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.ShrU64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.ShrU64\n            : BinaryOp.ShrU32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeAnd(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.AndI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.AndI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.AndI64\n            : BinaryOp.AndI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeOr(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.OrI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.OrI64, leftExpr, rightExpr);\n      }\n      case TypeKind.USIZE:\n      case TypeKind.ISIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.OrI64\n            : BinaryOp.OrI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  makeXor(leftExpr: ExpressionRef, rightExpr: ExpressionRef, type: Type): ExpressionRef {\n    // Does not care about garbage bits or signedness\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.BOOL: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return module.binary(BinaryOp.XorI32, leftExpr, rightExpr);\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.XorI64, leftExpr, rightExpr);\n      }\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: {\n        return module.binary(\n          this.options.isWasm64\n            ? BinaryOp.XorI64\n            : BinaryOp.XorI32,\n          leftExpr,\n          rightExpr\n        );\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileUnaryOverload(\n    operatorInstance: Function,\n    value: Expression,\n    valueExpr: ExpressionRef,\n    reportNode: Node\n  ): ExpressionRef {\n    // FIXME: see comment in compileBinaryOverload below why recompiling on type mismatch\n    // is a bad idea currently. so this assumes that the type matches.\n    return this.makeCallDirect(operatorInstance, [ valueExpr ], reportNode, false);\n  }\n\n  private compileBinaryOverload(\n    operatorInstance: Function,\n    left: Expression,\n    leftExpr: ExpressionRef,\n    right: Expression,\n    reportNode: Node\n  ): ExpressionRef {\n    var rightType: Type;\n    if (operatorInstance.is(CommonFlags.INSTANCE)) {\n      let classInstance = assert(operatorInstance.parent); assert(classInstance.kind == ElementKind.CLASS);\n      rightType = operatorInstance.signature.parameterTypes[0];\n    } else {\n      // FIXME: if LHS type differs we can't recompile left because that'd completely confuse\n      // local states, like having retained locals that actually do not even exist, possibly\n      // releasing something random in that local before and evil things like that. Hence this\n      // assumes that LHS type matches, which in turn means that static overloads must be\n      // guaranteed to never mismatch LHS type, which in turn means that we can't have shiny\n      // things like multiple static overloads for different combinations of LHS/RHS types.\n      // We might want that at some point of course, but requires to complete the resolver so\n      // it can actually resolve every kind of expression without ever having to recompile.\n      rightType = operatorInstance.signature.parameterTypes[1];\n    }\n    var rightExpr = this.compileExpression(right, rightType, Constraints.CONV_IMPLICIT);\n    return this.makeCallDirect(operatorInstance, [ leftExpr, rightExpr ], reportNode);\n  }\n\n  private compileAssignment(\n    expression: Expression,\n    valueExpression: Expression,\n    contextualType: Type\n  ): ExpressionRef {\n    var program = this.program;\n    var resolver = program.resolver;\n    var flow = this.currentFlow;\n    var target = resolver.lookupExpression(expression, flow); // reports\n    if (!target) return this.module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    var elementExpression = resolver.currentElementExpression;\n\n    // to compile just the value, we need to know the target's type\n    var targetType: Type;\n    switch (target.kind) {\n      case ElementKind.GLOBAL: {\n        // not yet compiled if a static field compiled as a global\n        if (!this.compileGlobal(<Global>target)) return this.module.unreachable(); // reports\n        // fall-through\n      }\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        if (this.pendingElements.has(target)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            target.internalName\n          );\n          return this.module.unreachable();\n        }\n        targetType = (<VariableLikeElement>target).type;\n        if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return this.module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            expression.range, propertyInstance.internalName\n          );\n          return this.module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1); // parser must guarantee this\n        targetType = setterInstance.signature.parameterTypes[0];\n        if (setterInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let parent = (<IndexSignature>target).parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedSet = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!indexedSet) {\n          let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n          if (!indexedGet) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              expression.range, classInstance.internalName\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n              expression.range, classInstance.internalName\n            );\n          }\n          return this.module.unreachable();\n        }\n        assert(indexedSet.signature.parameterTypes.length == 2); // parser must guarantee this\n        targetType = indexedSet.signature.parameterTypes[1];     // 2nd parameter is the element\n        if (indexedSet.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n        if (!isUnchecked && this.options.pedantic) {\n          this.pedantic(\n            DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n            expression.range\n          );\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return this.module.unreachable();\n      }\n    }\n\n    // compile the value and do the assignment\n    assert(targetType != Type.void);\n    var valueExpr = this.compileExpression(valueExpression, targetType, Constraints.WILL_RETAIN);\n    var valueType = this.currentType;\n    return this.makeAssignment(\n      target,\n      this.convertExpression(valueExpr, valueType, targetType, false, valueExpression),\n      valueType,\n      valueExpression,\n      thisExpression,\n      elementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  /** Makes an assignment expression or block, assigning a value to a target. */\n  makeAssignment(\n    /** Target element, e.g. a Local. */\n    target: Element,\n    /** Value expression that has been compiled in a previous step already. */\n    valueExpr: ExpressionRef,\n    /** Value expression type. */\n    valueType: Type,\n    /** Expression reference. Has already been compiled to `valueExpr`. */\n    valueExpression: Expression,\n    /** `this` expression reference if a field or property set. */\n    thisExpression: Expression | null,\n    /** Index expression reference if an indexed set. */\n    indexExpression: Expression | null,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // NOTE: Only locals, globals and fields can make use of skipped autoreleases while\n    // everything else must insert the skipped autorelease now. See (*)\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        if (flow.isLocalFlag(local.index, LocalFlags.CONSTANT, true)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          this.currentType = tee ? local.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeLocalAssignment(local, valueExpr, valueType, tee);\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable();\n        if (target.isAny(CommonFlags.CONST | CommonFlags.READONLY)) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range,\n            target.internalName\n          );\n          this.currentType = tee ? global.type : Type.void;\n          return module.unreachable();\n        }\n        return this.makeGlobalAssignment(global, valueExpr, valueType, tee);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let initializerNode = fieldInstance.initializerNode;\n        let isConstructor = flow.actualFunction.is(CommonFlags.CONSTRUCTOR);\n\n        // Cannot assign to readonly fields except in constructors if there's no initializer\n        if (fieldInstance.is(CommonFlags.READONLY)) {\n          if (!isConstructor || initializerNode !== null) {\n            this.error(\n              DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n              valueExpression.range, fieldInstance.internalName\n            );\n            return module.unreachable();\n          }\n        }\n\n        // Mark initialized fields in constructors\n        thisExpression = assert(thisExpression);\n        if (isConstructor && thisExpression.kind == NodeKind.THIS) {\n          flow.setThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED);\n        }\n\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        return this.makeFieldAssignment(fieldInstance,\n          valueExpr,\n          valueType,\n          this.compileExpression(\n            thisExpression,\n            (<Class>fieldParent).type,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          ),\n          tee\n        );\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let setterInstance = propertyInstance.setterInstance;\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\n            valueExpression.range, target.internalName\n          );\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 1);\n        let valueType = setterInstance.signature.parameterTypes[0];\n        if (this.skippedAutoreleases.has(valueExpr)) valueExpr = this.makeAutorelease(valueExpr, valueType, flow); // (*)\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          let thisType = assert(setterInstance.signature.thisType);\n          let thisExpr = this.compileExpression(\n            assert(thisExpression),\n            thisType,\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n          if (!tee) return this.makeCallDirect(setterInstance, [ thisExpr, valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          assert(getterInstance.signature.thisType == thisType);\n          let returnType = getterInstance.signature.returnType;\n          let nativeReturnType = returnType.toNativeType();\n          let tempThis = flow.getTempLocal(returnType);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempThis.index, thisExpr),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempThis.index, nativeReturnType)\n            ], valueExpression)\n          ], nativeReturnType);\n          flow.freeTempLocal(tempThis);\n          return ret;\n        } else {\n          if (!tee) return this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression);\n          let getterInstance = assert((<Property>target).getterInstance);\n          return module.block(null, [\n            this.makeCallDirect(setterInstance, [ valueExpr ], valueExpression),\n            this.makeCallDirect(getterInstance, null, valueExpression)\n          ], getterInstance.signature.returnType.toNativeType());\n        }\n      }\n      case ElementKind.INDEXSIGNATURE: {\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        assert(classInstance.kind == ElementKind.CLASS);\n        let isUnchecked = flow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let getterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (!getterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_is_missing_in_type_0,\n            valueExpression.range, classInstance.internalName\n          );\n          return module.unreachable();\n        }\n        let setterInstance = classInstance.lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n        if (!setterInstance) {\n          this.error(\n            DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n            valueExpression.range, classInstance.internalName\n          );\n          this.currentType = tee ? getterInstance.signature.returnType : Type.void;\n          return module.unreachable();\n        }\n        assert(setterInstance.signature.parameterTypes.length == 2);\n        let valueType = setterInstance.signature.parameterTypes[1];\n        if (this.skippedAutoreleases.has(valueExpr)) valueExpr = this.makeAutorelease(valueExpr, valueType, flow); // (*)\n        let thisExpr = this.compileExpression(\n          assert(thisExpression),\n          classInstance.type,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let elementExpr = this.compileExpression(assert(indexExpression), Type.i32, Constraints.CONV_IMPLICIT);\n        if (tee) {\n          let tempTarget = flow.getTempLocal(classInstance.type);\n          let tempElement = flow.getTempLocal(this.currentType);\n          let returnType = getterInstance.signature.returnType;\n          flow.freeTempLocal(tempTarget);\n          let ret = module.block(null, [\n            this.makeCallDirect(setterInstance, [\n              module.local_tee(tempTarget.index, thisExpr),\n              module.local_tee(tempElement.index, elementExpr),\n              valueExpr\n            ], valueExpression),\n            this.makeCallDirect(getterInstance, [\n              module.local_get(tempTarget.index, tempTarget.type.toNativeType()),\n              module.local_get(tempElement.index, tempElement.type.toNativeType())\n            ], valueExpression)\n          ], returnType.toNativeType());\n          flow.freeTempLocal(tempElement);\n          flow.freeTempLocal(tempTarget);\n          return ret;\n        } else {\n          return this.makeCallDirect(setterInstance, [\n            thisExpr,\n            elementExpr,\n            valueExpr\n          ], valueExpression);\n        }\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  /** Makes an assignment to a local, possibly retaining and releasing affected references and keeping track of wrap and null states. */\n  private makeLocalAssignment(\n    /** Local to assign to. */\n    local: Local,\n    /** Value to assign. */\n    valueExpr: ExpressionRef,\n    /** Value type. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var type = local.type;\n    assert(type != Type.void);\n    var localIndex = local.index;\n\n    if (type.isNullableReference) {\n      if (!valueType.isNullableReference || flow.isNonnull(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.NONNULL);\n      else flow.unsetLocalFlag(localIndex, LocalFlags.NONNULL);\n    }\n    flow.setLocalFlag(localIndex, LocalFlags.INITIALIZED);\n\n    if (type.isManaged) {\n      let alreadyRetained = this.skippedAutoreleases.has(valueExpr);\n      if (flow.isAnyLocalFlag(localIndex, LocalFlags.ANY_RETAINED)) {\n        valueExpr = this.makeReplace(\n          valueExpr,\n          valueType,\n          module.local_get(localIndex, type.toNativeType()),\n          type,\n          alreadyRetained\n        );\n        if (tee) { // local = REPLACE(local, value)\n          this.currentType = type;\n          return module.local_tee(localIndex, valueExpr);\n        } else { // void(local = REPLACE(local, value))\n          this.currentType = Type.void;\n          return module.local_set(localIndex, valueExpr);\n        }\n      } else {\n        flow.unsetLocalFlag(localIndex, LocalFlags.CONDITIONALLY_RETAINED);\n        flow.setLocalFlag(localIndex, LocalFlags.RETAINED);\n        if (!alreadyRetained) valueExpr = this.makeRetain(valueExpr, valueType);\n        if (tee) { // local = __retain(value, local)\n          this.currentType = type;\n          return module.local_tee(localIndex, valueExpr);\n        } else { // void(local = __retain(value, local))\n          this.currentType = Type.void;\n          return module.local_set(localIndex, valueExpr);\n        }\n      }\n    } else {\n      if (type.isShortIntegerValue) {\n        if (!flow.canOverflow(valueExpr, type)) flow.setLocalFlag(localIndex, LocalFlags.WRAPPED);\n        else flow.unsetLocalFlag(localIndex, LocalFlags.WRAPPED);\n      }\n      if (tee) { // local = value\n        this.currentType = type;\n        return module.local_tee(localIndex, valueExpr);\n      } else { // void(local = value)\n        this.currentType = Type.void;\n        return module.local_set(localIndex, valueExpr);\n      }\n    }\n  }\n\n  /** Makes an assignment to a global, possibly retaining and releasing affected references. */\n  private makeGlobalAssignment(\n    /** The global variable to assign to. */\n    global: VariableLikeElement,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var type = global.type;\n    assert(type != Type.void);\n    var nativeType = type.toNativeType();\n\n    if (type.isManaged) {\n      let alreadyRetained = this.skippedAutoreleases.has(valueExpr);\n      valueExpr = module.global_set(global.internalName,\n        this.makeReplace(\n          valueExpr,\n          valueType,\n          module.global_get(global.internalName, nativeType),\n          type,\n          alreadyRetained\n        )\n      );\n      if (tee) { // (global = REPLACE(global, value))), global\n        this.currentType = type;\n        return module.block(null, [\n          valueExpr,\n          module.global_get(global.internalName, nativeType)\n        ], nativeType);\n      } else { // global = REPLACE(global, value)\n        this.currentType = Type.void;\n        return valueExpr;\n      }\n    } else {\n      valueExpr = this.ensureSmallIntegerWrap(valueExpr, type); // globals must be wrapped\n      if (tee) { // (global = value), global\n        this.currentType = type;\n        return module.block(null, [\n          module.global_set(global.internalName, valueExpr),\n          module.global_get(global.internalName, nativeType)\n        ], nativeType);\n      } else { // global = value\n        this.currentType = Type.void;\n        return module.global_set(global.internalName,\n          valueExpr\n        );\n      }\n    }\n  }\n\n  /** Makes an assignment to a field, possibly retaining and releasing affected references. */\n  private makeFieldAssignment(\n    /** The field to assign to. */\n    field: Field,\n    /** The value to assign. */\n    valueExpr: ExpressionRef,\n    /** The type of the value to assign. */\n    valueType: Type,\n    /** The value of `this`. */\n    thisExpr: ExpressionRef,\n    /** Whether to tee the value. */\n    tee: bool\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var fieldType = field.type;\n    var nativeFieldType = fieldType.toNativeType();\n    assert(field.parent.kind == ElementKind.CLASS);\n    var thisType = (<Class>field.parent).type;\n    var nativeThisType = thisType.toNativeType();\n\n    if (!field.is(CommonFlags.COMPILED)) {\n      field.set(CommonFlags.COMPILED);\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(field.type, typeNode);\n    }\n\n    if (fieldType.isManaged && thisType.isManaged) {\n      let tempThis = flow.getTempLocal(thisType, findUsedLocals(valueExpr));\n      // set before and read after valueExpr executes below ^\n      let alreadyRetained = this.skippedAutoreleases.has(valueExpr);\n      let ret: ExpressionRef;\n      if (tee) { // ((t1 = this).field = REPLACE(t1.field, t2 = value)), t2\n        let tempValue = flow.getTempLocal(fieldType);\n        if (!flow.canOverflow(valueExpr, fieldType)) flow.setLocalFlag(tempValue.index, LocalFlags.WRAPPED);\n        if (flow.isNonnull(valueExpr, fieldType)) flow.setLocalFlag(tempValue.index, LocalFlags.NONNULL);\n        ret = module.block(null, [\n          module.store(fieldType.byteSize,\n            module.local_tee(tempThis.index, thisExpr),\n            this.makeReplace(\n              module.local_tee(tempValue.index, valueExpr),\n              valueType,\n              module.load(fieldType.byteSize, fieldType.isSignedIntegerValue,\n                module.local_get(tempThis.index, nativeThisType),\n                nativeFieldType, field.memoryOffset\n              ),\n              fieldType,\n              alreadyRetained\n            ),\n            nativeFieldType, field.memoryOffset\n          ),\n          module.local_get(tempValue.index, nativeFieldType)\n        ], nativeFieldType);\n        flow.freeTempLocal(tempValue);\n        this.currentType = fieldType;\n      } else { // (t1 = this).field = REPLACE(t1.field, value)\n        ret = module.store(fieldType.byteSize,\n          module.local_tee(tempThis.index, thisExpr),\n          this.makeReplace(\n            valueExpr,\n            valueType,\n            module.load(fieldType.byteSize, fieldType.isSignedIntegerValue,\n              module.local_get(tempThis.index, nativeThisType),\n              nativeFieldType, field.memoryOffset\n            ),\n            fieldType,\n            alreadyRetained\n          ),\n          nativeFieldType, field.memoryOffset\n        );\n        this.currentType = Type.void;\n      }\n      flow.freeTempLocal(tempThis);\n      return ret;\n    } else {\n      if (tee) { // (this.field = (t1 = value)), t1\n        let temp = flow.getTempLocal(fieldType);\n        if (!flow.canOverflow(valueExpr, fieldType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n        if (flow.isNonnull(valueExpr, fieldType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n        let ret = module.block(null, [\n          module.store(fieldType.byteSize,\n            thisExpr,\n            module.local_tee(temp.index, valueExpr),\n            nativeFieldType, field.memoryOffset\n          ),\n          module.local_get(temp.index, nativeFieldType)\n        ], nativeFieldType);\n        flow.freeTempLocal(temp);\n        this.currentType = fieldType;\n        return ret;\n      } else { // this.field = value\n        this.currentType = Type.void;\n        return module.store(fieldType.byteSize,\n          thisExpr,\n          valueExpr,\n          nativeFieldType, field.memoryOffset\n        );\n      }\n    }\n  }\n\n  /** Compiles a call expression according to the specified context. */\n  private compileCallExpression(\n    /** Call expression to compile. */\n    expression: CallExpression,\n    /** Contextual type indicating the return type the caller expects, if any. */\n    contextualType: Type,\n    /** Constraints indicating contextual conditions. */\n    constraints: Constraints\n  ): ExpressionRef {\n\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // handle call to super\n    if (expression.expression.kind == NodeKind.SUPER) {\n      let flow = this.currentFlow;\n      let actualFunction = flow.actualFunction;\n      if (!actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n        this.error(\n          DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors,\n          expression.range\n        );\n        return module.unreachable();\n      }\n\n      let parent = assert(actualFunction.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let baseClassInstance = assert(classInstance.base);\n      let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n      let nativeSizeType = this.options.nativeSizeType;\n\n      let baseCtorInstance = this.ensureConstructor(baseClassInstance, expression);\n      this.checkFieldInitialization(baseClassInstance, expression);\n      let superCall = this.compileCallDirect(\n        baseCtorInstance,\n        expression.args,\n        expression,\n        module.local_get(thisLocal.index, nativeSizeType),\n        Constraints.WILL_RETAIN\n      );\n      assert(baseClassInstance.type.isUnmanaged || this.skippedAutoreleases.has(superCall)); // guaranteed\n\n      // check that super had been called before accessing `this`\n      if (flow.isAny(\n        FlowFlags.ACCESSES_THIS |\n        FlowFlags.CONDITIONALLY_ACCESSES_THIS\n      )) {\n        this.error(\n          DiagnosticCode._super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class,\n          expression.range\n        );\n        return module.unreachable();\n      }\n      flow.set(FlowFlags.ACCESSES_THIS | FlowFlags.CALLS_SUPER);\n      this.currentType = Type.void;\n      return module.local_set(thisLocal.index, superCall);\n    }\n\n    // otherwise resolve normally\n    var target = this.resolver.lookupExpression(expression.expression, flow); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = this.resolver.currentThisExpression;\n\n    var signature: Signature | null;\n    var indexArg: ExpressionRef;\n    switch (target.kind) {\n\n      // direct call: concrete function\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        if (functionPrototype.hasDecorator(DecoratorFlags.BUILTIN)) {\n          // builtins handle present respectively omitted type arguments on their own\n          return this.compileCallExpressionBuiltin(functionPrototype, expression, contextualType);\n        }\n        let functionInstance = this.resolver.maybeInferCall(expression, functionPrototype, flow);\n        if (!functionInstance) return this.module.unreachable();\n        target = functionInstance;\n        // fall-through\n      }\n      case ElementKind.FUNCTION: {\n        let functionInstance = <Function>target;\n        let thisArg: ExpressionRef = 0;\n        if (functionInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(functionInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(\n          functionInstance,\n          expression.args,\n          expression,\n          thisArg,\n          constraints\n        );\n      }\n\n      // indirect call: index argument with signature (non-generic, can't be inlined)\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        signature = local.type.signatureReference;\n        if (signature) {\n          if (local.is(CommonFlags.INLINED)) {\n            indexArg = module.i32(i64_low(local.constantIntegerValue));\n          } else {\n            indexArg = module.local_get(local.index, NativeType.I32);\n          }\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, local.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        signature = global.type.signatureReference;\n        if (signature) {\n          indexArg = module.global_get(global.internalName, global.type.toNativeType());\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, global.type.toString()\n        );\n        return module.unreachable();\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        signature = fieldType.signatureReference;\n        if (signature) {\n          let fieldParent = fieldInstance.parent;\n          assert(fieldParent.kind == ElementKind.CLASS);\n          indexArg = module.load(4, false,\n            this.compileExpression(\n              assert(thisExpression),\n              (<Class>fieldParent).type,\n              Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n            ),\n            NativeType.I32,\n            fieldInstance.memoryOffset\n          );\n          break;\n        }\n        this.error(\n          DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n          expression.range, fieldType.toString()\n        );\n        return module.unreachable();\n      }\n\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = this.resolver.resolveProperty(<PropertyPrototype>target);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance);\n        let thisArg: ExpressionRef = 0;\n        if (propertyInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        indexArg = this.compileCallDirect(getterInstance, [], expression.expression, thisArg);\n        signature = this.currentType.signatureReference;\n        if (!signature) {\n          this.error(\n            DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n            expression.range, this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n        break;\n      }\n      case ElementKind.CLASS: {\n        let classInstance = <Class>target;\n        let typeArguments = classInstance.getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          signature = ftype.getSignature();\n          indexArg = this.compileExpression(expression.expression, ftype, Constraints.CONV_IMPLICIT);\n          break;\n        }\n        // fall-through\n      }\n\n      // not supported\n      default: {\n        let type = this.resolver.getTypeOfElement(target);\n        if (type) {\n          this.error(\n            DiagnosticCode.Type_0_has_no_call_signatures,\n            expression.range, type.toString()\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n            expression.range\n          );\n        }\n        return module.unreachable();\n      }\n    }\n    return this.compileCallIndirect(\n      assert(signature), // FIXME: bootstrap can't see this yet\n      indexArg,\n      expression.args,\n      expression,\n      0,\n      contextualType == Type.void\n    );\n  }\n\n  private compileCallExpressionBuiltin(\n    prototype: FunctionPrototype,\n    expression: CallExpression,\n    contextualType: Type\n  ): ExpressionRef {\n    if (prototype.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    var typeArguments: Type[] | null = null;\n\n    // builtins handle omitted type arguments on their own. if present, however, resolve them here\n    // and pass them to the builtin, even if it's still up to the builtin how to handle them.\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var typeArgumentNodes = expression.typeArguments;\n    if (expression.typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          expression.range, prototype.internalName\n        );\n      }\n      typeArguments = this.resolver.resolveTypeArguments(\n        assert(typeParameterNodes),\n        typeArgumentNodes,\n        this.currentFlow.actualFunction.parent,\n        uniqueMap<string,Type>(this.currentFlow.contextualTypeArguments),\n        expression\n      );\n    }\n    var callee = expression.expression;\n    var ctx = new BuiltinContext(\n      this,\n      prototype,\n      typeArguments,\n      expression.args,\n      callee.kind == NodeKind.PROPERTYACCESS\n        ? (<PropertyAccessExpression>callee).expression\n        : null,\n      contextualType,\n      expression,\n      false\n    );\n    // global builtins\n    var internalName = prototype.internalName;\n    if (builtins.has(internalName)) {\n      let fn = assert(builtins.get(internalName));\n      return fn(ctx);\n    }\n    // class builtins\n    var parent = prototype.parent;\n    if (parent.kind == ElementKind.CLASS) {\n      let classPrototype = (<Class>parent).prototype;\n      if (classPrototype == this.program.functionPrototype) {\n        let methodName = prototype.name;\n        if (function_builtins.has(methodName)) {\n          let fn = assert(function_builtins.get(methodName));\n          return fn(ctx);\n        }\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  /**\n   * Checks that a call with the given number as arguments can be performed according to the\n   * specified signature.\n   */\n  checkCallSignature(\n    signature: Signature,\n    numArguments: i32,\n    hasThis: bool,\n    reportNode: Node\n  ): bool {\n\n    // cannot call an instance method without a `this` argument (TODO: `.call`?)\n    var thisType = signature.thisType;\n    if (hasThis != (thisType != null)) {\n      this.error(\n        DiagnosticCode.The_this_types_of_each_signature_are_incompatible,\n        reportNode.range\n      );\n      return false;\n    }\n\n    // not yet implemented (TODO: maybe some sort of an unmanaged/lightweight array?)\n    var hasRest = signature.hasRest;\n    if (hasRest) {\n      this.error(\n        DiagnosticCode.Not_implemented_0,\n        reportNode.range,\n        \"Rest parameters\"\n      );\n      return false;\n    }\n\n    var minimum = signature.requiredParameters;\n    var maximum = signature.parameterTypes.length;\n\n    // must at least be called with required arguments\n    if (numArguments < minimum) {\n      this.error(\n        minimum < maximum\n          ? DiagnosticCode.Expected_at_least_0_arguments_but_got_1\n          : DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, minimum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    // must not be called with more than the maximum arguments\n    if (numArguments > maximum && !hasRest) {\n      this.error(\n        DiagnosticCode.Expected_0_arguments_but_got_1,\n        reportNode.range, maximum.toString(), numArguments.toString()\n      );\n      return false;\n    }\n\n    return true;\n  }\n\n  /** Checks that an unsafe expression is allowed. */\n  private checkUnsafe(reportNode: Node, relatedReportNode: Node | null = null): void {\n    // Library files may always use unsafe features\n    if (this.options.noUnsafe && !reportNode.range.source.isLibrary) {\n      if (relatedReportNode) {\n        this.errorRelated(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range, relatedReportNode.range\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Operation_is_unsafe,\n          reportNode.range\n        );\n      }\n    }\n  }\n\n  /** Compiles a direct call to a concrete function. */\n  compileCallDirect(\n    instance: Function,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    constraints: Constraints = Constraints.NONE\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n    var signature = instance.signature;\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      this.currentType = signature.returnType;\n      return this.module.unreachable();\n    }\n    if (instance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n\n    // handle call on `this` in constructors\n    let actualFunction = this.currentFlow.actualFunction;\n    if (actualFunction.is(CommonFlags.CONSTRUCTOR) && reportNode.isAccessOnThis) {\n      let parent = actualFunction.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitialization(<Class>parent, reportNode);\n    }\n\n    // Inline if explicitly requested\n    if (instance.hasDecorator(DecoratorFlags.INLINE) && (!instance.is(CommonFlags.VIRTUAL) || reportNode.isAccessOnSuper)) {\n      assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n      let inlineStack = this.inlineStack;\n      if (inlineStack.includes(instance)) {\n        this.warning(\n          DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n          reportNode.range, instance.internalName\n        );\n      } else {\n        inlineStack.push(instance);\n        let parameterTypes = signature.parameterTypes;\n        assert(numArguments <= parameterTypes.length);\n        // compile argument expressions\n        let args = new Array<ExpressionRef>(numArguments);\n        for (let i = 0; i < numArguments; ++i) {\n          args[i] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n            Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n          );\n        }\n        // make the inlined call (is aware of autoreleases)\n        let expr = this.makeCallInline(instance, args, thisArg, (constraints & Constraints.WILL_DROP) != 0);\n        if (this.currentType.isManaged) {\n          if (!(constraints & Constraints.WILL_RETAIN)) {\n            expr = this.makeAutorelease(expr, instance.signature.returnType, this.currentFlow);\n          } else {\n            this.skippedAutoreleases.add(expr);\n          }\n        }\n        inlineStack.pop();\n        return expr;\n      }\n    }\n\n    // Otherwise compile to just a call\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    if (signature.returnType.isManaged) {\n      if (constraints & Constraints.WILL_DROP) {\n        // Skip autorelease and simply release\n        return this.makeCallDirect(instance, operands, reportNode, true);\n      } else if (constraints & Constraints.WILL_RETAIN) {\n        // Skip autorelease and remember\n        let expr = this.makeCallDirect(instance, operands, reportNode, false, true);\n        this.skippedAutoreleases.add(expr);\n        return expr;\n      } else {\n        return this.makeCallDirect(instance, operands, reportNode, false, false);\n      }\n    }\n    return this.makeCallDirect(instance, operands, reportNode,\n      (constraints & Constraints.WILL_DROP) != 0\n    );\n  }\n\n  makeCallInline(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    var numArguments = operands ? operands.length : 0;\n    var signature = instance.signature;\n    var parameterTypes = signature.parameterTypes;\n    var numParameters = parameterTypes.length;\n\n    // Create a new inline flow and use it to compile the function as a block\n    var previousFlow = this.currentFlow;\n    var flow = Flow.createInline(previousFlow.parentFunction, instance);\n    var body = [];\n    var usedLocals = new Set<i32>();\n\n    // Prepare compiled arguments right to left, keeping track of used locals.\n    for (let i = numArguments - 1; i >= 0; --i) {\n      // This is necessary because a later expression must not set an earlier argument local, which\n      // is also just a temporary, when being executed. Take for example `t1=1, t2=(t1 = 2)`, where\n      // the right expression would reassign the foregoing argument local. So, we iterate from right\n      // to left, remembering what's used later, and don't use these for earlier arguments, making\n      // the example above essentially `t2=1, t1=(t1 = 2)`.\n      let paramExpr = operands![i];\n      let paramType = parameterTypes[i];\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), paramType, usedLocals);\n      findUsedLocals(paramExpr, usedLocals);\n      // inlining is aware of wrap/nonnull states:\n      if (!previousFlow.canOverflow(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(paramExpr, paramType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\n      // inlining is aware of skipped autoreleases:\n      if (paramType.isManaged) {\n        if (!this.skippedAutoreleases.has(paramExpr)) paramExpr = this.makeRetain(paramExpr, paramType);\n        flow.setLocalFlag(argumentLocal.index, LocalFlags.RETAINED);\n      }\n      body.unshift(\n        module.local_set(argumentLocal.index, paramExpr)\n      );\n    }\n    if (thisArg) {\n      let parent = assert(instance.parent);\n      assert(parent.kind == ElementKind.CLASS);\n      let classInstance = <Class>parent;\n      let thisType = assert(instance.signature.thisType);\n      let thisLocal = flow.addScopedLocal(CommonNames.this_, thisType, usedLocals);\n      // In normal instance functions, `this` is effectively a constant\n      // retained elsewhere so does not need to be retained.\n      if (instance.is(CommonFlags.CONSTRUCTOR)) {\n        // Constructors, however, can allocate their own memory, and as such\n        // must refcount the allocation in case something else is `return`ed.\n        flow.setLocalFlag(thisLocal.index, LocalFlags.RETAINED);\n      }\n      body.unshift(\n        module.local_set(thisLocal.index, thisArg)\n      );\n      let base = classInstance.base;\n      if (base) flow.addScopedAlias(CommonNames.super_, base.type, thisLocal.index);\n    } else {\n      assert(!instance.signature.thisType);\n    }\n\n    // Compile omitted arguments with final argument locals blocked. Doesn't need to take care of\n    // side-effects within earlier expressions because these already happened on set.\n    this.currentFlow = flow;\n    for (let i = numArguments; i < numParameters; ++i) {\n      let initType = parameterTypes[i];\n      let initExpr = this.compileExpression(\n        assert(instance.prototype.functionTypeNode.parameters[i].initializer),\n        initType,\n        Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n      );\n      let argumentLocal = flow.addScopedLocal(instance.getParameterName(i), initType);\n      if (!flow.canOverflow(initExpr, initType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(initExpr, initType)) flow.setLocalFlag(argumentLocal.index, LocalFlags.NONNULL);\n      if (initType.isManaged) {\n        flow.setLocalFlag(argumentLocal.index, LocalFlags.RETAINED);\n        if (!this.skippedAutoreleases.has(initExpr)) initExpr = this.makeRetain(initExpr, initType);\n      }\n      body.push(\n        module.local_set(argumentLocal.index, initExpr)\n      );\n    }\n\n    // Compile the called function's body in the scope of the inlined flow\n    this.compileFunctionBody(instance, body);\n\n    // If a constructor, perform field init checks on its flow directly\n    if (instance.is(CommonFlags.CONSTRUCTOR)) {\n      let parent = instance.parent;\n      assert(parent.kind == ElementKind.CLASS);\n      this.checkFieldInitializationInFlow(<Class>parent, flow);\n    }\n\n    // Free any new scoped locals and reset to the original flow\n    if (!flow.is(FlowFlags.TERMINATES)) {\n      this.performAutoreleases(flow, body);\n      this.finishAutoreleases(flow, body);\n    }\n    flow.freeScopedLocals();\n    var returnType = flow.returnType;\n    this.currentFlow = previousFlow;\n\n    // Create an outer block that we can break to when returning a value out of order\n    var expr = module.block(flow.inlineReturnLabel, body, returnType.toNativeType());\n    this.currentType = returnType;\n    if (returnType.isManaged) {\n      if (immediatelyDropped) {\n        expr = this.makeRelease(expr, returnType);\n        this.currentType = Type.void;\n      }\n    }\n    return expr;\n  }\n\n  /** Makes sure that the arguments length helper global is present. */\n  ensureArgumentsLength(): void {\n    if (!this.builtinArgumentsLength) {\n      let module = this.module;\n      this.builtinArgumentsLength = module.addGlobal(BuiltinNames.argumentsLength, NativeType.I32, true, module.i32(0));\n    }\n  }\n\n  /** Ensures compilation of the varargs stub for the specified function. */\n  ensureVarargsStub(original: Function): Function {\n    // A varargs stub is a function called with omitted arguments being zeroed,\n    // reading the `argumentsLength` helper global to decide which initializers\n    // to inject before calling the original function. It is typically attempted\n    // to circumvent the varargs stub where possible, for example where omitted\n    // arguments are constants and can be inlined into the original call.\n    var stub = original.varargsStub;\n    if (stub) return stub;\n\n    var originalSignature = original.signature;\n    var originalParameterTypes = originalSignature.parameterTypes;\n    var originalParameterDeclarations = original.prototype.functionTypeNode.parameters;\n    var returnType = originalSignature.returnType;\n    var isInstance = original.is(CommonFlags.INSTANCE);\n\n    // arguments excl. `this`, operands incl. `this`\n    var minArguments = originalSignature.requiredParameters;\n    var minOperands = minArguments;\n    var maxArguments = originalParameterTypes.length;\n    var maxOperands = maxArguments;\n    if (isInstance) {\n      ++minOperands;\n      ++maxOperands;\n    }\n    var numOptional = assert(maxOperands - minOperands);\n\n    var forwardedOperands = new Array<ExpressionRef>(minOperands);\n    var operandIndex = 0;\n\n    // forward `this` if applicable\n    var module = this.module;\n    if (isInstance) {\n      forwardedOperands[0] = module.local_get(0, this.options.nativeSizeType);\n      operandIndex = 1;\n    }\n\n    // forward required arguments\n    for (let i = 0; i < minArguments; ++i, ++operandIndex) {\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, originalParameterTypes[i].toNativeType());\n    }\n    assert(operandIndex == minOperands);\n\n    // create the varargs stub\n    stub = original.newStub(\"varargs\");\n    stub.signature.requiredParameters = maxArguments;\n    original.varargsStub = stub;\n\n    // compile initializers of omitted arguments in the scope of the stub,\n    // accounting for additional locals and a proper `this` context.\n    var previousFlow = this.currentFlow;\n    var flow = stub.flow;\n    this.currentFlow = flow;\n\n    // create a br_table switching over the number of optional parameters provided\n    var numNames = numOptional + 1; // incl. outer block\n    var names = new Array<string>(numNames);\n    var ofN = \"of\" + numOptional.toString();\n    for (let i = 0; i < numNames; ++i) {\n      let label = i.toString() + ofN;\n      names[i] = label;\n    }\n    var body = module.block(names[0], [\n      module.block(\"outOfRange\", [\n        module.switch(names, \"outOfRange\",\n          // condition is number of provided optional arguments, so subtract required arguments\n          minArguments\n            ? module.binary(\n                BinaryOp.SubI32,\n                module.global_get(BuiltinNames.argumentsLength, NativeType.I32),\n                module.i32(minArguments)\n              )\n            : module.global_get(BuiltinNames.argumentsLength, NativeType.I32)\n        )\n      ]),\n      module.unreachable()\n    ]);\n    for (let i = 0; i < numOptional; ++i, ++operandIndex) {\n      let type = originalParameterTypes[minArguments + i];\n      let declaration = originalParameterDeclarations[minArguments + i];\n      let initializer = declaration.initializer;\n      let initExpr: ExpressionRef;\n      if (initializer) {\n        initExpr = module.local_set(operandIndex,\n          this.compileExpression(\n            initializer,\n            type,\n            Constraints.CONV_IMPLICIT\n          )\n        );\n      } else {\n        this.error(\n          DiagnosticCode.Optional_parameter_must_have_an_initializer,\n          declaration.range\n        );\n        initExpr = module.unreachable();\n      }\n      body = module.block(names[i + 1], [\n        body,\n        initExpr,\n      ]);\n      forwardedOperands[operandIndex] = module.local_get(operandIndex, type.toNativeType());\n    }\n    assert(operandIndex == maxOperands);\n\n    var stmts: ExpressionRef[] = [ body ];\n    var theCall = module.call(original.internalName, forwardedOperands, returnType.toNativeType());\n    if (returnType != Type.void) {\n      this.performAutoreleasesWithValue(flow, theCall, returnType, stmts);\n    } else {\n      stmts.push(theCall);\n      this.performAutoreleases(flow, stmts);\n    }\n    flow.freeScopedLocals();\n    this.currentFlow = previousFlow;\n\n    var funcRef = module.addFunction(\n      stub.internalName,\n      stub.signature.nativeParams,\n      stub.signature.nativeResults,\n      typesToNativeTypes(stub.additionalLocals),\n      module.flatten(stmts, returnType.toNativeType())\n    );\n    stub.set(CommonFlags.COMPILED);\n    stub.finalize(module, funcRef);\n    return stub;\n  }\n\n  /** Ensures compilation of the virtual stub for the specified function. */\n  ensureVirtualStub(original: Function): Function {\n    // A virtual stub is a function redirecting virtual calls to the actual\n    // overload targeted by the call. It utilizes varargs stubs where necessary\n    // and as such has the same semantics as one. Here, we only make sure that\n    // a placeholder exist, with actual code being generated as a finalization\n    // step once module compilation is otherwise complete.\n    var stub = original.virtualStub;\n    if (stub) return stub;\n    stub = original.newStub(\"virtual\");\n    original.virtualStub = stub;\n    var module = this.module;\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.nativeParams,\n      stub.signature.nativeResults,\n      null,\n      module.unreachable()\n    );\n    this.virtualCalls.add(original);\n    return stub;\n  }\n\n  /** Finalizes the virtual stub of the specified function. */\n  private finalizeVirtualStub(instance: Function): void {\n    var stub = this.ensureVirtualStub(instance);\n    if (stub.is(CommonFlags.COMPILED)) return;\n\n    // Wouldn't be here if there wasn't at least one overload\n    var overloadPrototypes = assert(instance.prototype.overloads);\n\n    var module = this.module;\n    var usizeType = this.options.usizeType;\n    var nativeSizeType = usizeType.toNativeType();\n    var parameterTypes = instance.signature.parameterTypes;\n    var returnType = instance.signature.returnType;\n    var numParameters = parameterTypes.length;\n    var tempIndex = 1 + parameterTypes.length; // incl. `this`\n\n    // Switch over this's rtId and map it to the respective overload\n    var builder = new SwitchBuilder(this.module,\n      module.load(4, false,\n        module.binary(\n          nativeSizeType == NativeType.I64\n            ? BinaryOp.SubI64\n            : BinaryOp.SubI32,\n          module.local_get(0, nativeSizeType),\n          nativeSizeType == NativeType.I64\n            ? module.i64(8) // rtId offset = -8\n            : module.i32(8)\n        ),\n        NativeType.I32\n      )\n    );\n\n    // A method's `overloads` property contains its unbound overload prototypes\n    // so we first have to find the concrete classes it became bound to, obtain\n    // their bound prototypes and make sure these are resolved and compiled as\n    // we are going to call them conditionally based on this's class id.\n    for (let _values = Set_values(overloadPrototypes), i = 0, k = _values.length; i < k; ++i) {\n      let unboundOverloadPrototype = _values[i];\n      assert(!unboundOverloadPrototype.isBound);\n      let unboundOverloadParent = unboundOverloadPrototype.parent;\n      let isProperty = unboundOverloadParent.kind == ElementKind.PROPERTY_PROTOTYPE;\n      let classInstances: Map<string,Class> | null;\n      if (isProperty) {\n        let propertyParent = (<PropertyPrototype>unboundOverloadParent).parent;\n        assert(propertyParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>propertyParent).instances;\n      } else {\n        assert(unboundOverloadParent.kind == ElementKind.CLASS_PROTOTYPE);\n        classInstances = (<ClassPrototype>unboundOverloadParent).instances;\n      }\n      if (classInstances) {\n        for (let _values = Map_values(classInstances), j = 0, l = _values.length; j < l; ++j) {\n          let classInstance = _values[j];\n          let overloadInstance: Function | null;\n          if (isProperty) {\n            let boundProperty = assert(classInstance.members!.get(unboundOverloadParent.name));\n            assert(boundProperty.kind == ElementKind.PROPERTY_PROTOTYPE);\n            let boundPropertyInstance = this.resolver.resolveProperty(<PropertyPrototype>boundProperty);\n            if (!boundPropertyInstance) continue;\n            if (instance.is(CommonFlags.GET)) {\n              overloadInstance = boundPropertyInstance.getterInstance;\n            } else {\n              assert(instance.is(CommonFlags.SET));\n              overloadInstance = boundPropertyInstance.setterInstance;\n            }\n          } else {\n            let boundPrototype = assert(classInstance.members!.get(unboundOverloadPrototype.name));\n            assert(boundPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n            overloadInstance = this.resolver.resolveFunction(<FunctionPrototype>boundPrototype, instance.typeArguments);\n          }\n          if (!overloadInstance || !this.compileFunction(overloadInstance)) continue;\n          let overloadType = overloadInstance.type;\n          let originalType = instance.type;\n          if (!overloadType.isAssignableTo(originalType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              overloadInstance.identifierNode.range, overloadType.toString(), originalType.toString()\n            );\n            continue;\n          }\n          // TODO: additional optional parameters are not permitted by `isAssignableTo` yet\n          let overloadSignature = overloadInstance.signature;\n          let overloadParameterTypes = overloadSignature.parameterTypes;\n          let overloadNumParameters = overloadParameterTypes.length;\n          let paramExprs = new Array<ExpressionRef>(1 + overloadNumParameters);\n          paramExprs[0] = module.local_get(0, nativeSizeType); // this\n          for (let n = 1; n <= numParameters; ++n) {\n            paramExprs[n] = module.local_get(n, parameterTypes[n - 1].toNativeType());\n          }\n          let needsVarargsStub = false;\n          for (let n = numParameters; n < overloadNumParameters; ++n) {\n            // TODO: inline constant initializers and skip varargs stub\n            paramExprs[1 + n] = this.makeZero(overloadParameterTypes[n], overloadInstance.declaration);\n            needsVarargsStub = true;\n          }\n          let calledName = needsVarargsStub\n            ? this.ensureVarargsStub(overloadInstance).internalName\n            : overloadInstance.internalName;\n          let nativeReturnType = overloadSignature.returnType.toNativeType();\n          let stmts = new Array<ExpressionRef>();\n          if (needsVarargsStub) {\n            this.ensureArgumentsLength();\n            // Safe to prepend since paramExprs are local.get's\n            stmts.push(module.global_set(BuiltinNames.argumentsLength, module.i32(numParameters)));\n          }\n          if (returnType == Type.void) {\n            stmts.push(\n              module.call(calledName, paramExprs, nativeReturnType)\n            );\n            stmts.push(\n              module.return()\n            );\n          } else {\n            stmts.push(\n              module.return(\n                module.call(calledName, paramExprs, nativeReturnType)\n              )\n            );\n          }\n          builder.addCase(classInstance.id, stmts);\n          // Also alias each extendee inheriting this exact overload\n          let extendees = classInstance.getAllExtendees(\n            isProperty\n              ? unboundOverloadParent.name\n              : instance.prototype.name\n          );\n          for (let _values = Set_values(extendees), a = 0, b = _values.length; a < b; ++a) {\n            let extendee = _values[a];\n            builder.addCase(extendee.id, stmts);\n          }\n        }\n      }\n    }\n\n    // Call the original function if no other id matches and the method is not\n    // abstract or part of an interface. Note that doing so will not catch an\n    // invalid id, but can reduce code size significantly since we also don't\n    // have to add branches for extendees inheriting the original function.\n    var body: ExpressionRef;\n    if (instance.prototype.bodyNode) {\n      let paramExprs = new Array<ExpressionRef>(numParameters);\n      paramExprs[0] = module.local_get(0, nativeSizeType); // this\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        paramExprs[1 + i] = module.local_get(1 + i, parameterTypes[i].toNativeType());\n      }\n      body = module.call(instance.internalName, paramExprs, returnType.toNativeType());\n\n    // Otherwise trap\n    } else {\n      body = module.unreachable();\n    }\n\n    // Create the virtual stub function\n    var ref = stub.ref;\n    if (ref) module.removeFunction(stub.internalName);\n    stub.ref = module.addFunction(\n      stub.internalName,\n      stub.signature.nativeParams,\n      stub.signature.nativeResults,\n      [ NativeType.I32 ],\n      module.block(null, [\n        builder.render(tempIndex),\n        body\n      ], returnType.toNativeType())\n    );\n    stub.set(CommonFlags.COMPILED);\n  }\n\n  // <reference-counting>\n\n  /** Makes a retain call, retaining the expression's value. */\n  makeRetain(expr: ExpressionRef, type: Type): ExpressionRef {\n    var retainInstance = this.program.retainInstance;\n    this.compileFunction(retainInstance);\n    return this.module.call(retainInstance.internalName, [ expr ], this.options.nativeSizeType);\n  }\n\n  /** Makes a release call, releasing the expression's value. Changes the current type to void.*/\n  makeRelease(expr: ExpressionRef, type: Type): ExpressionRef {\n    var releaseInstance = this.program.releaseInstance;\n    this.compileFunction(releaseInstance);\n    return this.module.call(releaseInstance.internalName, [ expr ], NativeType.None);\n  }\n\n  /** Makes a replace, retaining the new expression's value and releasing the old expression's value, in this order. */\n  makeReplace(\n    /** New value being assigned. */\n    newExpr: ExpressionRef,\n    /** The type of the new expression. */\n    newType: Type,\n    /** Old value being replaced. */\n    oldExpr: ExpressionRef,\n    /** The type of the old expression. */\n    oldType: Type,\n    /** Whether the new value is already retained. */\n    alreadyRetained: bool = false,\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var nativeSizeType = this.options.nativeSizeType;\n    if (alreadyRetained) {\n      // (t1=newExpr), __release(oldExpr), t1\n      // it is important that `newExpr` evaluates before `oldExpr` is released, hence the local\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(oldExpr));\n      let ret = module.block(null, [\n        module.local_set(temp.index, newExpr),\n        this.makeRelease(oldExpr, oldType),\n        module.local_get(temp.index, nativeSizeType)\n      ], nativeSizeType);\n      flow.freeTempLocal(temp);\n      return ret;\n    } else {\n      // if ((t1=newExpr) != (t2=oldExpr)) {\n      //   t1 = __retain(t1);\n      //   __release(t2);\n      // }, t1\n      let usizeType = this.options.usizeType;\n      let temp1 = flow.getTempLocal(usizeType, findUsedLocals(oldExpr));\n      let temp2 = flow.getTempLocal(usizeType);\n      let ret = module.block(null, [\n        module.if(\n          module.binary(nativeSizeType == NativeType.I64 ? BinaryOp.NeI64 : BinaryOp.NeI32,\n            module.local_tee(temp1.index, newExpr),\n            module.local_tee(temp2.index, oldExpr)\n          ),\n          module.block(null, [\n            module.local_set(temp1.index,\n              this.makeRetain(module.local_get(temp1.index, nativeSizeType), newType)\n            ),\n            this.makeRelease(module.local_get(temp2.index, nativeSizeType), oldType)\n          ])\n        ),\n        module.local_get(temp1.index, nativeSizeType)\n      ], nativeSizeType);\n      flow.freeTempLocal(temp2);\n      flow.freeTempLocal(temp1);\n      return ret;\n    }\n  }\n\n  /** Makes an autorelease call at the end of the specified `flow`. */\n  makeAutorelease(\n    /** Expression to autorelease. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Flow that should autorelease. Defaults to the current flow. */\n    flow: Flow = this.currentFlow\n  ): ExpressionRef {\n    // An 'autorelease' is the assignment of a managed reference to a temporary local,\n    // keeping the reference alive until the surrounding flow concludes. This is useful\n    // if a reference is not being immediately assigned to something that would keep it\n    // alive, like a local or a global, yet it'll remain alive in other code. Example:\n    //\n    //   callReceivingAReference(callReturningAReference())\n    //\n    // will be transformed into an autorelease like\n    //\n    //   callReceivingAReference(t = callReturningAReference())\n    //   ...\n    //   __release(t)\n    //\n    // since releasing immediately would free the value before the call:\n    //\n    //   callReceivingAReference((__release(t = callReturningAReference()), t))\n    //\n    var local = flow.getAutoreleaseLocal(type);\n    if (flow.isNonnull(expr, type)) flow.setLocalFlag(local.index, LocalFlags.NONNULL);\n    return this.module.local_tee(local.index, expr);\n  }\n\n  /**\n   * Attempts to undo an autorelease in the specified `flow`.\n   * Returns the index of the previously retaining variable or -1 if not possible.\n   */\n  tryUndoAutorelease(\n    /** Expression being autoreleased. */\n    expr: ExpressionRef,\n    /** Flow that would autorelease. */\n    flow: Flow\n  ): i32 {\n    // The following assumes that the expression actually belongs to the flow and that\n    // top-level autoreleases are never undone. While that's true, it's not necessary\n    // to check presence in scopedLocals.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalGet: { // local.get(idx)\n        let index = getLocalGetIndex(expr);\n        if (flow.isAnyLocalFlag(index, LocalFlags.ANY_RETAINED)) {\n          flow.unsetLocalFlag(index, LocalFlags.ANY_RETAINED);\n          return index;\n        }\n        break;\n      }\n      case ExpressionId.LocalSet: { // local.tee(idx, expr)\n        if (isLocalTee(expr)) {\n          // NOTE: Can't remove the local.tee completely because it's already compiled\n          // and a child of something else. Preventing the final release however makes\n          // it optimize away.\n          let index = getLocalSetIndex(expr);\n          if (flow.isAnyLocalFlag(index, LocalFlags.ANY_RETAINED)) {\n            flow.unsetLocalFlag(index, LocalFlags.ANY_RETAINED);\n            return index;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Block: { // { ..., local.get|tee(...) }\n        if (getBlockName(expr) === null) { // must not be a break target\n          let count = getBlockChildCount(expr);\n          if (count) {\n            return this.tryUndoAutorelease(getBlockChildAt(expr, count - 1), flow);\n          }\n        }\n        break;\n      }\n    }\n    return -1;\n  }\n\n  /** Delays an autorelease in `innerFlow` until `outerFlow` concludes. */\n  delayAutorelease(\n    /** Expression being autoreleased in `innerFlow`. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Inner flow that would autorelease. Must not have processed autoreleases yet. */\n    innerFlow: Flow,\n    /** Outer flow that should autorelease instead. */\n    outerFlow: Flow\n  ): ExpressionRef {\n    // Attempt to undo the autorelease in `innerFlow`\n    var index = this.tryUndoAutorelease(expr, innerFlow);\n    return ~index\n      // If it worked, autorelease in `outerFlow` instead\n      ? this.makeAutorelease(expr, type, outerFlow)\n      // If it didn't work, extend the lifetime into `outerFlow`\n      : this.makeAutorelease(this.makeRetain(expr, type), type, outerFlow);\n  }\n\n  /** Performs any queued autoreleases in the specified flow. */\n  performAutoreleases(\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[],\n    /**\n     * Whether to finalize affected locals. Defaults to `true`, which\n     * is almost always correct, except when bubbling up parent flows\n     * in break-like scenarios.\n     */\n    finalize: bool = true\n  ): void {\n    // Autoreleases must be performed whenever a flow concludes, decrementing\n    // the RC of all the references in that flow scheduled for an autorelease.\n    var scopedLocals = flow.scopedLocals;\n    if (scopedLocals) {\n      let module = this.module;\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          let localIndex = local.index;\n          if (flow.isAnyLocalFlag(localIndex, LocalFlags.ANY_RETAINED)) {\n            if (finalize) flow.unsetLocalFlag(localIndex, LocalFlags.ANY_RETAINED);\n            stmts.push(\n              this.makeRelease(\n                module.local_get(localIndex, local.type.toNativeType()),\n                local.type\n              )\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /** Performs any queued autoreleases in the specified flow and returns the given value. */\n  performAutoreleasesWithValue(\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Value to return. */\n    valueExpr: ExpressionRef,\n    /** Type of the returned value. */\n    valueType: Type,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[] | null = null,\n    /** Whether to finalize affected locals. */\n    finalize: bool = true\n  ): ExpressionRef {\n    if (!stmts) stmts = new Array<ExpressionRef>();\n    stmts.push(\n      this.module.nop()\n    );\n    var lengthBefore = stmts.length;\n    this.performAutoreleases(flow, stmts, finalize);\n    var module = this.module;\n    if (stmts.length > lengthBefore) {\n      let nativeType = valueType.toNativeType();\n      let temp = flow.getTempLocal(valueType);\n      if (!flow.canOverflow(valueExpr, valueType)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n      if (flow.isNonnull(valueExpr, valueType)) flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n      stmts[lengthBefore - 1] = module.local_set(temp.index, valueExpr); // nop -> set\n      stmts.push(\n        module.local_get(temp.index, nativeType) // append get\n      );\n      let ret = module.flatten(stmts, nativeType);\n      flow.freeTempLocal(temp);\n      return ret;\n    } else if (stmts.length > 1) {\n      stmts[lengthBefore - 1] = valueExpr; // nop -> value\n      return module.flatten(stmts, valueType.toNativeType());\n    }\n    return valueExpr;\n  }\n\n  /** Finishes any queued autoreleases in the actual function of the specified flow. */\n  finishAutoreleases(\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[]\n  ): void {\n    // Differs from `performAutoreleases` in that concluding this flow also\n    // concludes all its parent flows, for example on a `return`.\n    if (flow.isInline) {\n      // Traverse to the top-most flow containing the inlined function's\n      // locals as scoped locals and release these instead of all the locals.\n      let current = flow;\n      let parent: Flow | null;\n      while (parent = current.parent) current = parent;\n      let scopedLocals = current.scopedLocals;\n      if (scopedLocals) {\n        // TODO: for (let local of scopedLocals.values()) {\n        for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n          let local = unchecked(_values[i]);\n          this.maybeFinishAutorelease(local, flow, stmts);\n        }\n      }\n    } else {\n      let localsByIndex = flow.parentFunction.localsByIndex;\n      for (let i = 0, k = localsByIndex.length; i < k; ++i) {\n        let local = unchecked(localsByIndex[i]);\n        this.maybeFinishAutorelease(local, flow, stmts);\n      }\n    }\n  }\n\n  /** Finishes a single autorelease of the specified local. */\n  private maybeFinishAutorelease(\n    /** Local to finish autoreleasing. */\n    local: Local,\n    /** Flow releasing its queued autoreleases. */\n    flow: Flow,\n    /** Array of statements to append the releases to. */\n    stmts: ExpressionRef[]\n  ): void {\n    var localIndex = local.index;\n    var module = this.module;\n    if (~localIndex && flow.isAnyLocalFlag(localIndex, LocalFlags.ANY_RETAINED)) {\n      flow.unsetLocalFlag(localIndex, LocalFlags.ANY_RETAINED);\n      stmts.push(\n        this.makeRelease(\n          module.local_get(localIndex, local.type.toNativeType()),\n          local.type\n        )\n      );\n    }\n  }\n\n  // </reference-counting>\n\n  /** Creates a direct call to the specified function. */\n  makeCallDirect(\n    instance: Function,\n    operands: ExpressionRef[] | null,\n    reportNode: Node,\n    immediatelyDropped: bool = false,\n    /** Skip the usual autorelease and manage this at the callsite instead. */\n    skipAutorelease: bool = false\n  ): ExpressionRef {\n    if (instance.hasDecorator(DecoratorFlags.INLINE)) {\n      if (!instance.is(CommonFlags.VIRTUAL)) {\n        assert(!instance.is(CommonFlags.STUB)); // doesn't make sense\n        let inlineStack = this.inlineStack;\n        if (inlineStack.includes(instance)) {\n          this.warning(\n            DiagnosticCode.Function_0_cannot_be_inlined_into_itself,\n            reportNode.range, instance.internalName\n          );\n        } else {\n          inlineStack.push(instance);\n          let expr: ExpressionRef;\n          if (instance.is(CommonFlags.INSTANCE)) {\n            let theOperands = assert(operands);\n            assert(theOperands.length);\n            expr = this.makeCallInline(instance, theOperands.slice(1), theOperands[0], immediatelyDropped);\n          } else {\n            expr = this.makeCallInline(instance, operands, 0, immediatelyDropped);\n          }\n          let returnType = this.currentType;\n          if (returnType.isManaged) {\n            if (!skipAutorelease) {\n              expr = this.makeAutorelease(expr, returnType);\n            } else {\n              this.skippedAutoreleases.add(expr);\n            }\n          }\n          inlineStack.pop();\n          return expr;\n        }\n      } else {\n        this.warning(\n          DiagnosticCode.Function_0_is_virtual_and_will_not_be_inlined,\n          reportNode.range, instance.internalName\n        );\n      }\n    }\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = instance.signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = instance.signature.parameterTypes;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (instance.is(CommonFlags.INSTANCE)) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    if (!this.compileFunction(instance)) return module.unreachable();\n    var returnType = instance.signature.returnType;\n\n    // fill up omitted arguments with their initializers, if constant, otherwise with zeroes.\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterNodes = instance.prototype.functionTypeNode.parameters;\n      assert(parameterNodes.length == parameterTypes.length);\n      let allOptionalsAreConstant = true;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        let initializer = parameterNodes[i].initializer;\n        if (initializer) {\n          if (initializer.compilesToConst) {\n            operands.push(this.compileExpression(\n              initializer,\n              parameterTypes[i],\n              Constraints.CONV_IMPLICIT\n            ));\n            continue;\n          }\n          let resolved = this.resolver.lookupExpression(initializer, instance.flow, parameterTypes[i], ReportMode.SWALLOW);\n          if (resolved) {\n            if (resolved.kind == ElementKind.GLOBAL) {\n              let global = <Global>resolved;\n              if (this.compileGlobal(global)) {\n                if (global.is(CommonFlags.INLINED)) {\n                  operands.push(\n                    this.compileInlineConstant(global, parameterTypes[i], Constraints.CONV_IMPLICIT)\n                  );\n                } else {\n                  operands.push(\n                    this.convertExpression(\n                      module.global_get(global.internalName, global.type.toNativeType()),\n                      global.type, parameterTypes[i], false, initializer\n                    )\n                  );\n                }\n                continue;\n              }\n            }\n          }\n        }\n        operands.push(this.makeZero(parameterTypes[i], instance.declaration));\n        allOptionalsAreConstant = false;\n      }\n      if (!allOptionalsAreConstant) {\n        if (!instance.is(CommonFlags.MODULE_IMPORT)) {\n          let original = instance;\n          instance = this.ensureVarargsStub(instance);\n          if (!this.compileFunction(instance)) return module.unreachable();\n          instance.flow.flags = original.flow.flags;\n          let nativeReturnType = returnType.toNativeType();\n          // We know the last operand is optional and omitted, so inject setting\n          // ~argumentsLength into that operand, which is always safe.\n          let lastOperand = operands[maxOperands - 1];\n          assert(!(getSideEffects(lastOperand) & SideEffects.WritesGlobal));\n          let lastOperandType = parameterTypes[maxArguments - 1];\n          operands[maxOperands - 1] = module.block(null, [\n            module.global_set(BuiltinNames.argumentsLength, module.i32(numArguments)),\n            lastOperand\n          ], lastOperandType.toNativeType());\n          let expr = module.call(instance.internalName, operands, nativeReturnType);\n          this.currentType = returnType;\n          if (returnType.isManaged) {\n            if (immediatelyDropped) {\n              expr = this.makeRelease(expr, returnType);\n              this.currentType = Type.void;\n            } else if (!skipAutorelease) {\n              expr = this.makeAutorelease(expr, returnType);\n            } else {\n              this.skippedAutoreleases.add(expr);\n            }\n          }\n          this.ensureArgumentsLength();\n          return expr;\n        }\n      }\n    }\n\n    // Call the virtual stub with the vtable if the function has overloads\n    if (instance.is(CommonFlags.VIRTUAL) && !reportNode.isAccessOnSuper) {\n      instance = this.ensureVirtualStub(instance);\n    }\n\n    // If the return value is of a reference type it has not yet been released but is in flight\n    // which is equivalent to a skipped autorelease. Hence, insert either a release if it is\n    // dropped anyway, preserve the skipped autorelease if explicitly requested or autorelease now.\n    var expr = module.call(instance.internalName, operands, returnType.toNativeType());\n    this.currentType = returnType;\n    if (returnType.isManaged) {\n      if (immediatelyDropped) {\n        expr = this.makeRelease(expr, returnType);\n        this.currentType = Type.void;\n      } else if (!skipAutorelease) {\n        expr = this.makeAutorelease(expr, returnType);\n      }\n    }\n    return expr;\n  }\n\n  /** Compiles an indirect call using an index argument and a signature. */\n  compileCallIndirect(\n    signature: Signature,\n    indexArg: ExpressionRef,\n    argumentExpressions: Expression[],\n    reportNode: Node,\n    thisArg: ExpressionRef = 0,\n    immediatelyDropped: bool = false\n  ): ExpressionRef {\n    var numArguments = argumentExpressions.length;\n\n    if (!this.checkCallSignature( // reports\n      signature,\n      numArguments,\n      thisArg != 0,\n      reportNode\n    )) {\n      return this.module.unreachable();\n    }\n\n    var numArgumentsInclThis = thisArg ? numArguments + 1 : numArguments;\n    var operands = new Array<ExpressionRef>(numArgumentsInclThis);\n    var index = 0;\n    if (thisArg) {\n      operands[0] = thisArg;\n      index = 1;\n    }\n    var parameterTypes = signature.parameterTypes;\n    for (let i = 0; i < numArguments; ++i, ++index) {\n      operands[index] = this.compileExpression(argumentExpressions[i], parameterTypes[i],\n        Constraints.CONV_IMPLICIT\n      );\n    }\n    assert(index == numArgumentsInclThis);\n    return this.makeCallIndirect(signature, indexArg, reportNode, operands, immediatelyDropped);\n  }\n\n  /** Creates an indirect call to the function at `indexArg` in the function table. */\n  makeCallIndirect(\n    signature: Signature,\n    indexArg: ExpressionRef,\n    reportNode: Node,\n    operands: ExpressionRef[] | null = null,\n    immediatelyDropped: bool = false,\n  ): ExpressionRef {\n    var module = this.module;\n    var numOperands = operands ? operands.length : 0;\n    var numArguments = numOperands;\n    var minArguments = signature.requiredParameters;\n    var minOperands = minArguments;\n    var parameterTypes = signature.parameterTypes;\n    var returnType = signature.returnType;\n    var maxArguments = parameterTypes.length;\n    var maxOperands = maxArguments;\n    if (signature.thisType) {\n      ++minOperands;\n      ++maxOperands;\n      --numArguments;\n    }\n    assert(numOperands >= minOperands);\n\n    // fill up omitted arguments with zeroes\n    if (numOperands < maxOperands) {\n      if (!operands) {\n        operands = new Array(maxOperands);\n        operands.length = 0;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = numArguments; i < maxArguments; ++i) {\n        operands.push(this.makeZero(parameterTypes[i], reportNode));\n      }\n    }\n\n    if (this.options.isWasm64) {\n      indexArg = module.unary(UnaryOp.WrapI64, indexArg);\n    }\n\n    // We might be calling a varargs stub here, even if all operands have been\n    // provided, so we must set `argumentsLength` in any case. Inject setting it\n    // into the index argument, which becomes executed last after any operands.\n    this.ensureArgumentsLength();\n    var nativeSizeType = this.options.nativeSizeType;\n    if (getSideEffects(indexArg) & SideEffects.WritesGlobal) {\n      let flow = this.currentFlow;\n      let temp = flow.getTempLocal(this.options.usizeType, findUsedLocals(indexArg));\n      indexArg = module.block(null, [\n        module.local_set(temp.index, indexArg),\n        module.global_set(BuiltinNames.argumentsLength, module.i32(numArguments)),\n        module.local_get(temp.index, nativeSizeType)\n      ], nativeSizeType);\n      flow.freeTempLocal(temp);\n    } else { // simplify\n      indexArg = module.block(null, [\n        module.global_set(BuiltinNames.argumentsLength, module.i32(numArguments)),\n        indexArg\n      ], nativeSizeType);\n    }\n    var expr = module.call_indirect(\n      nativeSizeType == NativeType.I64\n        ? module.unary(UnaryOp.WrapI64,\n            module.load(8, false, indexArg, NativeType.I64)\n          )\n        : module.load(4, false, indexArg, NativeType.I32),\n      operands,\n      signature.nativeParams,\n      signature.nativeResults\n    );\n    this.currentType = returnType;\n    if (returnType.isManaged) {\n      if (immediatelyDropped) {\n        expr = this.makeRelease(expr, returnType);\n        this.currentType = Type.void;\n      } else {\n        expr = this.makeAutorelease(expr, returnType);\n      }\n    }\n    return expr;\n  }\n\n  private compileCommaExpression(\n    expression: CommaExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var expressions = expression.expressions;\n    var numExpressions = expressions.length;\n    var exprs = new Array<ExpressionRef>(numExpressions--);\n    for (let i = 0; i < numExpressions; ++i) {\n      exprs[i] = this.compileExpression(expressions[i], Type.void, // drop all except last\n        Constraints.CONV_IMPLICIT | Constraints.WILL_DROP\n      );\n    }\n    exprs[numExpressions] = this.compileExpression(expressions[numExpressions], contextualType, constraints);\n    return this.module.flatten(exprs, this.currentType.toNativeType());\n  }\n\n  private compileElementAccessExpression(\n    expression: ElementAccessExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var targetExpression = expression.expression;\n    var targetType = this.resolver.resolveExpression(targetExpression, this.currentFlow); // reports\n    if (targetType) {\n      let classReference = targetType.getClassOrWrapper(this.program);\n      if (classReference) {\n        let isUnchecked = this.currentFlow.is(FlowFlags.UNCHECKED_CONTEXT);\n        let indexedGet = classReference.lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n        if (indexedGet) {\n          let thisType = assert(indexedGet.signature.thisType);\n          let thisArg = this.compileExpression(targetExpression, thisType,\n            Constraints.CONV_IMPLICIT\n          );\n          if (!isUnchecked && this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Indexed_access_may_involve_bounds_checking,\n              expression.range\n            );\n          }\n          return this.compileCallDirect(indexedGet, [\n            expression.elementExpression\n          ], expression, thisArg, constraints);\n        }\n      }\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        expression.expression.range, targetType.toString()\n      );\n    }\n    return module.unreachable();\n  }\n\n  private compileFunctionExpression(\n    expression: FunctionExpression,\n    contextualSignature: Signature | null,\n    constraints: Constraints\n  ): ExpressionRef {\n    var declaration = expression.declaration.clone(); // generic contexts can have multiple\n    assert(!declaration.typeParameters); // function expression cannot be generic\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n    var prototype = new FunctionPrototype(\n      declaration.name.text.length\n        ? declaration.name.text\n        : \"anonymous|\" + (actualFunction.nextAnonymousId++).toString(),\n      actualFunction,\n      declaration,\n      DecoratorFlags.NONE\n    );\n    var instance: Function | null;\n    var contextualTypeArguments = uniqueMap(flow.contextualTypeArguments);\n\n    // compile according to context. this differs from a normal function in that omitted parameter\n    // and return types can be inferred and omitted arguments can be replaced with dummies.\n    if (contextualSignature) {\n      let signatureNode = prototype.functionTypeNode;\n      let parameterNodes = signatureNode.parameters;\n      let numPresentParameters = parameterNodes.length;\n\n      // must not require more than the maximum number of parameters\n      let parameterTypes = contextualSignature.parameterTypes;\n      let numParameters = parameterTypes.length;\n      if (numPresentParameters > numParameters) {\n        this.error(\n          DiagnosticCode.Expected_0_arguments_but_got_1,\n          expression.range, numParameters.toString(), numPresentParameters.toString()\n        );\n        return this.module.unreachable();\n      }\n\n      // check non-omitted parameter types\n      for (let i = 0; i < numPresentParameters; ++i) {\n        let parameterNode = parameterNodes[i];\n        if (!isTypeOmitted(parameterNode.type)) {\n          let resolvedType = this.resolver.resolveType(\n            parameterNode.type,\n            actualFunction.parent,\n            contextualTypeArguments\n          );\n          if (!resolvedType) return this.module.unreachable();\n          if (!parameterTypes[i].isStrictlyAssignableTo(resolvedType)) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n              parameterNode.range, parameterTypes[i].toString(), resolvedType.toString()\n            );\n            return this.module.unreachable();\n          }\n        }\n        // any unused parameters are inherited but ignored\n      }\n\n      // check non-omitted return type\n      let returnType = contextualSignature.returnType;\n      if (!isTypeOmitted(signatureNode.returnType)) {\n        let resolvedType = this.resolver.resolveType(\n          signatureNode.returnType,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return this.module.unreachable();\n        if (\n          returnType == Type.void\n            ? resolvedType != Type.void\n            : !resolvedType.isStrictlyAssignableTo(returnType)\n        ) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            signatureNode.returnType.range, resolvedType.toString(), returnType.toString()\n          );\n          return this.module.unreachable();\n        }\n      }\n\n      // check explicit this type\n      let thisType = contextualSignature.thisType;\n      let thisTypeNode = signatureNode.explicitThisType;\n      if (thisTypeNode) {\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            thisTypeNode.range\n          );\n          return this.module.unreachable();\n        }\n        let resolvedType = this.resolver.resolveType(\n          thisTypeNode,\n          actualFunction.parent,\n          contextualTypeArguments\n        );\n        if (!resolvedType) return this.module.unreachable();\n        if (!thisType.isStrictlyAssignableTo(resolvedType)) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n            thisTypeNode.range, thisType.toString(), resolvedType.toString()\n          );\n          return this.module.unreachable();\n        }\n      }\n\n      let signature = new Signature(this.program, parameterTypes, returnType, thisType);\n      signature.requiredParameters = numParameters; // !\n      instance = new Function(\n        prototype.name,\n        prototype,\n        null,\n        signature,\n        contextualTypeArguments\n      );\n      if (!this.compileFunction(instance)) return this.module.unreachable();\n      this.currentType = contextualSignature.type;\n\n    // otherwise compile like a normal function\n    } else {\n      instance = this.resolver.resolveFunction(prototype, null, contextualTypeArguments);\n      if (!instance) return this.module.unreachable();\n      this.compileFunction(instance);\n      this.currentType = instance.signature.type;\n    }\n\n    var offset = this.ensureRuntimeFunction(instance); // reports\n    return this.options.isWasm64\n      ? this.module.i64(i64_low(offset), i64_high(offset))\n      : this.module.i32(i64_low(offset));\n  }\n\n  /** Makes sure the enclosing source file of the specified expression has been compiled. */\n  private maybeCompileEnclosingSource(expression: Expression): void {\n    var internalPath = expression.range.source.internalPath;\n    var filesByName = this.program.filesByName;\n    assert(filesByName.has(internalPath));\n    var enclosingFile = assert(filesByName.get(internalPath));\n    if (!enclosingFile.is(CommonFlags.COMPILED)) {\n      this.compileFileByPath(internalPath, expression);\n    }\n  }\n\n  private compileIdentifierExpression(\n    expression: IdentifierExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var actualFunction = flow.actualFunction;\n\n    // check special keywords first\n    switch (expression.kind) {\n      case NodeKind.NULL: {\n        let options = this.options;\n        if (contextualType.isReference) {\n          let classReference = contextualType.getClass();\n          if (classReference) {\n            this.currentType = classReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          let signatureReference = contextualType.getSignature();\n          if (signatureReference) {\n            this.currentType = signatureReference.type.asNullable();\n            return options.isWasm64 ? module.i64(0) : module.i32(0);\n          }\n          return this.makeZero(contextualType, expression);\n        }\n        this.currentType = options.usizeType;\n        this.warning(\n          DiagnosticCode.Expression_resolves_to_unusual_type_0,\n          expression.range, this.currentType.toString()\n        );\n        return options.isWasm64\n          ? module.i64(0)\n          : module.i32(0);\n      }\n      case NodeKind.TRUE: {\n        this.currentType = Type.bool;\n        return module.i32(1);\n      }\n      case NodeKind.FALSE: {\n        this.currentType = Type.bool;\n        return module.i32(0);\n      }\n      case NodeKind.THIS: {\n        let thisType = actualFunction.signature.thisType;\n        if (!thisType) {\n          this.error(\n            DiagnosticCode._this_cannot_be_referenced_in_current_location,\n            expression.range\n          );\n          this.currentType = this.options.usizeType;\n          return module.unreachable();\n        }\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR) && !(constraints & Constraints.IS_THIS)) {\n          let parent = actualFunction.parent;\n          assert(parent.kind == ElementKind.CLASS);\n          this.checkFieldInitialization(<Class>parent, expression);\n        }\n        let thisLocal = assert(flow.lookupLocal(CommonNames.this_));\n        flow.set(FlowFlags.ACCESSES_THIS);\n        this.currentType = thisType;\n        return module.local_get(thisLocal.index, thisType.toNativeType());\n      }\n      case NodeKind.SUPER: {\n        let flow = this.currentFlow;\n        let actualFunction = flow.actualFunction;\n        if (actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n          if (!flow.is(FlowFlags.CALLS_SUPER)) {\n            // TS1034 in the parser effectively limits this to property accesses\n            this.error(\n              DiagnosticCode._super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class,\n              expression.range\n            );\n          }\n        }\n        if (flow.isInline) {\n          let scopedThis = flow.lookupLocal(CommonNames.this_);\n          if (scopedThis) {\n            let scopedThisClass = assert(scopedThis.type.getClass());\n            let base = scopedThisClass.base;\n            if (base) {\n              this.currentType = base.type;\n              return module.local_get(scopedThis.index, base.type.toNativeType());\n            }\n          }\n        }\n        if (actualFunction.is(CommonFlags.INSTANCE)) {\n          let parent = assert(actualFunction.parent);\n          assert(parent.kind == ElementKind.CLASS);\n          let classInstance = <Class>parent;\n          let baseClassInstance = classInstance.base;\n          if (baseClassInstance) {\n            let superType = baseClassInstance.type;\n            this.currentType = superType;\n            return module.local_get(0, superType.toNativeType());\n          }\n        }\n        this.error(\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n          expression.range\n        );\n        this.currentType = this.options.usizeType;\n        return module.unreachable();\n      }\n    }\n\n    this.maybeCompileEnclosingSource(expression);\n\n    // otherwise resolve\n    var currentParent = this.currentParent;\n    if (!currentParent) currentParent = actualFunction;\n    var target = this.resolver.lookupIdentifierExpression( // reports\n      expression,\n      flow,\n      currentParent\n    );\n    if (!target) {\n      // make a guess to avoid assertions in calling code\n      if (this.currentType == Type.void) this.currentType = Type.i32;\n      return module.unreachable();\n    }\n\n    switch (target.kind) {\n      case ElementKind.LOCAL: {\n        let local = <Local>target;\n        let localType = local.type;\n        assert(localType != Type.void);\n        if (this.pendingElements.has(local)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            local.internalName\n          );\n          this.currentType = localType;\n          return module.unreachable();\n        }\n        if (local.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(local, contextualType, constraints);\n        }\n        let localIndex = local.index;\n        assert(localIndex >= 0);\n        if (localType.isNullableReference && flow.isLocalFlag(localIndex, LocalFlags.NONNULL, false)) {\n          localType = localType.nonNullableType;\n        }\n        this.currentType = localType;\n\n        if (target.parent != flow.parentFunction) {\n          // TODO: closures\n          this.error(\n            DiagnosticCode.Not_implemented_0,\n            expression.range,\n            \"Closures\"\n          );\n          return module.unreachable();\n        }\n        return module.local_get(localIndex, localType.toNativeType());\n      }\n      case ElementKind.GLOBAL: {\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) { // reports; not yet compiled if a static field\n          return module.unreachable();\n        }\n        let globalType = global.type;\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        assert(globalType != Type.void);\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, contextualType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toNativeType());\n      }\n      case ElementKind.ENUMVALUE: { // here: if referenced from within the same enum\n        let enumValue = <EnumValue>target;\n        if (!target.is(CommonFlags.COMPILED)) {\n          this.error(\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\n            expression.range\n          );\n          this.currentType = Type.i32;\n          return module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return module.i32(i64_low(enumValue.constantIntegerValue));\n        }\n        return module.global_get(enumValue.internalName, NativeType.I32);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let typeParameterNodes = functionPrototype.typeParameterNodes;\n\n        if (typeParameterNodes !== null && typeParameterNodes.length != 0) {\n          this.error(\n            DiagnosticCode.Expected_0_arguments_but_got_1,\n            expression.range, typeParameterNodes.length.toString(), \"0\"\n          );\n          return module.unreachable();\n        }\n\n        let functionInstance = this.resolver.resolveFunction(\n          functionPrototype,\n          null,\n          uniqueMap<string,Type>(flow.contextualTypeArguments)\n        );\n        if (!functionInstance || !this.compileFunction(functionInstance)) return module.unreachable();\n        if (contextualType.isExternalReference) {\n          this.currentType = Type.funcref;\n          return module.ref_func(functionInstance.internalName);\n        }\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        this.currentType = functionInstance.signature.type;\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    assert(false);\n    return this.module.unreachable();\n  }\n\n  private compileInstanceOfExpression(\n    expression: InstanceOfExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var flow = this.currentFlow;\n    var isType = expression.isType;\n\n    // Mimic `instanceof CLASS`\n    if (isType.kind == NodeKind.NAMEDTYPE) {\n      let namedType = <NamedTypeNode>isType;\n      if (!(namedType.isNullable || namedType.hasTypeArguments)) {\n        let element = this.resolver.resolveTypeName(namedType.name, flow.actualFunction, ReportMode.SWALLOW);\n        if (element !== null && element.kind == ElementKind.CLASS_PROTOTYPE) {\n          let prototype = <ClassPrototype>element;\n          if (prototype.is(CommonFlags.GENERIC)) {\n            return this.makeInstanceofClass(expression, prototype);\n          }\n        }\n      }\n    }\n\n    // Fall back to `instanceof TYPE`\n    var expectedType = this.resolver.resolveType(\n      expression.isType,\n      flow.actualFunction,\n      uniqueMap(flow.contextualTypeArguments)\n    );\n    if (!expectedType) {\n      this.currentType = Type.bool;\n      return this.module.unreachable();\n    }\n    return this.makeInstanceofType(expression, expectedType);\n  }\n\n  private makeInstanceofType(expression: InstanceOfExpression, expectedType: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var expr = this.compileExpression(expression.expression, expectedType);\n    var actualType = this.currentType;\n    this.currentType = Type.bool;\n\n    // instanceof <value> - must be exact\n    if (expectedType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(actualType == expectedType ? 1 : 0));\n    }\n\n    // <value> instanceof <nonValue> - always false\n    if (actualType.isValue) {\n      return module.maybeDropCondition(expr, module.i32(0));\n    }\n\n    // both LHS and RHS are references now\n    var nativeSizeType = actualType.toNativeType();\n\n    // <nullable> instanceof <nonNullable> - LHS must be != 0\n    if (actualType.isNullableReference && !expectedType.isNullableReference) {\n\n      // downcast - check statically\n      if (actualType.nonNullableType.isAssignableTo(expectedType)) {\n        return module.binary(\n          nativeSizeType == NativeType.I64\n            ? BinaryOp.NeI64\n            : BinaryOp.NeI32,\n          expr,\n          this.makeZero(actualType, expression.expression)\n        );\n      }\n\n      // upcast - check dynamically\n      if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              nativeSizeType == NativeType.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, nativeSizeType),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          if (this.options.pedantic) {\n            this.pedantic(\n              DiagnosticCode.Expression_compiles_to_a_dynamic_check_at_runtime,\n              expression.range\n            );\n          }\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n\n    // either none or both nullable\n    } else {\n\n      // downcast - check statically\n      if (actualType.isAssignableTo(expectedType)) {\n        return module.maybeDropCondition(expr, module.i32(1));\n\n      // upcast - check dynamically\n      } else if (expectedType.isAssignableTo(actualType)) {\n        let program = this.program;\n        if (!(actualType.isUnmanaged || expectedType.isUnmanaged)) {\n          // FIXME: the temp local and the if can be removed here once flows\n          // perform null checking, which would error earlier when checking\n          // uninitialized (thus zero) `var a: A` to be an instance of something.\n          let temp = flow.getTempLocal(actualType);\n          let instanceofInstance = assert(program.instanceofInstance);\n          this.compileFunction(instanceofInstance);\n          let ret = module.if(\n            module.unary(\n              nativeSizeType == NativeType.I64\n                ? UnaryOp.EqzI64\n                : UnaryOp.EqzI32,\n              module.local_tee(temp.index, expr),\n            ),\n            module.i32(0),\n            this.makeCallDirect(instanceofInstance, [\n              module.local_get(temp.index, nativeSizeType),\n              module.i32(expectedType.classReference!.id)\n            ], expression)\n          );\n          flow.freeTempLocal(temp);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n            expression.range, \"instanceof\", actualType.toString(), expectedType.toString()\n          );\n        }\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private makeInstanceofClass(expression: InstanceOfExpression, prototype: ClassPrototype): ExpressionRef {\n    var module = this.module;\n    var expr = this.compileExpression(expression.expression, Type.auto);\n    var actualType = this.currentType;\n    var nativeSizeType = actualType.toNativeType();\n\n    this.currentType = Type.bool;\n\n    // exclusively interested in class references here\n    var classReference = actualType.getClass();\n    if (classReference) {\n\n      // static check\n      if (classReference.extends(prototype)) {\n\n        // <nullable> instanceof <PROTOTYPE> - LHS must be != 0\n        if (actualType.isNullableReference) {\n          return module.binary(\n            nativeSizeType == NativeType.I64\n              ? BinaryOp.NeI64\n              : BinaryOp.NeI32,\n            expr,\n            this.makeZero(actualType, expression.expression)\n          );\n\n        // <nonNullable> is just `true`\n        } else {\n          return module.maybeDropCondition(expr, module.i32(1));\n        }\n\n      // dynamic check against all possible concrete ids\n      } else if (prototype.extends(classReference.prototype)) {\n        this.pendingClassInstanceOf.add(prototype);\n        return module.call(prototype.internalName + \"~instanceof\", [ expr ], NativeType.I32);\n      }\n    }\n\n    // false\n    return module.maybeDropCondition(expr, module.i32(0));\n  }\n\n  private compileLiteralExpression(\n    expression: LiteralExpression,\n    contextualType: Type,\n    constraints: Constraints,\n    implicitlyNegate: bool = false\n  ): ExpressionRef {\n    var module = this.module;\n    switch (expression.literalKind) {\n      case LiteralKind.ARRAY: {\n        assert(!implicitlyNegate);\n        return this.compileArrayLiteral(\n          <ArrayLiteralExpression>expression,\n          contextualType,\n          constraints\n        );\n      }\n      case LiteralKind.FLOAT: {\n        let floatValue = (<FloatLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          floatValue = -floatValue;\n        }\n        if (contextualType == Type.f32) {\n          return module.f32(<f32>floatValue);\n        }\n        this.currentType = Type.f64;\n        return module.f64(floatValue);\n      }\n      case LiteralKind.INTEGER: {\n        let intValue = (<IntegerLiteralExpression>expression).value;\n        if (implicitlyNegate) {\n          intValue = i64_sub(\n            i64_new(0),\n            intValue\n          );\n        }\n        let type = this.resolver.determineIntegerLiteralType(intValue, contextualType);\n        this.currentType = type;\n        switch (type.kind) {\n          case TypeKind.ISIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.I64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.USIZE: if (!this.options.isWasm64) return module.i32(i64_low(intValue));\n          case TypeKind.U64: return module.i64(i64_low(intValue), i64_high(intValue));\n          case TypeKind.F32: return module.f32(i64_to_f32(intValue));\n          case TypeKind.F64: return module.f64(i64_to_f64(intValue));\n          default: return module.i32(i64_low(intValue));\n        }\n      }\n      case LiteralKind.STRING: {\n        assert(!implicitlyNegate);\n        return this.compileStringLiteral(<StringLiteralExpression>expression, constraints);\n      }\n      case LiteralKind.OBJECT: {\n        assert(!implicitlyNegate);\n        return this.compileObjectLiteral(<ObjectLiteralExpression>expression, contextualType);\n      }\n      case LiteralKind.REGEXP: {\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          expression.range,\n          \"Regular expressions\"\n        );\n        this.currentType = contextualType;\n        return module.unreachable();\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileStringLiteral(\n    expression: StringLiteralExpression,\n    constraints: Constraints\n  ): ExpressionRef {\n    var expr = this.ensureStaticString(expression.value);\n    if (constraints & Constraints.WILL_RETAIN) {\n      this.skippedAutoreleases.add(expr);\n    } else {\n      // not necessary since this is static data anyway\n      // expr = this.makeAutorelease(expr, this.currentType);\n    }\n    return expr;\n  }\n\n  private compileArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // handle static arrays\n    let contextualClass = contextualType.getClass();\n    if (contextualClass !== null && contextualClass.extends(program.staticArrayPrototype)) {\n      return this.compileStaticArrayLiteral(expression, contextualType, constraints);\n    }\n\n    // handle normal arrays\n    var element = this.resolver.lookupExpression(expression, flow, this.currentType);\n    if (!element) return module.unreachable();\n    assert(element.kind == ElementKind.CLASS);\n    var arrayInstance = <Class>element;\n    var arrayType = arrayInstance.type;\n    var elementType = arrayInstance.getTypeArgumentsTo(program.arrayPrototype)![0];\n    var arrayBufferInstance = assert(program.arrayBufferInstance);\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n    var tempDataStart = flow.getTempLocal(arrayBufferInstance.type);\n\n    // compile value expressions and find out whether all are constant\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var isStatic = !elementType.isExternalReference;\n    var nativeElementType = elementType.toNativeType();\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(<Expression>elementExpression, elementType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n\n      let runtimeHeaderSize = program.runtimeHeaderSize;\n      let bufferSegment = this.addStaticBuffer(elementType, values);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(runtimeHeaderSize));\n\n      // make both the buffer and array header static if assigned to a global. this can't be done\n      // if inside of a function because each invocation must create a new array reference then.\n      if (constraints & Constraints.PREFER_STATIC) {\n        let arraySegment = this.addStaticArrayHeader(elementType, bufferSegment);\n        let arrayAddress = i64_add(arraySegment.offset, i64_new(runtimeHeaderSize));\n        this.currentType = arrayType;\n        return program.options.isWasm64\n          ? this.module.i64(i64_low(arrayAddress), i64_high(arrayAddress))\n          : this.module.i32(i64_low(arrayAddress));\n\n      // otherwise allocate a new array header and make it wrap a copy of the static buffer\n      } else {\n        // __newArray(length, alignLog2, classId, staticBuffer)\n        let expr = this.makeCallDirect(program.newArrayInstance, [\n          module.i32(length),\n          program.options.isWasm64\n            ? module.i64(elementType.alignLog2)\n            : module.i32(elementType.alignLog2),\n          module.i32(arrayInstance.id),\n          program.options.isWasm64\n            ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n            : module.i32(i64_low(bufferAddress))\n        ], expression);\n        this.currentType = arrayType;\n        expr = this.makeRetain(expr, arrayType);\n        if (arrayType.isManaged) {\n          if (!(constraints & Constraints.WILL_RETAIN)) {\n            expr = this.makeAutorelease(expr, arrayType);\n          } else {\n            this.skippedAutoreleases.add(expr);\n          }\n        }\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var setter = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!setter) {\n      flow.freeTempLocal(tempThis);\n      flow.freeTempLocal(tempDataStart);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var nativeArrayType = arrayType.toNativeType();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newArray(length, alignLog2, classId, source = 0)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeRetain(\n          this.makeCallDirect(program.newArrayInstance, [\n            module.i32(length),\n            program.options.isWasm64\n              ? module.i64(elementType.alignLog2)\n              : module.i32(elementType.alignLog2),\n            module.i32(arrayInstance.id),\n            program.options.isWasm64\n              ? module.i64(0)\n              : module.i32(0)\n          ], expression),\n          arrayType\n        )\n      )\n    );\n    // tempData = tempThis.dataStart\n    var dataStartMember = assert(arrayInstance.lookupInSelf(\"dataStart\"));\n    assert(dataStartMember.kind == ElementKind.FIELD);\n    stmts.push(\n      module.local_set(tempDataStart.index,\n        module.load(arrayType.byteSize, false,\n          module.local_get(tempThis.index, nativeArrayType),\n          nativeArrayType,\n          (<Field>dataStartMember).memoryOffset\n        )\n      )\n    );\n    var isManaged = elementType.isManaged;\n    for (let i = 0, alignLog2 = elementType.alignLog2; i < length; ++i) {\n      let valueExpr = values[i];\n      if (isManaged) {\n        // value = __retain(value)\n        if (!this.skippedAutoreleases.has(valueExpr)) {\n          valueExpr = this.makeRetain(valueExpr, elementType);\n        }\n      }\n      // store<T>(tempData, value, immOffset)\n      stmts.push(\n        module.store(elementType.byteSize,\n          module.local_get(tempDataStart.index, nativeArrayType),\n          valueExpr,\n          nativeElementType,\n          i << alignLog2\n        )\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, nativeArrayType)\n    );\n    flow.freeTempLocal(tempThis);\n    flow.freeTempLocal(tempDataStart);\n    this.currentType = arrayType;\n    var expr = module.flatten(stmts, nativeArrayType);\n    if (arrayType.isManaged) {\n      if (constraints & Constraints.WILL_RETAIN) {\n        this.skippedAutoreleases.add(expr);\n      } else {\n        expr = this.makeAutorelease(expr, arrayType, this.currentFlow);\n      }\n    }\n    return expr;\n  }\n\n  /** Compiles a special `fixed` array literal. */\n  private compileStaticArrayLiteral(\n    expression: ArrayLiteralExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var program = this.program;\n\n    // make sure this method is only called with a valid contextualType\n    var arrayInstance = assert(contextualType.getClass());\n    var arrayType = arrayInstance.type;\n    var typeArguments = assert(arrayInstance.getTypeArgumentsTo(program.staticArrayPrototype));\n    var elementType = typeArguments[0];\n\n    // block those here so compiling expressions doesn't conflict\n    var tempThis = flow.getTempLocal(this.options.usizeType);\n\n    // compile value expressions and check if all are compile-time constants\n    var expressions = expression.elementExpressions;\n    var length = expressions.length;\n    var values = new Array<ExpressionRef>(length);\n    var nativeElementType = elementType.toNativeType();\n    var isStatic = !elementType.isExternalReference;\n    for (let i = 0; i < length; ++i) {\n      let elementExpression = expressions[i];\n      if (elementExpression.kind != NodeKind.OMITTED) {\n        let expr = this.compileExpression(elementExpression, elementType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        let precomp = module.runExpression(expr, ExpressionRunnerFlags.PreserveSideeffects);\n        if (precomp) {\n          expr = precomp;\n        } else {\n          isStatic = false;\n        }\n        values[i] = expr;\n      } else {\n        values[i] = this.makeZero(elementType, elementExpression);\n      }\n    }\n\n    var isWasm64 = this.options.isWasm64;\n    var bufferSize = values.length << elementType.alignLog2;\n\n    // if the array is static, make a static arraybuffer segment\n    if (isStatic) {\n      flow.freeTempLocal(tempThis);\n\n      let bufferSegment = this.addStaticBuffer(elementType, values, arrayInstance.id);\n      let bufferAddress = i64_add(bufferSegment.offset, i64_new(program.runtimeHeaderSize));\n\n      // return the static buffer directly if assigned to a global\n      if (constraints & Constraints.PREFER_STATIC) {\n        let expr = this.options.isWasm64\n          ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n          : module.i32(i64_low(bufferAddress));\n        if (constraints & Constraints.WILL_RETAIN) {\n          this.skippedAutoreleases.add(expr);\n        } else {\n          // not necessary since this is static data anyway\n          // expr = this.makeAutorelease(expr, arrayType, flow);\n        }\n        this.currentType = arrayType;\n        return expr;\n\n      // otherwise allocate a new chunk of memory and return a copy of the buffer\n      } else {\n        // __newBuffer(bufferSize, id, buffer)\n        let expr = this.makeRetain(\n          this.makeCallDirect(program.newBufferInstance, [\n            isWasm64\n              ? module.i64(bufferSize)\n              : module.i32(bufferSize),\n            module.i32(arrayInstance.id),\n            isWasm64\n              ? module.i64(i64_low(bufferAddress), i64_high(bufferAddress))\n              : module.i32(i64_low(bufferAddress))\n          ], expression),\n          program.arrayBufferInstance.type\n        );\n        if (arrayType.isManaged) {\n          if (constraints & Constraints.WILL_RETAIN) {\n            this.skippedAutoreleases.add(expr);\n          } else {\n            expr = this.makeAutorelease(expr, arrayType);\n          }\n        }\n        this.currentType = arrayType;\n        return expr;\n      }\n    }\n\n    // otherwise compile an explicit instantiation with indexed sets\n    var setter = arrayInstance.lookupOverload(OperatorKind.INDEXED_SET, true);\n    if (!setter) {\n      flow.freeTempLocal(tempThis);\n      this.error(\n        DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\n        expression.range, arrayInstance.internalName\n      );\n      this.currentType = arrayType;\n      return module.unreachable();\n    }\n    var nativeArrayType = arrayType.toNativeType();\n\n    var stmts = new Array<ExpressionRef>();\n    // tempThis = __newBuffer(bufferSize, classId)\n    stmts.push(\n      module.local_set(tempThis.index,\n        this.makeRetain(\n          this.makeCallDirect(program.newBufferInstance, [\n            isWasm64\n              ? module.i64(bufferSize)\n              : module.i32(bufferSize),\n            module.i32(arrayInstance.id)\n          ], expression),\n          program.arrayBufferInstance.type\n        )\n      )\n    );\n    var isManaged = elementType.isManaged;\n    for (let i = 0, alignLog2 = elementType.alignLog2; i < length; ++i) {\n      let valueExpr = values[i];\n      if (isManaged) {\n        // value = __retain(value)\n        if (!this.skippedAutoreleases.has(valueExpr)) {\n          valueExpr = this.makeRetain(valueExpr, elementType);\n        }\n      }\n      // store<T>(tempThis, value, immOffset)\n      stmts.push(\n        module.store(elementType.byteSize,\n          module.local_get(tempThis.index, nativeArrayType),\n          valueExpr,\n          nativeElementType,\n          i << alignLog2\n        )\n      );\n    }\n    // -> tempThis\n    stmts.push(\n      module.local_get(tempThis.index, nativeArrayType)\n    );\n    flow.freeTempLocal(tempThis);\n    this.currentType = arrayType;\n    var expr = module.flatten(stmts, nativeArrayType);\n    if (arrayType.isManaged) {\n      if (constraints & Constraints.WILL_RETAIN) {\n        this.skippedAutoreleases.add(expr);\n      } else {\n        expr = this.makeAutorelease(expr, arrayType, this.currentFlow);\n      }\n    }\n    return expr;\n  }\n\n  private compileObjectLiteral(expression: ObjectLiteralExpression, contextualType: Type): ExpressionRef {\n    var module = this.module;\n\n    // Check that contextual type is a class (TODO: hidden class for interfaces?)\n    var classReference = contextualType.getClass();\n    if (!classReference) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        expression.range, \"<object>\", contextualType.toString()\n      );\n      return module.unreachable();\n    }\n    var classType = classReference.type;\n    this.currentType = classType.nonNullableType;\n    if (classReference.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.range\n      );\n      return module.unreachable();\n    }\n\n    // Check that the class is compatible with object literals\n    var ctorPrototype = classReference.prototype.constructorPrototype;\n    if (ctorPrototype) {\n      this.errorRelated(\n        DiagnosticCode.Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal,\n        expression.range, ctorPrototype.identifierNode.range, classType.toString()\n      );\n      return module.unreachable();\n    }\n\n    var isManaged = classType.isManaged;\n    if (!isManaged) {\n      this.checkUnsafe(expression, findDecorator(DecoratorKind.UNMANAGED, classReference.decoratorNodes));\n    }\n\n    // check and compile field values\n    var names = expression.names;\n    var numNames = names.length;\n    var values = expression.values;\n    var members = classReference.members;\n    var hasErrors = false;\n    var exprs = new Array<ExpressionRef>();\n    var flow = this.currentFlow;\n    var tempLocal = isManaged\n      ? flow.getAutoreleaseLocal(classType)\n      : flow.getTempLocal(classType);\n    var nativeClassType = classType.toNativeType();\n    assert(numNames == values.length);\n\n    // Assume all class fields will be omitted, and add them to our omitted list\n    var omittedFields = new Set<Field>();\n    if (members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberKey = _keys[i];\n        let member = assert(members.get(memberKey));\n        if (member !== null && member.kind == ElementKind.FIELD) {\n          omittedFields.add(<Field>member); // incl. private/protected\n        }\n      }\n    }\n\n    // Iterate through the members defined in our expression\n    for (let i = 0; i < numNames; ++i) {\n      let memberName = names[i].text;\n      let member: DeclaredElement;\n      if (!members || !members.has(memberName) || (member = assert(members.get(memberName))).kind != ElementKind.FIELD) {\n        this.error(\n          DiagnosticCode.Property_0_does_not_exist_on_type_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PRIVATE)) {\n        this.error(\n          DiagnosticCode.Property_0_is_private_and_only_accessible_within_class_1,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      if (member.is(CommonFlags.PROTECTED)) {\n        this.error(\n          DiagnosticCode.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses,\n          names[i].range, memberName, classType.toString()\n        );\n        hasErrors = true;\n        continue;\n      }\n      let fieldInstance = <Field>member;\n      let fieldType = fieldInstance.type;\n\n      let expr = this.compileExpression(values[i], fieldType, Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN);\n      if (fieldType.isManaged && !this.skippedAutoreleases.has(expr)) {\n        expr = this.makeRetain(expr, fieldType);\n      }\n      exprs.push(\n        module.store( // TODO: handle setters as well\n          fieldType.byteSize,\n          module.local_get(tempLocal.index, nativeClassType),\n          expr,\n          fieldType.toNativeType(),\n          fieldInstance.memoryOffset\n        )\n      );\n\n      // This member is no longer omitted, so delete from our omitted fields\n      omittedFields.delete(fieldInstance);\n    }\n    this.currentType = classType.nonNullableType;\n    if (hasErrors) return module.unreachable();\n\n    // Check remaining omitted fields\n    for (let _values = Set_values(omittedFields), j = 0, l = _values.length; j < l; ++j) {\n      let fieldInstance = _values[j];\n      let fieldType = fieldInstance.type;\n\n      if (fieldInstance.initializerNode) {\n        continue; // set by generated ctor\n      }\n\n      if (fieldType.isReference) {\n        if (!fieldType.isNullableReference) {\n          this.error(\n            DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n            expression.range, fieldInstance.name, \"<object>\", classType.toString()\n          );\n          hasErrors = true;\n          continue;\n        }\n      }\n\n      switch (fieldType.kind) {\n        // Number Types (and Number alias types)\n        case TypeKind.I8:\n        case TypeKind.I16:\n        case TypeKind.I32:\n        case TypeKind.I64:\n        case TypeKind.ISIZE:\n        case TypeKind.U8:\n        case TypeKind.U16:\n        case TypeKind.U32:\n        case TypeKind.U64:\n        case TypeKind.USIZE:\n        case TypeKind.BOOL:\n        case TypeKind.F32:\n        case TypeKind.F64: {\n          exprs.push(\n            module.store( // TODO: handle setters as well\n              fieldType.byteSize,\n              module.local_get(tempLocal.index, nativeClassType),\n              this.makeZero(fieldType, expression),\n              fieldType.toNativeType(),\n              fieldInstance.memoryOffset\n            )\n          );\n          continue;\n        }\n      }\n\n      // Otherwise error\n      this.error(\n        DiagnosticCode.Property_0_is_missing_in_type_1_but_required_in_type_2,\n        expression.range, fieldInstance.name, \"<object>\", classType.toString()\n      );\n      hasErrors = true;\n    }\n    if (hasErrors) return module.unreachable();\n\n    // generate the default constructor\n    var ctor = this.ensureConstructor(classReference, expression);\n    // note that this is not checking field initialization within the ctor, but\n    // instead checks conditions above with provided fields taken into account.\n\n    // allocate a new instance first and assign 'this' to the temp. local\n    exprs.unshift(\n      module.local_set(tempLocal.index,\n        this.compileInstantiate(ctor, [], Constraints.WILL_RETAIN, expression)\n      )\n    );\n\n    // once all field values have been set, return 'this'\n    exprs.push(\n      module.local_get(tempLocal.index, nativeClassType)\n    );\n\n    if (!isManaged) flow.freeTempLocal(tempLocal);\n    this.currentType = classType.nonNullableType;\n    return module.flatten(exprs, nativeClassType);\n  }\n\n  private compileNewExpression(\n    expression: NewExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // obtain the class being instantiated\n    var target = this.resolver.resolveTypeName(expression.typeName, flow.actualFunction);\n    if (!target) return module.unreachable();\n    if (target.kind != ElementKind.CLASS_PROTOTYPE) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    if (target.is(CommonFlags.ABSTRACT)) {\n      this.error(\n        DiagnosticCode.Cannot_create_an_instance_of_an_abstract_class,\n        expression.typeName.range\n      );\n      return this.module.unreachable();\n    }\n    var classPrototype = <ClassPrototype>target;\n    var classInstance: Class | null = null;\n    var typeArguments = expression.typeArguments;\n    var classReference: Class | null;\n    if (\n      !typeArguments &&\n      (classReference = contextualType.classReference) !== null &&\n      classReference.is(CommonFlags.GENERIC)\n    ) {\n      classInstance = this.resolver.resolveClass(\n        classPrototype,\n        classReference.typeArguments,\n        uniqueMap<string,Type>(flow.contextualTypeArguments)\n      );\n    } else {\n      classInstance = this.resolver.resolveClassInclTypeArguments(\n        classPrototype,\n        typeArguments,\n        flow.actualFunction.parent, // relative to caller\n        uniqueMap<string,Type>(flow.contextualTypeArguments),\n        expression\n      );\n    }\n    if (!classInstance) return module.unreachable();\n    if (contextualType == Type.void) constraints |= Constraints.WILL_DROP;\n    var ctor = this.ensureConstructor(classInstance, expression);\n    if (!ctor.hasDecorator(DecoratorFlags.INLINE)) {\n      // Inlined ctors haven't been compiled yet and are checked upon inline\n      // compilation of their body instead.\n      this.checkFieldInitialization(classInstance, expression);\n    }\n    return this.compileInstantiate(ctor, expression.args, constraints, expression);\n  }\n\n  /** Gets the compiled constructor of the specified class or generates one if none is present. */\n  ensureConstructor(\n    /** Class wanting a constructor. */\n    classInstance: Class,\n    /** Report node. */\n    reportNode: Node\n  ): Function {\n    var instance = classInstance.constructorInstance;\n    if (instance) {\n      // shortcut if already compiled\n      if (instance.is(CommonFlags.COMPILED)) return instance;\n      // do not attempt to compile if inlined anyway\n      if (!instance.hasDecorator(DecoratorFlags.INLINE)) this.compileFunction(instance);\n    } else {\n      // clone base constructor if a derived class\n      let baseClass = classInstance.base;\n      let contextualTypeArguments = uniqueMap(classInstance.contextualTypeArguments);\n      if (baseClass) {\n        let baseCtor = this.ensureConstructor(baseClass, reportNode);\n        this.checkFieldInitialization(baseClass, reportNode);\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance,\n            // declaration is important, i.e. to access optional parameter initializers\n            (<FunctionDeclaration>baseCtor.declaration).clone()\n          ),\n          null,\n          baseCtor.signature,\n          contextualTypeArguments\n        );\n\n      // otherwise make a default constructor\n      } else {\n        instance = new Function(\n          CommonNames.constructor,\n          new FunctionPrototype(\n            CommonNames.constructor,\n            classInstance, // bound\n            this.program.makeNativeFunctionDeclaration(CommonNames.constructor,\n              CommonFlags.INSTANCE | CommonFlags.CONSTRUCTOR\n            )\n          ),\n          null,\n          new Signature(this.program, null, classInstance.type, classInstance.type),\n          contextualTypeArguments\n        );\n        let members = classInstance.members;\n        if (!members) classInstance.members = members = new Map();\n        members.set(\"constructor\", instance.prototype);\n      }\n\n      instance.internalName = classInstance.internalName + INSTANCE_DELIMITER + \"constructor\";\n      instance.set(CommonFlags.COMPILED);\n      instance.prototype.setResolvedInstance(\"\", instance);\n      classInstance.constructorInstance = instance;\n      let previousFlow = this.currentFlow;\n      let flow = instance.flow;\n      this.currentFlow = flow;\n\n      // generate body\n      let signature = instance.signature;\n      let module = this.module;\n      let nativeSizeType = this.options.nativeSizeType;\n      let stmts = new Array<ExpressionRef>();\n\n      // {\n      //   if (!this) this = <ALLOC>\n      //   IF_DERIVED: this = super(this, ...args)\n      //   this.a = X\n      //   this.b = Y\n      //   return this\n      // }\n      let allocExpr = this.makeAllocation(classInstance);\n      let classType = classInstance.type;\n      if (classType.isManaged) allocExpr = this.makeRetain(allocExpr, classType);\n      stmts.push(\n        module.if(\n          module.unary(nativeSizeType == NativeType.I64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32,\n            module.local_get(0, nativeSizeType)\n          ),\n          module.local_set(0, allocExpr)\n        )\n      );\n      if (baseClass) {\n        let parameterTypes = signature.parameterTypes;\n        let numParameters = parameterTypes.length;\n        let operands = new Array<ExpressionRef>(1 + numParameters);\n        operands[0] = module.local_get(0, nativeSizeType);\n        for (let i = 1; i <= numParameters; ++i) {\n          operands[i] = module.local_get(i, parameterTypes[i - 1].toNativeType());\n        }\n        stmts.push(\n          module.local_set(0,\n            this.makeCallDirect(assert(baseClass.constructorInstance), operands, reportNode, false, true)\n          )\n        );\n      }\n      this.makeFieldInitializationInConstructor(classInstance, stmts);\n      let body = this.performAutoreleasesWithValue(flow, module.local_get(0, nativeSizeType), classInstance.type, stmts);\n      flow.freeScopedLocals();\n      this.currentFlow = previousFlow;\n\n      // make the function\n      let locals = instance.localsByIndex;\n      let varTypes = new Array<NativeType>(); // of temp. vars added while compiling initializers\n      let numOperands = 1 + signature.parameterTypes.length;\n      let numLocals = locals.length;\n      if (numLocals > numOperands) {\n        for (let i = numOperands; i < numLocals; ++i) varTypes.push(locals[i].type.toNativeType());\n      }\n      let funcRef = module.addFunction(instance.internalName, signature.nativeParams, signature.nativeResults, varTypes, body);\n      instance.finalize(module, funcRef);\n    }\n\n    return instance;\n  }\n\n  /** Checks that all class fields have been initialized. */\n  checkFieldInitialization(classInstance: Class, relatedNode: Node | null = null): void {\n    if (classInstance.didCheckFieldInitialization) return;\n    classInstance.didCheckFieldInitialization = true;\n    var ctor = assert(classInstance.constructorInstance);\n    this.checkFieldInitializationInFlow(classInstance, ctor.flow, relatedNode);\n  }\n\n  /** Checks that all class fields have been initialized in the specified flow. */\n  checkFieldInitializationInFlow(classInstance: Class, flow: Flow, relatedNode: Node | null = null): void {\n    var members = classInstance.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let element = _values[i];\n        if (element.kind == ElementKind.FIELD && element.parent == classInstance) {\n          let field = <Field>element;\n          if (!field.initializerNode && !flow.isThisFieldFlag(field, FieldFlags.INITIALIZED)) {\n            if (!field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n              if (relatedNode) {\n                this.errorRelated(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  relatedNode.range,\n                  field.internalName\n                );\n              } else {\n                this.error(\n                  DiagnosticCode.Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned,\n                  field.declaration.name.range,\n                  field.internalName\n                );\n              }\n            }\n          } else if (field.is(CommonFlags.DEFINITELY_ASSIGNED)) {\n            if (field.type.isReference) {\n              this.warning( // involves a runtime check\n                DiagnosticCode.Property_0_is_always_assigned_before_being_used,\n                field.identifierNode.range,\n                field.internalName\n              );\n            } else {\n              this.pedantic( // is a nop anyway\n                DiagnosticCode.Unnecessary_definite_assignment,\n                field.identifierNode.range\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  compileInstantiate(\n    /** Constructor to call. */\n    ctorInstance: Function,\n    /** Constructor arguments. */\n    argumentExpressions: Expression[],\n    /** Contextual flags. */\n    constraints: Constraints,\n    /** Node to report on. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(ctorInstance.is(CommonFlags.CONSTRUCTOR));\n    var parent = ctorInstance.parent;\n    assert(parent.kind == ElementKind.CLASS);\n    var classInstance = <Class>parent;\n    if (classInstance.type.isUnmanaged || ctorInstance.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(reportNode);\n    var expr = this.compileCallDirect( // no need for another autoreleased local\n      ctorInstance,\n      argumentExpressions,\n      reportNode,\n      this.makeZero(this.options.usizeType, reportNode),\n      constraints\n    );\n    if (getExpressionType(expr) != NativeType.None) { // possibly WILL_DROP\n      this.currentType = classInstance.type; // important because a super ctor could be called\n    }\n    return expr;\n  }\n\n  private compilePropertyAccessExpression(\n    expression: PropertyAccessExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    this.maybeCompileEnclosingSource(expression);\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression, flow, ctxType); // reports\n    if (!target) return module.unreachable();\n    var thisExpression = resolver.currentThisExpression;\n    if (target.hasDecorator(DecoratorFlags.UNSAFE)) this.checkUnsafe(expression);\n\n    switch (target.kind) {\n      case ElementKind.GLOBAL: { // static field\n        let global = <Global>target;\n        if (!this.compileGlobal(global)) return module.unreachable(); // reports\n        let globalType = global.type;\n        assert(globalType != Type.void);\n        if (this.pendingElements.has(global)) {\n          this.error(\n            DiagnosticCode.Variable_0_used_before_its_declaration,\n            expression.range,\n            global.internalName\n          );\n          this.currentType = globalType;\n          return module.unreachable();\n        }\n        if (global.is(CommonFlags.INLINED)) {\n          return this.compileInlineConstant(global, ctxType, constraints);\n        }\n        this.currentType = globalType;\n        return module.global_get(global.internalName, globalType.toNativeType());\n      }\n      case ElementKind.ENUMVALUE: { // enum value\n        let enumValue = <EnumValue>target;\n        let parent = assert(enumValue.parent);\n        assert(parent.kind == ElementKind.ENUM);\n        let parentEnum = <Enum>parent;\n        if (!this.compileEnum(parentEnum)) {\n          this.currentType = Type.i32;\n          return this.module.unreachable();\n        }\n        this.currentType = Type.i32;\n        if (enumValue.is(CommonFlags.INLINED)) {\n          assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n          return this.compileInlineConstant(enumValue, ctxType, constraints);\n        }\n        assert(enumValue.type == Type.i32);\n        return module.global_get(enumValue.internalName, NativeType.I32);\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>target;\n        let fieldType = fieldInstance.type;\n        assert(fieldInstance.memoryOffset >= 0);\n        let fieldParent = fieldInstance.parent;\n        assert(fieldParent.kind == ElementKind.CLASS);\n        thisExpression = assert(thisExpression);\n        let thisExpr = this.compileExpression(\n          thisExpression,\n          (<Class>fieldParent).type,\n          Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n        );\n        let thisType = this.currentType;\n        if (\n          flow.actualFunction.is(CommonFlags.CONSTRUCTOR) &&\n          thisExpression.kind == NodeKind.THIS &&\n          !flow.isThisFieldFlag(fieldInstance, FieldFlags.INITIALIZED) &&\n          !fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED)\n        ) {\n          this.errorRelated(\n            DiagnosticCode.Property_0_is_used_before_being_assigned,\n            expression.range,\n            fieldInstance.identifierNode.range,\n            fieldInstance.internalName\n          );\n        }\n        if (thisType.isNullableReference) {\n          if (!flow.isNonnull(thisExpr, thisType)) {\n            this.error(\n              DiagnosticCode.Object_is_possibly_null,\n              thisExpression.range\n            );\n          }\n        }\n        if (!fieldInstance.is(CommonFlags.COMPILED)) {\n          fieldInstance.set(CommonFlags.COMPILED);\n          let typeNode = fieldInstance.typeNode;\n          if (typeNode) this.checkTypeSupported(fieldInstance.type, typeNode);\n        }\n        this.currentType = fieldType;\n        let ret = module.load(\n          fieldType.byteSize,\n          fieldType.isSignedIntegerValue,\n          thisExpr,\n          fieldType.toNativeType(),\n          fieldInstance.memoryOffset\n        );\n        if (fieldInstance.is(CommonFlags.DEFINITELY_ASSIGNED) && fieldType.isReference && !fieldType.isNullableReference) {\n          ret = this.makeRuntimeNonNullCheck(ret, fieldType, expression);\n        }\n        return ret;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>target;\n        let propertyInstance = this.resolver.resolveProperty(propertyPrototype);\n        if (!propertyInstance) return module.unreachable();\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance);\n        let thisArg: ExpressionRef = 0;\n        if (getterInstance.is(CommonFlags.INSTANCE)) {\n          thisArg = this.compileExpression(\n            assert(thisExpression),\n            assert(getterInstance.signature.thisType),\n            Constraints.CONV_IMPLICIT | Constraints.IS_THIS\n          );\n        }\n        return this.compileCallDirect(getterInstance, [], expression, thisArg);\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        let functionInstance = this.resolver.resolveFunction(functionPrototype, null);\n        if (!functionInstance) return module.unreachable();\n        if (!this.compileFunction(functionInstance)) return module.unreachable();\n        this.currentType = functionInstance.type;\n        let offset = this.ensureRuntimeFunction(functionInstance);\n        return this.options.isWasm64\n          ? module.i64(i64_low(offset), i64_high(offset))\n          : module.i32(i64_low(offset));\n      }\n    }\n    assert(false);\n    return module.unreachable();\n  }\n\n  private compileTernaryExpression(\n    expression: TernaryExpression,\n    ctxType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var ifThen = expression.ifThen;\n    var ifElse = expression.ifElse;\n\n    var condExpr = this.makeIsTrueish(\n      this.compileExpression(expression.condition, Type.bool),\n      this.currentType,\n      expression.condition\n    );\n    // Try to eliminate unnecesssary branches if the condition is constant\n    // FIXME: skips common denominator, inconsistently picking branch type\n    var condKind = this.evaluateCondition(condExpr);\n    if (condKind == ConditionKind.TRUE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifThen, ctxType));\n    }\n    if (condKind == ConditionKind.FALSE) {\n      return module.maybeDropCondition(condExpr, this.compileExpression(ifElse, ctxType));\n    }\n\n    var inheritedConstraints = constraints & Constraints.WILL_RETAIN;\n\n    var outerFlow = this.currentFlow;\n    var ifThenFlow = outerFlow.fork();\n    ifThenFlow.inheritNonnullIfTrue(condExpr);\n    this.currentFlow = ifThenFlow;\n    var ifThenExpr = this.compileExpression(ifThen, ctxType, inheritedConstraints);\n    var ifThenType = this.currentType;\n    var ifThenAutoreleaseSkipped = this.skippedAutoreleases.has(ifThenExpr);\n\n    var ifElseFlow = outerFlow.fork();\n    ifElseFlow.inheritNonnullIfFalse(condExpr);\n    this.currentFlow = ifElseFlow;\n    var ifElseExpr = this.compileExpression(ifElse, ctxType == Type.auto ? ifThenType : ctxType, inheritedConstraints);\n    var ifElseType = this.currentType;\n    var ifElseAutoreleaseSkipped = this.skippedAutoreleases.has(ifElseExpr);\n\n    var commonType = Type.commonDenominator(ifThenType, ifElseType, false);\n    if (!commonType) {\n      this.error(\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n        ifElse.range, ifElseType.toString(), ifThenType.toString()\n      );\n      this.currentType = ctxType;\n      return module.unreachable();\n    }\n    ifThenExpr = this.convertExpression(ifThenExpr, ifThenType, commonType, false, ifThen);\n    ifThenType = commonType;\n    ifElseExpr = this.convertExpression(ifElseExpr, ifElseType, commonType, false, ifElse);\n    ifElseType = commonType;\n    this.currentType = commonType;\n\n    if (ifThenAutoreleaseSkipped != ifElseAutoreleaseSkipped) { // unify to both skipped\n      if (!ifThenAutoreleaseSkipped) {\n        ifThenExpr = this.makeRetain(ifThenExpr, ifThenType);\n        ifThenAutoreleaseSkipped = true;\n      } else {\n        ifElseExpr = this.makeRetain(ifElseExpr, ifElseType);\n        ifElseAutoreleaseSkipped = true;\n      }\n    } else if (!ifThenAutoreleaseSkipped && commonType.isManaged) { // keep alive a little longer\n      if (constraints & Constraints.WILL_RETAIN) { // try to undo both\n        let ifThenIndex = this.tryUndoAutorelease(ifThenExpr, ifThenFlow);\n        if (ifThenIndex == -1) ifThenExpr = this.makeRetain(ifThenExpr, ifThenType);\n        let ifElseIndex = this.tryUndoAutorelease(ifElseExpr, ifElseFlow);\n        if (ifElseIndex == -1) ifElseExpr = this.makeRetain(ifElseExpr, ifElseType);\n        ifThenAutoreleaseSkipped = true;\n        ifElseAutoreleaseSkipped = true;\n      } else {\n        ifThenExpr = this.delayAutorelease(ifThenExpr, ifThenType, ifThenFlow, outerFlow);\n        ifElseExpr = this.delayAutorelease(ifElseExpr, ifElseType, ifElseFlow, outerFlow);\n      }\n    }\n\n    ifThenExpr = this.performAutoreleasesWithValue(ifThenFlow, ifThenExpr, commonType);\n    ifThenFlow.freeScopedLocals();\n\n    ifElseExpr = this.performAutoreleasesWithValue(ifElseFlow, ifElseExpr, commonType);\n    ifElseFlow.freeScopedLocals();\n\n    this.currentFlow = outerFlow;\n    outerFlow.inheritMutual(ifThenFlow, ifElseFlow);\n\n    var expr = module.if(condExpr, ifThenExpr, ifElseExpr);\n    assert(ifThenAutoreleaseSkipped == ifElseAutoreleaseSkipped);\n    if (ifThenAutoreleaseSkipped) this.skippedAutoreleases.add(expr);\n    return expr;\n  }\n\n  private compileUnaryPostfixExpression(\n    expression: UnaryPostfixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n\n    // make a getter for the expression (also obtains the type)\n    var getValue = this.compileExpression( // reports\n      expression.operand,\n      contextualType.exceptVoid,\n      Constraints.NONE\n    );\n\n    // shortcut if compiling the getter already failed\n    if (getExpressionId(getValue) == ExpressionId.Unreachable) return getValue;\n\n    // if the value isn't dropped, a temp. local is required to remember the original value,\n    // except if a static overload is found, which reverses the use of a temp. (see below)\n    var tempLocal: Local | null = null;\n    if (contextualType != Type.void) {\n      tempLocal = flow.getTempLocal(this.currentType);\n      getValue = module.local_tee(\n        tempLocal.index,\n        getValue\n      );\n    }\n\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS_PLUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_INC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (isInstance) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.AddI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.AddI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.AddF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.AddF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.POSTFIX_DEC);\n          if (overload) {\n            let isInstance = overload.is(CommonFlags.INSTANCE);\n            if (tempLocal !== null && !isInstance) { // revert: static overload simply returns\n              getValue = getLocalSetValue(getValue);\n              flow.freeTempLocal(tempLocal);\n              tempLocal = null;\n            }\n            expr = this.compileUnaryOverload(overload, expression.operand, getValue, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break;\n            return expr; // here\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          if (tempLocal) flow.freeTempLocal(tempLocal);\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(\n              BinaryOp.SubI32,\n              getValue,\n              module.i32(1)\n            );\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            let options = this.options;\n            expr = module.binary(\n              options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              getValue,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(\n              BinaryOp.SubI64,\n              getValue,\n              module.i64(1)\n            );\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(\n              BinaryOp.SubF32,\n              getValue,\n              module.f32(1)\n            );\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(\n              BinaryOp.SubF64,\n              getValue,\n              module.f64(1)\n            );\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            return module.unreachable();\n          }\n        }\n        break;\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, flow); // reports\n    if (!target) {\n      if (tempLocal) flow.freeTempLocal(tempLocal);\n      return module.unreachable();\n    }\n\n    // simplify if dropped anyway\n    if (!tempLocal) {\n      return this.makeAssignment(\n        target,\n        expr,\n        this.currentType,\n        expression.operand,\n        resolver.currentThisExpression,\n        resolver.currentElementExpression,\n        false\n      );\n    }\n\n    // otherwise use the temp. local for the intermediate value (always possibly overflows)\n    var setValue = this.makeAssignment(\n      target,\n      expr, // includes a tee of getValue to tempLocal\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      false\n    );\n\n    this.currentType = tempLocal.type;\n    flow.freeTempLocal(tempLocal);\n    var nativeType = tempLocal.type.toNativeType();\n\n    return module.block(null, [\n      setValue,\n      module.local_get(tempLocal.index, nativeType)\n    ], nativeType); // result of 'x++' / 'x--' might overflow\n  }\n\n  private compileUnaryPrefixExpression(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var module = this.module;\n    var compound = false;\n    var expr: ExpressionRef;\n\n    switch (expression.operator) {\n      case Token.PLUS: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PLUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"+\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        // nop\n        break;\n      }\n      case Token.MINUS: {\n        let operand = expression.operand;\n        if (operand.isNumericLiteral) {\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\n          expr = this.compileLiteralExpression(<LiteralExpression>operand, contextualType, Constraints.NONE, true);\n          // compileExpression normally does this:\n          if (this.options.sourceMap) this.addDebugLocation(expr, expression.range);\n          break;\n        }\n\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.MINUS);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"-\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, module.i32(0), expr);\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              this.makeZero(this.currentType, expression.operand),\n              expr\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, module.i64(0), expr);\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.unary(UnaryOp.NegF32, expr);\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.unary(UnaryOp.NegF64, expr);\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"-\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.PLUS_PLUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_INC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"++\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.AddI32, expr, this.module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.AddI64\n                : BinaryOp.AddI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.AddI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.AddF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.AddF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"++\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.MINUS_MINUS: {\n        compound = true;\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.PREFIX_DEC);\n          if (overload) {\n            expr = this.compileUnaryOverload(overload, expression.operand, expr, expression);\n            if (overload.is(CommonFlags.INSTANCE)) break; // re-assign\n            return expr; // skip re-assign\n          }\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"--\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.SubI32, expr, module.i32(1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.SubI64\n                : BinaryOp.SubI32,\n              expr,\n              this.makeOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.SubI64, expr, module.i64(1));\n            break;\n          }\n          case TypeKind.F32: {\n            expr = module.binary(BinaryOp.SubF32, expr, module.f32(1));\n            break;\n          }\n          case TypeKind.F64: {\n            expr = module.binary(BinaryOp.SubF64, expr, module.f64(1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"--\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.EXCLAMATION: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType.exceptVoid,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n          // fall back to compare by value\n        }\n\n        expr = module.unary(UnaryOp.EqzI32, this.makeIsTrueish(expr, this.currentType, expression.operand));\n        this.currentType = Type.bool;\n        break;\n      }\n      case Token.TILDE: {\n        expr = this.compileExpression(\n          expression.operand,\n          contextualType == Type.void\n            ? Type.i32\n            : contextualType.isFloatValue\n              ? Type.i64\n              : contextualType,\n          Constraints.NONE\n        );\n\n        // check operator overload\n        let classReference = this.currentType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return this.compileUnaryOverload(overload, expression.operand, expr, expression);\n        }\n        if (!this.currentType.isValue) {\n          this.error(\n            DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n            expression.range, \"~\", this.currentType.toString()\n          );\n          return module.unreachable();\n        }\n\n        expr = this.convertExpression(expr, this.currentType, this.currentType.intType, false, expression.operand);\n\n        switch (this.currentType.kind) {\n          case TypeKind.I8:\n          case TypeKind.I16:\n          case TypeKind.I32:\n          case TypeKind.U8:\n          case TypeKind.U16:\n          case TypeKind.U32:\n          case TypeKind.BOOL: {\n            expr = module.binary(BinaryOp.XorI32, expr, module.i32(-1));\n            break;\n          }\n          case TypeKind.USIZE:\n          case TypeKind.ISIZE: {\n            expr = module.binary(\n              this.options.isWasm64\n                ? BinaryOp.XorI64\n                : BinaryOp.XorI32,\n              expr,\n              this.makeNegOne(this.currentType)\n            );\n            break;\n          }\n          case TypeKind.I64:\n          case TypeKind.U64: {\n            expr = module.binary(BinaryOp.XorI64, expr, module.i64(-1, -1));\n            break;\n          }\n          default: {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              expression.range, \"~\", this.currentType.toString()\n            );\n            expr = module.unreachable();\n          }\n        }\n        break;\n      }\n      case Token.TYPEOF: {\n        return this.compileTypeof(expression, contextualType, constraints);\n      }\n      default: {\n        assert(false);\n        return module.unreachable();\n      }\n    }\n    if (!compound) return expr;\n    var resolver = this.resolver;\n    var target = resolver.lookupExpression(expression.operand, this.currentFlow);\n    if (!target) return module.unreachable();\n    return this.makeAssignment(\n      target,\n      expr,\n      this.currentType,\n      expression.operand,\n      resolver.currentThisExpression,\n      resolver.currentElementExpression,\n      contextualType != Type.void\n    );\n  }\n\n  private compileTypeof(\n    expression: UnaryPrefixExpression,\n    contextualType: Type,\n    constraints: Constraints\n  ): ExpressionRef {\n    var operand = expression.operand;\n    var expr: ExpressionRef = 0;\n    var stringInstance = this.program.stringInstance;\n    var typeString: string;\n    if (operand.kind == NodeKind.NULL) {\n      typeString = \"object\"; // special since `null` without type context is usize\n    } else {\n      let element = this.resolver.lookupExpression(operand, this.currentFlow, Type.auto, ReportMode.SWALLOW);\n      if (!element) {\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER: break; // ignore error: typeof doesntExist -> undefined\n          case NodeKind.PROPERTYACCESS:\n          case NodeKind.ELEMENTACCESS: {\n            operand = operand.kind == NodeKind.PROPERTYACCESS\n              ? (<PropertyAccessExpression>operand).expression\n              : (<ElementAccessExpression>operand).expression;\n            let targetType = this.resolver.resolveExpression(operand, this.currentFlow, Type.auto, ReportMode.REPORT);\n            if (!targetType) { // access on non-object\n              this.currentType = stringInstance.type;\n              return this.module.unreachable();\n            }\n            // fall-through\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto); // may trigger an error\n            expr = this.convertExpression(expr, this.currentType, Type.void, true, operand);\n          }\n        }\n        typeString = \"undefined\";\n      } else {\n        switch (element.kind) {\n          case ElementKind.CLASS_PROTOTYPE:\n          case ElementKind.NAMESPACE:\n          case ElementKind.ENUM: {\n            typeString = \"object\";\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            typeString = \"function\";\n            break;\n          }\n          default: {\n            expr = this.compileExpression(operand, Type.auto);\n            let type = this.currentType;\n            expr = this.convertExpression(expr, type, Type.void, true, operand);\n            if (type.isReference) {\n              let signatureReference = type.getSignature();\n              if (signatureReference) {\n                typeString = \"function\";\n              } else {\n                let classReference = type.getClass();\n                if (classReference) {\n                  if (classReference.prototype === stringInstance.prototype) {\n                    typeString = \"string\";\n                  } else {\n                    typeString = \"object\";\n                  }\n                } else {\n                  typeString = \"externref\"; // TODO?\n                }\n              }\n            } else if (type == Type.bool) {\n              typeString = \"boolean\";\n            } else if (type.isNumericValue) {\n              typeString = \"number\";\n            } else {\n              typeString = \"undefined\"; // failed to compile?\n            }\n            break;\n          }\n        }\n      }\n    }\n    this.currentType = stringInstance.type;\n    return expr\n      ? this.module.block(null, [ expr, this.ensureStaticString(typeString) ], this.options.nativeSizeType)\n      : this.ensureStaticString(typeString);\n  }\n\n  /** Makes sure that a 32-bit integer value is wrapped to a valid value of the specified type. */\n  ensureSmallIntegerWrap(expr: ExpressionRef, type: Type): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    switch (type.kind) {\n      case TypeKind.I8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.ExtendI8ToI32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(24)\n                ),\n                module.i32(24)\n              );\n        }\n        break;\n      }\n      case TypeKind.I16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = this.options.hasFeature(Feature.SIGN_EXTENSION)\n            ? module.unary(UnaryOp.ExtendI16ToI32, expr)\n            : module.binary(BinaryOp.ShrI32,\n                module.binary(BinaryOp.ShlI32,\n                  expr,\n                  module.i32(16)\n                ),\n                module.i32(16)\n              );\n        }\n        break;\n      }\n      case TypeKind.U8: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xff)\n          );\n        }\n        break;\n      }\n      case TypeKind.U16: {\n        if (flow.canOverflow(expr, type)) {\n          expr = module.binary(BinaryOp.AndI32,\n            expr,\n            module.i32(0xffff)\n          );\n        }\n        break;\n      }\n      case TypeKind.BOOL: {\n        if (flow.canOverflow(expr, type)) {\n          // bool is special in that it compares to 0 instead of masking with 0x1\n          expr = module.binary(BinaryOp.NeI32,\n            expr,\n            module.i32(0)\n          );\n        }\n        break;\n      }\n    }\n    return expr;\n  }\n\n  /** Adds the debug location of the specified expression at the specified range to the source map. */\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\n    var parentFunction = this.currentFlow.parentFunction;\n    var source = range.source;\n    if (source.debugInfoIndex < 0) source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\n    range.debugInfoRef = expr;\n    parentFunction.debugLocations.push(range);\n  }\n\n  /** Checks whether a particular feature is enabled. */\n  checkFeatureEnabled(feature: Feature, reportNode: Node): bool {\n    if (!this.options.hasFeature(feature)) {\n      this.error(\n        DiagnosticCode.Feature_0_is_not_enabled,\n        reportNode.range, featureToString(feature)\n      );\n      return false;\n    }\n    return true;\n  }\n\n  /** Checks whether a particular type is supported. */\n  checkTypeSupported(type: Type, reportNode: Node): bool {\n    switch (type.kind) {\n      case TypeKind.V128: return this.checkFeatureEnabled(Feature.SIMD, reportNode);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode);\n      case TypeKind.EXNREF: {\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\n            && this.checkFeatureEnabled(Feature.EXCEPTION_HANDLING, reportNode);\n      }\n      case TypeKind.ANYREF: {\n        return this.checkFeatureEnabled(Feature.REFERENCE_TYPES, reportNode)\n            && this.checkFeatureEnabled(Feature.GC, reportNode);\n      }\n    }\n    let classReference = type.getClass();\n    if (classReference) {\n      do {\n        let typeArguments = classReference.typeArguments;\n        if (typeArguments) {\n          for (let i = 0, k = typeArguments.length; i < k; ++i) {\n            if (!this.checkTypeSupported(typeArguments[i], reportNode)) {\n              return false;\n            }\n          }\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    } else {\n      let signatureReference = type.getSignature();\n      if (signatureReference) {\n        let thisType = signatureReference.thisType;\n        if (thisType) {\n          if (!this.checkTypeSupported(thisType, reportNode)) {\n            return false;\n          }\n        }\n        let parameterTypes = signatureReference.parameterTypes;\n        for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n          if (!this.checkTypeSupported(parameterTypes[i], reportNode)) {\n            return false;\n          }\n        }\n        let returnType = signatureReference.returnType;\n        if (!this.checkTypeSupported(returnType, reportNode)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** Checks whether a particular function signature is supported. */\n  checkSignatureSupported(signature: Signature, reportNode: FunctionTypeNode): bool {\n    var supported = true;\n    var explicitThisType = reportNode.explicitThisType;\n    if (explicitThisType) {\n      if (!this.checkTypeSupported(assert(signature.thisType), explicitThisType)) {\n        supported = false;\n      }\n    }\n    var parameterTypes = signature.parameterTypes;\n    var parameterNodes = reportNode.parameters;\n    for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n      let parameterReportNode: Node;\n      if (parameterNodes.length > i) parameterReportNode = parameterNodes[i];\n      else parameterReportNode = reportNode;\n      if (!this.checkTypeSupported(parameterTypes[i], parameterReportNode)) {\n        supported = false;\n      }\n    }\n    if (!this.checkTypeSupported(signature.returnType, reportNode.returnType)) {\n      supported = false;\n    }\n    return supported;\n  }\n\n  /** Evaluates a boolean condition, determining whether it is TRUE, FALSE or UNKNOWN. */\n  evaluateCondition(expr: ExpressionRef): ConditionKind {\n    var module = this.module;\n    var evaled = module.runExpression(expr, ExpressionRunnerFlags.Default);\n    if (evaled) {\n      return getConstValueI32(evaled)\n        ? ConditionKind.TRUE\n        : ConditionKind.FALSE;\n    }\n    return ConditionKind.UNKNOWN;\n  }\n\n  // === Specialized code generation ==============================================================\n\n  /** Makes a constant zero of the specified type. */\n  makeZero(type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(0);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(0);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(0);\n      case TypeKind.F32: return module.f32(0);\n      case TypeKind.F64: return module.f64(0);\n      case TypeKind.V128: return module.v128(v128_zero);\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF:\n        return module.ref_null(type.toNativeType());\n    }\n  }\n\n  /** Makes a constant one of the specified type. */\n  makeOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return module.i32(1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(1);\n      case TypeKind.F32: return module.f32(1);\n      case TypeKind.F64: return module.f64(1);\n    }\n  }\n\n  /** Makes a constant negative one of the specified type. */\n  makeNegOne(type: Type): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32: return module.i32(-1);\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (type.size != 64) return module.i32(-1);\n      case TypeKind.I64:\n      case TypeKind.U64: return module.i64(-1, -1);\n      case TypeKind.F32: return module.f32(-1);\n      case TypeKind.F64: return module.f64(-1);\n    }\n  }\n\n  /** Creates a comparison whether an expression is 'true' in a broader sense. */\n  makeIsTrueish(expr: ExpressionRef, type: Type, reportNode: Node): ExpressionRef {\n    var module = this.module;\n    switch (type.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.U8:\n      case TypeKind.U16: {\n        expr = this.ensureSmallIntegerWrap(expr, type);\n        // fall-through\n      }\n      case TypeKind.BOOL: // not a mask, just != 0\n      case TypeKind.I32:\n      case TypeKind.U32: {\n        return expr;\n      }\n      case TypeKind.I64:\n      case TypeKind.U64: {\n        return module.binary(BinaryOp.NeI64, expr, module.i64(0));\n      }\n      case TypeKind.USIZE: if (type.isManaged && this.skippedAutoreleases.has(expr)) expr = this.makeAutorelease(expr, type);\n      case TypeKind.ISIZE: {\n        return type.size == 64\n          ? module.binary(BinaryOp.NeI64, expr, module.i64(0))\n          : expr;\n      }\n      case TypeKind.F32: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u32>(x) & 0x7FFFFFFF) - 1 <= 0x7F800000 - 1\n        //\n        // and finally:\n        // (reinterpret<u32>(x) << 1) - (1 << 1) <= ((0x7F800000 - 1) << 1)\n        return module.binary(BinaryOp.LeU32,\n          module.binary(BinaryOp.SubI32,\n            module.binary(BinaryOp.ShlI32,\n              module.unary(UnaryOp.ReinterpretF32, expr),\n              module.i32(1)\n            ),\n            module.i32(2) // 1 << 1\n          ),\n          module.i32(0xFEFFFFFE) // (0x7F800000 - 1) << 1\n        );\n      }\n      case TypeKind.F64: {\n        // 0 < abs(bitCast(x)) <= bitCast(Infinity) or\n        // (reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF) - 1 <= 0x7FF0000000000000 - 1\n        //\n        // and finally:\n        // (reinterpret<u64>(x) << 1) - (1 << 1) <= ((0x7FF0000000000000 - 1) << 1)\n        return module.binary(BinaryOp.LeU64,\n          module.binary(BinaryOp.SubI64,\n            module.binary(BinaryOp.ShlI64,\n              module.unary(UnaryOp.ReinterpretF64, expr),\n              module.i64(1)\n            ),\n            module.i64(2) // 1 << 1\n          ),\n          module.i64(0xFFFFFFFE, 0xFFDFFFFF) // (0x7FF0000000000000 - 1) << 1\n        );\n      }\n      case TypeKind.FUNCREF:\n      case TypeKind.EXTERNREF:\n      case TypeKind.EXNREF:\n      case TypeKind.ANYREF:{\n        return module.ref_is_null(expr);\n      }\n      default: {\n        assert(false);\n        return module.i32(0);\n      }\n    }\n  }\n\n  /** Makes an allocation suitable to hold the data of an instance of the given class. */\n  makeAllocation(\n    classInstance: Class\n  ): ExpressionRef {\n    var program = this.program;\n    assert(classInstance.program == program);\n    var module = this.module;\n    var options = this.options;\n    this.currentType = classInstance.type;\n    if (classInstance.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let allocInstance = program.allocInstance;\n      this.compileFunction(allocInstance);\n      return module.call(allocInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset)\n      ], options.nativeSizeType);\n    } else {\n      let newInstance = program.newInstance;\n      this.compileFunction(newInstance);\n      return module.call(newInstance.internalName, [\n        options.isWasm64\n          ? module.i64(classInstance.nextMemoryOffset)\n          : module.i32(classInstance.nextMemoryOffset),\n        module.i32(classInstance.id)\n      ], options.nativeSizeType);\n    }\n  }\n\n  /** Makes the initializers for a class's fields within the constructor. */\n  makeFieldInitializationInConstructor(\n    /** Class being initialized. */\n    classInstance: Class,\n    /** Statements to append to also being returned. Created if omitted. */\n    stmts: ExpressionRef[] = []\n  ): ExpressionRef[] {\n    var members = classInstance.members;\n    if (!members) return stmts;\n\n    var module = this.module;\n    var flow = this.currentFlow;\n    var isInline = flow.isInline;\n    var thisLocalIndex = isInline\n      ? flow.lookupLocal(CommonNames.this_)!.index\n      : 0;\n    var nativeSizeType = this.options.nativeSizeType;\n\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      if (\n        member.kind != ElementKind.FIELD || // not a field\n        member.parent != classInstance      // inherited field\n      ) continue;\n\n      let field = <Field>member;\n      assert(!field.isAny(CommonFlags.CONST));\n      let fieldType = field.type;\n      let nativeFieldType = fieldType.toNativeType();\n      let fieldPrototype = field.prototype;\n      let initializerNode = fieldPrototype.initializerNode;\n      let parameterIndex = fieldPrototype.parameterIndex;\n      let initExpr: ExpressionRef;\n      let typeNode = field.typeNode;\n      if (typeNode) this.checkTypeSupported(fieldType, typeNode);\n\n      // if declared as a constructor parameter, use its value\n      if (parameterIndex >= 0) {\n        initExpr = module.local_get(\n          isInline\n            ? flow.lookupLocal(field.name)!.index\n            : 1 + parameterIndex, // this is local 0\n          nativeFieldType\n        );\n        if (fieldType.isManaged) initExpr = this.makeRetain(initExpr, fieldType);\n\n      // fall back to use initializer if present\n      } else if (initializerNode) {\n        initExpr = this.compileExpression(initializerNode, fieldType,\n          Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN\n        );\n        if (fieldType.isManaged && !this.skippedAutoreleases.has(initExpr)) {\n          initExpr = this.makeRetain(initExpr, fieldType);\n        }\n\n      // otherwise initialize with zero\n      } else {\n        initExpr = this.makeZero(fieldType, fieldPrototype.declaration);\n      }\n\n      stmts.push(\n        module.store(fieldType.byteSize,\n          module.local_get(thisLocalIndex, nativeSizeType),\n          initExpr,\n          nativeFieldType,\n          field.memoryOffset\n        )\n      );\n    }\n    return stmts;\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeAbort(\n    /** Message argument of type string, if any. */\n    message: Expression | null,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return this.module.unreachable();\n\n    var stringInstance = program.stringInstance;\n    var messageArg: ExpressionRef;\n    if (message !== null) {\n      // The message argument works much like an arm of an IF that does not become executed if the\n      // assertion succeeds respectively is only being computed if the program actually crashes.\n      // Hence, let's make it so that the autorelease is skipped at the end of the current block,\n      // essentially ignoring the message GC-wise. Doesn't matter anyway on a crash.\n      messageArg = this.compileExpression(message, stringInstance.type, Constraints.CONV_IMPLICIT | Constraints.WILL_RETAIN);\n    } else {\n      messageArg = this.makeZero(stringInstance.type, codeLocation);\n    }\n\n    return this.makeStaticAbort(messageArg, codeLocation);\n  }\n\n  /** Makes a call to `abort`, if present, otherwise creates a trap. */\n  makeStaticAbort(\n    /** Message argument of type string. May be zero. */\n    messageExpr: ExpressionRef,\n    /** Code location to report when aborting. */\n    codeLocation: Node\n  ): ExpressionRef {\n    var program = this.program;\n    var module = this.module;\n    var abortInstance = program.abortInstance;\n    if (!abortInstance || !this.compileFunction(abortInstance)) return module.unreachable();\n\n    var filenameExpr = this.ensureStaticString(codeLocation.range.source.normalizedPath);\n    var range = codeLocation.range;\n    var source = range.source;\n    return module.block(null, [\n      module.call(\n        abortInstance.internalName, [\n          messageExpr,\n          filenameExpr,\n          module.i32(source.lineAt(range.start)),\n          module.i32(source.columnAt())\n        ],\n        NativeType.None\n      ),\n      module.unreachable()\n    ]);\n  }\n\n  /** Makes a runtime non-null check, e.g. on `<Type>possiblyNull` or `possiblyNull!`. */\n  makeRuntimeNonNullCheck(\n    /** Expression being checked. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    if (!flow.canOverflow(expr, type)) flow.setLocalFlag(temp.index, LocalFlags.WRAPPED);\n    flow.setLocalFlag(temp.index, LocalFlags.NONNULL);\n    expr = module.if(\n      module.local_tee(temp.index, expr),\n      module.local_get(temp.index, type.toNativeType()),\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected null\"), reportNode) // TODO: throw\n    );\n    flow.freeTempLocal(temp);\n    this.currentType = type.nonNullableType;\n    return expr;\n  }\n\n  /** Makes a runtime upcast check, e.g. on `<Child>parent`. */\n  makeRuntimeUpcastCheck(\n    /** Expression being upcast. */\n    expr: ExpressionRef,\n    /** Type of the expression. */\n    type: Type,\n    /** Type casting to. */\n    toType: Type,\n    /** Report node. */\n    reportNode: Node\n  ): ExpressionRef {\n    assert(toType.isReference && toType.nonNullableType.isAssignableTo(type));\n    var module = this.module;\n    var flow = this.currentFlow;\n    var temp = flow.getTempLocal(type);\n    var instanceofInstance = this.program.instanceofInstance;\n    assert(this.compileFunction(instanceofInstance));\n    expr = module.if(\n      module.call(instanceofInstance.internalName, [\n        module.local_tee(temp.index, expr),\n        module.i32(toType.classReference!.id)\n      ], NativeType.I32),\n      module.local_get(temp.index, type.toNativeType()),\n      this.makeStaticAbort(this.ensureStaticString(\"unexpected upcast\"), reportNode) // TODO: throw\n    );\n    flow.freeTempLocal(temp);\n    this.currentType = toType;\n    return expr;\n  }\n}\n\n// helpers\n\nfunction mangleImportName(\n  element: Element,\n  declaration: DeclarationStatement\n): void {\n  // by default, use the file name as the module name\n  mangleImportName_moduleName = declaration.range.source.simplePath;\n  // and the internal name of the element within that file as the element name\n  mangleImportName_elementName = mangleInternalName(\n    element.name, element.parent, element.is(CommonFlags.INSTANCE), true\n  );\n  if (!element.hasDecorator(DecoratorFlags.EXTERNAL)) return;\n\n  var program = element.program;\n  var decorator = assert(findDecorator(DecoratorKind.EXTERNAL, declaration.decorators));\n  var args = decorator.args;\n  if (args !== null && args.length > 0) {\n    let arg = args[0];\n    // if one argument is given, override just the element name\n    // if two arguments are given, override both module and element name\n    if (arg.isLiteralKind(LiteralKind.STRING)) {\n      mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n      if (args.length >= 2) {\n        arg = args[1];\n        if (arg.isLiteralKind(LiteralKind.STRING)) {\n          mangleImportName_moduleName = mangleImportName_elementName;\n          mangleImportName_elementName = (<StringLiteralExpression>arg).value;\n          if (args.length > 2) {\n            program.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              decorator.range, \"2\", args.length.toString()\n            );\n          }\n        } else {\n          program.error(\n            DiagnosticCode.String_literal_expected,\n            arg.range\n          );\n        }\n      }\n    } else {\n      program.error(\n        DiagnosticCode.String_literal_expected,\n        arg.range\n      );\n    }\n  } else {\n    program.error(\n      DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\n      decorator.range, \"1\", \"0\"\n    );\n  }\n}\n\nvar mangleImportName_moduleName: string;\nvar mangleImportName_elementName: string;\n","/**\n * @fileoverview Builders for various definitions describing a module.\n *\n * - TSDBuilder: Creates a TypeScript definition file (.d.ts)\n * - IDLBuilder: Creates a WebIDL interface definition (.webidl)\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  Program,\n  Element,\n  ElementKind,\n  Global,\n  Enum,\n  EnumValue,\n  Field,\n  Function,\n  FunctionPrototype,\n  Class,\n  ClassPrototype,\n  Namespace,\n  ConstantValueKind,\n  Interface,\n  Property,\n  PropertyPrototype,\n  File\n} from \"./program\";\n\nimport {\n  Type,\n  TypeKind\n} from \"./types\";\n\nimport {\n  SourceKind\n} from \"./ast\";\n\nimport {\n  indent\n} from \"./util\";\n\n/** Walker base class. */\nexport abstract class ExportsWalker {\n\n  /** Program reference. */\n  program: Program;\n  /** Whether to include private members */\n  includePrivate: bool;\n  /** Already seen elements. */\n  seen: Map<Element,string> = new Map();\n\n  /** Constructs a new Element walker. */\n  constructor(program: Program, includePrivate: bool = false) {\n    this.program = program;\n    this.includePrivate = includePrivate;\n  }\n\n  /** Walks all elements and calls the respective handlers. */\n  walk(): void {\n    // TODO: for (let file of this.program.filesByName.values()) {\n    for (let _values = Map_values(this.program.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) this.visitFile(file);\n    }\n  }\n\n  /** Visits all exported elements of a file. */\n  visitFile(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        this.visitElement(memberName, member);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let exportStar = unchecked(exportsStar[i]);\n        this.visitFile(exportStar);\n      }\n    }\n  }\n\n  /** Visits an element.*/\n  visitElement(name: string, element: Element): void {\n    if (element.is(CommonFlags.PRIVATE) && !this.includePrivate) return;\n    var seen = this.seen;\n    if (!element.is(CommonFlags.INSTANCE) && seen.has(element)) {\n      this.visitAlias(name, element, assert(seen.get(element)));\n      return;\n    }\n    seen.set(element, name);\n    switch (element.kind) {\n      case ElementKind.GLOBAL: {\n        if (element.is(CommonFlags.COMPILED)) this.visitGlobal(name, <Global>element);\n        break;\n      }\n      case ElementKind.ENUM: {\n        if (element.is(CommonFlags.COMPILED)) this.visitEnum(name, <Enum>element);\n        break;\n      }\n      case ElementKind.ENUMVALUE: break; // handled by visitEnum\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        this.visitFunctionInstances(name, <FunctionPrototype>element);\n        break;\n      }\n      case ElementKind.CLASS_PROTOTYPE: {\n        this.visitClassInstances(name, <ClassPrototype>element);\n        break;\n      }\n      case ElementKind.FIELD: {\n        let fieldInstance = <Field>element;\n        if (fieldInstance.is(CommonFlags.COMPILED)) this.visitField(name, fieldInstance);\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyInstance = (<PropertyPrototype>element).instance;\n        if (!propertyInstance) break;\n        element = propertyInstance;\n        // fall-through\n        break;\n      }\n      case ElementKind.PROPERTY: {\n        let propertyInstance = <Property>element;\n        let getterInstance = propertyInstance.getterInstance;\n        if (getterInstance) this.visitFunction(name, getterInstance);\n        let setterInstance = propertyInstance.setterInstance;\n        if (setterInstance) this.visitFunction(name, setterInstance);\n        break;\n      }\n      case ElementKind.NAMESPACE: {\n        if (hasCompiledMember(element)) this.visitNamespace(name, element);\n        break;\n      }\n      case ElementKind.TYPEDEFINITION: break;\n      default: assert(false);\n    }\n  }\n\n  private visitFunctionInstances(name: string, element: FunctionPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitFunction(name, instance);\n      }\n    }\n  }\n\n  private visitClassInstances(name: string, element: ClassPrototype): void {\n    var instances = element.instances;\n    if (instances) {\n      // TODO: for (let instance of instances.values()) {\n      for (let _values = Map_values(instances), i = 0, k = _values.length; i < k; ++i) {\n        let instance = unchecked(_values[i]);\n        if (instance.is(CommonFlags.COMPILED)) this.visitClass(name, instance);\n      }\n    }\n  }\n\n  abstract visitGlobal(name: string, element: Global): void;\n  abstract visitEnum(name: string, element: Enum): void;\n  abstract visitFunction(name: string, element: Function): void;\n  abstract visitClass(name: string, element: Class): void;\n  abstract visitInterface(name: string, element: Interface): void;\n  abstract visitField(name: string, element: Field): void;\n  abstract visitNamespace(name: string, element: Element): void;\n  abstract visitAlias(name: string, element: Element, originalName: string): void;\n}\n\n/** A WebIDL definitions builder. */\nexport class IDLBuilder extends ExportsWalker {\n\n  /** Builds WebIDL definitions for the specified program. */\n  static build(program: Program): string {\n    return new IDLBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (isConst) sb.push(\"const \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\" \");\n    sb.push(name);\n    if (isConst) {\n      switch (element.constantValueKind) {\n        case ConstantValueKind.INTEGER: {\n          sb.push(\" = \");\n          sb.push(i64_to_string(element.constantIntegerValue));\n          break;\n        }\n        case ConstantValueKind.FLOAT: {\n          sb.push(\" = \");\n          sb.push(element.constantFloatValue.toString());\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    sb.push(\";\\n\");\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          let isConst = enumValue.is(CommonFlags.INLINED);\n          indent(sb, this.indentLevel);\n          if (isConst) sb.push(\"const \");\n          else sb.push(\"readonly \");\n          sb.push(\"unsigned long \");\n          sb.push(memberName);\n          if (isConst) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\";\\n\");\n        }\n      }\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind != ElementKind.ENUMVALUE) this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitFunction(name: string, element: Function): void {\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    sb.push(this.typeToString(signature.returnType));\n    sb.push(\" \");\n    sb.push(name);\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    // var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      // if (i >= requiredParameters) sb.push(\"optional \");\n      sb.push(this.typeToString(parameters[i]));\n      sb.push(\" \");\n      sb.push(element.getParameterName(i));\n    }\n    sb.push(\");\\n\");\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      indent(sb, this.indentLevel);\n      sb.push(\"interface \");\n      sb.push(element.name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    // TODO\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    // TODO\n  }\n\n  visitNamespace(name: string, element: Namespace): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"interface \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    if (members) {\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    // TODO\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"byte\";\n      case TypeKind.I16: return \"short\";\n      case TypeKind.I32: return \"long\";\n      case TypeKind.I64: return \"long long\";\n      case TypeKind.ISIZE: return this.program.options.isWasm64 ? \"long long\" : \"long\";\n      case TypeKind.U8: return \"octet\";\n      case TypeKind.U16: return \"unsigned short\";\n      case TypeKind.U32: return \"unsigned long\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"unsigned long long\";\n      case TypeKind.USIZE: return this.program.options.isWasm64 ? \"unsigned long long\" : \"unsigned long\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"boolean\";\n      case TypeKind.F32: return \"unrestricted float\";\n      case TypeKind.F64: return \"unrestricted double\";\n      case TypeKind.VOID: return \"void\";\n      default: {\n        assert(false);\n        return \"\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    sb.push(\"interface ASModule {\\n\");\n    ++this.indentLevel;\n    this.walk();\n    --this.indentLevel;\n    sb.push(\"}\\n\");\n    return sb.join(\"\");\n  }\n}\n\n/** A TypeScript definitions builder. */\nexport class TSDBuilder extends ExportsWalker {\n\n  /** Builds TypeScript definitions for the specified program. */\n  static build(program: Program): string {\n    return new TSDBuilder(program).build();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  /** Constructs a new WebIDL builder. */\n  constructor(program: Program, includePrivate: bool = false) {\n    super(program, includePrivate);\n  }\n\n  visitGlobal(name: string, element: Global): void {\n    var sb = this.sb;\n    var isConst = element.is(CommonFlags.INLINED);\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.STATIC)) {\n      if (isConst) sb.push(\"static readonly \");\n      else sb.push(\"static \");\n    } else {\n      if (isConst) sb.push(\"export const \");\n      else sb.push(\"export var \");\n    }\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitEnum(name: string, element: Enum): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel++);\n    sb.push(\"export \");\n    if (element.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    sb.push(name);\n    sb.push(\" {\\n\");\n    var members = element.members;\n    var remainingMembers = 0;\n    if (members) {\n      remainingMembers = members.size;\n      // TODO: for (let [memberName, member] of members) {\n      for (let _keys = Map_keys(members), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(members.get(memberName));\n        if (member.kind == ElementKind.ENUMVALUE) {\n          let enumValue = <EnumValue>member;\n          indent(sb, this.indentLevel);\n          sb.push(memberName);\n          if (member.is(CommonFlags.INLINED)) {\n            sb.push(\" = \");\n            assert(enumValue.constantValueKind == ConstantValueKind.INTEGER);\n            sb.push(i64_low(enumValue.constantIntegerValue).toString());\n          }\n          sb.push(\",\\n\");\n          --remainingMembers;\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n    if (remainingMembers) this.visitNamespace(name, element);\n  }\n\n  visitFunction(name: string, element: Function): void {\n    if (element.isAny(CommonFlags.PRIVATE | CommonFlags.SET)) return;\n    var sb = this.sb;\n    var signature = element.signature;\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n    if (element.is(CommonFlags.GET)) {\n      sb.push(\"get \");\n      sb.push(name); // 'get:funcName' internally\n      sb.push(\"(): \");\n      sb.push(this.typeToString(signature.returnType));\n      sb.push(\";\\n\");\n      return;\n    } else {\n      if (!element.isAny(CommonFlags.STATIC | CommonFlags.INSTANCE)) sb.push(\"export function \");\n      sb.push(name);\n    }\n    sb.push(\"(\");\n    var parameters = signature.parameterTypes;\n    var numParameters = parameters.length;\n    // var requiredParameters = signature.requiredParameters;\n    for (let i = 0; i < numParameters; ++i) {\n      if (i) sb.push(\", \");\n      // if (i >= requiredParameters) sb.push(\"optional \");\n      sb.push(element.getParameterName(i));\n      sb.push(\": \");\n      sb.push(this.typeToString(parameters[i]));\n    }\n    if (element.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)) {\n      sb.push(\")\");\n    } else {\n      sb.push(\"): \");\n      sb.push(this.typeToString(signature.returnType));\n    }\n    sb.push(\";\\n\");\n    this.visitNamespace(name, element);\n  }\n\n  visitClass(name: string, element: Class): void {\n    var sb = this.sb;\n    var isInterface = element.kind == ElementKind.INTERFACE;\n    indent(sb, this.indentLevel++);\n    if (isInterface) {\n      sb.push(\"export interface \");\n    } else {\n      sb.push(\"export \");\n      if (element.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n      sb.push(\"class \");\n    }\n    sb.push(name);\n    var base = element.base;\n    if (base !== null && base.is(CommonFlags.COMPILED | CommonFlags.MODULE_EXPORT)) {\n      sb.push(\" extends \");\n      let extendsNode = assert(element.prototype.extendsNode);\n      sb.push(extendsNode.name.identifier.text); // TODO: fqn?\n    }\n    sb.push(\" {\\n\");\n    var staticMembers = element.prototype.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n    }\n    var instanceMembers = element.members;\n    if (instanceMembers) {\n      // TODO: for (let member of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.parent == element) { // own member\n          this.visitElement(member.name, member);\n        }\n      }\n    }\n    indent(sb, --this.indentLevel);\n    sb.push(\"}\\n\");\n  }\n\n  visitInterface(name: string, element: Interface): void {\n    this.visitClass(name, element);\n  }\n\n  visitField(name: string, element: Field): void {\n    if (element.is(CommonFlags.PRIVATE)) return;\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    if (element.is(CommonFlags.PROTECTED)) sb.push(\"protected \");\n    if (element.is(CommonFlags.STATIC)) sb.push(\"static \");\n    if (element.is(CommonFlags.READONLY)) sb.push(\"readonly \");\n    sb.push(name);\n    sb.push(\": \");\n    sb.push(this.typeToString(element.type));\n    sb.push(\";\\n\");\n  }\n\n  visitNamespace(name: string, element: Element): void {\n    var members = element.members;\n    if (members !== null && members.size > 0) {\n      let sb = this.sb;\n      indent(sb, this.indentLevel++);\n      sb.push(\"export namespace \");\n      sb.push(name);\n      sb.push(\" {\\n\");\n      // TODO: for (let member of members.values()) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.visitElement(member.name, member);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\\n\");\n    }\n  }\n\n  visitAlias(name: string, element: Element, originalName: string): void {\n    var sb = this.sb;\n    indent(sb, this.indentLevel);\n    sb.push(\"export const \");\n    sb.push(name);\n    sb.push(\": typeof \");\n    sb.push(originalName);\n    sb.push(\";\\n\");\n  }\n\n  typeToString(type: Type): string {\n    switch (type.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n        // ^ TODO: function types\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n        // ^ TODO: class types\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.VOID: return \"void\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.EXNREF: return \"exnref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      default: {\n        assert(false);\n        return \"any\";\n      }\n    }\n  }\n\n  build(): string {\n    var sb = this.sb;\n    var isWasm64 = this.program.options.isWasm64;\n    sb.push(\"declare module ASModule {\\n\");\n    sb.push(\"  type i8 = number;\\n\");\n    sb.push(\"  type i16 = number;\\n\");\n    sb.push(\"  type i32 = number;\\n\");\n    sb.push(\"  type i64 = bigint;\\n\");\n    if (isWasm64) {\n      sb.push(\"  type isize = bigint;\\n\");\n    } else {\n      sb.push(\"  type isize = number;\\n\");\n    }\n    sb.push(\"  type u8 = number;\\n\");\n    sb.push(\"  type u16 = number;\\n\");\n    sb.push(\"  type u32 = number;\\n\");\n    sb.push(\"  type u64 = bigint;\\n\");\n    if (isWasm64) {\n      sb.push(\"  type usize = bigint;\\n\");\n    } else {\n      sb.push(\"  type usize = number;\\n\");\n    }\n    sb.push(\"  type f32 = number;\\n\");\n    sb.push(\"  type f64 = number;\\n\");\n    sb.push(\"  type bool = boolean | number;\\n\");\n    ++this.indentLevel;\n    this.walk();\n    --this.indentLevel;\n    sb.push(\"}\\n\");\n    sb.push(\"export default ASModule;\\n\");\n    return this.sb.join(\"\");\n  }\n}\n\n// helpers\n\n/** Tests if a namespace-like element has at least one compiled member. */\nfunction hasCompiledMember(element: Element): bool {\n  var members = element.members;\n  if (members) {\n    // TODO: for (let member of members.values()) {\n    for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n      let member = unchecked(_values[i]);\n      switch (member.kind) {\n        case ElementKind.FUNCTION_PROTOTYPE: {\n          let instances = (<FunctionPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        case ElementKind.CLASS_PROTOTYPE: {\n          let instances = (<ClassPrototype>member).instances;\n          if (instances) {\n            // TODO: for (let instance of instances.values()) {\n            for (let _values = Map_values(instances), j = 0, l = _values.length; j < l; ++j) {\n              let instance = unchecked(_values[j]);\n              if (instance.is(CommonFlags.COMPILED)) return true;\n            }\n          }\n          break;\n        }\n        default: {\n          if (member.is(CommonFlags.COMPILED) || hasCompiledMember(member)) return true;\n          break;\n        }\n      }\n    }\n  }\n  return false;\n}\n","/**\n * @fileoverview Generated from diagnosticsMessages.json. Do not edit.\n * @license Apache-2.0\n */\n\n/* tslint:disable:max-line-length */\n\n/** Enum of available diagnostic codes. */\nexport enum DiagnosticCode {\n  Not_implemented_0 = 100,\n  Operation_is_unsafe = 101,\n  User_defined_0 = 102,\n  Feature_0_is_not_enabled = 103,\n  Low_memory_limit_exceeded_by_static_data_0_1 = 104,\n  Module_requires_at_least_0_pages_of_initial_memory = 105,\n  Module_requires_at_least_0_pages_of_maximum_memory = 106,\n  Shared_memory_requires_maximum_memory_to_be_defined = 107,\n  Shared_memory_requires_feature_threads_to_be_enabled = 108,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Operation_0_cannot_be_applied_to_type_1 = 203,\n  Type_0_cannot_be_nullable = 204,\n  Cannot_export_a_mutable_global = 205,\n  Mutable_value_cannot_be_inlined = 206,\n  Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa = 207,\n  Unmanaged_classes_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Expression_is_never_null = 210,\n  Class_0_is_final_and_cannot_be_extended = 211,\n  Decorator_0_is_not_valid_here = 212,\n  Duplicate_decorator = 213,\n  Type_0_is_illegal_in_this_context = 214,\n  Optional_parameter_must_have_an_initializer = 215,\n  Class_0_cannot_declare_a_constructor_when_instantiated_from_an_object_literal = 216,\n  Function_0_cannot_be_inlined_into_itself = 217,\n  Cannot_access_method_0_without_calling_it_as_it_requires_this_to_be_set = 218,\n  Optional_properties_are_not_supported = 219,\n  Expression_must_be_a_compile_time_constant = 220,\n  Type_0_is_not_a_function_index_or_function_reference = 221,\n  _0_must_be_a_value_between_1_and_2_inclusive = 222,\n  _0_must_be_a_power_of_two = 223,\n  _0_is_not_a_valid_operator = 224,\n  Expression_cannot_be_represented_by_a_type = 225,\n  Expression_resolves_to_unusual_type_0 = 226,\n  Array_literal_expected = 227,\n  Function_0_is_virtual_and_will_not_be_inlined = 228,\n  Property_0_only_has_a_setter_and_is_missing_a_getter = 229,\n  _0_keyword_cannot_be_used_here = 230,\n  A_class_with_a_constructor_explicitly_returning_something_else_than_this_must_be_final = 231,\n  Exported_generic_function_or_class_has_no_concrete_instances = 232,\n  Property_0_is_always_assigned_before_being_used = 233,\n  Type_0_is_cyclic_Module_will_include_deferred_garbage_collection = 900,\n  Importing_the_table_disables_some_indirect_call_optimizations = 901,\n  Exporting_the_table_disables_some_indirect_call_optimizations = 902,\n  Expression_compiles_to_a_dynamic_check_at_runtime = 903,\n  Indexed_access_may_involve_bounds_checking = 904,\n  Explicitly_returning_constructor_drops_this_allocation = 905,\n  Unnecessary_definite_assignment = 906,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Enum_member_must_have_initializer = 1061,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  Type_argument_list_cannot_be_empty = 1099,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  An_export_assignment_cannot_have_modifiers = 1120,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  _super_must_be_followed_by_an_argument_list_or_member_access = 1034,\n  A_declare_modifier_cannot_be_used_in_an_already_ambient_context = 1038,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Interface_declaration_cannot_have_implements_clause = 1176,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = 1190,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = 1245,\n  A_definite_assignment_assertion_is_not_permitted_in_this_context = 1255,\n  A_class_may_only_extend_another_class = 1311,\n  A_parameter_property_cannot_be_declared_using_a_rest_parameter = 1317,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  An_interface_can_only_extend_an_interface = 2312,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = 2337,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Property_0_is_private_and_only_accessible_within_class_1 = 2341,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  This_expression_is_not_constructable = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  A_super_call_must_be_the_first_statement_in_the_constructor = 2376,\n  Constructors_for_derived_classes_must_contain_a_super_call = 2377,\n  Getter_and_setter_accessors_do_not_agree_in_visibility = 2379,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Overload_signatures_must_all_be_public_private_or_protected = 2385,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  This_overload_signature_is_not_compatible_with_its_implementation_signature = 2394,\n  Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = 2395,\n  A_class_can_only_implement_an_interface = 2422,\n  A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = 2434,\n  Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = 2445,\n  Variable_0_used_before_its_declaration = 2448,\n  The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = 2453,\n  Type_0_has_no_property_1 = 2460,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  In_const_enum_declarations_member_initializer_must_be_constant_expression = 2474,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = 2506,\n  Cannot_create_an_instance_of_an_abstract_class = 2511,\n  Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2 = 2515,\n  Object_is_possibly_null = 2531,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  Property_0_has_no_initializer_and_is_not_assigned_in_the_constructor_before_this_is_used_or_returned = 2564,\n  Property_0_is_used_before_being_assigned = 2565,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = 2673,\n  Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = 2674,\n  The_this_types_of_each_signature_are_incompatible = 2685,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  Required_type_parameters_may_not_follow_optional_type_parameters = 2706,\n  Duplicate_property_0 = 2718,\n  Property_0_is_missing_in_type_1_but_required_in_type_2 = 2741,\n  Type_0_has_no_call_signatures = 2757,\n  File_0_not_found = 6054,\n  Numeric_separators_are_not_allowed_here = 6188,\n  Multiple_consecutive_numeric_separators_are_not_permitted = 6189,\n  _super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = 17009,\n  _super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = 17011\n}\n\n/** Translates a diagnostic code to its respective string. */\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Not implemented: {0}\";\n    case 101: return \"Operation is unsafe.\";\n    case 102: return \"User-defined: {0}\";\n    case 103: return \"Feature '{0}' is not enabled.\";\n    case 104: return \"Low memory limit exceeded by static data: {0} > {1}\";\n    case 105: return \"Module requires at least '{0}' pages of initial memory.\";\n    case 106: return \"Module requires at least '{0}' pages of maximum memory.\";\n    case 107: return \"Shared memory requires maximum memory to be defined.\";\n    case 108: return \"Shared memory requires feature 'threads' to be enabled.\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Operation '{0}' cannot be applied to type '{1}'.\";\n    case 204: return \"Type '{0}' cannot be nullable.\";\n    case 205: return \"Cannot export a mutable global.\";\n    case 206: return \"Mutable value cannot be inlined.\";\n    case 207: return \"Unmanaged classes cannot extend managed classes and vice-versa.\";\n    case 208: return \"Unmanaged classes cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Expression is never 'null'.\";\n    case 211: return \"Class '{0}' is final and cannot be extended.\";\n    case 212: return \"Decorator '{0}' is not valid here.\";\n    case 213: return \"Duplicate decorator.\";\n    case 214: return \"Type '{0}' is illegal in this context.\";\n    case 215: return \"Optional parameter must have an initializer.\";\n    case 216: return \"Class '{0}' cannot declare a constructor when instantiated from an object literal.\";\n    case 217: return \"Function '{0}' cannot be inlined into itself.\";\n    case 218: return \"Cannot access method '{0}' without calling it as it requires 'this' to be set.\";\n    case 219: return \"Optional properties are not supported.\";\n    case 220: return \"Expression must be a compile-time constant.\";\n    case 221: return \"Type '{0}' is not a function index or function reference.\";\n    case 222: return \"'{0}' must be a value between '{1}' and '{2}' inclusive.\";\n    case 223: return \"'{0}' must be a power of two.\";\n    case 224: return \"'{0}' is not a valid operator.\";\n    case 225: return \"Expression cannot be represented by a type.\";\n    case 226: return \"Expression resolves to unusual type '{0}'.\";\n    case 227: return \"Array literal expected.\";\n    case 228: return \"Function '{0}' is virtual and will not be inlined.\";\n    case 229: return \"Property '{0}' only has a setter and is missing a getter.\";\n    case 230: return \"'{0}' keyword cannot be used here.\";\n    case 231: return \"A class with a constructor explicitly returning something else than 'this' must be '@final'.\";\n    case 232: return \"Exported generic function or class has no concrete instances.\";\n    case 233: return \"Property '{0}' is always assigned before being used.\";\n    case 900: return \"Type '{0}' is cyclic. Module will include deferred garbage collection.\";\n    case 901: return \"Importing the table disables some indirect call optimizations.\";\n    case 902: return \"Exporting the table disables some indirect call optimizations.\";\n    case 903: return \"Expression compiles to a dynamic check at runtime.\";\n    case 904: return \"Indexed access may involve bounds checking.\";\n    case 905: return \"Explicitly returning constructor drops 'this' allocation.\";\n    case 906: return \"Unnecessary definite assignment.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1099: return \"Type argument list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1120: return \"An export assignment cannot have modifiers.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1034: return \"'super' must be followed by an argument list or member access.\";\n    case 1038: return \"A 'declare' modifier cannot be used in an already ambient context.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1176: return \"Interface declaration cannot have 'implements' clause.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1190: return \"The variable declaration of a 'for...of' statement cannot have an initializer.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1245: return \"Method '{0}' cannot have an implementation because it is marked abstract.\";\n    case 1255: return \"A definite assignment assertion '!' is not permitted in this context.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 1317: return \"A parameter property cannot be declared using a rest parameter.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2312: return \"An interface can only extend an interface.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2337: return \"Super calls are not permitted outside constructors or in nested functions inside constructors.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2341: return \"Property '{0}' is private and only accessible within class '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"This expression is not constructable.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2376: return \"A 'super' call must be the first statement in the constructor.\";\n    case 2377: return \"Constructors for derived classes must contain a 'super' call.\";\n    case 2379: return \"Getter and setter accessors do not agree in visibility.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2385: return \"Overload signatures must all be public, private or protected.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2394: return \"This overload signature is not compatible with its implementation signature.\";\n    case 2395: return \"Individual declarations in merged declaration '{0}' must be all exported or all local.\";\n    case 2422: return \"A class can only implement an interface.\";\n    case 2434: return \"A namespace declaration cannot be located prior to a class or function with which it is merged.\";\n    case 2445: return \"Property '{0}' is protected and only accessible within class '{1}' and its subclasses.\";\n    case 2448: return \"Variable '{0}' used before its declaration.\";\n    case 2453: return \"The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.\";\n    case 2460: return \"Type '{0}' has no property '{1}'.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2474: return \"In 'const' enum declarations member initializer must be constant expression.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2506: return \"'{0}' is referenced directly or indirectly in its own base expression.\";\n    case 2511: return \"Cannot create an instance of an abstract class.\";\n    case 2515: return \"Non-abstract class '{0}' does not implement inherited abstract member '{1}' from '{2}'.\";\n    case 2531: return \"Object is possibly 'null'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2564: return \"Property '{0}' has no initializer and is not assigned in the constructor before 'this' is used or returned.\";\n    case 2565: return \"Property '{0}' is used before being assigned.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2673: return \"Constructor of class '{0}' is private and only accessible within the class declaration.\";\n    case 2674: return \"Constructor of class '{0}' is protected and only accessible within the class declaration.\";\n    case 2685: return \"The 'this' types of each signature are incompatible.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 2706: return \"Required type parameters may not follow optional type parameters.\";\n    case 2718: return \"Duplicate property '{0}'.\";\n    case 2741: return \"Property '{0}' is missing in type '{1}' but required in type '{2}'.\";\n    case 2757: return \"Type '{0}' has no call signatures.\";\n    case 6054: return \"File '{0}' not found.\";\n    case 6188: return \"Numeric separators are not allowed here.\";\n    case 6189: return \"Multiple consecutive numeric separators are not permitted.\";\n    case 17009: return \"'super' must be called before accessing 'this' in the constructor of a derived class.\";\n    case 17011: return \"'super' must be called before accessing a property of 'super' in the constructor of a derived class.\";\n    default: return \"\";\n  }\n}\n","/**\n * @fileoverview Shared diagnostic handling.\n * @license Apache-2.0\n */\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Source\n} from \"./ast\";\n\nimport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\nimport {\n  isLineBreak\n} from \"./util\";\n\nexport {\n  DiagnosticCode,\n  diagnosticCodeToString\n} from \"./diagnosticMessages.generated\";\n\n/** Indicates the category of a {@link DiagnosticMessage}. */\nexport enum DiagnosticCategory {\n  /** Overly pedantic message. */\n  PEDANTIC,\n  /** Informatory message. */\n  INFO,\n  /** Warning message. */\n  WARNING,\n  /** Error message. */\n  ERROR\n}\n\n/** Returns the string representation of the specified diagnostic category. */\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return \"PEDANTIC\";\n    case DiagnosticCategory.INFO: return \"INFO\";\n    case DiagnosticCategory.WARNING: return \"WARNING\";\n    case DiagnosticCategory.ERROR: return \"ERROR\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** ANSI escape sequence for blue foreground. */\nexport const COLOR_BLUE: string = \"\\u001b[96m\";\n/** ANSI escape sequence for yellow foreground. */\nexport const COLOR_YELLOW: string = \"\\u001b[93m\";\n/** ANSI escape sequence for red foreground. */\nexport const COLOR_RED: string = \"\\u001b[91m\";\n/** ANSI escape sequence for magenta foreground. */\nexport const COLOR_MAGENTA: string = \"\\u001b[95m\";\n/** ANSI escape sequence to reset the foreground color. */\nexport const COLOR_RESET: string = \"\\u001b[0m\";\n\n/** Returns the ANSI escape sequence for the specified category. */\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\n  switch (category) {\n    case DiagnosticCategory.PEDANTIC: return COLOR_MAGENTA;\n    case DiagnosticCategory.INFO: return COLOR_BLUE;\n    case DiagnosticCategory.WARNING: return COLOR_YELLOW;\n    case DiagnosticCategory.ERROR: return COLOR_RED;\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\n/** Represents a diagnostic message. */\nexport class DiagnosticMessage {\n\n  /** Message code. */\n  code: i32;\n  /** Message category. */\n  category: DiagnosticCategory;\n  /** Message text. */\n  message: string;\n  /** Respective source range, if any. */\n  range: Range | null = null;\n  /** Related range, if any. */\n  relatedRange: Range | null = null; // TODO: Make this a related message for chains?\n\n  /** Constructs a new diagnostic message. */\n  private constructor(code: i32, category: DiagnosticCategory, message: string) {\n    this.code = code;\n    this.category = category;\n    this.message = message;\n  }\n\n  /** Creates a new diagnostic message of the specified category. */\n  static create(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): DiagnosticMessage {\n    var message = diagnosticCodeToString(code);\n    if (arg0 !== null) message = message.replace(\"{0}\", arg0);\n    if (arg1 !== null) message = message.replace(\"{1}\", arg1);\n    if (arg2 !== null) message = message.replace(\"{2}\", arg2);\n    return new DiagnosticMessage(code, category, message);\n  }\n\n  /** Tests if this message equals the specified. */\n  equals(other: DiagnosticMessage): bool {\n    if (this.code != other.code) return false;\n    var thisRange = this.range;\n    var otherRange = other.range;\n    if (thisRange) {\n      if (!otherRange || !thisRange.equals(otherRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    var thisRelatedRange = this.relatedRange;\n    var otherRelatedRange = other.relatedRange;\n    if (thisRelatedRange) {\n      if (!otherRelatedRange || !thisRelatedRange.equals(otherRelatedRange)) return false;\n    } else if (otherRange) {\n      return false;\n    }\n    return this.message == other.message;\n  }\n\n  /** Adds a source range to this message. */\n  withRange(range: Range): this {\n    this.range = range;\n    return this;\n  }\n\n  /** Adds a related source range to this message. */\n  withRelatedRange(range: Range): this {\n    this.relatedRange = range;\n    return this;\n  }\n\n  /** Converts this message to a string. */\n  toString(): string {\n    var range = this.range;\n    if (range) {\n      let source = range.source;\n      return (\n        diagnosticCategoryToString(this.category) +\n        \" \" +\n        this.code.toString() +\n        \": \\\"\" +\n        this.message +\n        \"\\\" in \" +\n        source.normalizedPath +\n        \"(\" +\n        source.lineAt(range.start).toString() +\n        \",\" +\n        source.columnAt().toString() +\n        \"+\" +\n        (range.end - range.start).toString() +\n        \")\"\n      );\n    }\n    return (\n      diagnosticCategoryToString(this.category) +\n      \" \" +\n      this.code.toString() +\n      \": \" +\n      this.message\n    );\n  }\n}\n\n/** Formats a diagnostic message, optionally with terminal colors and source context. */\nexport function formatDiagnosticMessage(\n  message: DiagnosticMessage,\n  useColors: bool = false,\n  showContext: bool = false\n): string {\n\n  // general information\n  var sb: string[] = [];\n  if (useColors) sb.push(diagnosticCategoryToColor(message.category));\n  sb.push(diagnosticCategoryToString(message.category));\n  if (useColors) sb.push(COLOR_RESET);\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\n  sb.push(message.code.toString());\n  sb.push(\": \");\n  sb.push(message.message);\n\n  // include range information if available\n  var range = message.range;\n  if (range) {\n    let source = range.source;\n\n    // include context information if requested\n    if (showContext) {\n      sb.push(\"\\n\");\n      sb.push(formatDiagnosticContext(range, useColors));\n    }\n    sb.push(\"\\n\");\n    sb.push(\" in \");\n    sb.push(source.normalizedPath);\n    sb.push(\"(\");\n    sb.push(source.lineAt(range.start).toString());\n    sb.push(\",\");\n    sb.push(source.columnAt().toString());\n    sb.push(\")\");\n\n    let relatedRange = message.relatedRange;\n    if (relatedRange) {\n      let relatedSource = relatedRange.source;\n      if (showContext) {\n        sb.push(\"\\n\");\n        sb.push(formatDiagnosticContext(relatedRange, useColors));\n      }\n      sb.push(\"\\n\");\n      sb.push(\" in \");\n      sb.push(relatedSource.normalizedPath);\n      sb.push(\"(\");\n      sb.push(relatedSource.lineAt(relatedRange.start).toString());\n      sb.push(\",\");\n      sb.push(relatedSource.columnAt().toString());\n      sb.push(\")\");\n    }\n  }\n  return sb.join(\"\");\n}\n\n/** Formats the diagnostic context for the specified range, optionally with terminal colors. */\nexport function formatDiagnosticContext(range: Range, useColors: bool = false): string {\n  var text = range.source.text;\n  var len = text.length;\n  var start = range.start;\n  var end = range.end;\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) start--;\n  while (end < len && !isLineBreak(text.charCodeAt(end))) end++;\n  var sb: string[] = [\n    \"\\n \",\n    text.substring(start, end),\n    \"\\n \"\n  ];\n  while (start < range.start) {\n    sb.push(\" \");\n    start++;\n  }\n  if (useColors) sb.push(COLOR_RED);\n  if (range.start == range.end) {\n    sb.push(\"^\");\n  } else {\n    while (start++ < range.end) {\n      if (isLineBreak(text.charCodeAt(start))) {\n        sb.push(start == range.start + 1 ? \"^\" : \"~\");\n        break;\n      }\n      sb.push(\"~\");\n    }\n  }\n  if (useColors) sb.push(COLOR_RESET);\n  return sb.join(\"\");\n}\n\n/** Base class of all diagnostic emitters. */\nexport abstract class DiagnosticEmitter {\n\n  /** Diagnostic messages emitted so far. */\n  diagnostics: DiagnosticMessage[];\n  /** Diagnostic messages already seen, by range. */\n  private seen: Map<Source,Map<i32,DiagnosticMessage[]>> = new Map();\n\n  /** Initializes this diagnostic emitter. */\n  protected constructor(diagnostics: DiagnosticMessage[] | null = null) {\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n  }\n\n  /** Emits a diagnostic message of the specified category. */\n  emitDiagnostic(\n    code: DiagnosticCode,\n    category: DiagnosticCategory,\n    range: Range | null,\n    relatedRange: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2);\n    if (range) message = message.withRange(range);\n    if (relatedRange) message.relatedRange = relatedRange;\n    // It is possible that the same diagnostic is emitted twice, for example\n    // when compiling generics with different types or when recompiling a loop\n    // because our initial assumptions didn't hold. It is even possible to get\n    // multiple instances of the same range during parsing. Deduplicate these.\n    if (range) {\n      let seen = this.seen;\n      if (seen.has(range.source)) {\n        let seenInSource = assert(seen.get(range.source));\n        if (seenInSource.has(range.start)) {\n          let seenMessagesAtPos = assert(seenInSource.get(range.start));\n          for (let i = 0, k = seenMessagesAtPos.length; i < k; ++i) {\n            if (seenMessagesAtPos[i].equals(message)) return;\n          }\n          seenMessagesAtPos.push(message);\n        } else {\n          seenInSource.set(range.start, [ message ]);\n        }\n      } else {\n        let seenInSource = new Map<i32,DiagnosticMessage[]>();\n        seenInSource.set(range.start, [ message ]);\n        seen.set(range.source, seenInSource);\n      }\n    }\n    this.diagnostics.push(message);\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\n    // console.log(<string>new Error(\"stack\").stack);\n  }\n\n  /** Emits an overly pedantic diagnostic message. */\n  pedantic(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an overly pedantic diagnostic message with a related range. */\n  pedanticRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.PEDANTIC, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message. */\n  info(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an informatory diagnostic message with a related range. */\n  infoRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message. */\n  warning(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits a warning diagnostic message with a related range. */\n  warningRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, relatedRange, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message. */\n  error(\n    code: DiagnosticCode,\n    range: Range | null,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, null, arg0, arg1, arg2);\n  }\n\n  /** Emits an error diagnostic message with a related range. */\n  errorRelated(\n    code: DiagnosticCode,\n    range: Range,\n    relatedRange: Range,\n    arg0: string | null = null,\n    arg1: string | null = null,\n    arg2: string | null = null\n  ): void {\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, relatedRange, arg0, arg1, arg2);\n  }\n}\n","import {\n  SerializeInserter,\n  InsertPoint\n} from \"./inserter\";\n\nimport {\n  Type,\n  TypeKind,\n} from \"../types\";\n\nimport {\n  ElementKind,\n  Element,\n  ClassPrototype,\n  FunctionPrototype,\n  Program,\n  VariableLikeElement,\n} from \"../program\";\n\nimport {\n  DecoratorKind,\n  FunctionDeclaration,\n  DeclarationStatement,\n  FieldDeclaration,\n  NodeKind,\n  ParameterNode,\n  Expression,\n  VariableLikeDeclarationStatement,\n  StringLiteralExpression,\n  TypeNode,\n  DecoratorNode,\n  Node,\n  ClassDeclaration,\n  NamedTypeNode\n} from \"../ast\";\n\nimport {\n  AstUtil,\n  TypeNodeAnalyzer,\n  TypeNodeDesc,\n  AbiTypeEnum\n} from \"./astutil\";\n\nimport {\n  Strings,\n  AbiUtils,\n  Indent\n} from \"./primitiveutil\";\n\nimport {\n  ExportGenerator, StorageGenerator\n} from './generator';\n\nclass StructDef {\n  name: string = '';\n  fields: Array<Object> = new Array<Object>();\n  base: string = '';\n\n  addField(name: string, type: string): void {\n    this.fields.push({ \"name\": name, \"type\": type });\n  }\n}\n\nexport class ExportMethod {\n  methodName: string = \"\";\n  paramters: TypeNodeDesc[] = new Array();\n  hasReturnVal: boolean = false;\n  returnType: TypeNodeDesc | undefined;\n}\n\nexport class ExportDef {\n  className: string;\n  deployers: ExportMethod[] = new Array();\n  messages: ExportMethod[] = new Array();\n\n  constructor(clzName: string) {\n    this.className = clzName;\n  }\n}\n\nclass AbiAliasDef {\n  new_type_name: string;\n  type: string;\n\n  constructor(newTypeName: string, wasmType: string) {\n    this.new_type_name = newTypeName;\n    this.type = wasmType;\n  }\n}\n\n/**\n * Contract abi action. This class represents one action structure.\n * The field \"ability\" represents whether action would change the db status.\n * It has two values, normal and pureview.\n * Pureview represents readable action which would not change the db.\n */\nclass ActionDef {\n  name: string;\n  type: string;\n  ability: string;\n  ricardian_contract: string = \"\";\n\n  constructor(name: string, type: string, ability: string = \"normal\") {\n    this.name = name;\n    this.type = type;\n    this.ability = ability;\n  }\n\n  static isValidAbility(ability: string): boolean {\n    return ability == \"normal\" || ability == \"pureview\";\n  }\n}\n\nexport class AbiHelper {\n  /**\n   * Main node support internal abi type\n   * bool\n   */\n  static abiTypeLookup: Map<string, string> = new Map([\n    [\"i8\", \"int8\"],\n    [\"i16\", \"int16\"],\n    [\"i32\", \"int32\"],\n    [\"i64\", \"int64\"],\n    [\"isize\", \"uin32\"],\n    [\"u8\", \"uint8\"],\n    [\"u16\", \"uint16\"],\n    [\"u32\", \"uint32\"],\n    [\"u64\", \"uint64\"],\n    [\"usize\", \"usize\"],\n    [\"f32\", \"float32\"],\n    [\"f64\", \"float64\"],\n    [\"bool\", \"bool\"],\n    [\"boolean\", \"bool\"],\n    [\"string\", \"string\"],\n    [\"String\", \"string\"],\n  ]);\n}\n\nclass TableDef {\n  name: string;\n  type: string;\n  index_type: string = \"i64\";\n  keys_names: string[] = [\"currency\"];\n  keys_types: string[] = [\"uint64\"];\n\n  constructor(name: string, type: string, indexType: string = \"i64\") {\n    this.name = name;\n    this.type = type;\n    this.index_type = indexType;\n  }\n}\n\n/**\n * Abi defination\n */\nclass AbiDef {\n  version: string = \"link\";\n  types: Array<AbiAliasDef> = new Array<AbiAliasDef>();\n  structs: Array<StructDef> = new Array<StructDef>();\n  actions: Array<ActionDef> = new Array<ActionDef>();\n  tables: Array<TableDef> = new Array<TableDef>();\n}\n\nexport class AbiInfo {\n\n  abiInfo: AbiDef = new AbiDef();\n  dispatch: string = '';\n  program: Program;\n  abiTypeLookup: Map<string, string> = AbiHelper.abiTypeLookup;\n  typeAliasSet: Set<string> = new Set<string>();\n  structsLookup: Map<string, StructDef> = new Map();\n  elementLookup: Map<string, Element> = new Map();\n  exportIndent: Indent = new Indent();\n  exportDef: ExportDef = new ExportDef(\"\");\n  insertPointsLookup: Map<string, Array<InsertPoint>> = new Map<string, Array<InsertPoint>>();\n\n  constructor(program: Program) {\n    this.program = program;\n    this.resolve();\n  }\n\n  private addAbiTypeAlias(typeNodeAnalyzer: TypeNodeAnalyzer): void {\n    var asTypes = typeNodeAnalyzer.getAsTypes();\n    for (let asType of asTypes) {\n      if (this.typeAliasSet.has(asType)) {\n        continue;\n      }\n      // if the as argument is basic type, get his alias type\n      let abiType = typeNodeAnalyzer.findSourceAbiType(asType);\n      if (abiType && asType != abiType) {\n        this.abiInfo.types.push(new AbiAliasDef(asType, abiType));\n      }\n      // If the as argument is class, convert it to struct\n      let element = typeNodeAnalyzer.findElement(asType);\n      if (element && element.kind == ElementKind.CLASS_PROTOTYPE) {\n        let classPrototype = <ClassPrototype>element;\n        this.getStructFromClzPrototype(classPrototype);\n      }\n      this.typeAliasSet.add(asType);\n    }\n  }\n\n\n\n  resolveDatabaseDecorator(clsProto: ClassPrototype): void {\n    var decorators = clsProto.decoratorNodes;\n    if (!decorators) {\n      return;\n    }\n    for (let decorator of decorators) {\n      if (decorator.decoratorKind == DecoratorKind.DATABASE && decorator.args) {\n        // Decorator argument must have two arguments\n        if (decorator.args.length != 2) {\n          throw new Error(\"Database decorator must have two arguments\");\n        }\n        let type = decorator.args[0].range.toString();\n        let name = this.getExprValue(clsProto, decorator.args[1]);\n        AbiUtils.checkDatabaseName(name);\n        this.abiInfo.tables.push(new TableDef(name, type));\n        this.getStructFromNode(clsProto, decorator.args[0]);\n      }\n    }\n  }\n\n  /**\n   * Get the expression value.\n   * @param expr\n   */\n  getExprValue(protoEle: Element,expr: Expression): string {\n    var arg: string = expr.range.toString();\n    if (Strings.isAroundQuotation(arg)) {\n      return arg.substring(1, arg.length - 1);\n    }\n    var element = protoEle.lookup(arg);\n    var internalName = AstUtil.getInternalName(expr);\n    if (!element) {\n      element = this.program.elementsByName.get(internalName) || null;\n    }\n    if (element) {\n      let declaration = <VariableLikeDeclarationStatement> (<VariableLikeElement>element).declaration;\n      if (declaration.initializer) {\n        let literal = <StringLiteralExpression>declaration.initializer;\n        return literal.value;\n      }\n    }\n    throw new Error(`Can't find constant ${internalName}`);\n  }\n\n  /**\n  *  Get struct from expression.\n  */\n  private getStructFromNode(ele: Element, node: Node): void {\n    var element = ele.lookup(node.range.toString());\n    var classPrototype = <ClassPrototype>element;\n    this.getStructFromClzPrototype(classPrototype);\n  }\n\n  /**\n   * Add the field of the class to the structure\n   * @param classPrototype The class prototype\n   * @param struct The abi structure\n   */\n  private addFieldsFromClassPrototype(classPrototype: ClassPrototype, struct: StructDef): void {\n    var members: DeclarationStatement[] = (<ClassDeclaration>classPrototype.declaration).members;\n    if (classPrototype.basePrototype && AstUtil.impledSerializable(classPrototype.basePrototype)) {\n      this.addFieldsFromClassPrototype(classPrototype.basePrototype, struct);\n    }\n    for (let member of members) {\n      if (member.kind == NodeKind.FIELDDECLARATION) {\n        let fieldDeclare: FieldDeclaration = <FieldDeclaration>member;\n        let memberName = member.name.range.toString();\n        let memberType: TypeNode | null = fieldDeclare.type;\n        if (memberType && !AstUtil.haveSpecifyDecorator(fieldDeclare, DecoratorKind.DEPLOYER)) {\n          let typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(classPrototype, <NamedTypeNode>memberType);\n          let abiType = typeNodeAnalyzer.getAbiDeclareType();\n          struct.addField(memberName, abiType);\n          this.addAbiTypeAlias(typeNodeAnalyzer);\n        }\n      }\n    }\n  }\n\n  private getStructFromClzPrototype(classPrototype: ClassPrototype): void {\n    if (!this.abiTypeLookup.get(classPrototype.name)) {\n      let struct = new StructDef();\n      struct.name = classPrototype.name;\n      this.addFieldsFromClassPrototype(classPrototype, struct);\n      this.addToStruct(struct);\n    }\n  }\n\n  /**\n   * It need to check the struct having fields.\n   * @param struct the struct to add\n   */\n  private addToStruct(struct: StructDef): void {\n    if (!this.structsLookup.has(struct.name)) {\n      this.abiInfo.structs.push(struct);\n      this.structsLookup.set(struct.name, struct);\n    }\n  }\n\n\n  /**\n  *  Resolve ClassPrototype to dispatcher\n  */\n  \n\n  private getActionAbility(funcPrototype: FunctionPrototype): string {\n    var statement = funcPrototype.declaration;\n    var decoratorNode: DecoratorNode | null = AstUtil.getSpecifyDecorator(statement, DecoratorKind.MESSAGE);\n    if (!decoratorNode) {\n      throw new Error(`The function don't have action decorator, location: ${AstUtil.location(statement.range)}.`);\n    }\n    var args: Expression[] | null = decoratorNode.args;\n    if (args && args.length > 0) {\n      let arg = this.getExprValue(funcPrototype, args[0]);\n      if (!ActionDef.isValidAbility(arg)) {\n        throw new Error(`Invalid action ability arguments: ${arg}, location: ${AstUtil.location(statement.range)}.`);\n      }\n      return arg;\n    }\n    return \"normal\";\n  }\n\n  /**\n   * Resolve funciton prototype to abi\n   */\n  private resolveFunctionPrototype(funcProto: FunctionPrototype): void {\n\n    var declaration: FunctionDeclaration = <FunctionDeclaration> funcProto.declaration;\n    var funcName = declaration.name.range.toString();\n    var signature = declaration.signature;\n\n    var struct = new StructDef();\n    struct.name = funcName;\n\n    var parameters: ParameterNode[] = signature.parameters;\n    for (let parameter of parameters) {\n      let type: TypeNode = parameter.type;\n      let typeInfo = new TypeNodeAnalyzer(funcProto,  <NamedTypeNode>type);\n      let abiType = typeInfo.getAbiDeclareType();\n      struct.addField(parameter.name.range.toString(), abiType);\n      this.addAbiTypeAlias(typeInfo);\n    }\n\n    this.addToStruct(struct);\n    this.abiInfo.actions.push(new ActionDef(funcName, funcName, this.getActionAbility(funcProto)));\n  }\n\n\n  private isContractClassPrototype(element: Element): boolean {\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      let clzPrototype = <ClassPrototype>element;\n      return clzPrototype.instanceMembers != null && \n      AstUtil.haveSpecifyDecorator(clzPrototype.declaration, DecoratorKind.CONTRACT);\n    }\n    return false;\n  }\n\n  private isStoreClassPrototype(element: Element): boolean {\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      let clzPrototype = <ClassPrototype>element;\n      return clzPrototype.instanceMembers != null &&\n        AstUtil.haveSpecifyDecorator(clzPrototype.declaration, DecoratorKind.STORAGE);\n    }\n    return false;\n  }\n\n\n  private resolve(): void {\n    var serializeInserter: SerializeInserter = new SerializeInserter(this.program);\n    var serializePoints = serializeInserter.getInsertPoints();\n    this.insertPointsLookup = InsertPoint.toSortedMap(serializePoints);\n\n    for (let [key, element] of this.program.elementsByName) {\n      // find class \n      if (!this.elementLookup.has(key) && this.isContractClassPrototype(element)) {\n        let exportGenerator = new ExportGenerator(<ClassPrototype>element)\n      \n        this.exportDef = exportGenerator.generateExportDef();\n      }\n\n      if (!this.elementLookup.has(key) && this.isStoreClassPrototype(element)) {\n        let storeGenerator: StorageGenerator = new StorageGenerator(<ClassPrototype>element);\n        this.exportIndent.joinIndents([storeGenerator.getBody()]);\n      }\n    }\n  }\n}\n\nexport function getAbiInfo(program: Program): AbiInfo {\n  return new AbiInfo(program);\n}\n","import {\n    DeclarationStatement,\n    DecoratorKind,\n    Node,\n    ClassDeclaration,\n    DecoratorNode,\n    TypeDeclaration,\n    NamedTypeNode\n} from \"../ast\";\n\nimport {\n    Range\n} from \"../tokenizer\";\n\nimport {\n    ClassPrototype,\n    Element,\n    ElementKind,\n    TypeDefinition,\n    DecoratorFlags,\n    FunctionPrototype\n} from \"../program\";\n\nimport {\n    Type\n} from \"../types\";\n\nimport {\n    Collections\n} from \"./collectionutil\";\n\nimport {\n    AbiHelper\n} from \"./abi\";\n\nexport class AstUtil {\n\n    /**\n     * Check the statment weather have the specify the decorator\n     * @param statement Ast declaration statement\n     * @param kind The specify decorators\n     */\n    static haveSpecifyDecorator(statement: DeclarationStatement, kind: DecoratorKind): boolean {\n        if (statement.decorators) {\n            for (let decorator of statement.decorators) {\n                if (decorator.decoratorKind == kind) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    static getSpecifyDecorator(statement: DeclarationStatement, kind: DecoratorKind): DecoratorNode | null {\n        if (statement.decorators) {\n            for (let decorator of statement.decorators) {\n                if (decorator.decoratorKind == kind) {\n                    return decorator;\n                }\n            }\n        }\n        return null;\n    }\n\n    static isString(typeName: string): boolean {\n        return \"string\" == typeName || \"String\" == typeName;\n    }\n\n    /**\n     * Get the node internal name\n     * @param node The program node\n     */\n    static getInternalName(node: Node): string {\n        var internalPath = node.range.source.internalPath;\n        var name = node.range.toString();\n        var internalName = `${internalPath}/${name}`;\n        return internalName.replace(\",\", \"_\");\n    }\n\n    /**\n     * Get the basic type name\n     * If the type name is string[], so the basic type name is string\n     * @param declareType\n     */\n    static getArrayTypeArgument(declareType: string): string {\n        assert(AstUtil.isArrayType(declareType));\n        var bracketIndex = declareType.indexOf(\"[\");\n        if (bracketIndex != -1) {\n            let index = declareType.indexOf(\" \") == -1 ? bracketIndex : declareType.indexOf(\" \");\n            return declareType.substring(0, index);\n        }\n        bracketIndex = declareType.indexOf(\"<\");\n        if (bracketIndex != -1) {\n            let endIndex = declareType.indexOf(\">\");\n            return declareType.substring(bracketIndex + 1, endIndex);\n        }\n        return declareType;\n    }\n\n    /**\n     * Test the declare type whether is array type or not.\n     * @param declareType The declare type\n     */\n    static isArrayType(declareType: string): boolean {\n        return declareType == \"[]\" || declareType == \"Array\";\n    }\n\n    /**\n     * Whether the declare type is map\n     * @param declareType the declare type\n     */\n    static isMapType(declareType: string): boolean {\n        return declareType == \"Map\";\n    }\n\n    /**\n     * Test the class whether to implement the Serializable interface or not.\n     */\n    static impledSerializable(classPrototype: ClassPrototype | null): boolean {\n        if (!classPrototype) {\n            return false;\n        }\n        const interfaceName = \"Serializable\";\n        var havingInterface = AstUtil.impledInterface(<ClassDeclaration>classPrototype.declaration, interfaceName);\n        return havingInterface || AstUtil.impledSerializable(classPrototype.basePrototype);\n    }\n\n    /**\n     * Test the class whetherto implement the Returnable interface or not.\n     * @param classDeclaration The class declaration\n     */\n    static impledReturnable(classDeclaration: ClassDeclaration): boolean {\n        const interfaceName = \"Returnable\";\n        return AstUtil.impledInterface(classDeclaration, interfaceName);\n    }\n\n    private static impledInterface(classDeclaration: ClassDeclaration, interfaceName: string): boolean {\n        var implementsTypes = classDeclaration.implementsTypes;\n        if (implementsTypes) {\n            for (let _type of implementsTypes) {\n                if (_type.name.range.toString() == interfaceName) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Check the classPrototype whther have the contract class.\n     */\n    static extendedContract(classPrototype: ClassPrototype): boolean {\n        const contractName = \"Contract\";\n        var basePrototype: ClassPrototype | null = classPrototype.basePrototype;\n        if (basePrototype && basePrototype.name == contractName) {\n            return true;\n        }\n        return false;\n    }\n\n    static isClassPrototype(element: Element): boolean {\n        return element.kind == ElementKind.CLASS_PROTOTYPE;\n    }\n\n    static isSpecifyElement(element: Element, kind: ElementKind): boolean {\n        return element.kind == kind;\n    }\n\n    /**\n     * Check the element whether is action function prototype.\n     * @param element \n     */\n    static isActionFnPrototype(element: Element): boolean {\n        if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n            let funcType = <FunctionPrototype>element;\n            return AstUtil.haveSpecifyDecorator(funcType.declaration, DecoratorKind.MESSAGE);\n        }\n        return false;\n    }\n\n    /**\n    * Check the element whether is action function prototype.\n    * @param element \n    */\n    static isDeployerFnPrototype(element: Element): boolean {\n        if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n            let funcType = <FunctionPrototype>element;\n            return AstUtil.haveSpecifyDecorator(funcType.declaration, DecoratorKind.DEPLOYER);\n        }\n        return false;\n    }\n\n\n    /**\n     * Get interfaces that class prototype implements.\n     * @param classPrototype classPrototype\n     */\n    static impledInterfaces(classPrototype: ClassPrototype): string[] {\n        var tempClz: ClassPrototype | null = classPrototype;\n        var interfaces: string[] = new Array<string>();\n        while (tempClz != null) {\n            let implTypes = (<ClassDeclaration>tempClz.declaration).implementsTypes;\n            if (implTypes) {\n                for (let type of implTypes) {\n                    interfaces.push(type.name.range.toString());\n                }\n            }\n            tempClz = tempClz.basePrototype;\n        }\n        return interfaces;\n    }\n\n    static location(range: Range): string {\n        // TODO\n        return range.source.normalizedPath + \":\" \n        + range.start.toString(10) + \":\"\n        + range.end.toString(10);\n    }\n}\n\n/**\n * Abi type enum\n */\nexport enum AbiTypeEnum {\n    NUMBER,\n    STRING,\n    ARRAY,\n    MAP,\n    CLASS\n}\n\ninterface TypeInfo {\n    getAbiTypeEnum(): void;\n    getAbiDeclareType(): string;\n    getArgs(): string[];\n    getSourceType(typeName: string): string;\n}\n\nexport class TypeNodeDesc {\n    abiType: AbiTypeEnum | undefined;\n    typeName: string = \"\";\n    codecType: string | undefined = \"\";\n    originalType: string = \"\";\n    defaultVal: string | undefined = \"\";\n}\n\nexport class TypeNodeAnalyzer extends TypeNodeDesc{\n\n    parent: Element;\n    typeNode: NamedTypeNode;\n    subTypes: TypeNodeAnalyzer[] = new Array();\n\n    constructor(parent: Element ,typeNode: NamedTypeNode) {\n        super();\n        this.parent = parent;\n        this.typeNode = typeNode;\n        // Here various clz[]'s type name is [], not clz.\n        this.typeName = this.typeNode.name.range.toString();\n    }\n\n    getDeclareType(): string {\n        return this.typeNode.range.toString();\n    }\n\n    isVoid(): boolean {\n        return this.typeName == \"void\";\n    }\n\n    get abiTypeEnum(): AbiTypeEnum {\n        var typeName = this.typeName;\n        if (AstUtil.isString(typeName)) {\n            return AbiTypeEnum.STRING;\n        }\n        if (AstUtil.isArrayType(typeName)) {\n            return AbiTypeEnum.ARRAY;\n        }\n        if (AstUtil.isMapType(typeName)) {\n            return AbiTypeEnum.MAP;\n        }\n        var type = this.findElement(typeName);\n\n        if (type) {\n            if (type.kind == ElementKind.TYPEDEFINITION) {\n                let typeDefine = <TypeDefinition>type;\n                let declaration = <TypeDeclaration>typeDefine.declaration;\n                let _typeNode = <NamedTypeNode>declaration.type;\n                let name = _typeNode.name.range.toString();\n                if (AbiHelper.abiTypeLookup.get(name) && name != \"Asset\") {\n                    return AbiTypeEnum.NUMBER;\n                }\n            }\n            if (type.kind == ElementKind.CLASS_PROTOTYPE) {\n                return AbiTypeEnum.CLASS;\n            }\n        }\n        return AbiTypeEnum.NUMBER;\n    }\n\n    isArray(): boolean {\n        return this.abiTypeEnum == AbiTypeEnum.ARRAY;\n    }\n\n    getArrayArgAbiTypeEnum(): AbiTypeEnum {\n        var typeName = this.getArgs()[0];\n        if (AstUtil.isString(typeName)) {\n            return AbiTypeEnum.STRING;\n        }\n        var type = this.findSourceAsElement(typeName);\n        if (type != null && type.kind == ElementKind.CLASS_PROTOTYPE) {\n            return AbiTypeEnum.CLASS;\n        }\n        return AbiTypeEnum.NUMBER;\n    }\n\n    isPrimaryType(): boolean {\n        if (this.abiTypeEnum == AbiTypeEnum.NUMBER) {\n            return this.findSourceAsTypeName(this.typeName) == \"u64\";\n        }\n        return false;\n    }\n\n    getArrayArg(): string {\n        if (this.typeNode.typeArguments) {\n            return this.typeNode.typeArguments[0].range.toString();\n        }\n        throw new Error(`The typenode is not array:${this.typeName}.`\n            + ` Location in ${AstUtil.location(this.typeNode.range)}`);\n    }\n\n    getAbiDeclareType(): string {\n        var abiType = this.abiTypeEnum;\n        var typeName = this.typeNode.name.range.toString();\n        switch (abiType) {\n            case AbiTypeEnum.STRING: {\n                return \"string\";\n            }\n            case AbiTypeEnum.NUMBER:\n            case AbiTypeEnum.CLASS: {\n                return typeName;\n            }\n            case AbiTypeEnum.ARRAY: {\n                return `${this.getArgs()[0]}[]`;\n            }\n            case AbiTypeEnum.MAP: {\n                return `${this.getArgs().join(\",\")}{}`;\n            }\n            default: {\n                return typeName;\n            }\n        }\n    }\n\n    private getArgs(): string[] {\n        var args = this.typeNode.typeArguments;\n        var argType = new Array<string>();\n        if (args) {\n            for (let arg of args) {\n                argType.push(arg.range.toString());\n            }\n        }\n        return argType;\n    }\n\n    getAsTypes(): string[] {\n        var args = this.getArgs();\n        if (!Collections.isEmptyArray(args)) {\n            return args;\n        }\n        return [this.typeName];\n    }\n\n    /**\n    * the typename maybe global scope or local scope.\n    * So search the local firtst, then search the global scope.\n    *\n    * @param typeName typename without type arguments\n    */\n    findElement(typeName: string): Element | null {\n        return this.parent.lookup(typeName);\n    }\n\n    /**\n     * Get the type {@type Type} by the type name\n     * @param asTypeName the AssemblyScript type name\n     */\n    private findSourceAsElement(asTypeName: string): Element | null {\n        var sourceTypeName = this.findSourceAsTypeName(asTypeName);\n        var sourceType: Element | null = this.parent.lookup(sourceTypeName);\n        return sourceType;\n    }\n\n    /**\n     * Find the source type name,\n     * eg: declare type account_name = u64;\n     *     declare type account_name_alias = account_name;\n     *     findSourceAsTypeName(\"account_name_alias\") return \"account_name\";\n     */\n    private findSourceAsTypeName(typeName: string): string {\n        var element = this.parent.lookup(typeName);\n        if (element && element.kind == ElementKind.TYPEDEFINITION) {\n            let typeDefine = <TypeDefinition>element;\n            let aliasTypeName = typeDefine.typeNode.range.toString();\n            return this.findSourceAsTypeName(aliasTypeName);\n        }\n        return typeName;\n    }\n\n    findSourceAbiType(typeName: string): string {\n        var abiType: string | null = AbiHelper.abiTypeLookup.get(typeName) || null;\n        if (abiType) {\n            return abiType;\n        }\n        var element = this.parent.lookup(typeName);\n        if (element && element.kind == ElementKind.TYPEDEFINITION) {\n            let typeDefine = <TypeDefinition> element;\n            let aliasTypeName = typeDefine.typeNode.range.toString();\n            return this.findSourceAbiType(aliasTypeName);\n        }\n        return typeName;\n    }\n}\n","export class Collections {\n\n    /**\n     * Check the array is empty\n     * @param arr parameter array\n     */\n    static isEmptyArray<T>(arr: T[]): boolean {\n        return arr.length == 0;\n    }\n\n    static newArray<T>(arg1: T): T[] {\n        var arr = new Array<T>();\n        arr.push(arg1);\n        return arr;\n    }\n}\n","import { ParameterNode, NamedTypeNode, FieldDeclaration, TypeNode, NodeKind } from \"../ast\";\nimport { FunctionPrototype, ClassPrototype, ElementKind, DeclaredElement, FieldPrototype } from \"../program\";\nimport { Indent } from \"./primitiveutil\";\nimport { TypeNodeAnalyzer, AstUtil, TypeNodeDesc } from \"./astutil\";\nimport { ExportDef, ExportMethod } from \"./abi\";\n\nexport class ExportGenerator {\n\n  private classPrototype: ClassPrototype;\n  private className: string;\n  private instanceName: string;\n\n  constructor(clzPrototype: ClassPrototype) {\n    this.classPrototype = clzPrototype;\n    let className: string = clzPrototype.name;\n    let instanceName: string = \"_\" + className;\n    this.className = className;\n    this.instanceName = instanceName;\n  }\n\n  static typeWrapperMap: Map<string, string> = new Map([\n    [\"i8\", \"Int8\"],\n    [\"i16\", \"Int16\"],\n    [\"i32\", \"Int32\"],\n    [\"i64\", \"Int64\"],\n    [\"isize\", \"Int32\"],\n    [\"u8\", \"UInt8\"],\n    [\"u16\", \"UInt16\"],\n    [\"u32\", \"UInt32\"],\n    [\"u64\", \"UInt64\"],\n    [\"usize\", \"UInt32\"],\n    [\"f32\", \"float32\"],\n    [\"f64\", \"float64\"],\n    [\"bool\", \"Bool\"],\n    [\"boolean\", \"Bool\"],\n    [\"string\", \"string\"]\n  ]);\n\n  static defaultValMap: Map<string, string> = new Map([\n    [\"i8\", \"0\"],\n    [\"i16\", \"0\"],\n    [\"i32\", \"0\"],\n    [\"i64\", \"0\"],\n    [\"isize\", \"0\"],\n    [\"u8\", \"0\"],\n    [\"u16\", \"0\"],\n    [\"u32\", \"0\"],\n    [\"u64\", \"0\"],\n    [\"usize\", \"0\"],\n    [\"f32\", \"0\"],\n    [\"f64\", \"0\"],\n    [\"bool\", \"false\"],\n    [\"boolean\", \"false\"],\n    [\"string\", \"''\"]\n  ]);\n\n\n  static getWrapperType(asType: string): string | undefined {\n    return ExportGenerator.typeWrapperMap.get(asType);\n  }\n\n  generateExportDef(): ExportDef {\n    let deployDef: ExportDef = new ExportDef(this.className);\n    if (this.classPrototype.instanceMembers) {\n      for (let [key, instance] of this.classPrototype.instanceMembers) {\n        if (instance && AstUtil.isDeployerFnPrototype(instance)) {\n          let method = ExportGenerator.generateMethod(this.instanceName, <FunctionPrototype>instance);\n          deployDef.deployers.push(method);\n        } else if (instance && AstUtil.isActionFnPrototype(instance)){\n          let method = ExportGenerator.generateMethod(this.instanceName, <FunctionPrototype>instance);\n          deployDef.messages.push(method);\n        }\n      }\n    }\n    return deployDef;\n  }\n\n  static generateMethod(instaceName: string, funcProto: FunctionPrototype): ExportMethod {\n    let deployMethod: ExportMethod = new ExportMethod();\n    let params = funcProto.functionTypeNode.parameters; // FunctionDeclaration parameter types\n    deployMethod.methodName = funcProto.name;\n    \n    for (let index = 0; index < params.length; index++) {\n      let type: ParameterNode = params[index];\n      let paramDesc: TypeNodeDesc = new TypeNodeDesc();\n\n      let parameterType = type.type.range.toString();\n      let parameterName = type.name.range.toString();\n      // console.log(\"parameterType\", parameterType);\n      // console.log(\"parameterName\", parameterName);\n\n      paramDesc.originalType = parameterType;\n      paramDesc.codecType = ExportGenerator.typeWrapperMap.get(parameterType)\n      paramDesc.defaultVal = ExportGenerator.defaultValMap.get(parameterType);\n      deployMethod.paramters.push(paramDesc);\n    }\n    let returnType = funcProto.functionTypeNode.returnType;\n    // console.log(\"returnType\", returnType.range.toString())\n    let rtnNodeAnly = new TypeNodeAnalyzer(funcProto, <NamedTypeNode>returnType);\n    let returnTypeDesc: TypeNodeDesc = new TypeNodeDesc();\n    if (!rtnNodeAnly.isVoid()) {\n      let wrapType = ExportGenerator.typeWrapperMap.get(rtnNodeAnly.typeName);\n      returnTypeDesc.codecType = wrapType;\n      returnTypeDesc.originalType = rtnNodeAnly.typeName;\n      deployMethod.hasReturnVal = true;\n    }\n    deployMethod.returnType = returnTypeDesc;\n    return deployMethod;\n  }\n}\n\nexport class StorageGenerator {\n\n  private classPrototype: ClassPrototype;\n  private fieldIndents: Indent[] = new Array<Indent>();\n  private methodIndents: Indent[] = new Array<Indent>();\n\n  constructor(clzPrototype: ClassPrototype) {\n    this.classPrototype = clzPrototype;\n    if (this.classPrototype.instanceMembers) {\n      this.resolveInstanceMembers(this.classPrototype.instanceMembers);\n    }\n  }\n\n  getBody(): Indent {\n    let bodyIndent: Indent = new Indent();\n    bodyIndent.add(`class ${this.classPrototype.name} {`);\n    bodyIndent.joinIndents(this.fieldIndents).joinIndents(this.methodIndents);\n    bodyIndent.add(`}`);\n    return bodyIndent;\n  }\n\n  resolveInstanceMembers(instanceMembers: Map<string, DeclaredElement>): void {\n    for (let [fieldName, element] of instanceMembers) {\n      if (element.kind == ElementKind.FIELD_PROTOTYPE) {\n        // console.log(\"fieldName\", fieldName);\n        this.resolveFieldPrototype(<FieldPrototype>element)\n      }\n    }\n  }\n\n  resolveFieldPrototype(fieldPrototype: FieldPrototype): void {\n    let fieldDeclaration: FieldDeclaration = <FieldDeclaration>fieldPrototype.declaration;\n    let commonType: TypeNode | null = fieldDeclaration.type;\n    if (commonType && commonType.kind == NodeKind.NAMEDTYPE) {\n      let typeNode = <NamedTypeNode>commonType;\n      let varName = \"_\" + fieldPrototype.name;\n      let key: string = varName;\n      var typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(this.classPrototype, typeNode);\n      let typeName = typeNodeAnalyzer.typeName;\n\n      let field: Indent = new Indent(2);\n      field.add(`private ${varName}: ${typeName} | null;`);\n      this.fieldIndents.push(field);\n\n      let getIndent = this.getField(fieldPrototype.name, key, typeNode);\n      let setIndent = this.setFiled(fieldPrototype.name, key, typeNode);\n      this.methodIndents.push(getIndent);\n      this.methodIndents.push(setIndent);\n\n      // console.log(`${field.toString()}`);\n      // console.log(`${getIndent.toString()}`);\n      // console.log(`${setIndent.toString()}`);\n    }\n  }\n\n  getField(fieldName: string, key: string, typeNode: NamedTypeNode): Indent {\n    var typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(this.classPrototype, typeNode);\n    let typeName = typeNodeAnalyzer.typeName;\n    let varName = \"_\" + fieldName;\n    let wrapType = ExportGenerator.getWrapperType(typeName);\n    var indent: Indent = new Indent(2);\n    indent.add(`get ${fieldName}(): ${typeName} {`).increase();\n    indent.add(`if (this.${varName} === null) {`).increase();\n    indent.add(`const st = new Storage<${wrapType}>(\"${key}\")`);\n    indent.add(`this.${varName} = st.load();`);\n    indent.decrease().add(`}`);\n    indent.add(`return this.${varName}!.unwrap();`);\n    indent.decrease().add(`}`);\n\n    return indent;\n  }\n\n  setFiled(fieldName: string, key: string, typeNode: NamedTypeNode): Indent {\n    var typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(this.classPrototype, typeNode);\n    let typeName = typeNodeAnalyzer.typeName;\n    let wrapType = ExportGenerator.getWrapperType(typeName);\n    var indent: Indent = new Indent(2);\n    let varName = \"_\" + fieldName;\n    indent.add(`set ${fieldName}(v: ${typeName}) {`).increase();\n    indent.add(`this.${varName} = new ${wrapType}(v);`);\n    indent.add(`const st = new Storage<${wrapType}>(\"${key}\");`);\n    indent.add(`st.store(this.${varName});`);\n    indent.decrease().add(`}`);\n    return indent;\n  }\n}","import {\n    AbiHelper\n} from \"./abi\";\n\nimport {\n    ClassDeclaration,\n    DecoratorKind,\n    FieldDeclaration,\n    NodeKind,\n    TypeNode,\n    NamedTypeNode\n} from \"../ast\";\n\nimport {\n    ClassPrototype,\n    Element,\n    ElementKind,\n    FieldPrototype,\n    FunctionPrototype,\n    Program,\n} from \"../program\";\n\nimport {\n    Range\n} from \"../tokenizer\";\n\nimport {\n    Type,\n    TypeKind\n} from \"../types\";\n\nimport {\n    AstUtil,\n    TypeNodeAnalyzer,\n    AbiTypeEnum\n} from \"./astutil\";\n\nimport {\n    Collections\n} from \"./collectionutil\";\n\nimport {\n    Indent,\n    Verify\n} from \"./primitiveutil\";\n\nexport class InsertPoint {\n\n    protected range: Range;\n    protected insertCode: string;\n    protected code: string[];\n\n    private static descComparator = (a: InsertPoint, b: InsertPoint): i32 => {\n        return (b.line - a.line);\n    }\n\n    static toSortedMap(insertPoints: Array<InsertPoint>): Map<string, Array<InsertPoint>> {\n\n        var map = new Map<string, Array<InsertPoint>>();\n        for (let insertPoint of insertPoints) {\n            let normalizedPath = insertPoint.normalizedPath;\n            let insertPointArr: Array<InsertPoint> | null = map.get(normalizedPath) || null;\n\n            if (!insertPointArr) {\n                insertPointArr = new Array<InsertPoint>();\n                map.set(normalizedPath, insertPointArr);\n            }\n            insertPointArr.push(insertPoint);\n        }\n\n        for (let [_, values] of map) {\n            values.sort(InsertPoint.descComparator);\n        }\n        return map;\n    }\n\n    constructor(range: Range, insertCode: string = \"\") {\n        this.range = range;\n        this.insertCode = insertCode;\n        this.code = [];\n    }\n\n    get line(): i32 {\n        // TODO\n        console.log(\"line\", this.range.toString());\n        return (this.range.start == 0) ? this.range.atEnd.start - 1 : this.range.atEnd.start - 2;\n    }\n    get normalizedPath(): string {\n        return this.range.source.normalizedPath;\n    }\n\n    get indentity(): string {\n        return this.range.source.normalizedPath + this.range.toString();\n    }\n\n    toString(): string {\n        return this.range.toString();\n    }\n\n    addInsertCode(code: string): void {\n        this.code.push(code);\n    }\n\n    getCodes(): string {\n        return this.insertCode;\n    }\n}\n\n/**\n * Serialiize Generateor\n */\nclass SerializeGenerator {\n\n    SERIALIZE_METHOD_NAME: string = \"serialize\";\n    DESERIALIZE_METHOD_NAME: string = \"deserialize\";\n    PRIMARY_METHOD_NAME: string = \"primaryKey\";\n\n    classPrototype: ClassPrototype;\n    /**Need to implement the Serialize method of the serialize interface */\n    private needSerialize: boolean = true;\n    /**Need to implement the Deserialize method of the serialize interface */\n    private needDeserialize: boolean = true;\n    /**Need to implement the primaryKey method */\n    private needPrimaryid: boolean = true;\n\n    constructor(classPrototype: ClassPrototype) {\n        this.classPrototype = classPrototype;\n        this.initialize();\n    }\n\n    private existing(): bool {\n        return this.needDeserialize || this.needSerialize || this.needPrimaryid;\n    }\n\n    private initialize(): void {\n        if (this.classPrototype.instanceMembers) {\n            for (let [_, element] of this.classPrototype.instanceMembers) {\n                if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n                    let fnPrototype = <FunctionPrototype>element;\n                    let fnName = fnPrototype.declaration.name.range.toString();\n                    if (fnName == this.SERIALIZE_METHOD_NAME) {\n                        this.needSerialize = false;\n                    }\n                    if (fnName == this.DESERIALIZE_METHOD_NAME) {\n                        this.needDeserialize = false;\n                    }\n                    if (fnName == this.PRIMARY_METHOD_NAME) {\n                        this.needPrimaryid = false;\n                    }\n                }\n            }\n        }\n    }\n\n    checkSerializable(typeNode: NamedTypeNode): void {\n        var internalName = AstUtil.getInternalName(typeNode);\n        var element: Element | null = this.classPrototype.program.elementsByName.get(internalName) || null;\n\n        // var element = this.classPrototype.lookup(typeNode.range.toString());\n        if (element && element.kind == ElementKind.CLASS_PROTOTYPE) {\n            let hasImpl = AstUtil.impledSerializable((<ClassPrototype>element));\n            Verify.verify(hasImpl, `Class ${internalName} has not implement the interface serializable`);\n        }\n    }\n\n    /**Parse the class prototype and get serialize points */\n    getSerializePoint(): SerializePoint | null {\n        if (!this.existing()) {\n            return null;\n        }\n        var serializePoint: SerializePoint = new SerializePoint(this.classPrototype.declaration.range);\n        serializePoint.classDeclaration = <ClassDeclaration>this.classPrototype.declaration;\n        serializePoint.needDeserialize = this.needDeserialize;\n        serializePoint.needSerialize = this.needSerialize;\n        serializePoint.needPrimaryid = this.needPrimaryid;\n\n        if (!this.classPrototype.instanceMembers) {\n            return null;\n        }\n        var countOfPkDecorator: u8 = 0;\n        if (AstUtil.impledSerializable(this.classPrototype.basePrototype)) {\n            serializePoint.serialize.increase().add(`super.serialize(ds);`);\n            serializePoint.deserialize.increase().add(`super.deserialize(ds);`);\n        }\n        for (let [fieldName, element] of this.classPrototype.instanceMembers) {\n            if (element.kind == ElementKind.FIELD_PROTOTYPE) {\n                let fieldPrototype: FieldPrototype = <FieldPrototype>element;\n                let fieldDeclaration: FieldDeclaration = <FieldDeclaration>fieldPrototype.declaration;\n                let commonType: TypeNode | null = fieldDeclaration.type;\n\n                if (commonType && commonType.kind == NodeKind.NAMEDTYPE &&\n                    // TODO\n                    !AstUtil.haveSpecifyDecorator(fieldDeclaration, DecoratorKind.DEPLOYER)) {\n                    let typeNode = <NamedTypeNode>commonType;\n                    if (this.needSerialize) {\n                        this.checkSerializable(<NamedTypeNode>commonType);\n                        serializePoint.serialize.addAll(this.serializeField(fieldName, typeNode));\n                    }\n                    if (this.needDeserialize) {\n                        this.checkSerializable(<NamedTypeNode>commonType);\n                        serializePoint.deserialize.addAll(this.deserializeField(fieldName, typeNode));\n                    }\n                }\n\n                if (commonType && commonType.kind == NodeKind.NAMEDTYPE && AstUtil.haveSpecifyDecorator(fieldDeclaration, DecoratorKind.PRIMARYID)) {\n                    countOfPkDecorator++;\n                    Verify.verify(countOfPkDecorator <= 1, `Class ${this.classPrototype.name} should have only one primaryid decorator field.`);\n                    let typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(this.classPrototype,  <NamedTypeNode>commonType);\n                    if (!typeNodeAnalyzer.isPrimaryType()) {\n                        throw new Error(`Class ${this.classPrototype.name} member ${fieldName}'s type should be id_type or refer to id_type.`);\n                    }\n                    serializePoint.primaryKey.indent(4).add(`return this.${fieldName};`);\n                }\n            }\n        }\n\n        if (!countOfPkDecorator) {\n            serializePoint.primaryKey.indent(4).add(`return 0;`);\n        }\n        serializePoint.primaryKey.indent(2).add(`}`);\n        serializePoint.deserialize.indent(2).add(`}`);\n        serializePoint.serialize.indent(2).add(`}`);\n        return serializePoint;\n    }\n\n    /** Implement the serrialize field */\n    serializeField(fieldName: string, typeNode: NamedTypeNode): string[] {\n        var typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(this.classPrototype, typeNode);\n        var indent: Indent = new Indent();\n        indent.indent(4);\n        if (typeNodeAnalyzer.isArray()) {\n            let argAbiTypeEnum = typeNodeAnalyzer.getArrayArgAbiTypeEnum();\n            let argTypeName = typeNodeAnalyzer.getArrayArg();\n            if (argAbiTypeEnum == AbiTypeEnum.NUMBER) {\n                indent.add(`ds.writeVector<${argTypeName}>(this.${fieldName});`);\n            } else if (argAbiTypeEnum == AbiTypeEnum.STRING) {\n                indent.add(`ds.writeStringVector(this.${fieldName});`);\n            } else {\n                indent.add(`ds.writeComplexVector<${argTypeName}>(this.${fieldName});`);\n            }\n        } else {\n            let abiTypeEnum = typeNodeAnalyzer.abiTypeEnum;\n            if (abiTypeEnum == AbiTypeEnum.STRING) {\n                indent.add(`ds.writeString(this.${fieldName});`);\n            } else if (abiTypeEnum == AbiTypeEnum.NUMBER) {\n                indent.add(`ds.write<${typeNodeAnalyzer.getDeclareType()}>(this.${fieldName});`);\n            } else {\n                indent.add(`this.${fieldName}.serialize(ds);`);\n            }\n        }\n        return indent.getContent();\n    }\n\n    deserializeField(fieldName: string, type: NamedTypeNode): string[] {\n        var typeNodeAnalyzer: TypeNodeAnalyzer = new TypeNodeAnalyzer(this.classPrototype, type);\n        var indent = new Indent();\n        indent.indent(4);\n        if (typeNodeAnalyzer.isArray()) {\n            let argAbiTypeEnum = typeNodeAnalyzer.getArrayArgAbiTypeEnum();\n            let argTypeName = typeNodeAnalyzer.getArrayArg();\n\n            if (argAbiTypeEnum == AbiTypeEnum.NUMBER) {\n                indent.add(`this.${fieldName} = ds.readVector<${argTypeName}>();`);\n            } else if (argAbiTypeEnum == AbiTypeEnum.STRING) {\n                indent.add(`this.${fieldName} = ds.readStringVector();`);\n            } else {\n                indent.add(`this.${fieldName} = ds.readComplexVector<${argTypeName}>();`);\n            }\n        } else {\n            let abiTypeEnum = typeNodeAnalyzer.abiTypeEnum;\n            if (abiTypeEnum == AbiTypeEnum.STRING) {\n                indent.add(`this.${fieldName} = ds.readString();`);\n            } else if (abiTypeEnum == AbiTypeEnum.NUMBER) {\n                indent.add(`this.${fieldName} = ds.read<${typeNodeAnalyzer.typeName}>();`);\n            } else {\n                indent.add(`this.${fieldName}.deserialize(ds);`);\n            }\n        }\n        return indent.getContent();\n    }\n}\n\nexport class SerializePoint extends InsertPoint {\n\n    serialize: Indent = new Indent();\n    deserialize: Indent = new Indent();\n    primaryKey: Indent = new Indent();\n\n    needSerialize: bool = false;\n    needDeserialize: bool = false;\n    needPrimaryid: bool = false;\n\n    classDeclaration: ClassDeclaration | undefined;\n\n    constructor(range: Range) {\n        super(range.atEnd);\n        this.serialize.indent(2).add(`serialize(ds: DataStream): void {`);\n        this.deserialize.indent(2).add(`deserialize(ds: DataStream): void {`);\n        this.primaryKey.indent(2).add(`primaryKey(): id_type {`);\n    }\n\n    get indentity(): string {\n        if (this.classDeclaration) {\n            return this.range.source.normalizedPath + this.range.toString() + this.classDeclaration.name.range.toString();\n        } else {\n            return \"\";\n        }\n    }\n\n    getCodes(): string {\n        var result = [];\n        if (this.needDeserialize) {\n            result.push(this.deserialize.toString());\n        }\n        if (this.needSerialize) {\n            result.push(this.serialize.toString());\n        }\n        if (this.needPrimaryid) {\n            result.push(this.primaryKey.toString());\n        }\n        return result.join(\"\\n\");\n    }\n}\n\nexport class SerializeInserter {\n\n    program: Program;\n    private serializeClassname: Set<string> = new Set<string>();\n    private insertPoints: Array<InsertPoint> = [];\n\n    constructor(program: Program) {\n        this.program = program;\n        this.resolve();\n    }\n\n    private resolve(): void {\n        for (let [_, element] of this.program.elementsByName) {\n            if (element && element.kind == ElementKind.CLASS_PROTOTYPE) {\n                if (AstUtil.impledSerializable(<ClassPrototype>element)) {\n                    let generator: SerializeGenerator = new SerializeGenerator(<ClassPrototype>element);\n\n                    let serializePoint = generator.getSerializePoint();\n                    if (serializePoint && !this.serializeClassname.has(serializePoint.indentity)) {\n                        this.insertPoints.push(serializePoint);\n                        this.serializeClassname.add(serializePoint.indentity);\n                    }\n                }\n            }\n        }\n    }\n\n    getInsertPoints(): InsertPoint[] {\n        return this.insertPoints;\n    }\n}\n","export class Strings {\n\n    /**\n     * Judge the string whetehr aroud by qutation or not.\n     * The charcode of '\"' is 0x22\n     * @param str The string to judge\n     */\n    static isAroundQuotation(str: string): bool {\n        if (str == undefined || str == null) {\n            return false;\n        }\n        var beginChar = str.charCodeAt(0);\n        var endChar = str.charCodeAt(str.length - 1);\n        return (beginChar == endChar) && (beginChar == 0x22 || beginChar == 0x27);\n    }\n\n    static EMPTY = '';\n\n    /**\n     * If the string around quotation, remove the quotation.\n     * @param str The source string\n     */\n    static removeQuotation(str: string): string {\n        if (Strings.isAroundQuotation(str)) {\n            return str.substring(1, str.length - 1);\n        }\n        return str;\n    }\n}\n\nexport class AbiUtils {\n    private static DATABASE_CHARSETS = \"abcdefghijklmnopqrstuvwxyz12345.\";\n\n    /**\n     * Check the action name whether is legal.\n     * The action name should be less or equal than 21 characters.\n     * @param str the action name\n     */\n    static checkActionName(str: string): void {\n        assert(str.length > 0, `Action name should not empty.`);\n        assert(str.length <= 21, `Action Name:${str} should be less than 21 characters.`);\n    }\n\n    /**\n     * Check the database name whether is legal.\n     * The database name should be less or equal than 12 characters.\n     * @param name the database name\n     */\n    static checkDatabaseName(name: string): void {\n        assert(name.length > 0, `Table name should not empty.`);\n        assert(name.length <= 12, `Table name Name:${name} should be less than 12 characters.`);\n        for (let aChar of name) {\n            assert(AbiUtils.DATABASE_CHARSETS.includes(aChar), `Table name:${name} should only contain the chars:${AbiUtils.DATABASE_CHARSETS}`);\n        }\n    }\n}\n\n/**\n * Indent for program, \n */\nexport class Indent {\n\n    private body: Array<string> = new Array<string>();\n    private indentX1: string = \"  \";\n    private indentX2: string = \"    \";\n    private indentX4: string = \"        \";\n    private padding: string = this.indentX1;\n    private defaultBlank: i32;\n\n    constructor(numBlanks: i32 = 0) {\n        this.defaultBlank = numBlanks;\n        this.initPadding(this.defaultBlank);\n    }\n\n    private initPadding(level: i32): void {\n        var padding = Strings.EMPTY;\n        while (level >= 4) {\n            padding += this.indentX4;\n            level -= 4;\n        }\n        if (level >= 2) {\n            padding += this.indentX2;\n            level -= 2;\n        }\n        if (level >= 1) {\n            padding += this.indentX1;\n        }\n        this.padding = padding;\n    }\n\n    indent(level: i32): Indent {\n        this.initPadding(level);\n        return this;\n    }\n\n    add(row: string): Indent {\n        this.body.push(this.padding + row);\n        return this;\n    }\n\n    increase(): Indent {\n        this.padding += this.indentX1;\n        return this;\n    }\n\n    decrease(): Indent {\n        this.padding = this.padding.replace(this.indentX1, \"\");\n        return this;\n    }\n\n    toString(): string {\n        return this.body.join(\"\\n\");\n    }\n\n    addAll(body: string[]): void {\n        for (let row of body) {\n            this.body.push(row);\n        }\n    }\n\n    joinIndents(indents: Indent[]): Indent {\n        for (let indent of indents) {\n          this.addAll(indent.getContent());\n        }\n        return this;\n    }\n\n    getContent(): string[] {\n        return this.body;\n    }\n}\n\nexport class Verify {\n\n    static verify(expression: boolean, message: string): void {\n        if (!expression) {\n            throw new Error(message);\n        }\n    }\n}\n","/**\n * @fileoverview Abstract Syntax Tree extras.\n *\n * Provides serialization of the AssemblyScript AST back to it source form.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  ArrowKind,\n\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  TypeName,\n  TypeParameterNode,\n\n  Expression,\n  IdentifierExpression,\n  LiteralExpression,\n  LiteralKind,\n  FloatLiteralExpression,\n  IntegerLiteralExpression,\n  StringLiteralExpression,\n  RegexpLiteralExpression,\n  ArrayLiteralExpression,\n  AssertionExpression,\n  AssertionKind,\n  BinaryExpression,\n  CallExpression,\n  CommaExpression,\n  ElementAccessExpression,\n  FunctionExpression,\n  NewExpression,\n  ParenthesizedExpression,\n  PropertyAccessExpression,\n  TernaryExpression,\n  UnaryPostfixExpression,\n  UnaryExpression,\n  UnaryPrefixExpression,\n  ClassExpression,\n  ObjectLiteralExpression,\n\n  BlockStatement,\n  BreakStatement,\n  ContinueStatement,\n  DoStatement,\n  EmptyStatement,\n  ExportImportStatement,\n  ExportStatement,\n  ExportDefaultStatement,\n  ExpressionStatement,\n  ForStatement,\n  ForOfStatement,\n  IfStatement,\n  ImportStatement,\n  InstanceOfExpression,\n  ReturnStatement,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  VariableStatement,\n  WhileStatement,\n\n  DeclarationStatement,\n  ClassDeclaration,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n\n  DecoratorNode,\n  ParameterNode,\n  ParameterKind,\n  ExportMember,\n  SwitchCase,\n  IndexSignatureNode,\n\n  isTypeOmitted\n} from \"../ast\";\n\nimport {\n  operatorTokenToString\n} from \"../tokenizer\";\n\nimport {\n  CharCode,\n  indent\n} from \"../util\";\n\nimport {\n  CommonFlags\n} from \"../common\";\n\n/** An AST builder. */\nexport class ASTBuilder {\n\n  /** Rebuilds the textual source from the specified AST, as far as possible. */\n  static build(node: Node): string {\n    var builder = new ASTBuilder();\n    builder.visitNode(node);\n    return builder.finish();\n  }\n\n  private sb: string[] = [];\n  private indentLevel: i32 = 0;\n\n  visitNode(node: Node): void {\n    switch (node.kind) {\n      case NodeKind.SOURCE: {\n        this.visitSource(<Source>node);\n        break;\n      }\n\n      // types\n\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      case NodeKind.TYPEPARAMETER: {\n        this.visitTypeParameter(<TypeParameterNode>node);\n        break;\n      }\n\n      // expressions\n\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.SUPER:\n      case NodeKind.THIS:\n      case NodeKind.TRUE:\n      case NodeKind.CONSTRUCTOR:\n      case NodeKind.IDENTIFIER: {\n        this.visitIdentifierExpression(<IdentifierExpression>node);\n        break;\n      }\n      case NodeKind.ASSERTION: {\n        this.visitAssertionExpression(<AssertionExpression>node);\n        break;\n      }\n      case NodeKind.BINARY: {\n        this.visitBinaryExpression(<BinaryExpression>node);\n        break;\n      }\n      case NodeKind.CALL: {\n        this.visitCallExpression(<CallExpression>node);\n        break;\n      }\n      case NodeKind.CLASS: {\n        this.visitClassExpression(<ClassExpression>node);\n        break;\n      }\n      case NodeKind.COMMA: {\n        this.visitCommaExpression(<CommaExpression>node);\n        break;\n      }\n      case NodeKind.ELEMENTACCESS: {\n        this.visitElementAccessExpression(<ElementAccessExpression>node);\n        break;\n      }\n      case NodeKind.FUNCTION: {\n        this.visitFunctionExpression(<FunctionExpression>node);\n        break;\n      }\n      case NodeKind.INSTANCEOF: {\n        this.visitInstanceOfExpression(<InstanceOfExpression>node);\n        break;\n      }\n      case NodeKind.LITERAL: {\n        this.visitLiteralExpression(<LiteralExpression>node);\n        break;\n      }\n      case NodeKind.NEW: {\n        this.visitNewExpression(<NewExpression>node);\n        break;\n      }\n      case NodeKind.PARENTHESIZED: {\n        this.visitParenthesizedExpression(<ParenthesizedExpression>node);\n        break;\n      }\n      case NodeKind.PROPERTYACCESS: {\n        this.visitPropertyAccessExpression(<PropertyAccessExpression>node);\n        break;\n      }\n      case NodeKind.TERNARY: {\n        this.visitTernaryExpression(<TernaryExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n\n      // statements\n\n      case NodeKind.BLOCK: {\n        this.visitBlockStatement(<BlockStatement>node);\n        break;\n      }\n      case NodeKind.BREAK: {\n        this.visitBreakStatement(<BreakStatement>node);\n        break;\n      }\n      case NodeKind.CONTINUE: {\n        this.visitContinueStatement(<ContinueStatement>node);\n        break;\n      }\n      case NodeKind.DO: {\n        this.visitDoStatement(<DoStatement>node);\n        break;\n      }\n      case NodeKind.EMPTY: {\n        this.visitEmptyStatement(<EmptyStatement>node);\n        break;\n      }\n      case NodeKind.EXPORT: {\n        this.visitExportStatement(<ExportStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTDEFAULT: {\n        this.visitExportDefaultStatement(<ExportDefaultStatement>node);\n        break;\n      }\n      case NodeKind.EXPORTIMPORT: {\n        this.visitExportImportStatement(<ExportImportStatement>node);\n        break;\n      }\n      case NodeKind.EXPRESSION: {\n        this.visitExpressionStatement(<ExpressionStatement>node);\n        break;\n      }\n      case NodeKind.FOR: {\n        this.visitForStatement(<ForStatement>node);\n        break;\n      }\n      case NodeKind.FOROF: {\n        this.visitForOfStatement(<ForOfStatement>node);\n        break;\n      }\n      case NodeKind.IF: {\n        this.visitIfStatement(<IfStatement>node);\n        break;\n      }\n      case NodeKind.IMPORT: {\n        this.visitImportStatement(<ImportStatement>node);\n        break;\n      }\n      case NodeKind.RETURN: {\n        this.visitReturnStatement(<ReturnStatement>node);\n        break;\n      }\n      case NodeKind.SWITCH: {\n        this.visitSwitchStatement(<SwitchStatement>node);\n        break;\n      }\n      case NodeKind.THROW: {\n        this.visitThrowStatement(<ThrowStatement>node);\n        break;\n      }\n      case NodeKind.TRY: {\n        this.visitTryStatement(<TryStatement>node);\n        break;\n      }\n      case NodeKind.VARIABLE: {\n        this.visitVariableStatement(<VariableStatement>node);\n        break;\n      }\n      case NodeKind.WHILE: {\n        this.visitWhileStatement(<WhileStatement>node);\n        break;\n      }\n\n      // declaration statements\n\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>node);\n        break;\n      }\n      case NodeKind.ENUMVALUEDECLARATION: {\n        this.visitEnumValueDeclaration(<EnumValueDeclaration>node);\n        break;\n      }\n      case NodeKind.FIELDDECLARATION: {\n        this.visitFieldDeclaration(<FieldDeclaration>node);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>node);\n        break;\n      }\n      case NodeKind.IMPORTDECLARATION: {\n        this.visitImportDeclaration(<ImportDeclaration>node);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>node);\n        break;\n      }\n      case NodeKind.METHODDECLARATION: {\n        this.visitMethodDeclaration(<MethodDeclaration>node);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>node);\n        break;\n      }\n      case NodeKind.TYPEDECLARATION: {\n        this.visitTypeDeclaration(<TypeDeclaration>node);\n        break;\n      }\n      case NodeKind.VARIABLEDECLARATION: {\n        this.visitVariableDeclaration(<VariableDeclaration>node);\n        break;\n      }\n\n      // other\n\n      case NodeKind.DECORATOR: {\n        this.serializeDecorator(<DecoratorNode>node);\n        break;\n      }\n      case NodeKind.EXPORTMEMBER: {\n        this.visitExportMember(<ExportMember>node);\n        break;\n      }\n      case NodeKind.PARAMETER: {\n        this.serializeParameter(<ParameterNode>node);\n        break;\n      }\n      case NodeKind.SWITCHCASE: {\n        this.visitSwitchCase(<SwitchCase>node);\n        break;\n      }\n      case NodeKind.INDEXSIGNATURE: {\n        this.visitIndexSignature(<IndexSignatureNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitSource(source: Source): void {\n    var statements = source.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      this.visitNodeAndTerminate(statements[i]);\n    }\n  }\n\n  // types\n\n  visitTypeNode(node: TypeNode): void {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        this.visitNamedTypeNode(<NamedTypeNode>node);\n        break;\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        this.visitFunctionTypeNode(<FunctionTypeNode>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitTypeName(node: TypeName): void {\n    this.visitIdentifierExpression(node.identifier);\n    var sb = this.sb;\n    var current = node.next;\n    while (current) {\n      sb.push(\".\");\n      this.visitIdentifierExpression(current.identifier);\n      current = current.next;\n    }\n  }\n\n  visitNamedTypeNode(node: NamedTypeNode): void {\n    this.visitTypeName(node.name);\n    var typeArguments = node.typeArguments;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      let sb = this.sb;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">\");\n      }\n      if (node.isNullable) sb.push(\" | null\");\n    }\n  }\n\n  visitFunctionTypeNode(node: FunctionTypeNode): void {\n    var isNullable = node.isNullable;\n    var sb = this.sb;\n    sb.push(isNullable ? \"((\" : \"(\");\n    var explicitThisType = node.explicitThisType;\n    if (explicitThisType) {\n      sb.push(\"this: \");\n      this.visitTypeNode(explicitThisType);\n    }\n    var parameters = node.parameters;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      if (explicitThisType) sb.push(\", \");\n      this.serializeParameter(parameters[0]);\n      for (let i = 1; i < numParameters; ++i) {\n        sb.push(\", \");\n        this.serializeParameter(parameters[i]);\n      }\n    }\n    var returnType = node.returnType;\n    if (returnType) {\n      sb.push(\") => \");\n      this.visitTypeNode(returnType);\n    } else {\n      sb.push(\") => void\");\n    }\n    if (isNullable) sb.push(\") | null\");\n  }\n\n  visitTypeParameter(node: TypeParameterNode): void {\n    this.visitIdentifierExpression(node.name);\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      this.sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var defaultType = node.defaultType;\n    if (defaultType) {\n      this.sb.push(\"=\");\n      this.visitTypeNode(defaultType);\n    }\n  }\n\n  // expressions\n\n  visitIdentifierExpression(node: IdentifierExpression): void {\n    if (node.isQuoted) this.visitStringLiteral(node.text);\n    else this.sb.push(node.text);\n  }\n\n  visitArrayLiteralExpression(node: ArrayLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"[\");\n    var elements = node.elementExpressions;\n    var numElements = elements.length;\n    if (numElements) {\n      let element = elements[0];\n      if (element) this.visitNode(element);\n      for (let i = 1; i < numElements; ++i) {\n        element = elements[i];\n        sb.push(\", \");\n        if (element) this.visitNode(element);\n      }\n    }\n    sb.push(\"]\");\n  }\n\n  visitObjectLiteralExpression(node: ObjectLiteralExpression): void {\n    var sb = this.sb;\n    var names = node.names;\n    var values = node.values;\n    var numElements = names.length;\n    assert(numElements == values.length);\n    if (numElements) {\n      sb.push(\"{\\n\");\n      indent(sb, ++this.indentLevel);\n      this.visitNode(names[0]);\n      sb.push(\": \");\n      this.visitNode(values[0]);\n      for (let i = 1; i < numElements; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, this.indentLevel);\n        let name = names[i];\n        let value = values[i];\n        if (name === value) {\n          this.visitNode(name);\n        } else {\n          this.visitNode(name);\n          sb.push(\": \");\n          this.visitNode(value);\n        }\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitAssertionExpression(node: AssertionExpression): void {\n    var sb = this.sb;\n    switch (node.assertionKind) {\n      case AssertionKind.PREFIX: {\n        sb.push(\"<\");\n        this.visitTypeNode(assert(node.toType));\n        sb.push(\">\");\n        this.visitNode(node.expression);\n        break;\n      }\n      case AssertionKind.AS: {\n        this.visitNode(node.expression);\n        sb.push(\" as \");\n        this.visitTypeNode(assert(node.toType));\n        break;\n      }\n      case AssertionKind.NONNULL: {\n        this.visitNode(node.expression);\n        sb.push(\"!\");\n        break;\n      }\n      case AssertionKind.CONST: {\n        this.visitNode(node.expression);\n        sb.push(\" as const\");\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitBinaryExpression(node: BinaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.left);\n    sb.push(\" \");\n    sb.push(operatorTokenToString(node.operator));\n    sb.push(\" \");\n    this.visitNode(node.right);\n  }\n\n  visitCallExpression(node: CallExpression): void {\n    this.visitNode(node.expression);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  private visitArguments(typeArguments: TypeNode[] | null, args: Expression[]): void {\n    var sb = this.sb;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (numTypeArguments) {\n        sb.push(\"<\");\n        this.visitTypeNode(typeArguments[0]);\n        for (let i = 1; i < numTypeArguments; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(typeArguments[i]);\n        }\n        sb.push(\">(\");\n      }\n    } else {\n      sb.push(\"(\");\n    }\n    var numArgs = args.length;\n    if (numArgs) {\n      this.visitNode(args[0]);\n      for (let i = 1; i < numArgs; ++i) {\n        sb.push(\", \");\n        this.visitNode(args[i]);\n      }\n    }\n    sb.push(\")\");\n  }\n\n  visitClassExpression(node: ClassExpression): void {\n    var declaration = node.declaration;\n    this.visitClassDeclaration(declaration);\n  }\n\n  visitCommaExpression(node: CommaExpression): void {\n    var expressions = node.expressions;\n    var numExpressions = assert(expressions.length);\n    this.visitNode(expressions[0]);\n    var sb = this.sb;\n    for (let i = 1; i < numExpressions; ++i) {\n      sb.push(\",\");\n      this.visitNode(expressions[i]);\n    }\n  }\n\n  visitElementAccessExpression(node: ElementAccessExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.expression);\n    sb.push(\"[\");\n    this.visitNode(node.elementExpression);\n    sb.push(\"]\");\n  }\n\n  visitFunctionExpression(node: FunctionExpression): void {\n    var declaration = node.declaration;\n    if (!declaration.arrowKind) {\n      if (declaration.name.text.length) {\n        this.sb.push(\"function \");\n      } else {\n        this.sb.push(\"function\");\n      }\n    } else {\n      assert(declaration.name.text.length == 0);\n    }\n    this.visitFunctionCommon(declaration);\n  }\n\n  visitLiteralExpression(node: LiteralExpression): void {\n    switch (node.literalKind) {\n      case LiteralKind.FLOAT: {\n        this.visitFloatLiteralExpression(<FloatLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.INTEGER: {\n        this.visitIntegerLiteralExpression(<IntegerLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.STRING: {\n        this.visitStringLiteralExpression(<StringLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.REGEXP: {\n        this.visitRegexpLiteralExpression(<RegexpLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.ARRAY: {\n        this.visitArrayLiteralExpression(<ArrayLiteralExpression>node);\n        break;\n      }\n      case LiteralKind.OBJECT: {\n        this.visitObjectLiteralExpression(<ObjectLiteralExpression>node);\n        break;\n      }\n      default: {\n        assert(false);\n        break;\n      }\n    }\n  }\n\n  visitFloatLiteralExpression(node: FloatLiteralExpression): void {\n    this.sb.push(node.value.toString());\n  }\n\n  visitInstanceOfExpression(node: InstanceOfExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\" instanceof \");\n    this.visitTypeNode(node.isType);\n  }\n\n  visitIntegerLiteralExpression(node: IntegerLiteralExpression): void {\n    this.sb.push(i64_to_string(node.value));\n  }\n\n  visitStringLiteral(str: string, singleQuoted: bool = false): void {\n    var sb = this.sb;\n    var off = 0;\n    var quote = singleQuoted ? \"'\" : \"\\\"\";\n    sb.push(quote);\n    var i = 0;\n    for (let k = str.length; i < k;) {\n      switch (str.charCodeAt(i)) {\n        case CharCode.NULL: {\n          if (i > off) sb.push(str.substring(off, off = i + 1));\n          sb.push(\"\\\\0\");\n          off = ++i;\n          break;\n        }\n        case CharCode.BACKSPACE: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\b\");\n          break;\n        }\n        case CharCode.TAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\t\");\n          break;\n        }\n        case CharCode.LINEFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\n\");\n          break;\n        }\n        case CharCode.VERTICALTAB: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\v\");\n          break;\n        }\n        case CharCode.FORMFEED: {\n          if (i > off) sb.push(str.substring(off, i));\n          off = ++i;\n          sb.push(\"\\\\f\");\n          break;\n        }\n        case CharCode.CARRIAGERETURN: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\r\");\n          off = ++i;\n          break;\n        }\n        case CharCode.DOUBLEQUOTE: {\n          if (!singleQuoted) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\\\\"\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.SINGLEQUOTE: {\n          if (singleQuoted) {\n            if (i > off) sb.push(str.substring(off, i));\n            sb.push(\"\\\\'\");\n            off = ++i;\n          } else {\n            ++i;\n          }\n          break;\n        }\n        case CharCode.BACKSLASH: {\n          if (i > off) sb.push(str.substring(off, i));\n          sb.push(\"\\\\\\\\\");\n          off = ++i;\n          break;\n        }\n        default: {\n          ++i;\n          break;\n        }\n      }\n    }\n    if (i > off) sb.push(str.substring(off, i));\n    sb.push(quote);\n  }\n\n  visitStringLiteralExpression(node: StringLiteralExpression): void {\n    this.visitStringLiteral(node.value);\n  }\n\n  visitRegexpLiteralExpression(node: RegexpLiteralExpression): void {\n    var sb = this.sb;\n    sb.push(\"/\");\n    sb.push(node.pattern);\n    sb.push(\"/\");\n    sb.push(node.patternFlags);\n  }\n\n  visitNewExpression(node: NewExpression): void {\n    this.sb.push(\"new \");\n    this.visitTypeName(node.typeName);\n    this.visitArguments(node.typeArguments, node.args);\n  }\n\n  visitParenthesizedExpression(node: ParenthesizedExpression): void {\n    var sb = this.sb;\n    sb.push(\"(\");\n    this.visitNode(node.expression);\n    sb.push(\")\");\n  }\n\n  visitPropertyAccessExpression(node: PropertyAccessExpression): void {\n    this.visitNode(node.expression);\n    this.sb.push(\".\");\n    this.visitIdentifierExpression(node.property);\n  }\n\n  visitTernaryExpression(node: TernaryExpression): void {\n    var sb = this.sb;\n    this.visitNode(node.condition);\n    sb.push(\" ? \");\n    this.visitNode(node.ifThen);\n    sb.push(\" : \");\n    this.visitNode(node.ifElse);\n  }\n\n  visitUnaryExpression(node: UnaryExpression): void {\n    switch (node.kind) {\n      case NodeKind.UNARYPOSTFIX: {\n        this.visitUnaryPostfixExpression(<UnaryPostfixExpression>node);\n        break;\n      }\n      case NodeKind.UNARYPREFIX: {\n        this.visitUnaryPrefixExpression(<UnaryPrefixExpression>node);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitUnaryPostfixExpression(node: UnaryPostfixExpression): void {\n    this.visitNode(node.operand);\n    this.sb.push(operatorTokenToString(node.operator));\n  }\n\n  visitUnaryPrefixExpression(node: UnaryPrefixExpression): void {\n    this.sb.push(operatorTokenToString(node.operator));\n    this.visitNode(node.operand);\n  }\n\n  // statements\n\n  visitNodeAndTerminate(node: Node): void {\n    this.visitNode(node);\n    var sb = this.sb;\n    if (\n      !sb.length ||                     // leading EmptyStatement\n      node.kind == NodeKind.VARIABLE || // potentially assigns a FunctionExpression\n      node.kind == NodeKind.EXPRESSION  // potentially assigns a FunctionExpression\n    ) {\n      sb.push(\";\\n\");\n    } else {\n      let last = sb[sb.length - 1];\n      let lastCharPos = last.length - 1;\n      if (lastCharPos >= 0 && (\n        last.charCodeAt(lastCharPos) == CharCode.CLOSEBRACE ||\n        last.charCodeAt(lastCharPos) == CharCode.SEMICOLON)\n      ) {\n        sb.push(\"\\n\");\n      } else {\n        sb.push(\";\\n\");\n      }\n    }\n  }\n\n  visitBlockStatement(node: BlockStatement): void {\n    var sb = this.sb;\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      sb.push(\"{\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\"{}\");\n    }\n  }\n\n  visitBreakStatement(node: BreakStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"break \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"break\");\n    }\n  }\n\n  visitContinueStatement(node: ContinueStatement): void {\n    var label = node.label;\n    if (label) {\n      this.sb.push(\"continue \");\n      this.visitIdentifierExpression(label);\n    } else {\n      this.sb.push(\"continue\");\n    }\n  }\n\n  visitClassDeclaration(node: ClassDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.ABSTRACT)) sb.push(\"abstract \");\n    if (node.name.text.length) {\n      sb.push(\"class \");\n      this.visitIdentifierExpression(node.name);\n    } else {\n      sb.push(\"class\");\n    }\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    var implementsTypes = node.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        sb.push(\" implements \");\n        this.visitTypeNode(implementsTypes[0]);\n        for (let i = 1; i < numImplementsTypes; ++i) {\n          sb.push(\", \");\n          this.visitTypeNode(implementsTypes[i]);\n        }\n      }\n    }\n    var indexSignature = node.indexSignature;\n    var members = node.members;\n    var numMembers = members.length;\n    if (indexSignature !== null || numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      if (indexSignature) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(indexSignature);\n      }\n      for (let i = 0, k = members.length; i < k; ++i) {\n        let member = members[i];\n        if (member.kind != NodeKind.FIELDDECLARATION || (<FieldDeclaration>member).parameterIndex < 0) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(member);\n        }\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitDoStatement(node: DoStatement): void {\n    var sb = this.sb;\n    sb.push(\"do \");\n    this.visitNode(node.statement);\n    if (node.statement.kind == NodeKind.BLOCK) {\n      sb.push(\" while (\");\n    } else {\n      sb.push(\";\\n\");\n      indent(sb, this.indentLevel);\n      sb.push(\"while (\");\n    }\n    this.visitNode(node.condition);\n    sb.push(\")\");\n  }\n\n  visitEmptyStatement(node: EmptyStatement): void {\n    /* nop */\n  }\n\n  visitEnumDeclaration(node: EnumDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    if (node.is(CommonFlags.CONST)) sb.push(\"const \");\n    sb.push(\"enum \");\n    this.visitIdentifierExpression(node.name);\n    var values = node.values;\n    var numValues = values.length;\n    if (numValues) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitEnumValueDeclaration(node.values[0]);\n      for (let i = 1; i < numValues; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitEnumValueDeclaration(node.values[i]);\n      }\n      sb.push(\"\\n\");\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitEnumValueDeclaration(node: EnumValueDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var initializer = node.initializer;\n    if (initializer) {\n      this.sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitExportImportStatement(node: ExportImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"export import \");\n    this.visitIdentifierExpression(node.externalName);\n    sb.push(\" = \");\n    this.visitIdentifierExpression(node.name);\n  }\n\n  visitExportMember(node: ExportMember): void {\n    this.visitIdentifierExpression(node.localName);\n    if (node.exportedName.text != node.localName.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(node.exportedName);\n    }\n  }\n\n  visitExportStatement(node: ExportStatement): void {\n    var sb = this.sb;\n    if (node.isDeclare) {\n      sb.push(\"declare \");\n    }\n    var members = node.members;\n    if (members != null && members.length > 0) {\n      let numMembers = members.length;\n      sb.push(\"export {\\n\");\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitExportMember(members[0]);\n      for (let i = 1; i < numMembers; ++i) {\n        sb.push(\",\\n\");\n        indent(sb, indentLevel);\n        this.visitExportMember(members[i]);\n      }\n      --this.indentLevel;\n      sb.push(\"\\n}\");\n    } else {\n      sb.push(\"export {}\");\n    }\n    var path = node.path;\n    if (path) {\n      sb.push(\" from \");\n      this.visitStringLiteralExpression(path);\n    }\n    sb.push(\";\");\n  }\n\n  visitExportDefaultStatement(node: ExportDefaultStatement): void {\n    var declaration = node.declaration;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        this.visitEnumDeclaration(<EnumDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        this.visitFunctionDeclaration(<FunctionDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        this.visitClassDeclaration(<ClassDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        this.visitInterfaceDeclaration(<InterfaceDeclaration>declaration, true);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        this.visitNamespaceDeclaration(<NamespaceDeclaration>declaration, true);\n        break;\n      }\n      default: assert(false);\n    }\n  }\n\n  visitExpressionStatement(node: ExpressionStatement): void {\n    this.visitNode(node.expression);\n  }\n\n  visitFieldDeclaration(node: FieldDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    this.visitIdentifierExpression(node.name);\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    var type = node.type;\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitForStatement(node: ForStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    var initializer = node.initializer;\n    if (initializer) {\n      this.visitNode(initializer);\n    }\n    var condition = node.condition;\n    if (condition) {\n      sb.push(\"; \");\n      this.visitNode(condition);\n    } else {\n      sb.push(\";\");\n    }\n    var incrementor = node.incrementor;\n    if (incrementor) {\n      sb.push(\"; \");\n      this.visitNode(incrementor);\n    } else {\n      sb.push(\";\");\n    }\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitForOfStatement(node: ForOfStatement): void {\n    var sb = this.sb;\n    sb.push(\"for (\");\n    this.visitNode(node.variable);\n    sb.push(\" of \");\n    this.visitNode(node.iterable);\n    sb.push(\") \");\n    this.visitNode(node.statement);\n  }\n\n  visitFunctionDeclaration(node: FunctionDeclaration, isDefault: bool = false): void {\n    var sb = this.sb;\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n      this.serializeAccessModifiers(node);\n    }\n    if (node.name.text.length) {\n      sb.push(\"function \");\n    } else {\n      sb.push(\"function\");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitFunctionCommon(node: FunctionDeclaration): void {\n    var sb = this.sb;\n    this.visitIdentifierExpression(node.name);\n    var signature = node.signature;\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        this.visitTypeParameter(typeParameters[0]);\n        for (let i = 1; i < numTypeParameters; ++i) {\n          sb.push(\", \");\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n      let parameters = signature.parameters;\n      assert(parameters.length == 1);\n      assert(!signature.explicitThisType);\n      this.serializeParameter(parameters[0]);\n    } else {\n      sb.push(\"(\");\n      let parameters = signature.parameters;\n      let numParameters = parameters.length;\n      let explicitThisType = signature.explicitThisType;\n      if (explicitThisType) {\n        sb.push(\"this: \");\n        this.visitTypeNode(explicitThisType);\n      }\n      if (numParameters) {\n        if (explicitThisType) sb.push(\", \");\n        this.serializeParameter(parameters[0]);\n        for (let i = 1; i < numParameters; ++i) {\n          sb.push(\", \");\n          this.serializeParameter(parameters[i]);\n        }\n      }\n    }\n    var body = node.body;\n    var returnType = signature.returnType;\n    if (node.arrowKind) {\n      if (body) {\n        if (node.arrowKind == ArrowKind.ARROW_SINGLE) {\n          assert(isTypeOmitted(returnType));\n        } else {\n          if (isTypeOmitted(returnType)) {\n            sb.push(\")\");\n          } else {\n            sb.push(\"): \");\n            this.visitTypeNode(returnType);\n          }\n        }\n        sb.push(\" => \");\n        this.visitNode(body);\n      } else {\n        assert(!isTypeOmitted(returnType));\n        sb.push(\" => \");\n        this.visitTypeNode(returnType);\n      }\n    } else {\n      if (\n        !isTypeOmitted(returnType) &&\n        !node.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.SET)\n      ) {\n        sb.push(\"): \");\n        this.visitTypeNode(returnType);\n      } else {\n        sb.push(\")\");\n      }\n      if (body) {\n        sb.push(\" \");\n        this.visitNode(body);\n      }\n    }\n  }\n\n  visitIfStatement(node: IfStatement): void {\n    var sb = this.sb;\n    sb.push(\"if (\");\n    this.visitNode(node.condition);\n    sb.push(\") \");\n    var ifTrue = node.ifTrue;\n    this.visitNode(ifTrue);\n    if (ifTrue.kind != NodeKind.BLOCK) {\n      sb.push(\";\\n\");\n    }\n    var ifFalse = node.ifFalse;\n    if (ifFalse) {\n      if (ifTrue.kind == NodeKind.BLOCK) {\n        sb.push(\" else \");\n      } else {\n        sb.push(\"else \");\n      }\n      this.visitNode(ifFalse);\n    }\n  }\n\n  visitImportDeclaration(node: ImportDeclaration): void {\n    var externalName = node.foreignName;\n    var name = node.name;\n    this.visitIdentifierExpression(externalName);\n    if (externalName.text != name.text) {\n      this.sb.push(\" as \");\n      this.visitIdentifierExpression(name);\n    }\n  }\n\n  visitImportStatement(node: ImportStatement): void {\n    var sb = this.sb;\n    sb.push(\"import \");\n    var declarations = node.declarations;\n    var namespaceName = node.namespaceName;\n    if (declarations) {\n      let numDeclarations = declarations.length;\n      if (numDeclarations) {\n        sb.push(\"{\\n\");\n        let indentLevel = ++this.indentLevel;\n        indent(sb, indentLevel);\n        this.visitImportDeclaration(declarations[0]);\n        for (let i = 1; i < numDeclarations; ++i) {\n          sb.push(\",\\n\");\n          indent(sb, indentLevel);\n          this.visitImportDeclaration(declarations[i]);\n        }\n        --this.indentLevel;\n        sb.push(\"\\n} from \");\n      } else {\n        sb.push(\"{} from \");\n      }\n    } else if (namespaceName) {\n      sb.push(\"* as \");\n      this.visitIdentifierExpression(namespaceName);\n      sb.push(\" from \");\n    }\n    this.visitStringLiteralExpression(node.path);\n  }\n\n  visitIndexSignature(node: IndexSignatureNode): void {\n    var sb = this.sb;\n    sb.push(\"[key: \");\n    this.visitTypeNode(node.keyType);\n    sb.push(\"]: \");\n    this.visitTypeNode(node.valueType);\n  }\n\n  visitInterfaceDeclaration(node: InterfaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"interface \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters != null && typeParameters.length > 0) {\n      sb.push(\"<\");\n      this.visitTypeParameter(typeParameters[0]);\n      for (let i = 1, k = typeParameters.length; i < k; ++i) {\n        sb.push(\", \");\n        this.visitTypeParameter(typeParameters[i]);\n      }\n      sb.push(\">\");\n    }\n    var extendsType = node.extendsType;\n    if (extendsType) {\n      sb.push(\" extends \");\n      this.visitTypeNode(extendsType);\n    }\n    // must not have implementsTypes\n    sb.push(\" {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var members = node.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(members[i]);\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitMethodDeclaration(node: MethodDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    this.serializeAccessModifiers(node);\n    if (node.is(CommonFlags.GET)) {\n      this.sb.push(\"get \");\n    } else if (node.is(CommonFlags.SET)) {\n      this.sb.push(\"set \");\n    }\n    this.visitFunctionCommon(node);\n  }\n\n  visitNamespaceDeclaration(node: NamespaceDeclaration, isDefault: bool = false): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    if (isDefault) {\n      sb.push(\"export default \");\n    } else {\n      this.serializeExternalModifiers(node);\n    }\n    sb.push(\"namespace \");\n    this.visitIdentifierExpression(node.name);\n    var members = node.members;\n    var numMembers = members.length;\n    if (numMembers) {\n      sb.push(\" {\\n\");\n      let indentLevel = ++this.indentLevel;\n      for (let i = 0, k = members.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(members[i]);\n      }\n      indent(sb, --this.indentLevel);\n      sb.push(\"}\");\n    } else {\n      sb.push(\" {}\");\n    }\n  }\n\n  visitReturnStatement(node: ReturnStatement): void {\n    var value = node.value;\n    if (value) {\n      this.sb.push(\"return \");\n      this.visitNode(value);\n    } else {\n      this.sb.push(\"return\");\n    }\n  }\n\n  visitSwitchCase(node: SwitchCase): void {\n    var sb = this.sb;\n    var label = node.label;\n    if (label) {\n      sb.push(\"case \");\n      this.visitNode(label);\n      sb.push(\":\\n\");\n    } else {\n      sb.push(\"default:\\n\");\n    }\n    var statements = node.statements;\n    var numStatements = statements.length;\n    if (numStatements) {\n      let indentLevel = ++this.indentLevel;\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[0]);\n      for (let i = 1; i < numStatements; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(statements[i]);\n      }\n      --this.indentLevel;\n    }\n  }\n\n  visitSwitchStatement(node: SwitchStatement): void {\n    var sb = this.sb;\n    sb.push(\"switch (\");\n    this.visitNode(node.condition);\n    sb.push(\") {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var cases = node.cases;\n    for (let i = 0, k = cases.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitSwitchCase(cases[i]);\n      sb.push(\"\\n\");\n    }\n    --this.indentLevel;\n    sb.push(\"}\");\n  }\n\n  visitThrowStatement(node: ThrowStatement): void {\n    this.sb.push(\"throw \");\n    this.visitNode(node.value);\n  }\n\n  visitTryStatement(node: TryStatement): void {\n    var sb = this.sb;\n    sb.push(\"try {\\n\");\n    var indentLevel = ++this.indentLevel;\n    var statements = node.statements;\n    for (let i = 0, k = statements.length; i < k; ++i) {\n      indent(sb, indentLevel);\n      this.visitNodeAndTerminate(statements[i]);\n    }\n    var catchVariable = node.catchVariable;\n    if (catchVariable) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} catch (\");\n      this.visitIdentifierExpression(catchVariable);\n      sb.push(\") {\\n\");\n      let catchStatements = node.catchStatements;\n      if (catchStatements) {\n        for (let i = 0, k = catchStatements.length; i < k; ++i) {\n          indent(sb, indentLevel);\n          this.visitNodeAndTerminate(catchStatements[i]);\n        }\n      }\n    }\n    var finallyStatements = node.finallyStatements;\n    if (finallyStatements) {\n      indent(sb, indentLevel - 1);\n      sb.push(\"} finally {\\n\");\n      for (let i = 0, k = finallyStatements.length; i < k; ++i) {\n        indent(sb, indentLevel);\n        this.visitNodeAndTerminate(finallyStatements[i]);\n      }\n    }\n    indent(sb, indentLevel - 1);\n    sb.push(\"}\");\n  }\n\n  visitTypeDeclaration(node: TypeDeclaration): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    this.serializeExternalModifiers(node);\n    sb.push(\"type \");\n    this.visitIdentifierExpression(node.name);\n    var typeParameters = node.typeParameters;\n    if (typeParameters) {\n      let numTypeParameters = typeParameters.length;\n      if (numTypeParameters) {\n        sb.push(\"<\");\n        for (let i = 0; i < numTypeParameters; ++i) {\n          this.visitTypeParameter(typeParameters[i]);\n        }\n        sb.push(\">\");\n      }\n    }\n    sb.push(\" = \");\n    this.visitTypeNode(node.type);\n  }\n\n  visitVariableDeclaration(node: VariableDeclaration): void {\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var sb = this.sb;\n    if (node.flags & CommonFlags.DEFINITELY_ASSIGNED) {\n      sb.push(\"!\");\n    }\n    if (type) {\n      sb.push(\": \");\n      this.visitTypeNode(type);\n    }\n    var initializer = node.initializer;\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  visitVariableStatement(node: VariableStatement): void {\n    var decorators = node.decorators;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.serializeDecorator(decorators[i]);\n      }\n    }\n    var sb = this.sb;\n    var declarations = node.declarations;\n    var numDeclarations = assert(declarations.length);\n    var firstDeclaration = declarations[0];\n    this.serializeExternalModifiers(firstDeclaration);\n    sb.push(firstDeclaration.is(CommonFlags.CONST) ? \"const \" : firstDeclaration.is(CommonFlags.LET) ? \"let \" : \"var \");\n    this.visitVariableDeclaration(node.declarations[0]);\n    for (let i = 1; i < numDeclarations; ++i) {\n      sb.push(\", \");\n      this.visitVariableDeclaration(node.declarations[i]);\n    }\n  }\n\n  visitWhileStatement(node: WhileStatement): void {\n    var sb = this.sb;\n    sb.push(\"while (\");\n    this.visitNode(node.condition);\n    var statement = node.statement;\n    if (statement.kind == NodeKind.EMPTY) {\n      sb.push(\")\");\n    } else {\n      sb.push(\") \");\n      this.visitNode(node.statement);\n    }\n  }\n\n  // other\n\n  serializeDecorator(node: DecoratorNode): void {\n    var sb = this.sb;\n    sb.push(\"@\");\n    this.visitNode(node.name);\n    var args = node.args;\n    if (args) {\n      sb.push(\"(\");\n      let numArgs = args.length;\n      if (numArgs) {\n        this.visitNode(args[0]);\n        for (let i = 1; i < numArgs; ++i) {\n          sb.push(\", \");\n          this.visitNode(args[i]);\n        }\n      }\n      sb.push(\")\\n\");\n    } else {\n      sb.push(\"\\n\");\n    }\n    indent(sb, this.indentLevel);\n  }\n\n  serializeParameter(node: ParameterNode): void {\n    var sb = this.sb;\n    var kind = node.parameterKind;\n    var implicitFieldDeclaration = node.implicitFieldDeclaration;\n    if (implicitFieldDeclaration) {\n      this.serializeAccessModifiers(implicitFieldDeclaration);\n    }\n    if (kind == ParameterKind.REST) {\n      sb.push(\"...\");\n    }\n    this.visitIdentifierExpression(node.name);\n    var type = node.type;\n    var initializer = node.initializer;\n    if (type) {\n      if (kind == ParameterKind.OPTIONAL && !initializer) sb.push(\"?\");\n      if (!isTypeOmitted(type)) {\n        sb.push(\": \");\n        this.visitTypeNode(type);\n      }\n    }\n    if (initializer) {\n      sb.push(\" = \");\n      this.visitNode(initializer);\n    }\n  }\n\n  serializeExternalModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.EXPORT)) {\n      sb.push(\"export \");\n    } else if (node.is(CommonFlags.IMPORT)) {\n      sb.push(\"import \");\n    } else if (node.is(CommonFlags.DECLARE)) {\n      sb.push(\"declare \");\n    }\n  }\n\n  serializeAccessModifiers(node: DeclarationStatement): void {\n    var sb = this.sb;\n    if (node.is(CommonFlags.PUBLIC)) {\n      sb.push(\"public \");\n    } else if (node.is(CommonFlags.PRIVATE)) {\n      sb.push(\"private \");\n    } else if (node.is(CommonFlags.PROTECTED)) {\n      sb.push(\"protected \");\n    }\n    if (node.is(CommonFlags.STATIC)) {\n      sb.push(\"static \");\n    } else if (node.is(CommonFlags.ABSTRACT)) {\n      sb.push(\"abstract \");\n    }\n    if (node.is(CommonFlags.READONLY)) {\n      sb.push(\"readonly \");\n    }\n  }\n\n  finish(): string {\n    var ret = this.sb.join(\"\");\n    this.sb = [];\n    return ret;\n  }\n}\n","/**\n * @fileoverview A concurrent code flow analyzer.\n *\n * Flows keep track of compilation state and can be queried for various\n * conditions, like whether the current branch always terminates, whether\n * a local is known to be non-null or whether an expression has possibly\n * overflown its value range.\n *\n * To accomplish this, compilation of each function begins with a clean\n * flow populated with initial local states etc. While compilation\n * progresses, statements and expressions update flow state while control\n * constructs fork, potentially add scoped locals and later merge these\n * forked branches as necessary.\n *\n * @license Apache-2.0\n */\n\nimport {\n  Type,\n  TypeFlags,\n  TypeKind\n} from \"./types\";\n\nimport {\n  Local,\n  Function,\n  Element,\n  ElementKind,\n  Global,\n  Field,\n  Class\n} from \"./program\";\n\nimport {\n  NativeType,\n  ExpressionId,\n  ExpressionRef,\n  BinaryOp,\n  UnaryOp,\n\n  getExpressionId,\n  getLocalGetIndex,\n  isLocalTee,\n  getLocalSetValue,\n  getGlobalGetName,\n  getBinaryOp,\n  getBinaryLeft,\n  getConstValueI32,\n  getBinaryRight,\n  getUnaryOp,\n  getExpressionType,\n  getConstValueI64Low,\n  getConstValueF32,\n  getConstValueF64,\n  getLoadBytes,\n  isLoadSigned,\n  getBlockName,\n  getBlockChildCount,\n  getBlockChildAt,\n  getIfTrue,\n  getIfFalse,\n  getSelectThen,\n  getSelectElse,\n  getCallTarget,\n  getLocalSetIndex,\n  getIfCondition,\n  getConstValueI64High,\n  getUnaryValue,\n  getCallOperandAt,\n  traverse\n} from \"./module\";\n\nimport {\n  CommonFlags\n} from \"./common\";\n\nimport {\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Node\n} from \"./ast\";\n\nimport {\n  uniqueMap\n} from \"./util\";\n\n/** Control flow flags indicating specific conditions. */\nexport const enum FlowFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  // categorical\n\n  /** This flow always returns. */\n  RETURNS = 1 << 0,\n  /** This flow always returns a wrapped value. */\n  RETURNS_WRAPPED = 1 << 1,\n  /** This flow always returns a non-null value. */\n  RETURNS_NONNULL = 1 << 2,\n  /** This flow always throws. */\n  THROWS = 1 << 3,\n  /** This flow always breaks. */\n  BREAKS = 1 << 4,\n  /** This flow always continues. */\n  CONTINUES = 1 << 5,\n  /** This flow always accesses `this`. Constructors only. */\n  ACCESSES_THIS = 1 << 6,\n  /** This flow always calls `super`. Constructors only. */\n  CALLS_SUPER = 1 << 7,\n  /** This flow always terminates (returns, throws or continues). */\n  TERMINATES = 1 << 8, // Note that this doesn't cover BREAKS, which is separate\n\n  // conditional\n\n  /** This flow conditionally returns in a child flow. */\n  CONDITIONALLY_RETURNS = 1 << 9,\n  /** This flow conditionally throws in a child flow. */\n  CONDITIONALLY_THROWS = 1 << 10,\n  /** This flow conditionally breaks in a child flow. */\n  CONDITIONALLY_BREAKS = 1 << 11,\n  /** This flow conditionally continues in a child flow. */\n  CONDITIONALLY_CONTINUES = 1 << 12,\n  /** This flow conditionally accesses `this` in a child flow. Constructors only. */\n  CONDITIONALLY_ACCESSES_THIS = 1 << 13,\n  /** This flow may return a non-this value. Constructors only. */\n  MAY_RETURN_NONTHIS = 1 << 14,\n\n  // other\n\n  /** This is a flow with explicitly disabled bounds checking. */\n  UNCHECKED_CONTEXT = 1 << 15,\n\n  // masks\n\n  /** Any categorical flag. */\n  ANY_CATEGORICAL = FlowFlags.RETURNS\n                  | FlowFlags.RETURNS_WRAPPED\n                  | FlowFlags.RETURNS_NONNULL\n                  | FlowFlags.THROWS\n                  | FlowFlags.BREAKS\n                  | FlowFlags.CONTINUES\n                  | FlowFlags.ACCESSES_THIS\n                  | FlowFlags.CALLS_SUPER\n                  | FlowFlags.TERMINATES,\n\n  /** Any conditional flag. */\n  ANY_CONDITIONAL = FlowFlags.CONDITIONALLY_RETURNS\n                  | FlowFlags.CONDITIONALLY_THROWS\n                  | FlowFlags.CONDITIONALLY_BREAKS\n                  | FlowFlags.CONDITIONALLY_CONTINUES\n                  | FlowFlags.CONDITIONALLY_ACCESSES_THIS\n}\n\n/** Flags indicating the current state of a local. */\nexport enum LocalFlags {\n  /** No specific conditions. */\n  NONE = 0,\n\n  /** Local is constant. */\n  CONSTANT = 1 << 0,\n  /** Local is properly wrapped. Relevant for small integers. */\n  WRAPPED = 1 << 1,\n  /** Local is non-null. */\n  NONNULL = 1 << 2,\n  /** Local is initialized. */\n  INITIALIZED = 1 << 3,\n  /** Local is retained. */\n  RETAINED = 1 << 4,\n\n  /** Local must be conditionally retained. */\n  CONDITIONALLY_RETAINED = 1 << 5,\n\n  /** Any retained flag. */\n  ANY_RETAINED = RETAINED\n               | CONDITIONALLY_RETAINED\n}\n\n/** Flags indicating the current state of a field. */\nexport enum FieldFlags {\n  NONE = 0,\n  INITIALIZED = 1 << 0\n}\n\n/** Condition kinds. */\nexport const enum ConditionKind {\n  /** Outcome of the condition is unknown */\n  UNKNOWN,\n  /** Condition is always true. */\n  TRUE,\n  /** Condition is always false. */\n  FALSE\n}\n\n/** A control flow evaluator. */\nexport class Flow {\n\n  /** Creates the parent flow of the specified function. */\n  static createParent(parentFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    if (parentFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  /** Creates an inline flow within `parentFunction`. */\n  static createInline(parentFunction: Function, inlineFunction: Function): Flow {\n    var flow = new Flow(parentFunction);\n    flow.inlineFunction = inlineFunction;\n    flow.inlineReturnLabel = inlineFunction.internalName + \"|inlined.\" + (inlineFunction.nextInlineId++).toString();\n    if (inlineFunction.is(CommonFlags.CONSTRUCTOR)) {\n      flow.initThisFieldFlags();\n    }\n    return flow;\n  }\n\n  private constructor(\n    /** Function this flow belongs to. */\n    public parentFunction: Function\n  ) {\n    /* nop */\n  }\n\n  /** Parent flow. */\n  parent: Flow | null = null;\n  /** Flow flags indicating specific conditions. */\n  flags: FlowFlags = FlowFlags.NONE;\n  /** The label we break to when encountering a continue statement. */\n  continueLabel: string | null = null;\n  /** The label we break to when encountering a break statement. */\n  breakLabel: string | null = null;\n  /** Scoped local variables. */\n  scopedLocals: Map<string,Local> | null = null;\n  /** Local flags. */\n  localFlags: LocalFlags[] = [];\n  /** Field flags on `this`. Constructors only. */\n  thisFieldFlags: Map<Field,FieldFlags> | null = null;\n  /** Function being inlined, when inlining. */\n  inlineFunction: Function | null = null;\n  /** The label we break to when encountering a return statement, when inlining. */\n  inlineReturnLabel: string | null = null;\n\n  /** Tests if this is an inline flow. */\n  get isInline(): bool {\n    return this.inlineFunction !== null;\n  }\n\n  /** Gets the actual function being compiled, The inlined function when inlining, otherwise the parent function. */\n  get actualFunction(): Function {\n    var inlineFunction = this.inlineFunction;\n    if (inlineFunction) return inlineFunction;\n    return this.parentFunction;\n  }\n\n  /** Gets the current return type. */\n  get returnType(): Type {\n    return this.actualFunction.signature.returnType;\n  }\n\n  /** Gets the current contextual type arguments. */\n  get contextualTypeArguments(): Map<string,Type> | null {\n    return this.actualFunction.contextualTypeArguments;\n  }\n\n  /** Tests if this flow has the specified flag or flags. */\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this flow has one of the specified flags. */\n  isAny(flag: FlowFlags): bool { return (this.flags & flag) != 0; }\n  /** Sets the specified flag or flags. */\n  set(flag: FlowFlags): void { this.flags |= flag; }\n  /** Unsets the specified flag or flags. */\n  unset(flag: FlowFlags): void { this.flags &= ~flag; }\n\n  /** Forks this flow to a child flow. */\n  fork(resetBreakContext: bool = false): Flow {\n    var branch = new Flow(this.parentFunction);\n    branch.parent = this;\n    if (resetBreakContext) {\n      branch.flags = this.flags & ~(\n        FlowFlags.BREAKS |\n        FlowFlags.CONDITIONALLY_BREAKS |\n        FlowFlags.CONTINUES |\n        FlowFlags.CONDITIONALLY_CONTINUES\n      );\n    } else {\n      branch.flags = this.flags;\n      branch.continueLabel = this.continueLabel;\n      branch.breakLabel = this.breakLabel;\n    }\n    branch.localFlags = this.localFlags.slice();\n    if (this.actualFunction.is(CommonFlags.CONSTRUCTOR)) {\n      let thisFieldFlags = assert(this.thisFieldFlags);\n      branch.thisFieldFlags = uniqueMap<Field,FieldFlags>(thisFieldFlags);\n    } else {\n      assert(!this.thisFieldFlags);\n    }\n    branch.inlineFunction = this.inlineFunction;\n    branch.inlineReturnLabel = this.inlineReturnLabel;\n    return branch;\n  }\n\n  /** Gets a free temporary local of the specified type. */\n  getTempLocal(type: Type, except: Set<i32> | null = null): Local {\n    var parentFunction = this.parentFunction;\n    var temps: Local[] | null;\n    switch (<u32>type.toNativeType()) {\n      case <u32>NativeType.I32: { temps = parentFunction.tempI32s; break; }\n      case <u32>NativeType.I64: { temps = parentFunction.tempI64s; break; }\n      case <u32>NativeType.F32: { temps = parentFunction.tempF32s; break; }\n      case <u32>NativeType.F64: { temps = parentFunction.tempF64s; break; }\n      case <u32>NativeType.V128: { temps = parentFunction.tempV128s; break; }\n      case <u32>NativeType.Funcref: { temps = parentFunction.tempFuncrefs; break; }\n      case <u32>NativeType.Externref: { temps = parentFunction.tempExternrefs; break; }\n      case <u32>NativeType.Exnref: { temps = parentFunction.tempExnrefs; break; }\n      case <u32>NativeType.Anyref: { temps = parentFunction.tempAnyrefs; break; }\n      default: throw new Error(\"concrete type expected\");\n    }\n    var local: Local;\n    if (except) {\n      if (temps !== null && temps.length > 0) {\n        for (let i = 0, k = temps.length; i < k; ++i) {\n          if (!except.has(temps[i].index)) {\n            local = temps[i];\n            let k = temps.length - 1;\n            while (i < k) unchecked(temps[i] = temps[i++ + 1]);\n            temps.length = k;\n            local.type = type;\n            local.flags = CommonFlags.NONE;\n            this.unsetLocalFlag(local.index, ~0);\n            return local;\n          }\n        }\n      }\n      local = parentFunction.addLocal(type);\n    } else {\n      if (temps !== null && temps.length > 0) {\n        local = assert(temps.pop());\n        local.type = type;\n        local.flags = CommonFlags.NONE;\n      } else {\n        local = parentFunction.addLocal(type);\n      }\n    }\n    this.unsetLocalFlag(local.index, ~0);\n    return local;\n  }\n\n  /** Gets a local that sticks around until this flow is exited, and then released. */\n  getAutoreleaseLocal(type: Type, except: Set<i32> | null = null): Local {\n    var local = this.getTempLocal(type, except);\n    local.set(CommonFlags.SCOPED);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    scopedLocals.set(\"~auto\" + (this.parentFunction.nextAutoreleaseId++).toString(), local);\n    this.setLocalFlag(local.index, LocalFlags.RETAINED);\n    return local;\n  }\n\n  /** Frees the temporary local for reuse. */\n  freeTempLocal(local: Local): void {\n    if (local.is(CommonFlags.INLINED)) return;\n    assert(local.index >= 0);\n    var parentFunction = this.parentFunction;\n    var temps: Local[];\n    assert(local.type != null); // internal error\n    local.resetTemporaryName();\n    switch (<u32>local.type.toNativeType()) {\n      case <u32>NativeType.I32: {\n        let tempI32s = parentFunction.tempI32s;\n        if (tempI32s) temps = tempI32s;\n        else parentFunction.tempI32s = temps = [];\n        break;\n      }\n      case <u32>NativeType.I64: {\n        let tempI64s = parentFunction.tempI64s;\n        if (tempI64s) temps = tempI64s;\n        else parentFunction.tempI64s = temps = [];\n        break;\n      }\n      case <u32>NativeType.F32: {\n        let tempF32s = parentFunction.tempF32s;\n        if (tempF32s) temps = tempF32s;\n        else parentFunction.tempF32s = temps = [];\n        break;\n      }\n      case <u32>NativeType.F64: {\n        let tempF64s = parentFunction.tempF64s;\n        if (tempF64s) temps = tempF64s;\n        else parentFunction.tempF64s = temps = [];\n        break;\n      }\n      case <u32>NativeType.V128: {\n        let tempV128s = parentFunction.tempV128s;\n        if (tempV128s) temps = tempV128s;\n        else parentFunction.tempV128s = temps = [];\n        break;\n      }\n      case <u32>NativeType.Funcref: {\n        let tempFuncrefs = parentFunction.tempFuncrefs;\n        if (tempFuncrefs) temps = tempFuncrefs;\n        else parentFunction.tempFuncrefs = temps = [];\n        break;\n      }\n      case <u32>NativeType.Externref: {\n        let tempExternrefs = parentFunction.tempExternrefs;\n        if (tempExternrefs) temps = tempExternrefs;\n        else parentFunction.tempExternrefs = temps = [];\n        break;\n      }\n      case <u32>NativeType.Exnref: {\n        let tempExnrefs = parentFunction.tempExnrefs;\n        if (tempExnrefs) temps = tempExnrefs;\n        else parentFunction.tempExnrefs = temps = [];\n        break;\n      }\n      case <u32>NativeType.Anyref: {\n        let tempAnyrefs = parentFunction.tempAnyrefs;\n        if (tempAnyrefs) temps = tempAnyrefs;\n        else parentFunction.tempAnyrefs = temps = [];\n        break;\n      }\n      default: throw new Error(\"concrete type expected\");\n    }\n    assert(local.index >= 0);\n    temps.push(local);\n  }\n\n  /** Gets the scoped local of the specified name. */\n  getScopedLocal(name: string): Local | null {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals !== null && scopedLocals.has(name)) return assert(scopedLocals.get(name));\n    return null;\n  }\n\n  /** Adds a new scoped local of the specified name. */\n  addScopedLocal(name: string, type: Type, except: Set<i32> | null = null): Local {\n    var scopedLocal = this.getTempLocal(type, except);\n    scopedLocal.setTemporaryName(name);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedLocal.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedLocal);\n    return scopedLocal;\n  }\n\n  /** Adds a new scoped dummy local of the specified name. */\n  addScopedDummyLocal(name: string, type: Type): Local {\n    var scopedDummy = new Local(name, -1, type, this.parentFunction);\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else assert(!scopedLocals.has(name));\n    scopedDummy.set(CommonFlags.SCOPED);\n    scopedLocals.set(name, scopedDummy);\n    return scopedDummy;\n  }\n\n  /** Adds a new scoped alias for the specified local. For example `super` aliased to the `this` local. */\n  addScopedAlias(name: string, type: Type, index: i32, reportNode: Node | null = null): Local {\n    var scopedLocals = this.scopedLocals;\n    if (!scopedLocals) this.scopedLocals = scopedLocals = new Map();\n    else {\n      let existingLocal = scopedLocals.get(name);\n      if (existingLocal) {\n        if (reportNode) {\n          if (!existingLocal.declaration.range.source.isNative) {\n            this.parentFunction.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportNode.range,\n              existingLocal.declaration.name.range,\n              name\n            );\n          } else {\n            this.parentFunction.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportNode.range, name\n            );\n          }\n        }\n        return existingLocal;\n      }\n    }\n    assert(index < this.parentFunction.localsByIndex.length);\n    var scopedAlias = new Local(name, index, type, this.parentFunction);\n    // not flagged as SCOPED as it must not be free'd when the flow is finalized\n    scopedLocals.set(name, scopedAlias);\n    return scopedAlias;\n  }\n\n  /** Tests if this flow has any scoped locals that must be free'd. */\n  get hasScopedLocals(): bool {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Frees a single scoped local by its name. */\n  freeScopedDummyLocal(name: string): void {\n    var scopedLocals = assert(this.scopedLocals);\n    assert(scopedLocals.has(name));\n    let local = assert(scopedLocals.get(name));\n    assert(local.index == -1);\n    scopedLocals.delete(name);\n  }\n\n  /** Frees this flow's scoped variables and returns its parent flow. */\n  freeScopedLocals(): void {\n    var scopedLocals = this.scopedLocals;\n    if (scopedLocals) {\n      // TODO: for (let local of scopedLocals.values()) {\n      for (let _values = Map_values(scopedLocals), i = 0, k = _values.length; i < k; ++i) {\n        let local = unchecked(_values[i]);\n        if (local.is(CommonFlags.SCOPED)) { // otherwise an alias\n          this.freeTempLocal(local);\n        }\n      }\n      this.scopedLocals = null;\n    }\n  }\n\n  /** Looks up the local of the specified name in the current scope. */\n  lookupLocal(name: string): Local | null {\n    var current: Flow | null = this;\n    do {\n      let scope = current.scopedLocals;\n      if (scope !== null && scope.has(name)) return assert(scope.get(name));\n      current = current.parent;\n    } while (current);\n    var localsByName = this.parentFunction.localsByName;\n    if (localsByName.has(name)) return assert(localsByName.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to the scope of this flow. */\n  lookup(name: string): Element | null {\n    var element = this.lookupLocal(name);\n    if (element) return element;\n    return this.actualFunction.lookup(name);\n  }\n\n  /** Tests if the local at the specified index has the specified flag or flags. */\n  isLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) == flag;\n  }\n\n  /** Tests if the local at the specified index has any of the specified flags. */\n  isAnyLocalFlag(index: i32, flag: LocalFlags, defaultIfInlined: bool = true): bool {\n    if (index < 0) return defaultIfInlined;\n    var localFlags = this.localFlags;\n    return index < localFlags.length && (unchecked(localFlags[index]) & flag) != 0;\n  }\n\n  /** Sets the specified flag or flags on the local at the specified index. */\n  setLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags | flag;\n  }\n\n  /** Unsets the specified flag or flags on the local at the specified index. */\n  unsetLocalFlag(index: i32, flag: LocalFlags): void {\n    if (index < 0) return;\n    var localFlags = this.localFlags;\n    var flags = index < localFlags.length ? unchecked(localFlags[index]) : 0;\n    localFlags[index] = flags & ~flag;\n  }\n\n  /** Initializes `this` field flags. */\n  initThisFieldFlags(): void {\n    var actualFunction = this.actualFunction;\n    assert(actualFunction.is(CommonFlags.CONSTRUCTOR));\n    var actualParent = actualFunction.parent;\n    assert(actualParent.kind == ElementKind.CLASS);\n    var actualClass = <Class>actualParent;\n    this.thisFieldFlags = new Map();\n    var members = actualClass.members;\n    if (members) {\n      for (let _values = Map_values(members), i = 0, k = _values.length; i < k; ++i) {\n        let member = _values[i];\n        if (member.kind == ElementKind.FIELD) {\n          let field = <Field>member;\n          if (\n            // guaranteed by super\n            field.parent != actualClass ||\n            // has field initializer\n            field.initializerNode !== null ||\n            // is initialized as a ctor parameter\n            field.prototype.parameterIndex != -1 ||\n            // is safe to initialize with zero\n            field.type.isAny(TypeFlags.VALUE | TypeFlags.NULLABLE)\n          ) {\n            this.setThisFieldFlag(field, FieldFlags.INITIALIZED);\n          }\n        }\n      }\n    }\n  }\n\n  /** Tests if the specified `this` field has the specified flag or flags. */\n  isThisFieldFlag(field: Field, flag: FieldFlags): bool {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags != null && fieldFlags.has(field)) {\n      return (changetype<FieldFlags>(fieldFlags.get(field)) & flag) == flag;\n    }\n    return false;\n  }\n\n  /** Sets the specified flag or flags on the given `this` field. */\n  setThisFieldFlag(field: Field, flag: FieldFlags): void {\n    var fieldFlags = this.thisFieldFlags;\n    if (fieldFlags) {\n      assert(this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n      if (fieldFlags.has(field)) {\n        let flags = changetype<FieldFlags>(fieldFlags.get(field));\n        fieldFlags.set(field, flags | flag);\n      } else {\n        fieldFlags.set(field, flag);\n      }\n    } else {\n      assert(!this.actualFunction.is(CommonFlags.CONSTRUCTOR));\n    }\n  }\n\n  /** Pushes a new break label to the stack, for example when entering a loop that one can `break` from. */\n  pushBreakLabel(): string {\n    var parentFunction = this.parentFunction;\n    var id = parentFunction.nextBreakId++;\n    var stack = parentFunction.breakStack;\n    if (!stack) parentFunction.breakStack = [ id ];\n    else stack.push(id);\n    var label = id.toString();\n    parentFunction.breakLabel = label;\n    return label;\n  }\n\n  /** Pops the most recent break label from the stack. */\n  popBreakLabel(): void {\n    var parentFunction = this.parentFunction;\n    var stack = assert(parentFunction.breakStack);\n    var length = assert(stack.length);\n    stack.pop();\n    if (length > 1) {\n      parentFunction.breakLabel = stack[length - 2].toString();\n    } else {\n      parentFunction.breakLabel = null;\n      parentFunction.breakStack = null;\n    }\n  }\n\n  /** Inherits flags of another flow into this one, i.e. a finished inner block. */\n  inherit(other: Flow): void {\n    assert(other.parentFunction == this.parentFunction);\n    assert(other.parent == this); // currently the case, but might change\n    var otherFlags = other.flags;\n\n    // respective inner flags are irrelevant if contexts differ\n    if (this.breakLabel != other.breakLabel) {\n      if (otherFlags & (FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS)) {\n        otherFlags &= ~FlowFlags.TERMINATES;\n      }\n      otherFlags &= ~(FlowFlags.BREAKS | FlowFlags.CONDITIONALLY_BREAKS);\n    }\n    if (this.continueLabel != other.continueLabel) {\n      otherFlags &= ~(FlowFlags.CONTINUES | FlowFlags.CONDITIONALLY_CONTINUES);\n    }\n\n    this.flags = this.flags | otherFlags; // what happens before is still true\n    this.localFlags = other.localFlags;\n    this.thisFieldFlags = other.thisFieldFlags;\n  }\n\n  /** Inherits flags of a conditional branch joining again with this one, i.e. then without else. */\n  inheritBranch(other: Flow, conditionKind: ConditionKind = ConditionKind.UNKNOWN): void {\n    assert(other.parentFunction == this.parentFunction);\n    switch (conditionKind) {\n      case ConditionKind.TRUE: this.inherit(other); // always executes\n      case ConditionKind.FALSE: return;             // never executes\n    }\n\n    // Note that flags in `this` flow have already happened. For instance,\n    // a return cannot be undone no matter what'd happen in subsequent branches,\n    // but an allocation, which doesn't terminate, can become conditional. Not\n    // all flags have a corresponding conditional flag that's tracked.\n\n    var thisFlags = this.flags;\n    var otherFlags = other.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (thisFlags & FlowFlags.RETURNS) { // nothing can change that\n      newFlags |= FlowFlags.RETURNS;\n    } else if (otherFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_WRAPPED;\n    newFlags |= thisFlags & otherFlags & FlowFlags.RETURNS_NONNULL;\n\n    if (thisFlags & FlowFlags.THROWS) { // nothing can change that\n      newFlags |= FlowFlags.THROWS;\n    } else if (otherFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (thisFlags & FlowFlags.BREAKS) { // nothing can change that\n      newFlags |= FlowFlags.BREAKS;\n    } else if (other.breakLabel == this.breakLabel) {\n      if (otherFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (thisFlags & FlowFlags.CONTINUES) { // nothing can change that\n      newFlags |= FlowFlags.CONTINUES;\n    } else if (other.continueLabel === this.continueLabel) {\n      if (otherFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else {\n      newFlags |= thisFlags & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (thisFlags & FlowFlags.ACCESSES_THIS) { // can become conditional\n      if (otherFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (otherFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    // may be the case in any\n    newFlags |= (thisFlags | otherFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    // must be the case in both\n    newFlags |= thisFlags & otherFlags & FlowFlags.CALLS_SUPER;\n\n    if (thisFlags & FlowFlags.TERMINATES) { // nothing can change that\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (thisFlags & FlowFlags.UNCHECKED_CONTEXT);\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    var numThisLocalFlags = thisLocalFlags.length;\n    var otherLocalFlags = other.localFlags;\n    var numOtherLocalFlags = otherLocalFlags.length;\n    var maxLocalFlags = max(numThisLocalFlags, numOtherLocalFlags);\n    for (let i = 0; i < maxLocalFlags; ++i) {\n      let thisFlags = i < numThisLocalFlags ? thisLocalFlags[i] : 0;\n      let otherFlags = i < numOtherLocalFlags ? otherLocalFlags[i] : 0;\n      let newFlags = thisFlags & otherFlags & (\n        LocalFlags.CONSTANT  |\n        LocalFlags.WRAPPED   |\n        LocalFlags.NONNULL   |\n        LocalFlags.INITIALIZED\n      );\n      if (thisFlags & LocalFlags.RETAINED) {\n        if (otherFlags & LocalFlags.RETAINED) {\n          newFlags |= LocalFlags.RETAINED;\n        } else {\n          newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n        }\n      } else if (otherFlags & LocalFlags.RETAINED) {\n        newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n      } else {\n        newFlags |= (thisFlags | otherFlags) & LocalFlags.CONDITIONALLY_RETAINED;\n      }\n      thisLocalFlags[i] = newFlags;\n    }\n\n    // field flags do not matter here since there's only INITIALIZED, which can\n    // only be set if it has been observed prior to entering the branch.\n  }\n\n  /** Inherits mutual flags of two alternate branches becoming this one, i.e. then with else. */\n  inheritMutual(left: Flow, right: Flow): void {\n    assert(left.parentFunction == right.parentFunction);\n    assert(left.parentFunction == this.parentFunction);\n    // This differs from the previous method in that no flags are guaranteed\n    // to happen unless it is the case in both flows.\n\n    var leftFlags = left.flags;\n    var rightFlags = right.flags;\n    var newFlags = FlowFlags.NONE;\n\n    if (leftFlags & FlowFlags.RETURNS) {\n      if (rightFlags & FlowFlags.RETURNS) {\n        newFlags |= FlowFlags.RETURNS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n      }\n    } else if (rightFlags & FlowFlags.RETURNS) {\n      newFlags |= FlowFlags.CONDITIONALLY_RETURNS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_RETURNS;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_WRAPPED) && (rightFlags & FlowFlags.RETURNS_WRAPPED)) {\n      newFlags |= FlowFlags.RETURNS_WRAPPED;\n    }\n\n    if ((leftFlags & FlowFlags.RETURNS_NONNULL) && (rightFlags & FlowFlags.RETURNS_NONNULL)) {\n      newFlags |= FlowFlags.RETURNS_NONNULL;\n    }\n\n    if (leftFlags & FlowFlags.THROWS) {\n      if (rightFlags & FlowFlags.THROWS) {\n        newFlags |= FlowFlags.THROWS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n      }\n    } else if (rightFlags & FlowFlags.THROWS) {\n      newFlags |= FlowFlags.CONDITIONALLY_THROWS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_THROWS;\n    }\n\n    if (leftFlags & FlowFlags.BREAKS) {\n      if (rightFlags & FlowFlags.BREAKS) {\n        newFlags |= FlowFlags.BREAKS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n      }\n    } else if (rightFlags & FlowFlags.BREAKS) {\n      newFlags |= FlowFlags.CONDITIONALLY_BREAKS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_BREAKS;\n    }\n\n    if (leftFlags & FlowFlags.CONTINUES) {\n      if (rightFlags & FlowFlags.CONTINUES) {\n        newFlags |= FlowFlags.CONTINUES;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n      }\n    } else if (rightFlags & FlowFlags.CONTINUES) {\n      newFlags |= FlowFlags.CONDITIONALLY_CONTINUES;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_CONTINUES;\n    }\n\n    if (leftFlags & FlowFlags.ACCESSES_THIS) {\n      if (rightFlags & FlowFlags.ACCESSES_THIS) {\n        newFlags |= FlowFlags.ACCESSES_THIS;\n      } else {\n        newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n      }\n    } else if (rightFlags & FlowFlags.ACCESSES_THIS) {\n      newFlags |= FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    } else {\n      newFlags |= (leftFlags | rightFlags) & FlowFlags.CONDITIONALLY_ACCESSES_THIS;\n    }\n\n    newFlags |= (leftFlags | rightFlags) & FlowFlags.MAY_RETURN_NONTHIS;\n\n    if ((leftFlags & FlowFlags.CALLS_SUPER) && (rightFlags & FlowFlags.CALLS_SUPER)) {\n      newFlags |= FlowFlags.CALLS_SUPER;\n    }\n\n    if ((leftFlags & FlowFlags.TERMINATES) && (rightFlags & FlowFlags.TERMINATES)) {\n      newFlags |= FlowFlags.TERMINATES;\n    }\n\n    this.flags = newFlags | (this.flags & FlowFlags.UNCHECKED_CONTEXT);\n\n    // local flags\n    var thisLocalFlags = this.localFlags;\n    if (leftFlags & FlowFlags.TERMINATES) {\n      if (!(rightFlags & FlowFlags.TERMINATES)) {\n        let rightLocalFlags = right.localFlags;\n        for (let i = 0, k = rightLocalFlags.length; i < k; ++i) {\n          thisLocalFlags[i] = rightLocalFlags[i];\n        }\n      }\n    } else if (rightFlags & FlowFlags.TERMINATES) {\n      let leftLocalFlags = left.localFlags;\n      for (let i = 0, k = leftLocalFlags.length; i < k; ++i) {\n        thisLocalFlags[i] = leftLocalFlags[i];\n      }\n    } else {\n      let leftLocalFlags = left.localFlags;\n      let numLeftLocalFlags = leftLocalFlags.length;\n      let rightLocalFlags = right.localFlags;\n      let numRightLocalFlags = rightLocalFlags.length;\n      let maxLocalFlags = max(numLeftLocalFlags, numRightLocalFlags);\n      for (let i = 0; i < maxLocalFlags; ++i) {\n        let leftFlags = i < numLeftLocalFlags ? leftLocalFlags[i] : 0;\n        let rightFlags = i < numRightLocalFlags ? rightLocalFlags[i] : 0;\n        let newFlags = leftFlags & rightFlags & (\n          LocalFlags.CONSTANT  |\n          LocalFlags.WRAPPED   |\n          LocalFlags.NONNULL   |\n          LocalFlags.INITIALIZED\n        );\n        if (leftFlags & LocalFlags.RETAINED) {\n          if (rightFlags & LocalFlags.RETAINED) {\n            newFlags |= LocalFlags.RETAINED;\n          } else {\n            newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n          }\n        } else if (rightFlags & LocalFlags.RETAINED) {\n          newFlags |= LocalFlags.CONDITIONALLY_RETAINED;\n        } else {\n          newFlags |= (leftFlags | rightFlags) & LocalFlags.CONDITIONALLY_RETAINED;\n        }\n        thisLocalFlags[i] = newFlags;\n      }\n    }\n\n    // field flags (currently only INITIALIZED, so can simplify)\n    var leftFieldFlags = left.thisFieldFlags;\n    if (leftFieldFlags) {\n      let newFieldFlags = new Map<Field,FieldFlags>();\n      let rightFieldFlags = assert(right.thisFieldFlags);\n      for (let _keys = Map_keys(leftFieldFlags), i = 0, k = _keys.length; i < k; ++i) {\n        let key = _keys[i];\n        let leftFlags = changetype<FieldFlags>(leftFieldFlags.get(key));\n        if (\n          (leftFlags & FieldFlags.INITIALIZED) != 0 && rightFieldFlags.has(key) && \n          (changetype<FieldFlags>(rightFieldFlags.get(key)) & FieldFlags.INITIALIZED)\n        ) {\n          newFieldFlags.set(key, FieldFlags.INITIALIZED);\n        }\n      }\n      this.thisFieldFlags = newFieldFlags;\n    } else {\n      assert(!right.thisFieldFlags);\n    }\n  }\n\n  /** Tests if the specified flows have differing local states. */\n  static hasIncompatibleLocalStates(before: Flow, after: Flow): bool {\n    var numThisLocalFlags = before.localFlags.length;\n    var numOtherLocalFlags = after.localFlags.length;\n    var parentFunction = before.parentFunction;\n    assert(parentFunction === after.parentFunction);\n    var localsByIndex = parentFunction.localsByIndex;\n    assert(localsByIndex === after.parentFunction.localsByIndex);\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      let local = localsByIndex[i];\n      let type = local.type;\n      if (type.isShortIntegerValue) {\n        if (before.isLocalFlag(i, LocalFlags.WRAPPED) && !after.isLocalFlag(i, LocalFlags.WRAPPED)) {\n          return true;\n        }\n      }\n      if (type.isNullableReference) {\n        if (before.isLocalFlag(i, LocalFlags.NONNULL) && !after.isLocalFlag(i, LocalFlags.NONNULL)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Unifies local flags between this and the other flow. */\n  unifyLocalFlags(other: Flow): void {\n    var numThisLocalFlags = this.localFlags.length;\n    var numOtherLocalFlags = other.localFlags.length;\n    for (let i = 0, k = min<i32>(numThisLocalFlags, numOtherLocalFlags); i < k; ++i) {\n      if (this.isLocalFlag(i, LocalFlags.WRAPPED) != other.isLocalFlag(i, LocalFlags.WRAPPED)) {\n        this.unsetLocalFlag(i, LocalFlags.WRAPPED); // assume not wrapped\n      }\n      if (this.isLocalFlag(i, LocalFlags.NONNULL) != other.isLocalFlag(i, LocalFlags.NONNULL)) {\n        this.unsetLocalFlag(i, LocalFlags.NONNULL); // assume possibly null\n      }\n      assert(\n        // having different retain states would be a problem because the compiler\n        // either can't release a retained local or would release a non-retained local\n        this.isAnyLocalFlag(i, LocalFlags.ANY_RETAINED) == other.isAnyLocalFlag(i, LocalFlags.ANY_RETAINED)\n      );\n    }\n  }\n\n  /** Checks if an expression of the specified type is known to be non-null, even if the type might be nullable. */\n  isNonnull(expr: ExpressionRef, type: Type): bool {\n    if (!type.isNullableReference) return true;\n    // below, only teeLocal/getLocal are relevant because these are the only expressions that\n    // depend on a dynamic nullable state (flag = LocalFlags.NONNULL), while everything else\n    // has already been handled by the nullable type check above.\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !local.type.isNullableReference || this.isLocalFlag(local.index, LocalFlags.NONNULL, false);\n      }\n    }\n    return false;\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is true-ish. */\n  inheritNonnullIfTrue(\n    /** Expression being true. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is true-ish -> Q: how did that happen?\n\n    // The iff argument is useful in situations like\n    //\n    //  if (!ref) {\n    //    ref = new Ref();\n    //  }\n    //  // inheritNonnullIfFalse(`!ref`, thenFlow) -> ref != null\n    //\n\n    switch (getExpressionId(expr)) {\n      case ExpressionId.LocalSet: {\n        if (!isLocalTee(expr)) break;\n        let local = this.parentFunction.localsByIndex[getLocalSetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        this.inheritNonnullIfTrue(getLocalSetValue(expr), iff); // must have been true-ish as well\n        break;\n      }\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        if (!iff || iff.isLocalFlag(local.index, LocalFlags.NONNULL)) {\n          this.setLocalFlag(local.index, LocalFlags.NONNULL);\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifFalse = getIfFalse(expr);\n        if (!ifFalse) break;\n        if (getExpressionId(ifFalse) == ExpressionId.Const) {\n          // Logical AND: (if (condition ifTrue 0))\n          // the only way this had become true is if condition and ifTrue are true\n          if (\n            (getExpressionType(ifFalse) == NativeType.I32 && getConstValueI32(ifFalse) == 0) ||\n            (getExpressionType(ifFalse) == NativeType.I64 && getConstValueI64Low(ifFalse) == 0 && getConstValueI64High(ifFalse) == 0)\n          ) {\n            this.inheritNonnullIfTrue(getIfCondition(expr), iff);\n            this.inheritNonnullIfTrue(getIfTrue(expr), iff);\n          }\n        }\n        break;\n      }\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfFalse(getUnaryValue(expr), iff); // !value -> value must have been false\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 && getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left == TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != FALSE -> left must have been true\n            }\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.Call: {\n        let name = getCallTarget(expr);\n        let program = this.parentFunction.program;\n        if (name == program.retainInstance.internalName) {\n          // __retain just passes through the argument\n          this.inheritNonnullIfTrue(getCallOperandAt(expr, 0), iff);\n        }\n        break;\n      }\n    }\n  }\n\n  /** Updates local states to reflect that this branch is only taken when `expr` is false-ish. */\n  inheritNonnullIfFalse(\n    /** Expression being false. */\n    expr: ExpressionRef,\n    /** If specified, only set the flag if also nonnull in this flow. */\n    iff: Flow | null = null\n  ): void {\n    // A: `expr` is false-ish -> Q: how did that happen?\n    switch (getExpressionId(expr)) {\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: {\n            this.inheritNonnullIfTrue(getUnaryValue(expr), iff); // !value -> value must have been true\n            break;\n          }\n        }\n        break;\n      }\n      case ExpressionId.If: {\n        let ifTrue = getIfTrue(expr);\n        if (getExpressionId(ifTrue) == ExpressionId.Const) {\n          let ifFalse = getIfFalse(expr);\n          if (!ifFalse) break;\n          // Logical OR: (if (condition 1 ifFalse))\n          // the only way this had become false is if condition and ifFalse are false\n          let exprType = getExpressionType(ifTrue);\n          if (\n            (exprType == NativeType.I32 && getConstValueI32(ifTrue) != 0) ||\n            (exprType == NativeType.I64 && (getConstValueI64Low(ifTrue) != 0 || getConstValueI64High(ifTrue) != 0))\n          ) {\n            this.inheritNonnullIfFalse(getIfCondition(expr), iff);\n            this.inheritNonnullIfFalse(getIfFalse(expr), iff);\n          }\n\n        }\n        break;\n      }\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n          // remember: we want to know how the _entire_ expression became FALSE (!)\n          case BinaryOp.EqI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.EqI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI64Low(left) == 0 && getConstValueI64High(left) == 0) {\n              this.inheritNonnullIfTrue(right, iff); // FALSE == right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI64Low(right) == 0 && getConstValueI64High(right) == 0) {\n              this.inheritNonnullIfTrue(left, iff); // left == FALSE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI32: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && getConstValueI32(left) != 0) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true\n            } else if (getExpressionId(right) == ExpressionId.Const && getConstValueI32(right) != 0) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true\n            }\n            break;\n          }\n          case BinaryOp.NeI64: {\n            let left = getBinaryLeft(expr);\n            let right = getBinaryRight(expr);\n            if (getExpressionId(left) == ExpressionId.Const && (getConstValueI64Low(left) != 0 || getConstValueI64High(left) != 0)) {\n              this.inheritNonnullIfTrue(right, iff); // TRUE != right -> right must have been true for this to become false\n            } else if (getExpressionId(right) == ExpressionId.Const && (getConstValueI64Low(right) != 0 || getConstValueI64High(right) != 0)) {\n              this.inheritNonnullIfTrue(left, iff); // left != TRUE -> left must have been true for this to become false\n            }\n            break;\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  /**\n   * Tests if an expression can possibly overflow in the context of this flow. Assumes that the\n   * expression might already have overflown and returns `false` only if the operation neglects\n   * any possible combination of garbage bits being present.\n   */\n  canOverflow(expr: ExpressionRef, type: Type): bool {\n    // TODO: the following catches most common and a few uncommon cases, but there are additional\n    // opportunities here, obviously.\n    assert(type != Type.void);\n\n    // types other than i8, u8, i16, u16 and bool do not overflow\n    if (!type.isShortIntegerValue) return false;\n\n    var operand: ExpressionRef;\n    switch (getExpressionId(expr)) {\n\n      // overflows if the local isn't wrapped or the conversion does\n      case ExpressionId.LocalGet: {\n        let local = this.parentFunction.localsByIndex[getLocalGetIndex(expr)];\n        return !this.isLocalFlag(local.index, LocalFlags.WRAPPED, true)\n            || canConversionOverflow(local.type, type);\n      }\n\n      // overflows if the value does\n      case ExpressionId.LocalSet: { // tee\n        assert(isLocalTee(expr));\n        return this.canOverflow(getLocalSetValue(expr), type);\n      }\n\n      // overflows if the conversion does (globals are wrapped on set)\n      case ExpressionId.GlobalGet: {\n        // TODO: this is inefficient because it has to read a string\n        let global = assert(this.parentFunction.program.elementsByName.get(assert(getGlobalGetName(expr))));\n        assert(global.kind == ElementKind.GLOBAL);\n        return canConversionOverflow((<Global>global).type, type);\n      }\n\n      case ExpressionId.Binary: {\n        switch (getBinaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case BinaryOp.EqI32:\n          case BinaryOp.EqI64:\n          case BinaryOp.EqF32:\n          case BinaryOp.EqF64:\n          case BinaryOp.NeI32:\n          case BinaryOp.NeI64:\n          case BinaryOp.NeF32:\n          case BinaryOp.NeF64:\n          case BinaryOp.LtI32:\n          case BinaryOp.LtU32:\n          case BinaryOp.LtI64:\n          case BinaryOp.LtU64:\n          case BinaryOp.LtF32:\n          case BinaryOp.LtF64:\n          case BinaryOp.LeI32:\n          case BinaryOp.LeU32:\n          case BinaryOp.LeI64:\n          case BinaryOp.LeU64:\n          case BinaryOp.LeF32:\n          case BinaryOp.LeF64:\n          case BinaryOp.GtI32:\n          case BinaryOp.GtU32:\n          case BinaryOp.GtI64:\n          case BinaryOp.GtU64:\n          case BinaryOp.GtF32:\n          case BinaryOp.GtF64:\n          case BinaryOp.GeI32:\n          case BinaryOp.GeU32:\n          case BinaryOp.GeI64:\n          case BinaryOp.GeU64:\n          case BinaryOp.GeF32:\n          case BinaryOp.GeF64: return false;\n\n          // result won't overflow if one side is 0 or if one side is 1 and the other wrapped\n          case BinaryOp.MulI32: {\n            return !(\n              (\n                getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryRight(expr), type)\n                  )\n                )\n              ) || (\n                getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                (\n                  getConstValueI32(operand) == 0 ||\n                  (\n                    getConstValueI32(operand) == 1 &&\n                    !this.canOverflow(getBinaryLeft(expr), type)\n                  )\n                )\n              )\n            );\n          }\n\n          // result won't overflow if one side is a constant less than this type's mask or one side\n          // is wrapped\n          case BinaryOp.AndI32: {\n            // note that computeSmallIntegerMask returns the mask minus the MSB for signed types\n            // because signed value garbage bits must be guaranteed to be equal to the MSB.\n            return !(\n              (\n                (\n                  getExpressionId(operand = getBinaryLeft(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              ) || (\n                (\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) <= type.computeSmallIntegerMask(Type.i32)\n                ) || !this.canOverflow(operand, type)\n              )\n            );\n          }\n\n          // overflows if the shift doesn't clear potential garbage bits\n          case BinaryOp.ShlI32: {\n            let shift = 32 - type.size;\n            return getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const\n                || getConstValueI32(operand) < shift;\n          }\n\n          // overflows if the value does and the shift doesn't clear potential garbage bits\n          case BinaryOp.ShrI32: {\n            let shift = 32 - type.size;\n            return this.canOverflow(getBinaryLeft(expr), type) && (\n              getExpressionId(operand = getBinaryRight(expr)) != ExpressionId.Const ||\n              getConstValueI32(operand) < shift\n            );\n          }\n\n          // overflows if the shift does not clear potential garbage bits. if an unsigned value is\n          // wrapped, it can't overflow.\n          case BinaryOp.ShrU32: {\n            let shift = 32 - type.size;\n            return type.isSignedIntegerValue\n              ? !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) > shift // must clear MSB\n                )\n              : this.canOverflow(getBinaryLeft(expr), type) &&\n                !(\n                  getExpressionId(operand = getBinaryRight(expr)) == ExpressionId.Const &&\n                  getConstValueI32(operand) >= shift // can leave MSB\n                );\n          }\n\n          // overflows if any side does\n          case BinaryOp.DivU32:\n          case BinaryOp.RemI32:\n          case BinaryOp.RemU32: {\n            return this.canOverflow(getBinaryLeft(expr), type)\n                || this.canOverflow(getBinaryRight(expr), type);\n          }\n        }\n        break;\n      }\n\n      case ExpressionId.Unary: {\n        switch (getUnaryOp(expr)) {\n\n          // comparisons do not overflow (result is 0 or 1)\n          case UnaryOp.EqzI32:\n          case UnaryOp.EqzI64: return false;\n\n          // overflow if the maximum result (32) cannot be represented in the target type\n          case UnaryOp.ClzI32:\n          case UnaryOp.CtzI32:\n          case UnaryOp.PopcntI32: return type.size < 7;\n        }\n        break;\n      }\n\n      // overflows if the value cannot be represented in the target type\n      case ExpressionId.Const: {\n        let value: i32 = 0;\n        switch (<u32>getExpressionType(expr)) {\n          case <u32>NativeType.I32: { value = getConstValueI32(expr); break; }\n          case <u32>NativeType.I64: { value = getConstValueI64Low(expr); break; } // discards upper bits\n          case <u32>NativeType.F32: { value = i32(getConstValueF32(expr)); break; }\n          case <u32>NativeType.F64: { value = i32(getConstValueF64(expr)); break; }\n          default: assert(false);\n        }\n        switch (type.kind) {\n          case TypeKind.I8: return value < <i32>i8.MIN_VALUE || value > <i32>i8.MAX_VALUE;\n          case TypeKind.I16: return value < <i32>i16.MIN_VALUE || value > <i32>i16.MAX_VALUE;\n          case TypeKind.U8: return value < 0 || value > <i32>u8.MAX_VALUE;\n          case TypeKind.U16: return value < 0 || value > <i32>u16.MAX_VALUE;\n          case TypeKind.BOOL: return (value & ~1) != 0;\n        }\n        break;\n      }\n\n      // overflows if the conversion does\n      case ExpressionId.Load: {\n        let fromType: Type;\n        let signed = isLoadSigned(expr);\n        switch (getLoadBytes(expr)) {\n          case 1:  { fromType = signed ? Type.i8  : Type.u8;  break; }\n          case 2:  { fromType = signed ? Type.i16 : Type.u16; break; }\n          default: { fromType = signed ? Type.i32 : Type.u32; break; }\n        }\n        return canConversionOverflow(fromType, type);\n      }\n\n      // overflows if the result does, which is either\n      // - the last expression of the block, by contract, if the block doesn't have a label\n      // - the last expression or the value of an inner br if the block has a label (TODO)\n      case ExpressionId.Block: {\n        if (!getBlockName(expr)) {\n          let size = assert(getBlockChildCount(expr));\n          let last = getBlockChildAt(expr, size - 1);\n          return this.canOverflow(last, type);\n        }\n        break;\n      }\n\n      // overflows if either side does\n      case ExpressionId.If: {\n        return this.canOverflow(getIfTrue(expr), type)\n            || this.canOverflow(assert(getIfFalse(expr)), type);\n      }\n\n      // overflows if either side does\n      case ExpressionId.Select: {\n        return this.canOverflow(getSelectThen(expr), type)\n            || this.canOverflow(getSelectElse(expr), type);\n      }\n\n      // overflows if the call does not return a wrapped value or the conversion does\n      case ExpressionId.Call: {\n        let program = this.parentFunction.program;\n        let instancesByName = program.instancesByName;\n        let instanceName = assert(getCallTarget(expr));\n        if (instancesByName.has(instanceName)) {\n          let instance = assert(instancesByName.get(instanceName));\n          assert(instance.kind == ElementKind.FUNCTION);\n          let functionInstance = <Function>instance;\n          let returnType = functionInstance.signature.returnType;\n          return !functionInstance.flow.is(FlowFlags.RETURNS_WRAPPED)\n              || canConversionOverflow(returnType, type);\n        }\n        return false; // assume no overflow for builtins\n      }\n\n      // doesn't technically overflow\n      case ExpressionId.Unreachable: return false;\n    }\n    return true;\n  }\n\n  toString(): string {\n    var levels = 0;\n    var parent = this.parent;\n    while (parent) {\n      parent = parent.parent;\n      ++levels;\n    }\n    var sb = new Array<string>();\n    if (this.is(FlowFlags.RETURNS)) sb.push(\"RETURNS\");\n    if (this.is(FlowFlags.RETURNS_WRAPPED)) sb.push(\"RETURNS_WRAPPED\");\n    if (this.is(FlowFlags.RETURNS_NONNULL)) sb.push(\"RETURNS_NONNULL\");\n    if (this.is(FlowFlags.THROWS)) sb.push(\"THROWS\");\n    if (this.is(FlowFlags.BREAKS)) sb.push(\"BREAKS\");\n    if (this.is(FlowFlags.CONTINUES)) sb.push(\"CONTINUES\");\n    if (this.is(FlowFlags.ACCESSES_THIS)) sb.push(\"ACCESSES_THIS\");\n    if (this.is(FlowFlags.CALLS_SUPER)) sb.push(\"CALLS_SUPER\");\n    if (this.is(FlowFlags.TERMINATES)) sb.push(\"TERMINATES\");\n    if (this.is(FlowFlags.CONDITIONALLY_RETURNS)) sb.push(\"CONDITIONALLY_RETURNS\");\n    if (this.is(FlowFlags.CONDITIONALLY_THROWS)) sb.push(\"CONDITIONALLY_THROWS\");\n    if (this.is(FlowFlags.CONDITIONALLY_BREAKS)) sb.push(\"CONDITIONALLY_BREAKS\");\n    if (this.is(FlowFlags.CONDITIONALLY_CONTINUES)) sb.push(\"CONDITIONALLY_CONTINUES\");\n    if (this.is(FlowFlags.CONDITIONALLY_ACCESSES_THIS)) sb.push(\"CONDITIONALLY_ACCESSES_THIS\");\n    if (this.is(FlowFlags.MAY_RETURN_NONTHIS)) sb.push(\"MAY_RETURN_NONTHIS\");\n    return \"Flow(\" + this.actualFunction.toString() + \")[\" + levels.toString() + \"] \" + sb.join(\" \");\n  }\n}\n\n/** Tests if a conversion from one type to another can technically overflow. */\nfunction canConversionOverflow(fromType: Type, toType: Type): bool {\n  return toType.isShortIntegerValue && (\n    !fromType.isIntegerValue ||                                    // i.e. float to small int\n    fromType.size > toType.size ||                                 // larger int to small int\n    fromType.isSignedIntegerValue != toType.isSignedIntegerValue   // signedness mismatch\n  );\n}\n\n/** Finds all indexes of locals used in the specified expression. */\nexport function findUsedLocals(expr: ExpressionRef, used: Set<i32> = new Set<i32>()): Set<i32> {\n  traverse(expr, used, findUsedLocalsVisit);\n  return used;\n}\n\n/** A visitor function for use with `traverse` that finds all indexes of used locals. */\nfunction findUsedLocalsVisit(expr: ExpressionRef, used: Set<i32>): void {\n  switch (getExpressionId(expr)) {\n    case ExpressionId.LocalGet: {\n      used.add(getLocalGetIndex(expr));\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      used.add(getLocalSetIndex(expr));\n      // fall-through for value\n    }\n    default: traverse(expr, used, findUsedLocalsVisit);\n  }\n}\n","/**\n * @fileoverview JavaScript glue code.\n * @license Apache-2.0\n */\n\nimport \"../../../std/portable/index\";\nimport \"../binaryen\";\nimport \"./float\";\nimport \"./i64\";\nimport \"./collections\";\n","/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The C-like and re-exported public compiler interface.\n *\n * The intended way to consume the compiler sources is to import this\n * file, which again exports all relevant functions, classes and constants\n * as a flat namespace.\n *\n * Note though that the compiler sources are written in \"portable\n * AssemblyScript\" that can be compiled to both JavaScript with tsc and\n * to WebAssembly with asc, and as such require additional glue code\n * depending on the target.\n *\n * When compiling to JavaScript `glue/js/index.js` must be included.\n * When compiling to WebAssembly `glue/wasm/index.ts` must be included.\n */\n\nimport { Target, Feature } from \"./common\";\nimport { Compiler, Options } from \"./compiler\";\nimport { IDLBuilder, TSDBuilder } from \"./definitions\";\nimport { DiagnosticMessage, DiagnosticCategory, formatDiagnosticMessage } from \"./diagnostics\";\nimport { Module } from \"./module\";\nimport { Program } from \"./program\";\n\n// Options\n\n/** Creates a new set of compiler options. */\nexport function newOptions(): Options {\n  return new Options();\n}\n\n/** Sets the `target` option. */\nexport function setTarget(options: Options, target: Target): void {\n  options.target = target;\n}\n\n/** Sets the `noAssert` option. */\nexport function setNoAssert(options: Options, noAssert: bool): void {\n  options.noAssert = noAssert;\n}\n\n/** Sets the `exportMemory` option. */\nexport function setExportMemory(options: Options, exportMemory: bool): void {\n  options.exportMemory = exportMemory;\n}\n\n/** Sets the `importMemory` option. */\nexport function setImportMemory(options: Options, importMemory: bool): void {\n  options.importMemory = importMemory;\n}\n\n/** Sets the `initialMemory` option. */\nexport function setInitialMemory(options: Options, initialMemory: u32): void {\n  options.initialMemory = initialMemory;\n}\n\n/** Sets the `maximumMemory` option. */\nexport function setMaximumMemory(options: Options, maximumMemory: u32): void {\n  options.maximumMemory = maximumMemory;\n}\n\n/** Sets the `sharedMemory` option. */\nexport function setSharedMemory(options: Options, sharedMemory: bool): void {\n  options.sharedMemory = sharedMemory;\n}\n\n/** Sets the `importTable` option. */\nexport function setImportTable(options: Options, importTable: bool): void {\n  options.importTable = importTable;\n}\n\n/** Sets the `exportTable` option. */\nexport function setExportTable(options: Options, exportTable: bool): void {\n  options.exportTable = exportTable;\n}\n\n/** Sets the `sourceMap` option. */\nexport function setSourceMap(options: Options, sourceMap: bool): void {\n  options.sourceMap = sourceMap;\n}\n\n/** Sets the `memoryBase` option. */\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\n  options.memoryBase = memoryBase;\n}\n\n/** Sets the `tableBase` option. */\nexport function setTableBase(options: Options, tableBase: u32): void {\n  options.tableBase = tableBase;\n}\n\n/** Sets a 'globalAliases' value. */\nexport function setGlobalAlias(options: Options, alias: string, name: string): void {\n  var globalAliases = options.globalAliases;\n  if (!globalAliases) options.globalAliases = globalAliases = new Map();\n  globalAliases.set(alias, name);\n}\n\n/** Sets the `explicitStart` option. */\nexport function setExplicitStart(options: Options, explicitStart: bool): void {\n  options.explicitStart = explicitStart;\n}\n\n/** Sets the `noUnsafe` option. */\nexport function setNoUnsafe(options: Options, noUnsafe: bool): void {\n  options.noUnsafe = noUnsafe;\n}\n\n/** Sets the `lowMemoryLimit` option. */\nexport function setLowMemoryLimit(options: Options, lowMemoryLimit: i32): void {\n  options.lowMemoryLimit = lowMemoryLimit;\n}\n\n/** Sign extension operations. */\nexport const FEATURE_SIGN_EXTENSION = Feature.SIGN_EXTENSION;\n/** Mutable global imports and exports. */\nexport const FEATURE_MUTABLE_GLOBALS = Feature.MUTABLE_GLOBALS;\n/** Non-trapping float to int conversion operations. */\nexport const FEATURE_NONTRAPPING_F2I = Feature.NONTRAPPING_F2I;\n/** Bulk memory operations. */\nexport const FEATURE_BULK_MEMORY = Feature.BULK_MEMORY;\n/** SIMD types and operations. */\nexport const FEATURE_SIMD = Feature.SIMD;\n/** Threading and atomic operations. */\nexport const FEATURE_THREADS = Feature.THREADS;\n/** Exception handling operations. */\nexport const FEATURE_EXCEPTION_HANDLING = Feature.EXCEPTION_HANDLING;\n/** Tail call operations. */\nexport const FEATURE_TAIL_CALLS = Feature.TAIL_CALLS;\n/** Reference types. */\nexport const FEATURE_REFERENCE_TYPES = Feature.REFERENCE_TYPES;\n/** Multi value types. */\nexport const FEATURE_MULTI_VALUE = Feature.MULTI_VALUE;\n/** Garbage collection. */\nexport const FEATURE_GC = Feature.GC;\n/** Memory64. */\nexport const FEATURE_MEMORY64 = Feature.MEMORY64;\n\n/** Enables a specific feature. */\nexport function enableFeature(options: Options, feature: Feature): void {\n  options.features |= feature;\n}\n\n/** Disables a specific feature. */\nexport function disableFeature(options: Options, feature: Feature): void {\n  options.features &= ~feature;\n}\n\n/** Gives the compiler a hint at the optimize levels that will be used later on. */\nexport function setOptimizeLevelHints(options: Options, optimizeLevel: i32, shrinkLevel: i32): void {\n  options.optimizeLevelHint = optimizeLevel;\n  options.shrinkLevelHint = shrinkLevel;\n}\n\n/** Sets the `pedantic` option. */\nexport function setPedantic(options: Options, pedantic: bool): void {\n  options.pedantic = pedantic;\n}\n\n// Program\n\n/** Creates a new Program. */\nexport function newProgram(options: Options): Program {\n  return new Program(options);\n}\n\n/** Obtains the next diagnostic message. Returns `null` once complete. */\nexport function nextDiagnostic(program: Program): DiagnosticMessage | null {\n  return program.diagnosticsOffset < program.diagnostics.length\n    ? program.diagnostics[program.diagnosticsOffset++]\n    : null;\n}\n\n/** Obtains the source of the given file. */\nexport function getSource(program: Program, internalPath: string): string | null {\n  return program.getSource(internalPath);\n}\n\n/** Formats a diagnostic message to a string. */\nexport { formatDiagnosticMessage as formatDiagnostic };\n\n/** Tests whether a diagnostic is informatory. */\nexport function isInfo(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.INFO;\n}\n\n/** Tests whether a diagnostic is a warning. */\nexport function isWarning(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.WARNING;\n}\n\n/** Tests whether a diagnostic is an error. */\nexport function isError(message: DiagnosticMessage): bool {\n  return message.category == DiagnosticCategory.ERROR;\n}\n\n// Parser\n\n/** Parses a source file. If `parser` has been omitted a new one is created. */\nexport function parse(\n  /** Program reference. */\n  program: Program,\n  /** Source text of the file, or `null` to indicate not found. */\n  text: string | null,\n  /** Normalized path of the file. */\n  path: string,\n  /** Whether this is an entry file. */\n  isEntry: bool = false\n): void {\n  program.parser.parseFile(text, path, isEntry);\n}\n\n/** Obtains the next required file's path. Returns `null` once complete. */\nexport function nextFile(program: Program): string | null {\n  return program.parser.nextFile();\n}\n\n/** Obtains the path of the dependee of a given imported file. */\nexport function getDependee(program: Program, file: string): string | null {\n  return program.parser.getDependee(file);\n}\n\n// Compiler\n\n/** Initializes the program pre-emptively for transform hooks. */\nexport function initializeProgram(program: Program): void {\n  program.initialize();\n}\n\n/** Compiles the parsed sources to a module. */\nexport function compile(program: Program): Module {\n  program.parser.finish();\n  return new Compiler(program).compile();\n}\n\n/** Builds WebIDL definitions for the specified program. */\nexport function buildIDL(program: Program): string {\n  return IDLBuilder.build(program);\n}\n\n/** Builds TypeScript definitions for the specified program. */\nexport function buildTSD(program: Program): string {\n  return TSDBuilder.build(program);\n}\n\n// Full API\nexport * from \"./ast\";\nexport * from \"./common\";\nexport * from \"./compiler\";\nexport * from \"./definitions\";\nexport * from \"./diagnostics\";\nexport * from \"./flow\";\nexport * from \"./module\";\nexport * from \"./parser\";\nexport * from \"./program\";\nexport * from \"./resolver\";\nexport * from \"./tokenizer\";\nexport * from \"./types\";\nexport * from \"./ext/abi\"\n// TODO: When vTables are pulled, perhaps it would be better to extend an ASTWalker\nexport * from \"./extra/ast\";\nimport * as util from \"./util/index\";\nexport { util };\n\n// TODO: compat with 0.9, remove with 0.10\nexport * from \"./util/index\";\n","/**\n * @fileoverview A thin wrapper around Binaryen's C-API.\n *\n * The AssemblyScript compiler utilizes Binaryen's C-API directly. Even\n * though it currently imports binaryen.js, none of the JS APIs it\n * provides are used.\n *\n * @license Apache-2.0\n */\n\nimport { Target } from \"./common\";\nimport * as binaryen from \"./glue/binaryen\";\n\nexport type ModuleRef = usize;\nexport type FunctionRef = usize;\nexport type ExpressionRef = usize;\nexport type GlobalRef = usize;\nexport type EventRef = usize;\nexport type ImportRef = usize;\nexport type ExportRef = usize;\nexport type RelooperRef = usize;\nexport type RelooperBlockRef = usize;\nexport type Index = u32;\n\n// The following constants must be updated by running scripts/update-constants.\n// This is necessary because the functions are not yet callable with Binaryen\n// compiled to WebAssembly, requiring awaiting the ready promise first. Note\n// that this essentially fixes the compiler to specific versions of Binaryen\n// sometimes, because these constants can differ between Binaryen versions.\n\nexport type NativeType = usize;\nexport namespace NativeType {\n  export const None: NativeType = 0 /* _BinaryenTypeNone */;\n  export const Unreachable: NativeType = 1 /* _BinaryenTypeUnreachable */;\n  export const I32: NativeType = 2 /* _BinaryenTypeInt32 */;\n  export const I64: NativeType = 3 /* _BinaryenTypeInt64 */;\n  export const F32: NativeType = 4 /* _BinaryenTypeFloat32 */;\n  export const F64: NativeType = 5 /* _BinaryenTypeFloat64 */;\n  export const V128: NativeType = 6 /* _BinaryenTypeVec128 */;\n  export const Funcref: NativeType = 7 /* _BinaryenTypeFuncref */;\n  export const Externref: NativeType = 8 /* _BinaryenTypeExternref */;\n  export const Exnref: NativeType = 9 /* _BinaryenTypeExnref */;\n  export const Anyref: NativeType = 10 /* _BinaryenTypeAnyref */;\n  export const Auto: NativeType = -1 /* _BinaryenTypeAuto */;\n}\n\nexport enum FeatureFlags {\n  MVP = 0 /* _BinaryenFeatureMVP */,\n  Atomics = 1 /* _BinaryenFeatureAtomics */,\n  MutableGloabls = 2 /* _BinaryenFeatureMutableGlobals */,\n  NontrappingFPToInt = 4 /* _BinaryenFeatureNontrappingFPToInt */,\n  SIMD128 = 8 /* _BinaryenFeatureSIMD128 */,\n  BulkMemory = 16 /* _BinaryenFeatureBulkMemory */,\n  SignExt = 32 /* _BinaryenFeatureSignExt */,\n  ExceptionHandling = 64 /* _BinaryenFeatureExceptionHandling */,\n  TailCall = 128 /* _BinaryenFeatureTailCall */,\n  ReferenceTypes = 256 /* _BinaryenFeatureReferenceTypes */,\n  MultiValue = 512 /* _BinaryenFeatureMultivalue */,\n  GC = 1024 /* _BinaryenFeatureGC */,\n  Memory64 = 2048, // TODO: missing in Binaryen API\n  All = 4095 /* _BinaryenFeatureAll */\n}\n\nexport enum ExpressionId {\n  Invalid = 0 /* _BinaryenInvalidId */,\n  Block = 1 /* _BinaryenBlockId */,\n  If = 2 /* _BinaryenIfId */,\n  Loop = 3 /* _BinaryenLoopId */,\n  Break = 4 /* _BinaryenBreakId */,\n  Switch = 5 /* _BinaryenSwitchId */,\n  Call = 6 /* _BinaryenCallId */,\n  CallIndirect = 7 /* _BinaryenCallIndirectId */,\n  LocalGet = 8 /* _BinaryenLocalGetId */,\n  LocalSet = 9 /* _BinaryenLocalSetId */,\n  GlobalGet = 10 /* _BinaryenGlobalGetId */,\n  GlobalSet = 11 /* _BinaryenGlobalSetId */,\n  Load = 12 /* _BinaryenLoadId */,\n  Store = 13 /* _BinaryenStoreId */,\n  Const = 14 /* _BinaryenConstId */,\n  Unary = 15 /* _BinaryenUnaryId */,\n  Binary = 16 /* _BinaryenBinaryId */,\n  Select = 17 /* _BinaryenSelectId */,\n  Drop = 18 /* _BinaryenDropId */,\n  Return = 19 /* _BinaryenReturnId */,\n  MemorySize = 20 /* _BinaryenMemorySizeId */,\n  MemoryGrow = 21 /* _BinaryenMemoryGrowId */,\n  Nop = 22 /* _BinaryenNopId */,\n  Unreachable = 23 /* _BinaryenUnreachableId */,\n  AtomicRMW = 24 /* _BinaryenAtomicRMWId */,\n  AtomicCmpxchg = 25 /* _BinaryenAtomicCmpxchgId */,\n  AtomicWait = 26 /* _BinaryenAtomicWaitId */,\n  AtomicNotify = 27 /* _BinaryenAtomicNotifyId */,\n  AtomicFence = 28 /* _BinaryenAtomicFenceId */,\n  SIMDExtract = 29 /* _BinaryenSIMDExtractId */,\n  SIMDReplace = 30 /* _BinaryenSIMDReplaceId */,\n  SIMDShuffle = 31 /* _BinaryenSIMDShuffleId */,\n  SIMDTernary = 32 /* _BinaryenSIMDTernaryId */,\n  SIMDShift = 33 /* _BinaryenSIMDShiftId */,\n  SIMDLoad = 34 /* _BinaryenSIMDLoadId */,\n  // SIMDLoadStoreLane = 35,\n  MemoryInit = 36 /* _BinaryenMemoryInitId */,\n  DataDrop = 37 /* _BinaryenDataDropId */,\n  MemoryCopy = 38 /* _BinaryenMemoryCopyId */,\n  MemoryFill = 39 /* _BinaryenMemoryFillId */,\n  Pop = 40 /* _BinaryenPopId */,\n  RefNull = 41 /* _BinaryenRefNullId */,\n  RefIsNull = 42 /* _BinaryenRefIsNullId */,\n  RefFunc = 43 /* _BinaryenRefFuncId */,\n  RefEq = 44 /* _BinaryenRefEqId */,\n  Try = 45 /* _BinaryenTryId */,\n  Throw = 46 /* _BinaryenThrowId */,\n  Rethrow = 47 /* _BinaryenRethrowId */,\n  BrOnExn = 48 /* _BinaryenBrOnExnId */,\n  TupleMake = 49 /* _BinaryenTupleMakeId */,\n  TupleExtract = 50 /* _BinaryenTupleExtractId */\n}\n\nexport enum UnaryOp {\n  ClzI32 = 0 /* _BinaryenClzInt32 */,\n  ClzI64 = 1 /* _BinaryenClzInt64 */,\n  CtzI32 = 2 /* _BinaryenCtzInt32 */,\n  CtzI64 = 3 /* _BinaryenCtzInt64 */,\n  PopcntI32 = 4 /* _BinaryenPopcntInt32 */,\n  PopcntI64 = 5 /* _BinaryenPopcntInt64 */,\n  NegF32 = 6 /* _BinaryenNegFloat32 */,\n  NegF64 = 7 /* _BinaryenNegFloat64 */,\n  AbsF32 = 8 /* _BinaryenAbsFloat32 */,\n  AbsF64 = 9 /* _BinaryenAbsFloat64 */,\n  CeilF32 = 10 /* _BinaryenCeilFloat32 */,\n  CeilF64 = 11 /* _BinaryenCeilFloat64 */,\n  FloorF32 = 12 /* _BinaryenFloorFloat32 */,\n  FloorF64 = 13 /* _BinaryenFloorFloat64 */,\n  TruncF32 = 14 /* _BinaryenTruncFloat32 */,\n  TruncF64 = 15 /* _BinaryenTruncFloat64 */,\n  NearestF32 = 16 /* _BinaryenNearestFloat32 */,\n  NearestF64 = 17 /* _BinaryenNearestFloat64 */,\n  SqrtF32 = 18 /* _BinaryenSqrtFloat32 */,\n  SqrtF64 = 19 /* _BinaryenSqrtFloat64 */,\n  EqzI32 = 20 /* _BinaryenEqZInt32 */,\n  EqzI64 = 21 /* _BinaryenEqZInt64 */,\n  ExtendI32 = 22 /* _BinaryenExtendSInt32 */,\n  ExtendU32 = 23 /* _BinaryenExtendUInt32 */,\n  WrapI64 = 24 /* _BinaryenWrapInt64 */,\n  TruncF32ToI32 = 25 /* _BinaryenTruncSFloat32ToInt32 */,\n  TruncF32ToI64 = 26 /* _BinaryenTruncSFloat32ToInt64 */,\n  TruncF32ToU32 = 27 /* _BinaryenTruncUFloat32ToInt32 */,\n  TruncF32ToU64 = 28 /* _BinaryenTruncUFloat32ToInt64 */,\n  TruncF64ToI32 = 29 /* _BinaryenTruncSFloat64ToInt32 */,\n  TruncF64ToI64 = 30 /* _BinaryenTruncSFloat64ToInt64 */,\n  TruncF64ToU32 = 31 /* _BinaryenTruncUFloat64ToInt32 */,\n  TruncF64ToU64 = 32 /* _BinaryenTruncUFloat64ToInt64 */,\n  ReinterpretF32 = 33 /* _BinaryenReinterpretFloat32 */,\n  ReinterpretF64 = 34 /* _BinaryenReinterpretFloat64 */,\n  ConvertI32ToF32 = 35 /* _BinaryenConvertSInt32ToFloat32 */,\n  ConvertI32ToF64 = 36 /* _BinaryenConvertSInt32ToFloat64 */,\n  ConvertU32ToF32 = 37 /* _BinaryenConvertUInt32ToFloat32 */,\n  ConvertU32ToF64 = 38 /* _BinaryenConvertUInt32ToFloat64 */,\n  ConvertI64ToF32 = 39 /* _BinaryenConvertSInt64ToFloat32 */,\n  ConvertI64ToF64 = 40 /* _BinaryenConvertSInt64ToFloat64 */,\n  ConvertU64ToF32 = 41 /* _BinaryenConvertUInt64ToFloat32 */,\n  ConvertU64ToF64 = 42 /* _BinaryenConvertUInt64ToFloat64 */,\n  PromoteF32 = 43 /* _BinaryenPromoteFloat32 */,\n  DemoteF64 = 44 /* _BinaryenDemoteFloat64 */,\n  ReinterpretI32 = 45 /* _BinaryenReinterpretInt32 */,\n  ReinterpretI64 = 46 /* _BinaryenReinterpretInt64 */,\n\n  // see: https://github.com/WebAssembly/sign-extension-ops\n  ExtendI8ToI32 = 47 /* _BinaryenExtendS8Int32 */,\n  ExtendI16ToI32 = 48 /* _BinaryenExtendS16Int32 */,\n  ExtendI8ToI64 = 49 /* _BinaryenExtendS8Int64 */,\n  ExtendI16ToI64 = 50 /* _BinaryenExtendS16Int64 */,\n  ExtendI32ToI64 = 51 /* _BinaryenExtendS32Int64 */,\n\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  TruncF32ToI32Sat = 52 /* _BinaryenTruncSatSFloat32ToInt32 */,\n  TruncF32ToU32Sat = 53 /* _BinaryenTruncSatUFloat32ToInt32 */,\n  TruncF64ToI32Sat = 54 /* _BinaryenTruncSatSFloat64ToInt32 */,\n  TruncF64ToU32Sat = 55 /* _BinaryenTruncSatUFloat64ToInt32 */,\n  TruncF32ToI64Sat = 56 /* _BinaryenTruncSatSFloat32ToInt64 */,\n  TruncF32ToU64Sat = 57 /* _BinaryenTruncSatUFloat32ToInt64 */,\n  TruncF64ToI64Sat = 58 /* _BinaryenTruncSatSFloat64ToInt64 */,\n  TruncF64ToU64Sat = 59 /* _BinaryenTruncSatUFloat64ToInt64 */,\n\n  // see: https://github.com/WebAssembly/simd\n  SplatI8x16 = 60 /* _BinaryenSplatVecI8x16 */,\n  SplatI16x8 = 61 /* _BinaryenSplatVecI16x8 */,\n  SplatI32x4 = 62 /* _BinaryenSplatVecI32x4 */,\n  SplatI64x2 = 63 /* _BinaryenSplatVecI64x2 */,\n  SplatF32x4 = 64 /* _BinaryenSplatVecF32x4 */,\n  SplatF64x2 = 65 /* _BinaryenSplatVecF64x2 */,\n  NotV128 = 66 /* _BinaryenNotVec128 */,\n  AbsI8x16 = 67 /* __BinaryenAbsVecI8x16 */,\n  NegI8x16 = 68 /* _BinaryenNegVecI8x16 */,\n  AnyTrueI8x16 = 69 /* _BinaryenAnyTrueVecI8x16 */,\n  AllTrueI8x16 = 70 /* _BinaryenAllTrueVecI8x16 */,\n  BitmaskI8x16 = 71 /* __BinaryenBitmaskVecI8x16 */,\n  AbsI16x8 = 72 /* __BinaryenAbsVecI16x8 */,\n  // PopcntVecI8x16\n  NegI16x8 = 74 /* _BinaryenNegVecI16x8 */,\n  AnyTrueI16x8 = 75 /* _BinaryenAnyTrueVecI16x8 */,\n  AllTrueI16x8 = 76 /* _BinaryenAllTrueVecI16x8 */,\n  BitmaskI16x8 = 77 /* _BinaryenBitmaskVecI16x8 */,\n  AbsI32x4 = 78 /* _BinaryenAbsVecI32x4 */,\n  NegI32x4 = 79 /* _BinaryenNegVecI32x4 */,\n  AnyTrueI32x4 = 80 /* _BinaryenAnyTrueVecI32x4 */,\n  AllTrueI32x4 = 81 /* _BinaryenAllTrueVecI32x4 */,\n  BitmaskI32x4 = 82 /* _BinaryenBitmaskVecI32x4 */,\n  NegI64x2 = 83 /* _BinaryenNegVecI64x2 */,\n  AnyTrueI64x2 = 84 /* _BinaryenAnyTrueVecI64x2 */,\n  AllTrueI64x2 = 85 /* _BinaryenAllTrueVecI64x2 */,\n  AbsF32x4 = 86 /* _BinaryenAbsVecF32x4 */,\n  NegF32x4 = 87 /* _BinaryenNegVecF32x4 */,\n  SqrtF32x4 = 88 /* _BinaryenSqrtVecF32x4 */,\n  CeilF32x4 = 89 /* _BinaryenCeilVecF32x4 */,\n  FloorF32x4 = 90 /* _BinaryenFloorVecF32x4 */,\n  TruncF32x4 = 90 /* BinaryenTruncVecF32x4 */,\n  NearestF32x4 = 91 /* BinaryenNearestVecF32x4 */,\n  AbsF64x2 = 93 /* _BinaryenAbsVecF64x2 */,\n  NegF64x2 = 94 /* _BinaryenNegVecF64x2 */,\n  SqrtF64x2 = 95 /* _BinaryenSqrtVecF64x2 */,\n  CeilF64x2 = 96 /* _BinaryenCeilVecF64x2 */,\n  FloorF64x2 = 97 /* _BinaryenFloorVecF64x2 */,\n  TruncF64x2 = 97 /* BinaryenTruncVecF64x2 */,\n  NearestF64x2 = 98 /* BinaryenNearestVecF64x2 */,\n  TruncSatF32x4ToI32x4 = 100 /* _BinaryenTruncSatSVecF32x4ToVecI32x4 */,\n  TruncSatF32x4ToU32x4 = 101 /* _BinaryenTruncSatUVecF32x4ToVecI32x4 */,\n  TruncSatF64x2ToI64x2 = 102 /* _BinaryenTruncSatSVecF64x2ToVecI64x2 */,\n  TruncSatF64x2ToU64x2 = 103 /* _BinaryenTruncSatUVecF64x2ToVecI64x2 */,\n  ConvertI32x4ToF32x4 = 104 /* _BinaryenConvertSVecI32x4ToVecF32x4 */,\n  ConvertU32x4ToF32x4 = 105 /* _BinaryenConvertUVecI32x4ToVecF32x4 */,\n  ConvertI64x2ToF64x2 = 106 /* _BinaryenConvertSVecI64x2ToVecF64x2 */,\n  ConvertU64x2ToF64x2 = 107 /* _BinaryenConvertUVecI64x2ToVecF64x2 */,\n  WidenLowI8x16ToI16x8 = 108 /* _BinaryenWidenLowSVecI8x16ToVecI16x8 */,\n  WidenHighI8x16ToI16x8 = 109 /* _BinaryenWidenHighSVecI8x16ToVecI16x8 */,\n  WidenLowU8x16ToU16x8 = 110 /* _BinaryenWidenLowUVecI8x16ToVecI16x8 */,\n  WidenHighU8x16ToU16x8 = 111 /* _BinaryenWidenHighUVecI8x16ToVecI16x8 */,\n  WidenLowI16x8ToI32x4 = 112 /* _BinaryenWidenLowSVecI16x8ToVecI32x4 */,\n  WidenHighI16x8ToI32x4 = 113 /* _BinaryenWidenHighSVecI16x8ToVecI32x4 */,\n  WidenLowU16x8ToU32x4 = 114 /* _BinaryenWidenLowUVecI16x8ToVecI32x4 */,\n  WidenHighU16x8ToU32x4 = 115 /* _BinaryenWidenHighUVecI16x8ToVecI32x4 */\n}\n\nexport enum BinaryOp {\n  AddI32 = 0 /* _BinaryenAddInt32 */,\n  SubI32 = 1 /* _BinaryenSubInt32 */,\n  MulI32 = 2 /* _BinaryenMulInt32 */,\n  DivI32 = 3 /* _BinaryenDivSInt32 */,\n  DivU32 = 4 /* _BinaryenDivUInt32 */,\n  RemI32 = 5 /* _BinaryenRemSInt32 */,\n  RemU32 = 6 /* _BinaryenRemUInt32 */,\n  AndI32 = 7 /* _BinaryenAndInt32 */,\n  OrI32 = 8 /* _BinaryenOrInt32 */,\n  XorI32 = 9 /* _BinaryenXorInt32 */,\n  ShlI32 = 10 /* _BinaryenShlInt32 */,\n  ShrI32 = 11 /* _BinaryenShrSInt32 */,\n  ShrU32 = 12 /* _BinaryenShrUInt32 */,\n  RotlI32 = 13 /* _BinaryenRotLInt32 */,\n  RotrI32 = 14 /* _BinaryenRotRInt32 */,\n  EqI32 = 15 /* _BinaryenEqInt32 */,\n  NeI32 = 16 /* _BinaryenNeInt32 */,\n  LtI32 = 17 /* _BinaryenLtSInt32 */,\n  LtU32 = 18 /* _BinaryenLtUInt32 */,\n  LeI32 = 19 /* _BinaryenLeSInt32 */,\n  LeU32 = 20 /* _BinaryenLeUInt32 */,\n  GtI32 = 21 /* _BinaryenGtSInt32 */,\n  GtU32 = 22 /* _BinaryenGtUInt32 */,\n  GeI32 = 23 /* _BinaryenGeSInt32 */,\n  GeU32 = 24 /* _BinaryenGeUInt32 */,\n  AddI64 = 25 /* _BinaryenAddInt64 */,\n  SubI64 = 26 /* _BinaryenSubInt64 */,\n  MulI64 = 27 /* _BinaryenMulInt64 */,\n  DivI64 = 28 /* _BinaryenDivSInt64 */,\n  DivU64 = 29 /* _BinaryenDivUInt64 */,\n  RemI64 = 30 /* _BinaryenRemSInt64 */,\n  RemU64 = 31 /* _BinaryenRemUInt64 */,\n  AndI64 = 32 /* _BinaryenAndInt64 */,\n  OrI64 = 33 /* _BinaryenOrInt64 */,\n  XorI64 = 34 /* _BinaryenXorInt64 */,\n  ShlI64 = 35 /* _BinaryenShlInt64 */,\n  ShrI64 = 36 /* _BinaryenShrSInt64 */,\n  ShrU64 = 37 /* _BinaryenShrUInt64 */,\n  RotlI64 = 38 /* _BinaryenRotLInt64 */,\n  RotrI64 = 39 /* _BinaryenRotRInt64 */,\n  EqI64 = 40 /* _BinaryenEqInt64 */,\n  NeI64 = 41 /* _BinaryenNeInt64 */,\n  LtI64 = 42 /* _BinaryenLtSInt64 */,\n  LtU64 = 43 /* _BinaryenLtUInt64 */,\n  LeI64 = 44 /* _BinaryenLeSInt64 */,\n  LeU64 = 45 /* _BinaryenLeUInt64 */,\n  GtI64 = 46 /* _BinaryenGtSInt64 */,\n  GtU64 = 47 /* _BinaryenGtUInt64 */,\n  GeI64 = 48 /* _BinaryenGeSInt64 */,\n  GeU64 = 49 /* _BinaryenGeUInt64 */,\n  AddF32 = 50 /* _BinaryenAddFloat32 */,\n  SubF32 = 51 /* _BinaryenSubFloat32 */,\n  MulF32 = 52 /* _BinaryenMulFloat32 */,\n  DivF32 = 53 /* _BinaryenDivFloat32 */,\n  CopysignF32 = 54 /* _BinaryenCopySignFloat32 */,\n  MinF32 = 55 /* _BinaryenMinFloat32 */,\n  MaxF32 = 56 /* _BinaryenMaxFloat32 */,\n  EqF32 = 57 /* _BinaryenEqFloat32 */,\n  NeF32 = 58 /* _BinaryenNeFloat32 */,\n  LtF32 = 59 /* _BinaryenLtFloat32 */,\n  LeF32 = 60 /* _BinaryenLeFloat32 */,\n  GtF32 = 61 /* _BinaryenGtFloat32 */,\n  GeF32 = 62 /* _BinaryenGeFloat32 */,\n  AddF64 = 63 /* _BinaryenAddFloat64 */,\n  SubF64 = 64 /* _BinaryenSubFloat64 */,\n  MulF64 = 65 /* _BinaryenMulFloat64 */,\n  DivF64 = 66 /* _BinaryenDivFloat64 */,\n  CopysignF64 = 67 /* _BinaryenCopySignFloat64 */,\n  MinF64 = 68 /* _BinaryenMinFloat64 */,\n  MaxF64 = 69 /* _BinaryenMaxFloat64 */,\n  EqF64 = 70 /* _BinaryenEqFloat64 */,\n  NeF64 = 71 /* _BinaryenNeFloat64 */,\n  LtF64 = 72 /* _BinaryenLtFloat64 */,\n  LeF64 = 73 /* _BinaryenLeFloat64 */,\n  GtF64 = 74 /* _BinaryenGtFloat64 */,\n  GeF64 = 75 /* _BinaryenGeFloat64 */,\n\n  // see: https://github.com/WebAssembly/simd\n  EqI8x16 = 76 /* _BinaryenEqVecI8x16 */,\n  NeI8x16 = 77 /* _BinaryenNeVecI8x16 */,\n  LtI8x16 = 78 /* _BinaryenLtSVecI8x16 */,\n  LtU8x16 = 79 /* _BinaryenLtUVecI8x16 */,\n  GtI8x16 = 80 /* _BinaryenGtSVecI8x16 */,\n  GtU8x16 = 81 /* _BinaryenGtUVecI8x16 */,\n  LeI8x16 = 82 /* _BinaryenLeSVecI8x16 */,\n  LeU8x16 = 83 /* _BinaryenLeUVecI8x16 */,\n  GeI8x16 = 84 /* _BinaryenGeSVecI8x16 */,\n  GeU8x16 = 85 /* _BinaryenGeUVecI8x16 */,\n  EqI16x8 = 86 /* _BinaryenEqVecI16x8 */,\n  NeI16x8 = 87 /* _BinaryenNeVecI16x8 */,\n  LtI16x8 = 88 /* _BinaryenLtSVecI16x8 */,\n  LtU16x8 = 89 /* _BinaryenLtUVecI16x8 */,\n  GtI16x8 = 90 /* _BinaryenGtSVecI16x8 */,\n  GtU16x8 = 91 /* _BinaryenGtUVecI16x8 */,\n  LeI16x8 = 92 /* _BinaryenLeSVecI16x8 */,\n  LeU16x8 = 93 /* _BinaryenLeUVecI16x8 */,\n  GeI16x8 = 94 /* _BinaryenGeSVecI16x8 */,\n  GeU16x8 = 95 /* _BinaryenGeUVecI16x8 */,\n  EqI32x4 = 96 /* _BinaryenEqVecI32x4 */,\n  NeI32x4 = 97 /* _BinaryenNeVecI32x4 */,\n  LtI32x4 = 98 /* _BinaryenLtSVecI32x4 */,\n  LtU32x4 = 99 /* _BinaryenLtUVecI32x4 */,\n  GtI32x4 = 100 /* _BinaryenGtSVecI32x4 */,\n  GtU32x4 = 101 /* _BinaryenGtUVecI32x4 */,\n  LeI32x4 = 102 /* _BinaryenLeSVecI32x4 */,\n  LeU32x4 = 103 /* _BinaryenLeUVecI32x4 */,\n  GeI32x4 = 104 /* _BinaryenGeSVecI32x4 */,\n  GeU32x4 = 105 /* _BinaryenGeUVecI32x4 */,\n  EqF32x4 = 106 /* _BinaryenEqVecF32x4 */,\n  NeF32x4 = 107 /* _BinaryenNeVecF32x4 */,\n  LtF32x4 = 108 /* _BinaryenLtVecF32x4 */,\n  GtF32x4 = 109 /* _BinaryenGtVecF32x4 */,\n  LeF32x4 = 110 /* _BinaryenLeVecF32x4 */,\n  GeF32x4 = 111 /* _BinaryenGeVecF32x4 */,\n  EqF64x2 = 112 /* _BinaryenEqVecF64x2 */,\n  NeF64x2 = 113 /* _BinaryenNeVecF64x2 */,\n  LtF64x2 = 114 /* _BinaryenLtVecF64x2 */,\n  GtF64x2 = 115 /* _BinaryenGtVecF64x2 */,\n  LeF64x2 = 116 /* _BinaryenLeVecF64x2 */,\n  GeF64x2 = 117 /* _BinaryenGeVecF64x2 */,\n  AndV128 = 118 /* _BinaryenAndVec128 */,\n  OrV128 = 119 /* _BinaryenOrVec128 */,\n  XorV128 = 120 /* _BinaryenXorVec128 */,\n  AndNotV128 = 121 /* _BinaryenAndNotVec128 */,\n  AddI8x16 = 122 /* _BinaryenAddVecI8x16 */,\n  AddSatI8x16 = 123 /* _BinaryenAddSatSVecI8x16 */,\n  AddSatU8x16 = 124 /* _BinaryenAddSatUVecI8x16 */,\n  SubI8x16 = 125 /* _BinaryenSubVecI8x16 */,\n  SubSatI8x16 = 126 /* _BinaryenSubSatSVecI8x16 */,\n  SubSatU8x16 = 127 /* _BinaryenSubSatUVecI8x16 */,\n  MulI8x16 = 128 /* _BinaryenMulVecI8x16 */,\n  MinI8x16 = 129 /* _BinaryenMinSVecI8x16 */,\n  MinU8x16 = 130 /* _BinaryenMinUVecI8x16 */,\n  MaxI8x16 = 131 /* _BinaryenMaxSVecI8x16 */,\n  MaxU8x16 = 132 /* _BinaryenMaxUVecI8x16 */,\n  AvgrU8x16 = 133 /* _BinaryenAvgrUVecI8x16 */,\n  AddI16x8 = 134 /* _BinaryenAddVecI16x8 */,\n  AddSatI16x8 = 135 /* _BinaryenAddSatSVecI16x8 */,\n  AddSatU16x8 = 136 /* _BinaryenAddSatUVecI16x8 */,\n  SubI16x8 = 137 /* _BinaryenSubVecI16x8 */,\n  SubSatI16x8 = 138 /* _BinaryenSubSatSVecI16x8 */,\n  SubSatU16x8 = 139 /* _BinaryenSubSatUVecI16x8 */,\n  MulI16x8 = 140 /* _BinaryenMulVecI16x8 */,\n  MinI16x8 = 141 /* _BinaryenMinSVecI16x8 */,\n  MinU16x8 = 142 /* _BinaryenMinUVecI16x8 */,\n  MaxI16x8 = 143 /* _BinaryenMaxSVecI16x8 */,\n  MaxU16x8 = 144 /* _BinaryenMaxUVecI16x8 */,\n  AvgrU16x8 = 145 /* _BinaryenAvgrUVecI16x8 */,\n  // Q15MulrSatSVecI16x8,\n  // ExtMulLowSVecI16x8,\n  // ExtMulHighSVecI16x8,\n  // ExtMulLowUVecI16x8,\n  // ExtMulHighUVecI16x8,\n  AddI32x4 = 151 /* _BinaryenAddVecI32x4 */,\n  SubI32x4 = 152 /* _BinaryenSubVecI32x4 */,\n  MulI32x4 = 153 /* _BinaryenMulVecI32x4 */,\n  MinI32x4 = 154 /* _BinaryenMinSVecI32x4 */,\n  MinU32x4 = 155 /* _BinaryenMinUVecI32x4 */,\n  MaxI32x4 = 156 /* _BinaryenMaxSVecI32x4 */,\n  MaxU32x4 = 157 /* _BinaryenMaxUVecI32x4 */,\n  DotI16x8 = 158 /* _BinaryenDotSVecI16x8ToVecI32x4 */,\n  AddI64x2 = 163 /* _BinaryenAddVecI64x2 */,\n  SubI64x2 = 164 /* _BinaryenSubVecI64x2 */,\n  // ExtMulLowSVecI64x2\n  // ExtMulHighSVecI64x2\n  // ExtMulLowUVecI64x2\n  // ExtMulHighUVecI64x2\n  AddF32x4 = 170 /* _BinaryenAddVecF32x4 */,\n  SubF32x4 = 171 /* _BinaryenSubVecF32x4 */,\n  MulF32x4 = 172 /* _BinaryenMulVecF32x4 */,\n  DivF32x4 = 173 /* _BinaryenDivVecF32x4 */,\n  MinF32x4 = 174 /* _BinaryenMinVecF32x4 */,\n  MaxF32x4 = 175 /* _BinaryenMaxVecF32x4 */,\n  PminF32x4 = 176 /* _BinaryenPMinVecF32x4 */,\n  PmaxF32x4 = 177 /* _BinaryenPMaxVecF32x4 */,\n  AddF64x2 = 178 /* _BinaryenAddVecF64x2 */,\n  SubF64x2 = 179 /* _BinaryenSubVecF64x2 */,\n  MulF64x2 = 180 /* _BinaryenMulVecF64x2 */,\n  DivF64x2 = 181 /* _BinaryenDivVecF64x2 */,\n  MinF64x2 = 182 /* _BinaryenMinVecF64x2 */,\n  MaxF64x2 = 183 /* _BinaryenMaxVecF64x2 */,\n  PminF64x2 = 184 /* _BinaryenPMinVecF64x2 */,\n  PmaxF64x2 = 185 /* _BinaryenPMaxVecF64x2 */,\n  NarrowI16x8ToI8x16 = 186 /* _BinaryenNarrowSVecI16x8ToVecI8x16 */,\n  NarrowU16x8ToU8x16 = 187 /* _BinaryenNarrowUVecI16x8ToVecI8x16 */,\n  NarrowI32x4ToI16x8 = 188 /* _BinaryenNarrowSVecI32x4ToVecI16x8 */,\n  NarrowU32x4ToU16x8 = 189 /* _BinaryenNarrowUVecI32x4ToVecI16x8 */,\n  SwizzleV8x16 = 190 /* _BinaryenSwizzleVec8x16 */\n}\n\nexport enum AtomicRMWOp {\n  Add = 0 /* _BinaryenAtomicRMWAdd */,\n  Sub = 1 /* _BinaryenAtomicRMWSub */,\n  And = 2 /* _BinaryenAtomicRMWAnd */,\n  Or = 3 /* _BinaryenAtomicRMWOr */,\n  Xor = 4 /* _BinaryenAtomicRMWXor */,\n  Xchg = 5 /* _BinaryenAtomicRMWXchg */\n}\n\nexport enum SIMDExtractOp {\n  ExtractLaneI8x16 = 0 /* _BinaryenExtractLaneSVecI8x16 */,\n  ExtractLaneU8x16 = 1 /* _BinaryenExtractLaneUVecI8x16 */,\n  ExtractLaneI16x8 = 2 /* _BinaryenExtractLaneSVecI16x8 */,\n  ExtractLaneU16x8 = 3 /* _BinaryenExtractLaneUVecI16x8 */,\n  ExtractLaneI32x4 = 4 /* _BinaryenExtractLaneVecI32x4 */,\n  ExtractLaneI64x2 = 5 /* _BinaryenExtractLaneVecI64x2 */,\n  ExtractLaneF32x4 = 6 /* _BinaryenExtractLaneVecF32x4 */,\n  ExtractLaneF64x2 = 7 /* _BinaryenExtractLaneVecF64x2 */,\n}\n\nexport enum SIMDReplaceOp {\n  ReplaceLaneI8x16 = 0 /* _BinaryenReplaceLaneVecI8x16 */,\n  ReplaceLaneI16x8 = 1 /* _BinaryenReplaceLaneVecI16x8 */,\n  ReplaceLaneI32x4 = 2 /* _BinaryenReplaceLaneVecI32x4 */,\n  ReplaceLaneI64x2 = 3 /* _BinaryenReplaceLaneVecI64x2 */,\n  ReplaceLaneF32x4 = 4 /* _BinaryenReplaceLaneVecF32x4 */,\n  ReplaceLaneF64x2 = 5 /* _BinaryenReplaceLaneVecF64x2 */\n}\n\nexport enum SIMDShiftOp {\n  ShlI8x16 = 0 /* _BinaryenShlVecI8x16 */,\n  ShrI8x16 = 1 /* _BinaryenShrSVecI8x16 */,\n  ShrU8x16 = 2 /* _BinaryenShrUVecI8x16 */,\n  ShlI16x8 = 3 /* _BinaryenShlVecI16x8 */,\n  ShrI16x8 = 4 /* _BinaryenShrSVecI16x8 */,\n  ShrU16x8 = 5 /* _BinaryenShrUVecI16x8 */,\n  ShlI32x4 = 6 /* _BinaryenShlVecI32x4 */,\n  ShrI32x4 = 7 /* _BinaryenShrSVecI32x4 */,\n  ShrU32x4 = 8 /* _BinaryenShrUVecI32x4 */,\n  ShlI64x2 = 9 /* _BinaryenShlVecI64x2 */,\n  ShrI64x2 = 10 /* _BinaryenShrSVecI64x2 */,\n  ShrU64x2 = 11 /* _BinaryenShrUVecI64x2 */\n}\n\nexport enum SIMDTernaryOp {\n  Bitselect = 0 /* _BinaryenBitselectVec128 */,\n  QFMAF32x4 = 1 /* _BinaryenQFMAVecF32x4 */,\n  QFMSF32x4 = 2 /* _BinaryenQFMSVecF32x4 */,\n  QFMAF64x2 = 3 /* _BinaryenQFMAVecF64x2 */,\n  QFMSF64x2 = 4 /* _BinaryenQFMSVecF64x2 */\n}\n\nexport enum SIMDLoadOp {\n  LoadSplatV8x16 = 0 /* _BinaryenLoadSplatVec8x16 */,\n  LoadSplatV16x8 = 1 /* _BinaryenLoadSplatVec16x8 */,\n  LoadSplatV32x4 = 2 /* _BinaryenLoadSplatVec32x4 */,\n  LoadSplatV64x2 = 3 /* _BinaryenLoadSplatVec64x2 */,\n  LoadI8ToI16x8 = 4 /* _BinaryenLoadExtSVec8x8ToVecI16x8 */,\n  LoadU8ToU16x8 = 5 /* _BinaryenLoadExtUVec8x8ToVecI16x8 */,\n  LoadI16ToI32x4 = 6 /* _BinaryenLoadExtSVec16x4ToVecI32x4 */,\n  LoadU16ToU32x4 = 7 /* _BinaryenLoadExtUVec16x4ToVecI32x4 */,\n  LoadI32ToI64x2 = 8 /* _BinaryenLoadExtSVec32x2ToVecI64x2 */,\n  LoadU32ToU64x2 = 9 /* _BinaryenLoadExtUVec32x2ToVecI64x2 */\n}\n\nexport enum ExpressionRunnerFlags {\n  Default = 0 /* _ExpressionRunnerFlagsDefault */,\n  PreserveSideeffects = 1 /* _ExpressionRunnerFlagsPreserveSideeffects */,\n  TraverseCalls = 2 /* _ExpressionRunnerFlagsTraverseCalls */\n}\n\nexport class MemorySegment {\n  constructor(\n    /** Segment data. */\n    public buffer: Uint8Array,\n    /** Segment offset. */\n    public offset: i64\n  ) {}\n}\n\nexport class Module {\n  constructor(\n    /** Binaryen module reference. */\n    public ref: ModuleRef\n  ) {\n    this.lit = binaryen._malloc(binaryen._BinaryenSizeofLiteral());\n  }\n\n  private lit: usize;\n\n  static create(): Module {\n    return new Module(binaryen._BinaryenModuleCreate());\n  }\n\n  static createFrom(buffer: Uint8Array): Module {\n    var cArr = allocU8Array(buffer);\n    var module = new Module(binaryen._BinaryenModuleRead(cArr, buffer.length));\n    binaryen._free(changetype<usize>(cArr));\n    return module;\n  }\n\n  // constants\n\n  i32(value: i32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  i64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralInt64(out, valueLow, valueHigh);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f32(value: f32): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat32(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  f64(value: f64): ExpressionRef {\n    var out = this.lit;\n    binaryen._BinaryenLiteralFloat64(out, value);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  v128(bytes: Uint8Array): ExpressionRef {\n    assert(bytes.length == 16);\n    var out = this.lit;\n    for (let i = 0; i < 16; ++i) {\n      binaryen.__i32_store8(out + i, bytes[i]);\n    }\n    binaryen._BinaryenLiteralVec128(out, out);\n    return binaryen._BinaryenConst(this.ref, out);\n  }\n\n  ref_null(type: NativeType): ExpressionRef {\n    return binaryen._BinaryenRefNull(this.ref, type);\n  }\n\n  // expressions\n\n  unary(\n    op: UnaryOp,\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenUnary(this.ref, op, expr);\n  }\n\n  binary(\n    op: BinaryOp,\n    left: ExpressionRef,\n    right: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenBinary(this.ref, op, left, right);\n  }\n\n  memory_size(): ExpressionRef {\n    return binaryen._BinaryenMemorySize(this.ref);\n  }\n\n  memory_grow(delta: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenMemoryGrow(this.ref, delta);\n  }\n\n  local_get(\n    index: i32,\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalGet(this.ref, index, type);\n  }\n\n  local_tee(\n    index: i32,\n    value: ExpressionRef,\n    type: NativeType = NativeType.Auto\n  ): ExpressionRef {\n    if (type == NativeType.Auto) type = binaryen._BinaryenExpressionGetType(value);\n    return binaryen._BinaryenLocalTee(this.ref, index, value, type);\n  }\n\n  global_get(\n    name: string,\n    type: NativeType\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalGet(this.ref, cStr, type);\n  }\n\n  load(\n    bytes: Index,\n    signed: bool,\n    ptr: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenLoad(this.ref, bytes, signed, offset, align, type, ptr);\n  }\n\n  store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0,\n    align: Index = bytes // naturally aligned by default\n  ): ExpressionRef {\n    return binaryen._BinaryenStore(this.ref, bytes, offset, align, ptr, value, type);\n  }\n\n  atomic_load(\n    bytes: Index,\n    ptr: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\n  }\n\n  atomic_store(\n    bytes: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: NativeType,\n    offset: Index = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\n  }\n\n  atomic_rmw(\n    op: AtomicRMWOp,\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    value: ExpressionRef,\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\n  }\n\n  atomic_cmpxchg(\n    bytes: Index,\n    offset: Index,\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    replacement: ExpressionRef,\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\n  }\n\n  atomic_wait(\n    ptr: ExpressionRef,\n    expected: ExpressionRef,\n    timeout: ExpressionRef,\n    expectedType: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\n  }\n\n  atomic_notify(\n    ptr: ExpressionRef,\n    notifyCount: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenAtomicNotify(this.ref, ptr, notifyCount);\n  }\n\n  atomic_fence(): ExpressionRef {\n    return binaryen._BinaryenAtomicFence(this.ref);\n  }\n\n  // statements\n\n  local_set(\n    index: Index,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenLocalSet(this.ref, index, value);\n  }\n\n  global_set(\n    name: string,\n    value: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGlobalSet(this.ref, cStr, value);\n  }\n\n  block(\n    label: string | null,\n    children: ExpressionRef[],\n    type: NativeType = NativeType.None\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    var cArr = allocPtrArray(children);\n    var ret = binaryen._BinaryenBlock(this.ref, cStr, cArr, children.length, type);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  /** Attempts to trivially flatten a series of expressions instead of emitting a block. */\n  flatten(\n    stmts: ExpressionRef[],\n    type: NativeType = NativeType.None\n  ): ExpressionRef {\n    var length = stmts.length;\n    if (length == 0) return this.nop(); // usually filtered out again\n    if (length == 1) {\n      let single = stmts[0];\n      switch (getExpressionId(single)) {\n        case ExpressionId.Return:\n        case ExpressionId.Throw:\n        case ExpressionId.Unreachable: {\n          // type does no matter, terminates anyway\n          return single;\n        }\n      }\n      let singleType = getExpressionType(single);\n      assert(singleType == NativeType.Unreachable || singleType == type);\n      return single;\n    }\n    return this.block(null, stmts, type);\n  }\n\n  br(\n    label: string | null,\n    condition: ExpressionRef = 0,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenBreak(this.ref, cStr, condition, value);\n  }\n\n  drop(\n    expression: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenDrop(this.ref, expression);\n  }\n\n  maybeDropCondition(condition: ExpressionRef, result: ExpressionRef): ExpressionRef {\n    // FIXME: This is necessary because Binaryen's ExpressionRunner bails early\n    // when encountering a local with an unknown value. This helper only drops\n    // the pre-evaluated condition if it has relevant side effects.\n    // see WebAssembly/binaryen#1237\n    if ((getSideEffects(condition) & ~(SideEffects.ReadsLocal | SideEffects.ReadsGlobal)) != 0) {\n      return this.block(null, [\n        this.drop(condition),\n        result\n      ], getExpressionType(result));\n    }\n    return result;\n  }\n\n  loop(\n    label: string | null,\n    body: ExpressionRef\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(label);\n    return binaryen._BinaryenLoop(this.ref, cStr, body);\n  }\n\n  if(\n    condition: ExpressionRef,\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenIf(this.ref, condition, ifTrue, ifFalse);\n  }\n\n  nop(): ExpressionRef {\n    return binaryen._BinaryenNop(this.ref);\n  }\n\n  return(\n    expression: ExpressionRef = 0\n  ): ExpressionRef {\n    return binaryen._BinaryenReturn(this.ref, expression);\n  }\n\n  select(\n    ifTrue: ExpressionRef,\n    ifFalse: ExpressionRef,\n    condition: ExpressionRef,\n    type: NativeType = NativeType.Auto\n  ): ExpressionRef {\n    if (type == NativeType.Auto) {\n      type = binaryen._BinaryenExpressionGetType(ifTrue);\n      assert(type == binaryen._BinaryenExpressionGetType(ifFalse));\n    }\n    return binaryen._BinaryenSelect(this.ref, condition, ifTrue, ifFalse, type);\n  }\n\n  switch(\n    names: string[],\n    defaultName: string | null,\n    condition: ExpressionRef,\n    value: ExpressionRef = 0\n  ): ExpressionRef {\n    var numNames = names.length;\n    var strs = new Array<usize>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      strs[i] = this.allocStringCached(names[i]);\n    }\n    var cArr = allocPtrArray(strs);\n    var cStr = this.allocStringCached(defaultName);\n    var ret = binaryen._BinaryenSwitch(this.ref, cArr, numNames, cStr, condition, value);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: NativeType,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(target);\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        )\n      : binaryen._BinaryenCall(\n          this.ref, cStr, cArr, operands ? operands.length : 0, returnType\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call(\n    target: string,\n    operands: ExpressionRef[] | null,\n    returnType: NativeType\n  ): ExpressionRef {\n    return this.call(target, operands, returnType, true);\n  }\n\n  call_indirect(\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: NativeType,\n    results: NativeType,\n    isReturn: bool = false\n  ): ExpressionRef {\n    var cArr = allocPtrArray(operands);\n    var ret = isReturn\n      ? binaryen._BinaryenReturnCallIndirect(\n          this.ref, index, cArr, operands ? operands.length : 0, params, results\n        )\n      : binaryen._BinaryenCallIndirect(\n          this.ref, index, cArr, operands ? operands.length : 0, params, results\n        );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  return_call_indirect(\n    index: ExpressionRef,\n    operands: ExpressionRef[] | null,\n    params: NativeType,\n    results: NativeType\n  ): ExpressionRef {\n    return this.call_indirect(index, operands, params, results, true);\n  }\n\n  unreachable(): ExpressionRef {\n    return binaryen._BinaryenUnreachable(this.ref);\n  }\n\n  // bulk memory\n\n  memory_copy(\n    dest: ExpressionRef,\n    source: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryCopy(this.ref, dest, source, size);\n  }\n\n  memory_fill(\n    dest: ExpressionRef,\n    value: ExpressionRef,\n    size: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenMemoryFill(this.ref, dest, value, size);\n  }\n\n  // exception handling\n\n  try(\n    body: ExpressionRef,\n    catchBody: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenTry(this.ref, body, catchBody);\n  }\n\n  throw(\n    eventName: string,\n    operands: ExpressionRef[]\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(eventName);\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenThrow(this.ref, cStr, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  rethrow(\n    exnref: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRethrow(this.ref, exnref);\n  }\n\n  br_on_exn(\n    name: string,\n    eventName: string,\n    exnref: ExpressionRef\n  ): ExpressionRef {\n    var cStr1 = this.allocStringCached(name);\n    var cStr2 = this.allocStringCached(eventName);\n    return binaryen._BinaryenBrOnExn(this.ref, cStr1, cStr2, exnref);\n  }\n\n  // multi value (pseudo instructions)\n\n  pop(\n    type: NativeType\n  ): ExpressionRef {\n    return binaryen._BinaryenPop(this.ref, type);\n  }\n\n  tuple_make(operands: ExpressionRef[]): ExpressionRef {\n    var cArr = allocPtrArray(operands);\n    var ret = binaryen._BinaryenTupleMake(this.ref, cArr, operands.length);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  tuple_extract(tuple: ExpressionRef, index: Index): ExpressionRef {\n    return binaryen._BinaryenTupleExtract(this.ref, tuple, index);\n  }\n\n  // simd\n\n  simd_extract(\n    op: SIMDExtractOp,\n    vec: ExpressionRef,\n    idx: u8\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDExtract(this.ref, op, vec, idx);\n  }\n\n  simd_replace(\n    op: SIMDReplaceOp,\n    vec: ExpressionRef,\n    idx: u8,\n    value: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDReplace(this.ref, op, vec, idx, value);\n  }\n\n  simd_shuffle(\n    vec1: ExpressionRef,\n    vec2: ExpressionRef,\n    mask: Uint8Array\n  ): ExpressionRef {\n    assert(mask.length == 16);\n    var cArr = allocU8Array(mask);\n    var ret = binaryen._BinaryenSIMDShuffle(this.ref, vec1, vec2, cArr);\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  simd_ternary(\n    op: SIMDTernaryOp,\n    a: ExpressionRef,\n    b: ExpressionRef,\n    c: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDTernary(this.ref, op, a, b, c);\n  }\n\n  simd_shift(\n    op: SIMDShiftOp,\n    vec: ExpressionRef,\n    shift: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDShift(this.ref, op, vec, shift);\n  }\n\n  simd_load(\n    op: SIMDLoadOp,\n    ptr: ExpressionRef,\n    offset: u32,\n    align: u32\n  ): ExpressionRef {\n    return binaryen._BinaryenSIMDLoad(this.ref, op, offset, align, ptr);\n  }\n\n  // reference types\n\n  ref_is_null(\n    expr: ExpressionRef\n  ): ExpressionRef {\n    return binaryen._BinaryenRefIsNull(this.ref, expr);\n  }\n\n  ref_func(\n    name: string\n  ): ExpressionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenRefFunc(this.ref, cStr);\n  }\n\n  // globals\n\n  addGlobal(\n    name: string,\n    type: NativeType,\n    mutable: bool,\n    initializer: ExpressionRef\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddGlobal(this.ref, cStr, type, mutable, initializer);\n  }\n\n  getGlobal(\n    name: string\n  ): GlobalRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetGlobal(this.ref, cStr);\n  }\n\n  removeGlobal(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveGlobal(this.ref, cStr);\n  }\n\n  // events\n\n  addEvent(\n    name: string,\n    attribute: u32,\n    params: NativeType,\n    results: NativeType\n  ): EventRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenAddEvent(this.ref, cStr, attribute, params, results);\n  }\n\n  getEvent(\n    name: string\n  ): EventRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetEvent(this.ref, cStr);\n  }\n\n  removeEvent(\n    name: string\n  ): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveEvent(this.ref, cStr);\n  }\n\n  // functions\n\n  addFunction(\n    name: string,\n    params: NativeType,\n    results: NativeType,\n    varTypes: NativeType[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocPtrArray(varTypes);\n    var ret = binaryen._BinaryenAddFunction(\n      this.ref,\n      cStr,\n      params,\n      results,\n      cArr,\n      varTypes ? varTypes.length : 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  getFunction(\n    name: string\n  ): FunctionRef {\n    var cStr = this.allocStringCached(name);\n    return binaryen._BinaryenGetFunction(this.ref, cStr);\n  }\n\n  removeFunction(name: string): void {\n    var cStr = this.allocStringCached(name);\n    binaryen._BinaryenRemoveFunction(this.ref, cStr);\n  }\n\n  private hasTemporaryFunction: bool = false;\n\n  addTemporaryFunction(\n    result: NativeType,\n    paramTypes: NativeType[] | null,\n    body: ExpressionRef\n  ): FunctionRef {\n    this.hasTemporaryFunction = assert(!this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    var cArr = allocPtrArray(paramTypes);\n    var ret = binaryen._BinaryenAddFunction(this.ref,\n      tempName,\n      createType(paramTypes),\n      result,\n      0, 0,\n      body\n    );\n    binaryen._free(cArr);\n    return ret;\n  }\n\n  removeTemporaryFunction(): void {\n    this.hasTemporaryFunction = !assert(this.hasTemporaryFunction);\n    var tempName = this.allocStringCached(\"\");\n    binaryen._BinaryenRemoveFunction(this.ref, tempName);\n  }\n\n  setStart(func: FunctionRef): void {\n    binaryen._BinaryenSetStart(this.ref, func);\n  }\n\n  // exports\n\n  addFunctionExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\n  }\n\n  addTableExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddTableExport(this.ref, cStr1, cStr2);\n  }\n\n  addMemoryExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\n  }\n\n  addGlobalExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\n  }\n\n  addEventExport(\n    internalName: string,\n    externalName: string\n  ): ExportRef {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalName);\n    return binaryen._BinaryenAddEventExport(this.ref, cStr1, cStr2);\n  }\n\n  removeExport(externalName: string): void {\n    var cStr = this.allocStringCached(externalName);\n    binaryen._BinaryenRemoveExport(this.ref, cStr);\n  }\n\n  // imports\n\n  addFunctionImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    params: NativeType,\n    results: NativeType\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, params, results);\n  }\n\n  addTableImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\n  }\n\n  addMemoryImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    shared: bool = false,\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3, shared);\n  }\n\n  addGlobalImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    globalType: NativeType,\n    mutable: bool = false\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType, mutable);\n  }\n\n  addEventImport(\n    internalName: string,\n    externalModuleName: string,\n    externalBaseName: string,\n    attribute: u32,\n    params: NativeType,\n    results: NativeType\n  ): void {\n    var cStr1 = this.allocStringCached(internalName);\n    var cStr2 = this.allocStringCached(externalModuleName);\n    var cStr3 = this.allocStringCached(externalBaseName);\n    binaryen._BinaryenAddEventImport(\n      this.ref, cStr1, cStr2, cStr3, attribute, params, results\n    );\n  }\n\n  // memory\n\n  /** Unlimited memory constant. */\n  static readonly UNLIMITED_MEMORY: Index = <Index>-1;\n\n  setMemory(\n    initial: Index,\n    maximum: Index,\n    segments: MemorySegment[],\n    target: Target,\n    exportName: string | null = null,\n    shared: bool = false\n  ): void {\n    var cStr = this.allocStringCached(exportName);\n    var k = segments.length;\n    var segs = new Array<usize>(k);\n    var psvs = new Uint8Array(k);\n    var offs = new Array<ExpressionRef>(k);\n    var sizs = new Array<Index>(k);\n    for (let i = 0; i < k; ++i) {\n      let segment = segments[i];\n      let buffer = segment.buffer;\n      let offset = segment.offset;\n      segs[i] = allocU8Array(buffer);\n      psvs[i] = 0; // no passive segments currently\n      offs[i] = target == Target.WASM64\n        ? this.i64(i64_low(offset), i64_high(offset))\n        : this.i32(i64_low(offset));\n      sizs[i] = buffer.length;\n    }\n    var cArr1 = allocPtrArray(segs);\n    var cArr2 = allocU8Array(psvs);\n    var cArr3 = allocPtrArray(offs);\n    var cArr4 = allocU32Array(sizs);\n    binaryen._BinaryenSetMemory(\n      this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, cArr4, k, shared\n    );\n    binaryen._free(cArr4);\n    binaryen._free(cArr3);\n    binaryen._free(cArr2);\n    binaryen._free(cArr1);\n    for (let i = k - 1; i >= 0; --i) {\n      binaryen._free(segs[i]);\n    }\n  }\n\n  // table\n\n  /** Unlimited table constant. */\n  static readonly UNLIMITED_TABLE: Index = <Index>-1;\n\n  setFunctionTable(\n    initial: Index,\n    maximum: Index,\n    funcs: string[],\n    offset: ExpressionRef\n  ): void {\n    var numNames = funcs.length;\n    var names = new Array<usize>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      names[i] = this.allocStringCached(funcs[i]);\n    }\n    var cArr = allocPtrArray(names);\n    binaryen._BinaryenSetFunctionTable(\n      this.ref, initial, maximum, cArr, numNames, offset\n    );\n    binaryen._free(cArr);\n  }\n\n  // sections\n\n  addCustomSection(name: string, contents: Uint8Array): void {\n    var cStr = this.allocStringCached(name);\n    var cArr = allocU8Array(contents);\n    binaryen._BinaryenAddCustomSection(this.ref, cStr, cArr, contents.length);\n    binaryen._free(cArr);\n  }\n\n  // meta (global)\n\n  getOptimizeLevel(): i32 {\n    return binaryen._BinaryenGetOptimizeLevel();\n  }\n\n  setOptimizeLevel(level: i32): void {\n    binaryen._BinaryenSetOptimizeLevel(level);\n  }\n\n  getShrinkLevel(): i32 {\n    return binaryen._BinaryenGetShrinkLevel();\n  }\n\n  setShrinkLevel(level: i32): void {\n    binaryen._BinaryenSetShrinkLevel(level);\n  }\n\n  getDebugInfo(): boolean {\n    return binaryen._BinaryenGetDebugInfo();\n  }\n\n  setDebugInfo(on: bool): void {\n    binaryen._BinaryenSetDebugInfo(on);\n  }\n\n  getLowMemoryUnused(): bool {\n    return binaryen._BinaryenGetLowMemoryUnused();\n  }\n\n  setLowMemoryUnused(on: bool): void {\n    binaryen._BinaryenSetLowMemoryUnused(on);\n  }\n\n  getFastMath(): bool {\n    return binaryen._BinaryenGetFastMath();\n  }\n\n  setFastMath(on: bool): void {\n    binaryen._BinaryenSetFastMath(on);\n  }\n\n  getPassArgument(key: string): string | null {\n    var cStr = this.allocStringCached(key);\n    var ptr = binaryen._BinaryenGetPassArgument(cStr);\n    return ptr ? readString(ptr) : null;\n  }\n\n  setPassArgument(key: string, value: string | null): void {\n    var cStr1 = this.allocStringCached(key);\n    var cStr2 = this.allocStringCached(value);\n    binaryen._BinaryenSetPassArgument(cStr1, cStr2);\n  }\n\n  clearPassArguments(): void {\n    binaryen._BinaryenClearPassArguments();\n  }\n\n  getAlwaysInlineMaxSize(): Index {\n    return binaryen._BinaryenGetAlwaysInlineMaxSize();\n  }\n\n  setAlwaysInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetAlwaysInlineMaxSize(size);\n  }\n\n  getFlexibleInlineMaxSize(): Index {\n    return binaryen._BinaryenGetFlexibleInlineMaxSize();\n  }\n\n  setFlexibleInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetFlexibleInlineMaxSize(size);\n  }\n\n  getOneCallerInlineMaxSize(): Index {\n    return binaryen._BinaryenGetOneCallerInlineMaxSize();\n  }\n\n  setOneCallerInlineMaxSize(size: Index): void {\n    binaryen._BinaryenSetOneCallerInlineMaxSize(size);\n  }\n\n  getAllowInliningFunctionsWithLoops(): bool {\n    return binaryen._BinaryenGetAllowInliningFunctionsWithLoops();\n  }\n\n  setAllowInliningFunctionsWithLoops(enabled: bool): void {\n    binaryen._BinaryenSetAllowInliningFunctionsWithLoops(enabled);\n  }\n\n  // meta (module)\n\n  getFeatures(): FeatureFlags {\n    return binaryen._BinaryenModuleGetFeatures(this.ref);\n  }\n\n  setFeatures(featureFlags: FeatureFlags): void {\n    binaryen._BinaryenModuleSetFeatures(this.ref, featureFlags);\n  }\n\n  runPass(pass: string, func: FunctionRef = 0): void {\n    var cStr = allocString(pass);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cStr, 1);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cStr, 1);\n    }\n    binaryen._free(cStr);\n  }\n\n  runPasses(passes: string[], func: FunctionRef = 0): void {\n    var numNames = passes.length;\n    var cStrs = new Array<usize>(numNames);\n    for (let i = 0; i < numNames; ++i) {\n      cStrs[i] = allocString(passes[i]);\n    }\n    var cArr = allocPtrArray(cStrs);\n    if (func) {\n      binaryen._BinaryenFunctionRunPasses(func, this.ref, cArr, numNames);\n    } else {\n      binaryen._BinaryenModuleRunPasses(this.ref, cArr, numNames);\n    }\n    binaryen._free(cArr);\n    for (let i = numNames; i >= 0; --i) binaryen._free(cStrs[i]);\n  }\n\n  optimize(optimizeLevel: i32, shrinkLevel: i32, debugInfo: bool = false, usesARC: bool = true): void {\n    // Implicitly run costly non-LLVM optimizations on -O3 or -Oz\n    if (optimizeLevel >= 3 || shrinkLevel >= 2) optimizeLevel = 4;\n\n    this.setOptimizeLevel(optimizeLevel);\n    this.setShrinkLevel(shrinkLevel);\n    this.setDebugInfo(debugInfo);\n    this.setFastMath(true);\n    this.clearPassArguments();\n\n    // Tweak inlining limits based on optimization levels\n    if (optimizeLevel >= 2 && shrinkLevel == 0) {\n      this.setAlwaysInlineMaxSize(12);\n      this.setFlexibleInlineMaxSize(70);\n      this.setOneCallerInlineMaxSize(200);\n      this.setAllowInliningFunctionsWithLoops(optimizeLevel >= 3);\n    } else {\n      this.setAlwaysInlineMaxSize(\n        optimizeLevel <= 1 || shrinkLevel >= 2\n          ? 2\n          : 6\n      );\n      this.setFlexibleInlineMaxSize(65);\n      this.setOneCallerInlineMaxSize(80);\n      this.setAllowInliningFunctionsWithLoops(false);\n    }\n\n    // Pass order here differs substantially from Binaryen's defaults\n    // see: Binaryen/src/pass.cpp\n    if (optimizeLevel > 0 || shrinkLevel > 0) {\n      let passes = new Array<string>();\n\n      // --- PassRunner::addDefaultGlobalOptimizationPrePasses ---\n\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-module-elements\"); // +\n\n      // --- PassRunner::addDefaultFunctionOptimizationPasses ---\n\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n        passes.push(\"ssa-nomerge\");\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"merge-blocks\");\n        passes.push(\"precompute-propagate\");\n      }\n      if (optimizeLevel >= 3) {\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"simplify-locals-notee-nostructure\");\n        passes.push(\"merge-locals\");\n\n        passes.push(\"code-folding\");\n        passes.push(\"flatten\");\n        passes.push(\"vacuum\");\n        passes.push(\"local-cse\");\n        passes.push(\"reorder-locals\");\n      }\n      // FIXME: see issue #1288\n      // if (usesARC) {\n      //   if (optimizeLevel < 3) {\n      //     passes.push(\"flatten\");\n      //   }\n      //   passes.push(\"post-assemblyscript\");\n      // }\n      passes.push(\"optimize-instructions\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"dce\");\n      }\n      passes.push(\"remove-unused-names\");\n      passes.push(\"remove-unused-brs\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 2) {\n        passes.push(\"inlining\");\n        passes.push(\"precompute-propagate\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"pick-load-signs\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      if (optimizeLevel >= 3 && shrinkLevel <= 1) {\n        passes.push(\"licm\");\n      }\n      passes.push(\"simplify-locals-nostructure\");\n      passes.push(\"vacuum\");\n\n      passes.push(\"reorder-locals\");\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"simplify-locals\");\n      passes.push(\"vacuum\");\n\n      passes.push(\"reorder-locals\");\n      passes.push(\"coalesce-locals\");\n      passes.push(\"reorder-locals\");\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"merge-locals\");\n      }\n      passes.push(\"vacuum\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      passes.push(\"merge-blocks\");\n      passes.push(\"remove-unused-brs\");\n      passes.push(\"remove-unused-names\");\n      passes.push(\"merge-blocks\");\n      if (optimizeLevel >= 3) {\n        passes.push(\"optimize-instructions\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        passes.push(\"vacuum\");\n      }\n\n      // --- PassRunner::addDefaultGlobalOptimizationPostPasses ---\n\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"simplify-globals-optimizing\");\n        passes.push(\"dae-optimizing\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"inlining-optimizing\");\n      }\n      if (this.getLowMemoryUnused()) {\n        if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n          passes.push(\"optimize-added-constants-propagate\");\n        } else {\n          passes.push(\"optimize-added-constants\");\n        }\n      }\n      passes.push(\"duplicate-import-elimination\");\n      if (optimizeLevel >= 2 || shrinkLevel >= 2) {\n        passes.push(\"simplify-globals-optimizing\");\n      } else {\n        passes.push(\"simplify-globals\");\n        passes.push(\"vacuum\");\n      }\n      if (optimizeLevel >= 3 || shrinkLevel >= 1) {\n        passes.push(\"code-folding\");\n      }\n      // precompute works best after global optimizations\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"precompute-propagate\");\n      } else {\n        passes.push(\"precompute\");\n      }\n      passes.push(\"directize\"); // replace indirect with direct calls\n      passes.push(\"dae-optimizing\"); // reduce arity\n      passes.push(\"inlining-optimizing\"); // and inline if possible\n      if (usesARC) {\n        // works best after inlining to cover most retains/releases\n        passes.push(\"post-assemblyscript-finalize\");\n      }\n      if (optimizeLevel >= 2 || shrinkLevel >= 1) {\n        passes.push(\"rse\");\n        // move code on early return (after CFG cleanup)\n        passes.push(\"code-pushing\");\n        if (optimizeLevel >= 3) {\n          // very expensive, so O3 only\n          passes.push(\"simplify-globals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"precompute-propagate\");\n\n          // replace indirect with direct calls again and inline\n          passes.push(\"inlining-optimizing\");\n          passes.push(\"directize\");\n          passes.push(\"dae-optimizing\");\n\n          passes.push(\"merge-locals\");\n          passes.push(\"coalesce-locals\");\n          passes.push(\"simplify-locals\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"inlining\");\n          passes.push(\"precompute-propagate\");\n          passes.push(\"vacuum\");\n\n          passes.push(\"coalesce-locals\");\n        }\n        passes.push(\"remove-unused-brs\");\n        passes.push(\"remove-unused-names\");\n        passes.push(\"vacuum\");\n\n        passes.push(\"optimize-instructions\");\n        passes.push(\"simplify-globals-optimizing\");\n      }\n      // clean up\n      passes.push(\"duplicate-function-elimination\");\n      passes.push(\"remove-unused-nonfunction-module-elements\");\n      passes.push(\"memory-packing\");\n      passes.push(\"remove-unused-module-elements\");\n\n      this.runPasses(passes);\n    }\n  }\n\n  validate(): bool {\n    return binaryen._BinaryenModuleValidate(this.ref) == 1;\n  }\n\n  interpret(): void {\n    binaryen._BinaryenModuleInterpret(this.ref);\n  }\n\n  toBinary(sourceMapUrl: string | null = null): BinaryModule {\n    var out = this.lit; // safe to reuse as long as..\n    assert(binaryen._BinaryenSizeofLiteral() >= 12);\n    var cStr = allocString(sourceMapUrl);\n    var binaryPtr: usize = 0;\n    var sourceMapPtr: usize = 0;\n    binaryen._BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\n    binaryPtr = assert(binaryen.__i32_load(out));\n    var binaryLen = binaryen.__i32_load(out + 4);\n    sourceMapPtr = binaryen.__i32_load(out + 8); // may be NULL\n    var binary = new BinaryModule(readBuffer(binaryPtr, binaryLen), readString(sourceMapPtr));\n    if (cStr) binaryen._free(cStr);\n    binaryen._free(binaryPtr);\n    if (sourceMapPtr) binaryen._free(sourceMapPtr);\n    return binary;\n  }\n\n  toText(watFormat: bool = true): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  toAsmjs(): string {\n    throw new Error(\"not implemented\"); // JS glue overrides this\n  }\n\n  private cachedStrings: Map<string,usize> = new Map();\n\n  private allocStringCached(str: string | null): usize {\n    if (str === null) return 0;\n    var cachedStrings = this.cachedStrings;\n    if (cachedStrings.has(str)) return <usize>cachedStrings.get(str);\n    var ptr = allocString(str);\n    cachedStrings.set(str, ptr);\n    return ptr;\n  }\n\n  dispose(): void {\n    assert(this.ref);\n    // TODO: for (let ptr of this.cachedStrings.values()) {\n    for (let _values = Map_values(this.cachedStrings), i = 0, k = _values.length; i < k; ++i) {\n      let ptr = unchecked(_values[i]);\n      binaryen._free(ptr);\n    }\n    this.cachedStrings = new Map();\n    binaryen._free(this.lit);\n    binaryen._BinaryenModuleDispose(this.ref);\n    this.ref = 0;\n  }\n\n  createRelooper(): Relooper {\n    return Relooper.create(this);\n  }\n\n  cloneExpression(\n    expr: ExpressionRef,\n    noSideEffects: bool = false,\n    maxDepth: i32 = i32.MAX_VALUE\n  ): ExpressionRef { // currently supports side effect free expressions only\n    if (maxDepth < 0) return 0;\n    maxDepth -= 1;\n\n    var nested1: ExpressionRef,\n        nested2: ExpressionRef;\n\n    switch (binaryen._BinaryenExpressionGetId(expr)) {\n      case ExpressionId.Const: {\n        switch (<u32>binaryen._BinaryenExpressionGetType(expr)) {\n          case <u32>NativeType.I32: {\n            return this.i32(binaryen._BinaryenConstGetValueI32(expr));\n          }\n          case <u32>NativeType.I64: {\n            return this.i64(\n              binaryen._BinaryenConstGetValueI64Low(expr),\n              binaryen._BinaryenConstGetValueI64High(expr)\n            );\n          }\n          case <u32>NativeType.F32: {\n            return this.f32(binaryen._BinaryenConstGetValueF32(expr));\n          }\n          case <u32>NativeType.F64: {\n            return this.f64(binaryen._BinaryenConstGetValueF64(expr));\n          }\n          case <u32>NativeType.V128: {\n            // TODO\n            return 0;\n          }\n          // Not possible to clone an externref as it is opaque\n          case <u32>NativeType.Externref: {\n            return 0;\n          }\n          default: {\n            throw new Error(\"concrete type expected\");\n          }\n        }\n      }\n      case ExpressionId.LocalGet: {\n        return binaryen._BinaryenLocalGet(this.ref,\n          binaryen._BinaryenLocalGetGetIndex(expr),\n          binaryen._BinaryenExpressionGetType(expr)\n        );\n      }\n      case ExpressionId.GlobalGet: {\n        let globalName = binaryen._BinaryenGlobalGetGetName(expr);\n        if (!globalName) break;\n        return binaryen._BinaryenGlobalGet(\n          this.ref, globalName, binaryen._BinaryenExpressionGetType(expr)\n        );\n      }\n      case ExpressionId.Load: {\n        if (!(nested1 = this.cloneExpression(\n          binaryen._BinaryenLoadGetPtr(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        return (\n          binaryen._BinaryenLoadIsAtomic(expr)\n            ? binaryen._BinaryenAtomicLoad(this.ref,\n                binaryen._BinaryenLoadGetBytes(expr),\n                binaryen._BinaryenLoadGetOffset(expr),\n                binaryen._BinaryenExpressionGetType(expr),\n                nested1\n              )\n            : binaryen._BinaryenLoad(this.ref,\n                binaryen._BinaryenLoadGetBytes(expr),\n                binaryen._BinaryenLoadIsSigned(expr),\n                binaryen._BinaryenLoadGetOffset(expr),\n                binaryen._BinaryenLoadGetAlign(expr),\n                binaryen._BinaryenExpressionGetType(expr),\n                nested1\n              )\n        );\n      }\n      case ExpressionId.Unary: {\n        if (!(nested1 = this.cloneExpression(\n          binaryen._BinaryenUnaryGetValue(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        return binaryen._BinaryenUnary(\n          this.ref, binaryen._BinaryenUnaryGetOp(expr), nested1\n        );\n      }\n      case ExpressionId.Binary: {\n        if (!(nested1 = this.cloneExpression(\n          binaryen._BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        if (!(nested2 = this.cloneExpression(\n          binaryen._BinaryenBinaryGetRight(expr), noSideEffects, maxDepth)\n        )) {\n          break;\n        }\n        return binaryen._BinaryenBinary(\n          this.ref, binaryen._BinaryenBinaryGetOp(expr), nested1, nested2\n        );\n      }\n    }\n    return 0;\n  }\n\n  copyExpression(expr: ExpressionRef): ExpressionRef {\n    return binaryen._BinaryenExpressionCopy(expr, this.ref);\n  }\n\n  runExpression(\n    expr: ExpressionRef,\n    flags: ExpressionRunnerFlags,\n    maxDepth: i32 = 50,\n    maxLoopIterations: i32 = 1\n  ): ExpressionRef {\n    var runner = binaryen._ExpressionRunnerCreate(this.ref, flags, maxDepth, maxLoopIterations);\n    var precomp =  binaryen._ExpressionRunnerRunAndDispose(runner, expr);\n    if (precomp) {\n      assert(getExpressionId(precomp) == ExpressionId.Const);\n      assert(getExpressionType(precomp) == getExpressionType(expr));\n    }\n    return precomp;\n  }\n\n  // source map generation\n\n  addDebugInfoFile(name: string): Index {\n    var cStr = allocString(name);\n    var ret = binaryen._BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\n    binaryen._free(cStr);\n    return ret;\n  }\n\n  getDebugInfoFile(index: Index): string | null {\n    return readString(binaryen._BinaryenModuleGetDebugInfoFileName(this.ref, index));\n  }\n\n  setDebugLocation(\n    func: FunctionRef,\n    expr: ExpressionRef,\n    fileIndex: Index,\n    lineNumber: Index,\n    columnNumber: Index\n  ): void {\n    binaryen._BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\n  }\n}\n\n// types\n\nexport function createType(types: NativeType[] | null): NativeType {\n  if (!types) return NativeType.None;\n  switch (types.length) {\n    case 0: return NativeType.None;\n    case 1: return types[0];\n  }\n  var cArr = allocPtrArray(types);\n  var ret = binaryen._BinaryenTypeCreate(cArr, types.length);\n  binaryen._free(cArr);\n  return ret;\n}\n\nexport function expandType(type: NativeType): NativeType[] {\n  var arity = binaryen._BinaryenTypeArity(type);\n  var cArr = binaryen._malloc(<usize>arity << 2);\n  binaryen._BinaryenTypeExpand(type, cArr);\n  var types = new Array<NativeType>(arity);\n  for (let i: u32 = 0; i < arity; ++i) {\n    types[i] = binaryen.__i32_load(cArr + (<usize>i << 2));\n  }\n  binaryen._free(cArr);\n  return types;\n}\n\n// expressions\n\nexport function getExpressionId(expr: ExpressionRef): ExpressionId {\n  return binaryen._BinaryenExpressionGetId(expr);\n}\n\nexport function getExpressionType(expr: ExpressionRef): NativeType {\n  return binaryen._BinaryenExpressionGetType(expr);\n}\n\nexport function getConstValueI32(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI32(expr);\n}\n\nexport function getConstValueI64Low(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64Low(expr);\n}\n\nexport function getConstValueI64High(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenConstGetValueI64High(expr);\n}\n\nexport function getConstValueF32(expr: ExpressionRef): f32 {\n  return binaryen._BinaryenConstGetValueF32(expr);\n}\n\nexport function getConstValueF64(expr: ExpressionRef): f64 {\n  return binaryen._BinaryenConstGetValueF64(expr);\n}\n\nexport function getLocalGetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalGetGetIndex(expr);\n}\n\nexport function getLocalSetIndex(expr: ExpressionRef): Index {\n  return binaryen._BinaryenLocalSetGetIndex(expr);\n}\n\nexport function getLocalSetValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLocalSetGetValue(expr);\n}\n\nexport function isLocalTee(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLocalSetIsTee(expr);\n}\n\nexport function getGlobalGetName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetGetName(expr));\n}\n\nexport function getBinaryOp(expr: ExpressionRef): BinaryOp {\n  return binaryen._BinaryenBinaryGetOp(expr);\n}\n\nexport function getBinaryLeft(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetLeft(expr);\n}\n\nexport function getBinaryRight(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBinaryGetRight(expr);\n}\n\nexport function getUnaryOp(expr: ExpressionRef): UnaryOp {\n  return binaryen._BinaryenUnaryGetOp(expr);\n}\n\nexport function getUnaryValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenUnaryGetValue(expr);\n}\n\nexport function getLoadBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetBytes(expr);\n}\n\nexport function getLoadOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenLoadGetOffset(expr);\n}\n\nexport function getLoadPtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoadGetPtr(expr);\n}\n\nexport function isLoadSigned(expr: ExpressionRef): bool {\n  return binaryen._BinaryenLoadIsSigned(expr);\n}\n\nexport function getStoreBytes(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetBytes(expr);\n}\n\nexport function getStoreOffset(expr: ExpressionRef): u32 {\n  return binaryen._BinaryenStoreGetOffset(expr);\n}\n\nexport function getStorePtr(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetPtr(expr);\n}\n\nexport function getStoreValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenStoreGetValue(expr);\n}\n\nexport function getBlockName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBlockGetName(expr));\n}\n\nexport function getBlockChildCount(expr: ExpressionRef): Index {\n  return binaryen._BinaryenBlockGetNumChildren(expr);\n}\n\nexport function getBlockChildAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenBlockGetChildAt(expr, index);\n}\n\nexport function getIfCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetCondition(expr);\n}\n\nexport function getIfTrue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfTrue(expr);\n}\n\nexport function getIfFalse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenIfGetIfFalse(expr);\n}\n\nexport function getLoopName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenLoopGetName(expr));\n}\n\nexport function getLoopBody(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenLoopGetBody(expr);\n}\n\nexport function getBreakName(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenBreakGetName(expr));\n}\n\nexport function getBreakCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenBreakGetCondition(expr);\n}\n\nexport function getSelectThen(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfTrue(expr);\n}\n\nexport function getSelectElse(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetIfFalse(expr);\n}\n\nexport function getSelectCondition(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenSelectGetCondition(expr);\n}\n\nexport function getDropValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenDropGetValue(expr);\n}\n\nexport function getReturnValue(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenReturnGetValue(expr);\n}\n\nexport function getCallTarget(expr: ExpressionRef): string | null {\n  return readString(binaryen._BinaryenCallGetTarget(expr));\n}\n\nexport function getCallOperandCount(expr: ExpressionRef): i32 {\n  return binaryen._BinaryenCallGetNumOperands(expr);\n}\n\nexport function getCallOperandAt(expr: ExpressionRef, index: Index): ExpressionRef {\n  return binaryen._BinaryenCallGetOperandAt(expr, index);\n}\n\nexport function getMemoryGrowDelta(expr: ExpressionRef): ExpressionRef {\n  return binaryen._BinaryenMemoryGrowGetDelta(expr);\n}\n\n// functions\n\nexport function getFunctionBody(func: FunctionRef): ExpressionRef {\n  return binaryen._BinaryenFunctionGetBody(func);\n}\n\nexport function getFunctionName(func: FunctionRef): string | null {\n  return readString(binaryen._BinaryenFunctionGetName(func));\n}\n\nexport function getFunctionParams(func: FunctionRef): NativeType {\n  return binaryen._BinaryenFunctionGetParams(func);\n}\n\nexport function getFunctionResults(func: FunctionRef): NativeType {\n  return binaryen._BinaryenFunctionGetResults(func);\n}\n\nexport function getFunctionVars(func: FunctionRef): NativeType[] {\n  var count = binaryen._BinaryenFunctionGetNumVars(func);\n  var types = new Array<NativeType>(count);\n  for (let i: Index = 0; i < count; ++i) {\n    types[i] = binaryen._BinaryenFunctionGetVar(func, i);\n  }\n  return types;\n}\n\n// globals\n\nexport function getGlobalName(global: GlobalRef): string | null {\n  return readString(binaryen._BinaryenGlobalGetName(global));\n}\n\nexport function getGlobalType(global: GlobalRef): NativeType {\n  return binaryen._BinaryenGlobalGetType(global);\n}\n\nexport function isGlobalMutable(global: GlobalRef): bool {\n  return binaryen._BinaryenGlobalIsMutable(global);\n}\n\nexport function getGlobalInit(global: GlobalRef): ExpressionRef {\n  return binaryen._BinaryenGlobalGetInitExpr(global);\n}\n\n// events\n\nexport function getEventName(event: EventRef): string | null {\n  return readString(binaryen._BinaryenEventGetName(event));\n}\n\nexport function getEventAttribute(event: EventRef): u32 {\n  return binaryen._BinaryenEventGetAttribute(event);\n}\n\nexport function getEventParams(event: EventRef): NativeType {\n  return binaryen._BinaryenEventGetParams(event);\n}\n\nexport function getEventResults(event: EventRef): NativeType {\n  return binaryen._BinaryenEventGetResults(event);\n}\n\nexport class Relooper {\n  constructor(\n    /** Module this relooper belongs to. */\n    public module: Module,\n    /** Binaryen relooper reference. */\n    public ref: RelooperRef\n  ) {}\n\n  static create(module: Module): Relooper {\n    return new Relooper(module, binaryen._RelooperCreate(module.ref));\n  }\n\n  addBlock(code: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlock(this.ref, code);\n  }\n\n  addBranch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    condition: ExpressionRef = 0,\n    code: ExpressionRef = 0\n  ): void {\n    binaryen._RelooperAddBranch(from, to, condition, code);\n  }\n\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\n    return binaryen._RelooperAddBlockWithSwitch(this.ref, code, condition);\n  }\n\n  addBranchForSwitch(\n    from: RelooperBlockRef,\n    to: RelooperBlockRef,\n    indexes: i32[],\n    code: ExpressionRef = 0\n  ): void {\n    var cArr = allocI32Array(indexes);\n    binaryen._RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\n    binaryen._free(cArr);\n  }\n\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\n    return binaryen._RelooperRenderAndDispose(this.ref, entry, labelHelper);\n  }\n}\n\n/** Builds a switch using a sequence of `br_if`s. */\nexport class SwitchBuilder {\n  // This is useful because Binaryen understands sequences of `br_if`s and\n  // knows how to make a `br_table` from such a sequence if switched over\n  // values are considered dense enough, respectively a size-efficient sequence\n  // of `if`s if not, depending on optimization levels.\n\n  private module: Module;\n  private condition: ExpressionRef;\n  private values: i32[] = new Array();\n  private indexes: i32[] = new Array();\n  private cases: ExpressionRef[][] = new Array();\n  private defaultIndex: i32 = -1;\n\n  /** Creates a new builder using the specified i32 condition. */\n  constructor(module: Module, condition: ExpressionRef) {\n    this.module = module;\n    this.condition = condition;\n  }\n\n  /** Links a case to the specified branch. */\n  addCase(value: i32, code: ExpressionRef[]): void {\n    var cases = this.cases;\n    var index = cases.indexOf(code);\n    if (index < 0) {\n      index = cases.length;\n      cases.push(code);\n    }\n    this.values.push(value);\n    this.indexes.push(index);\n  }\n\n  /** Links the default branch. */\n  addDefault(code: ExpressionRef[]): void {\n    assert(this.defaultIndex == -1);\n    var cases = this.cases;\n    this.defaultIndex = cases.length;\n    cases.push(code);\n  }\n\n  /** Renders the switch to a block. */\n  render(localIndex: i32, labelPostfix: string = \"\"): ExpressionRef {\n    var module = this.module;\n    var cases = this.cases;\n    var numCases = cases.length;\n    if (!numCases) {\n      return module.drop(this.condition);\n    }\n    var values = this.values;\n    var numValues = values.length;\n    var indexes = this.indexes;\n    var entry = new Array<ExpressionRef>(1 + numValues + 1);\n    var labels = new Array<string>(numCases);\n    for (let i = 0; i < numCases; ++i) {\n      labels[i] = \"case\" + i.toString() + labelPostfix;\n    }\n    entry[0] = module.local_set(localIndex, this.condition);\n    for (let i = 0; i < numValues; ++i) {\n      let index = indexes[i];\n      entry[1 + i] = module.br(labels[index],\n        module.binary(BinaryOp.EqI32,\n          module.local_get(localIndex, NativeType.I32),\n          module.i32(values[i])\n        )\n      );\n    }\n    var defaultIndex = this.defaultIndex;\n    var defaultLabel = \"default\" + labelPostfix;\n    entry[1 + numValues] = module.br(\n      ~defaultIndex\n        ? labels[defaultIndex]\n        : defaultLabel\n    );\n    var current = module.block(labels[0], entry);\n    for (let i = 1; i < numCases; ++i) {\n      let block = cases[i - 1];\n      block.unshift(current);\n      current = module.block(labels[i], block);\n    }\n    var lastCase = cases[numCases - 1];\n    lastCase.unshift(current);\n    return module.block(\n      ~defaultIndex\n        ? null\n        : defaultLabel,\n      lastCase\n    );\n  }\n}\n\nexport enum SideEffects {\n  None = 0 /* _BinaryenSideEffectNone */,\n  Branches = 1 /* _BinaryenSideEffectBranches */,\n  Calls = 2 /* _BinaryenSideEffectCalls */,\n  ReadsLocal = 4 /* _BinaryenSideEffectReadsLocal */,\n  WritesLocal = 8 /* _BinaryenSideEffectWritesLocal */,\n  ReadsGlobal = 16 /* _BinaryenSideEffectReadsGlobal */,\n  WritesGlobal = 32 /* _BinaryenSideEffectWritesGlobal */,\n  ReadsMemory = 64 /* _BinaryenSideEffectReadsMemory */,\n  WritesMemory = 128 /* _BinaryenSideEffectWritesMemory */,\n  ImplicitTrap = 256 /* _BinaryenSideEffectImplicitTrap */,\n  IsAtomic = 512 /* _BinaryenSideEffectIsAtomic */,\n  Throws = 1024 /* _BinaryenSideEffectThrows */,\n  DanglingPop = 2048 /* _BinaryenSideEffectDanglingPop */,\n  Any = 4095 /* _BinaryenSideEffectAny */\n}\n\nexport function getSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): SideEffects {\n  return binaryen._BinaryenExpressionGetSideEffects(expr, features);\n}\n\nexport function hasSideEffects(expr: ExpressionRef, features: FeatureFlags = FeatureFlags.All): bool {\n  return getSideEffects(expr, features) != SideEffects.None;\n}\n\n// helpers\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\n\nfunction allocU8Array(u8s: Uint8Array | null): usize {\n  if (!u8s) return 0;\n  var len = u8s.length;\n  var ptr = binaryen._malloc(len);\n  for (let i = 0; i < len; ++i) {\n    binaryen.__i32_store8(ptr + i, u8s[i]);\n  }\n  return ptr;\n}\n\nfunction allocI32Array(i32s: i32[] | null): usize {\n  if (!i32s) return 0;\n  var len = i32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  var idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = i32s[i];\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocU32Array(u32s: u32[] | null): usize {\n  if (!u32s) return 0;\n  var len = u32s.length;\n  var ptr = binaryen._malloc(len << 2);\n  var idx = ptr;\n  for (let i = 0; i < len; ++i) {\n    let val = u32s[i];\n    binaryen.__i32_store(idx, val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction allocPtrArray(ptrs: usize[] | null): usize {\n  if (!ptrs) return 0;\n  // TODO: WASM64\n  assert(ASC_TARGET != Target.WASM64);\n  var len = ptrs.length;\n  var ptr = binaryen._malloc(len << 2);\n  var idx = ptr;\n  for (let i = 0, k = len; i < k; ++i) {\n    let val = ptrs[i];\n    binaryen.__i32_store(idx, <i32>val);\n    idx += 4;\n  }\n  return ptr;\n}\n\nfunction stringLengthUTF8(str: string): usize {\n  var len = 0;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let u = str.charCodeAt(i);\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      len += 1;\n    } else if (u <= 0x7FF) {\n      len += 2;\n    } else if (u <= 0xFFFF) {\n      len += 3;\n    } else {\n      len += 4;\n    }\n  }\n  return len;\n}\n\nfunction allocString(str: string | null): usize {\n  if (str === null) return 0;\n  var ptr = binaryen._malloc(stringLengthUTF8(str) + 1) >>> 0;\n  // the following is based on Emscripten's stringToUTF8Array\n  var idx = ptr;\n  for (let i = 0, k = str.length; i < k; ++i) {\n    let u = str.charCodeAt(i);\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\n    }\n    if (u <= 0x7F) {\n      binaryen.__i32_store8(idx++, u as u8);\n    } else if (u <= 0x7FF) {\n      binaryen.__i32_store8(idx++, (0xC0 |  (u >>> 6)       ) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\n    } else if (u <= 0xFFFF) {\n      binaryen.__i32_store8(idx++, (0xE0 |  (u >>> 12)      ) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\n    } else {\n      assert(u < 0x200000, \"Invalid Unicode code point during allocString\");\n      binaryen.__i32_store8(idx++, (0xF0 |  (u >>> 18)      ) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>> 12) & 63)) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\n      binaryen.__i32_store8(idx++, (0x80 | ( u         & 63)) as u8);\n    }\n  }\n  binaryen.__i32_store8(idx, 0);\n  return ptr;\n}\n\nfunction readBuffer(ptr: usize, len: i32): Uint8Array {\n  var ret = new Uint8Array(len);\n  for (let i = 0; i < len; ++i) {\n    ret[i] = binaryen.__i32_load8_u(ptr + <usize>i);\n  }\n  return ret;\n}\n\nexport function readString(ptr: usize): string | null {\n  if (!ptr) return null;\n  var arr = new Array<i32>();\n  // the following is based on Emscripten's UTF8ArrayToString\n  var cp: u32;\n  var u1: u32, u2: u32, u3: u32;\n  while (cp = binaryen.__i32_load8_u(ptr++)) {\n    if (!(cp & 0x80)) {\n      arr.push(cp);\n      continue;\n    }\n    u1 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xE0) == 0xC0) {\n      arr.push(((cp & 31) << 6) | u1);\n      continue;\n    }\n    u2 = binaryen.__i32_load8_u(ptr++) & 63;\n    if ((cp & 0xF0) == 0xE0) {\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\n    } else {\n      u3 = binaryen.__i32_load8_u(ptr++) & 63;\n      if ((cp & 0xF8) == 0xF0) {\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\n      } else {\n        assert(false, \"Invalid UTF8 sequence during readString\");\n      }\n    }\n    if (cp < 0x10000) {\n      arr.push(cp);\n    } else {\n      let ch = cp - 0x10000;\n      arr.push(0xD800 | (ch >>> 10));\n      arr.push(0xDC00 | (ch & 0x3FF));\n    }\n  }\n  return String.fromCharCodes(arr);\n}\n\n/** Result structure of {@link Module#toBinary}. */\nexport class BinaryModule {\n  constructor(\n    /** WebAssembly binary. */\n    public output: Uint8Array,\n    /** Source map, if generated. */\n    public sourceMap: string | null\n  ) {}\n}\n\n/** Tests if an expression needs an explicit 'unreachable' when it is the terminating statement. */\nexport function needsExplicitUnreachable(expr: ExpressionRef): bool {\n  // not applicable if pushing a value to the stack\n  if (binaryen._BinaryenExpressionGetType(expr) != NativeType.Unreachable) {\n    return false;\n  }\n\n  switch (binaryen._BinaryenExpressionGetId(expr)) {\n    case ExpressionId.Unreachable:\n    case ExpressionId.Return: return false;\n    case ExpressionId.Break: {\n      return binaryen._BinaryenBreakGetCondition(expr) != 0;\n    }\n    case ExpressionId.Block: {\n      if (!binaryen._BinaryenBlockGetName(expr)) { // can't break out of it\n        let numChildren = binaryen._BinaryenBlockGetNumChildren(expr); // last child needs unreachable\n        return (\n          numChildren > 0 &&\n          needsExplicitUnreachable(binaryen._BinaryenBlockGetChildAt(expr, numChildren - 1))\n        );\n      }\n    }\n  }\n  return true;\n}\n\n/** Traverses all expression members of an expression, calling the given visitor. */\nexport function traverse<T>(\n  expr:  ExpressionRef,\n  data:  T,\n  visit: (expr: ExpressionRef, data: T) => void\n): bool {\n  switch (getExpressionId(expr)) {\n    case ExpressionId.Block: {\n      for (let i: Index = 0, n = binaryen._BinaryenBlockGetNumChildren(expr); i < n; ++i) {\n        visit(binaryen._BinaryenBlockGetChildAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.If: {\n      visit(binaryen._BinaryenIfGetCondition(expr), data);\n      visit(binaryen._BinaryenIfGetIfTrue(expr), data);\n      let ifFalse = binaryen._BinaryenIfGetIfFalse(expr);\n      if (ifFalse) visit(ifFalse, data);\n      break;\n    }\n    case ExpressionId.Loop: {\n      visit(binaryen._BinaryenLoopGetBody(expr), data);\n      break;\n    }\n    case ExpressionId.Break: {\n      let condition = binaryen._BinaryenBreakGetCondition(expr);\n      if (condition) visit(condition, data);\n      break;\n    }\n    case ExpressionId.Switch: {\n      visit(binaryen._BinaryenSwitchGetCondition(expr), data);\n      break;\n    }\n    case ExpressionId.Call: {\n      for (let i: Index = 0, n = binaryen._BinaryenCallGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenCallGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.CallIndirect: {\n      for (let i: Index = 0, n = binaryen._BinaryenCallIndirectGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenCallIndirectGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.LocalGet: {\n      break;\n    }\n    case ExpressionId.LocalSet: {\n      visit(binaryen._BinaryenLocalSetGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.GlobalGet: {\n      break;\n    }\n    case ExpressionId.GlobalSet: {\n      visit(binaryen._BinaryenGlobalSetGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Load: {\n      visit(binaryen._BinaryenLoadGetPtr(expr), data);\n      break;\n    }\n    case ExpressionId.Store: {\n      visit(binaryen._BinaryenStoreGetPtr(expr), data);\n      visit(binaryen._BinaryenStoreGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Const: {\n      break;\n    }\n    case ExpressionId.Unary: {\n      visit(binaryen._BinaryenUnaryGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Binary: {\n      visit(binaryen._BinaryenBinaryGetLeft(expr), data);\n      visit(binaryen._BinaryenBinaryGetRight(expr), data);\n      break;\n    }\n    case ExpressionId.Select: {\n      visit(binaryen._BinaryenSelectGetIfTrue(expr), data);\n      visit(binaryen._BinaryenSelectGetIfFalse(expr), data);\n      visit(binaryen._BinaryenSelectGetCondition(expr), data);\n      break;\n    }\n    case ExpressionId.Drop: {\n      visit(binaryen._BinaryenDropGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.Return: {\n      visit(binaryen._BinaryenReturnGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.MemorySize:\n      break;\n    case ExpressionId.MemoryGrow:\n      visit(binaryen._BinaryenMemoryGrowGetDelta(expr), data);\n      break;\n    case ExpressionId.Nop: {\n      break;\n    }\n    case ExpressionId.Unreachable: {\n      break;\n    }\n    case ExpressionId.AtomicRMW: {\n      visit(binaryen._BinaryenAtomicRMWGetPtr(expr), data);\n      visit(binaryen._BinaryenAtomicRMWGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicCmpxchg: {\n      visit(binaryen._BinaryenAtomicCmpxchgGetPtr(expr), data);\n      visit(binaryen._BinaryenAtomicCmpxchgGetExpected(expr), data);\n      visit(binaryen._BinaryenAtomicCmpxchgGetReplacement(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicWait: {\n      visit(binaryen._BinaryenAtomicWaitGetPtr(expr), data);\n      visit(binaryen._BinaryenAtomicWaitGetExpected(expr), data);\n      visit(binaryen._BinaryenAtomicWaitGetTimeout(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicNotify: {\n      visit(binaryen._BinaryenAtomicNotifyGetPtr(expr), data);\n      break;\n    }\n    case ExpressionId.AtomicFence: {\n      break;\n    }\n    case ExpressionId.SIMDExtract: {\n      visit(binaryen._BinaryenSIMDExtractGetVec(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDReplace: {\n      visit(binaryen._BinaryenSIMDReplaceGetVec(expr), data);\n      visit(binaryen._BinaryenSIMDReplaceGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDShuffle: {\n      visit(binaryen._BinaryenSIMDShuffleGetLeft(expr), data);\n      visit(binaryen._BinaryenSIMDShuffleGetRight(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDTernary: {\n      visit(binaryen._BinaryenSIMDTernaryGetA(expr), data);\n      visit(binaryen._BinaryenSIMDTernaryGetB(expr), data);\n      visit(binaryen._BinaryenSIMDTernaryGetC(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDShift: {\n      visit(binaryen._BinaryenSIMDShiftGetVec(expr), data);\n      visit(binaryen._BinaryenSIMDShiftGetShift(expr), data);\n      break;\n    }\n    case ExpressionId.SIMDLoad: {\n      visit(binaryen._BinaryenSIMDLoadGetPtr(expr), data);\n      break;\n    }\n    case ExpressionId.MemoryInit: {\n      visit(binaryen._BinaryenMemoryInitGetDest(expr), data);\n      visit(binaryen._BinaryenMemoryInitGetOffset(expr), data);\n      visit(binaryen._BinaryenMemoryInitGetSize(expr), data);\n      break;\n    }\n    case ExpressionId.DataDrop: {\n      break;\n    }\n    case ExpressionId.MemoryCopy: {\n      visit(binaryen._BinaryenMemoryCopyGetDest(expr), data);\n      visit(binaryen._BinaryenMemoryCopyGetSource(expr), data);\n      visit(binaryen._BinaryenMemoryCopyGetSize(expr), data);\n      break;\n    }\n    case ExpressionId.MemoryFill: {\n      visit(binaryen._BinaryenMemoryFillGetDest(expr), data);\n      visit(binaryen._BinaryenMemoryFillGetValue(expr), data);\n      visit(binaryen._BinaryenMemoryFillGetSize(expr), data);\n      break;\n    }\n    case ExpressionId.Pop: {\n      break;\n    }\n    case ExpressionId.RefNull: {\n      break;\n    }\n    case ExpressionId.RefIsNull: {\n      visit(binaryen._BinaryenRefIsNullGetValue(expr), data);\n      break;\n    }\n    case ExpressionId.RefFunc: {\n      break;\n    }\n    case ExpressionId.Try: {\n      visit(binaryen._BinaryenTryGetBody(expr), data);\n      visit(binaryen._BinaryenTryGetCatchBody(expr), data);\n      break;\n    }\n    case ExpressionId.Throw: {\n      for (let i: Index = 0, n = binaryen._BinaryenThrowGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenThrowGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.Rethrow: {\n      visit(binaryen._BinaryenRethrowGetExnref(expr), data);\n      break;\n    }\n    case ExpressionId.BrOnExn: {\n      visit(binaryen._BinaryenBrOnExnGetExnref(expr), data);\n      break;\n    }\n    case ExpressionId.TupleMake: {\n      for (let i: Index = 0, n = binaryen._BinaryenTupleMakeGetNumOperands(expr); i < n; ++i) {\n        visit(binaryen._BinaryenTupleMakeGetOperandAt(expr, i), data);\n      }\n      break;\n    }\n    case ExpressionId.TupleExtract: {\n      break;\n    }\n    default: assert(false);\n  }\n  return true;\n}\n","/**\n * @fileoverview A TypeScript parser for the AssemblyScript subset.\n *\n * Takes the tokens produced by the `Tokenizer` and builds an abstract\n * syntax tree composed of `Node`s wrapped in a `Source` out of it.\n *\n * @license Apache-2.0\n */\n\nimport {\n  CommonFlags,\n  LIBRARY_PREFIX,\n  PATH_DELIMITER\n} from \"./common\";\n\nimport {\n  Tokenizer,\n  Token,\n  Range,\n  CommentHandler,\n  IdentifierHandling,\n  isIllegalVariableIdentifier\n} from \"./tokenizer\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticEmitter,\n  DiagnosticMessage\n} from \"./diagnostics\";\n\nimport {\n  normalizePath\n} from \"./util\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  TypeNode,\n  TypeName,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  AssertionKind,\n  CallExpression,\n  ClassExpression,\n  FunctionExpression,\n  IdentifierExpression,\n  StringLiteralExpression,\n\n  Statement,\n  BlockStatement,\n  BreakStatement,\n  ClassDeclaration,\n  ContinueStatement,\n  DeclarationStatement,\n  DecoratorNode,\n  DoStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportImportStatement,\n  ExportMember,\n  ExportStatement,\n  ExpressionStatement,\n  ForOfStatement,\n  FunctionDeclaration,\n  IfStatement,\n  ImportDeclaration,\n  ImportStatement,\n  IndexSignatureNode,\n  NamespaceDeclaration,\n  ParameterNode,\n  ParameterKind,\n  ReturnStatement,\n  SwitchCase,\n  SwitchStatement,\n  ThrowStatement,\n  TryStatement,\n  TypeDeclaration,\n  TypeParameterNode,\n  VariableStatement,\n  VariableDeclaration,\n  VoidStatement,\n  WhileStatement,\n\n  mangleInternalPath\n} from \"./ast\";\n\n/** Represents a dependee. */\nclass Dependee {\n  constructor(\n    public source: Source,\n    public reportNode: Node\n  ) {}\n}\n\n/** Parser interface. */\nexport class Parser extends DiagnosticEmitter {\n\n  /** Source file names to be requested next. */\n  backlog: string[] = new Array();\n  /** Source file names already seen, that is processed or backlogged. */\n  seenlog: Set<string> = new Set();\n  /** Source file names already completely processed. */\n  donelog: Set<string> = new Set();\n  /** Optional handler to intercept comments while tokenizing. */\n  onComment: CommentHandler | null = null;\n  /** Current file being parsed. */\n  currentSource: Source | null = null;\n  /** Map of dependees being depended upon by a source, by path. */\n  dependees: Map<string, Dependee> = new Map();\n  /** An array of parsed sources. */\n  sources: Source[];\n\n  /** Constructs a new parser. */\n  constructor(\n    diagnostics: DiagnosticMessage[] | null = null,\n    sources: Source[] | null = null\n  ) {\n    super(diagnostics);\n    this.sources = sources ? sources : new Array<Source>();\n  }\n\n  /** Parses a file and adds its definitions to the program. */\n  parseFile(\n    /** Source text of the file, or `null` to indicate not found. */\n    text: string | null,\n    /** Normalized path of the file. */\n    path: string,\n    /** Whether this is an entry file. */\n    isEntry: bool\n  ): void {\n    // the frontend gives us paths with file extensions\n    var normalizedPath = normalizePath(path);\n    var internalPath = mangleInternalPath(path);\n\n    // check if already processed\n    if (this.donelog.has(internalPath)) return;\n    this.donelog.add(internalPath); // do not parse again\n    this.seenlog.add(internalPath); // do not request again\n\n    // check if this is an error\n    if (text === null) {\n      let dependees = this.dependees;\n      let dependee: Dependee | null = null;\n      if (dependees.has(internalPath)) dependee = assert(dependees.get(internalPath));\n      this.error(\n        DiagnosticCode.File_0_not_found,\n        dependee\n          ? dependee.reportNode.range\n          : null,\n        path\n      );\n      return;\n    }\n\n    // create the source element\n    var source = new Source(\n      isEntry\n        ? SourceKind.USER_ENTRY\n        : path.startsWith(LIBRARY_PREFIX)\n          ? path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\n            ? SourceKind.LIBRARY_ENTRY\n            : SourceKind.LIBRARY\n          : SourceKind.USER,\n      normalizedPath,\n      text\n    );\n\n    this.sources.push(source);\n    this.currentSource = source;\n\n    // tokenize and parse\n    var tn = new Tokenizer(source, this.diagnostics);\n    tn.onComment = this.onComment;\n    var statements = source.statements;\n    while (!tn.skip(Token.ENDOFFILE)) {\n      let statement = this.parseTopLevelStatement(tn, null);\n      if (statement) {\n        statements.push(statement);\n      } else {\n        this.skipStatement(tn);\n      }\n    }\n  }\n\n  /** Parses a top-level statement. */\n  parseTopLevelStatement(\n    tn: Tokenizer,\n    namespace: NamespaceDeclaration | null = null\n  ): Statement | null {\n    var flags = CommonFlags.NONE;\n    var startPos = -1;\n\n    // check decorators\n    var decorators: DecoratorNode[] | null = null;\n    while (tn.skip(Token.AT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      let decorator = this.parseDecorator(tn);\n      if (!decorator) {\n        this.skipStatement(tn);\n        continue;\n      }\n      if (!decorators) decorators = [decorator];\n      else decorators.push(decorator);\n    }\n\n    // check modifiers\n    var exportStart = 0;\n    var exportEnd = 0;\n    var defaultStart = 0;\n    var defaultEnd = 0;\n    if (tn.skip(Token.EXPORT)) {\n      if (startPos < 0) startPos = tn.tokenPos;\n      flags |= CommonFlags.EXPORT;\n      exportStart = tn.tokenPos;\n      exportEnd = tn.pos;\n      if (tn.skip(Token.DEFAULT)) {\n        defaultStart = tn.tokenPos;\n        defaultEnd = tn.pos;\n      }\n    }\n\n    var declareStart = 0;\n    var declareEnd = 0;\n    var contextIsAmbient = namespace != null && namespace.is(CommonFlags.AMBIENT);\n    if (tn.skip(Token.DECLARE)) {\n      if (contextIsAmbient) {\n        this.error(\n          DiagnosticCode.A_declare_modifier_cannot_be_used_in_an_already_ambient_context,\n          tn.range()\n        ); // recoverable\n      } else {\n        if (startPos < 0) startPos = tn.tokenPos;\n        declareStart = startPos;\n        declareEnd = tn.pos;\n        flags |= CommonFlags.DECLARE | CommonFlags.AMBIENT;\n      }\n    } else if (contextIsAmbient) {\n      flags |= CommonFlags.AMBIENT;\n    }\n\n    // parse the statement\n    var statement: Statement | null = null;\n\n    // handle declarations\n    var first = tn.peek();\n    if (startPos < 0) startPos = tn.nextTokenPos;\n    switch (first) {\n      case Token.CONST: {\n        tn.next();\n        flags |= CommonFlags.CONST;\n        if (tn.skip(Token.ENUM)) {\n          statement = this.parseEnum(tn, flags, decorators, startPos);\n        } else {\n          statement = this.parseVariable(tn, flags, decorators, startPos);\n        }\n        decorators = null;\n        break;\n      }\n      case Token.LET: flags |= CommonFlags.LET;\n      case Token.VAR: {\n        tn.next();\n        statement = this.parseVariable(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ENUM: {\n        tn.next();\n        statement = this.parseEnum(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.FUNCTION: {\n        tn.next();\n        statement = this.parseFunction(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.ABSTRACT: {\n        let state = tn.mark();\n        tn.next();\n        let abstractStart = tn.tokenPos;\n        let abstractEnd = tn.pos;\n        let next = tn.peek(true);\n        if (tn.nextTokenOnNewLine) {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        }\n        if (next != Token.CLASS) {\n          if (next == Token.INTERFACE) {\n            this.error(\n              DiagnosticCode._abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration,\n              tn.range(abstractStart, abstractEnd)\n            );\n          }\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n          break;\n        } else {\n          tn.discard(state);\n        }\n        flags |= CommonFlags.ABSTRACT;\n        // fall through\n      }\n      case Token.CLASS:\n      case Token.INTERFACE: {\n        tn.next();\n        statement = this.parseClassOrInterface(tn, flags, decorators, startPos);\n        decorators = null;\n        break;\n      }\n      case Token.NAMESPACE: {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseNamespace(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      case Token.IMPORT: {\n        tn.next();\n        flags |= CommonFlags.IMPORT;\n        if (flags & CommonFlags.EXPORT) {\n          statement = this.parseExportImport(tn, startPos);\n        } else {\n          statement = this.parseImport(tn);\n        }\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          tn.discard(state);\n          statement = this.parseTypeDeclaration(tn, flags, decorators, startPos);\n          decorators = null;\n        } else {\n          tn.reset(state);\n          statement = this.parseStatement(tn, true);\n        }\n        break;\n      }\n      default: {\n\n        // handle plain exports\n        if (flags & CommonFlags.EXPORT) {\n          if (defaultEnd && tn.skipIdentifier(IdentifierHandling.PREFER)) {\n            if (declareEnd) {\n              this.error(\n                DiagnosticCode.An_export_assignment_cannot_have_modifiers,\n                tn.range(declareStart, declareEnd)\n              );\n            }\n            statement = this.parseExportDefaultAlias(tn, startPos, defaultStart, defaultEnd);\n            defaultStart = defaultEnd = 0; // consume\n          } else {\n            statement = this.parseExport(tn, startPos, (flags & CommonFlags.DECLARE) != 0);\n          }\n\n        // handle non-declaration statements\n        } else {\n          if (exportEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(exportStart, exportEnd), \"export\"\n            ); // recoverable\n          }\n          if (declareEnd) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(declareStart, declareEnd), \"declare\"\n            ); // recoverable\n          }\n          if (!namespace) {\n            statement = this.parseStatement(tn, true);\n          } // TODO: else?\n        }\n        break;\n      }\n    }\n\n    // check for decorators that weren't consumed\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          decorators[i].range\n        );\n      }\n    }\n\n    // check if this an `export default` declaration\n    if (defaultEnd && statement !== null) {\n      switch (statement.kind) {\n        case NodeKind.ENUMDECLARATION:\n        case NodeKind.FUNCTIONDECLARATION:\n        case NodeKind.CLASSDECLARATION:\n        case NodeKind.INTERFACEDECLARATION:\n        case NodeKind.NAMESPACEDECLARATION: {\n          return Node.createExportDefaultStatement(<DeclarationStatement>statement, tn.range(startPos, tn.pos));\n        }\n        default: {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(defaultStart, defaultEnd), \"default\"\n          );\n        }\n      }\n    }\n    return statement;\n  }\n\n  /** Obtains the next file to parse. */\n  nextFile(): string | null {\n    var backlog = this.backlog;\n    return backlog.length ? assert(backlog.shift()) : null;\n  }\n\n  /** Obtains the path of the dependee of the given imported file. */\n  getDependee(dependent: string): string | null {\n    var dependees = this.dependees;\n    if (dependees.has(dependent)) {\n      let dependee = assert(dependees.get(dependent));\n      return dependee.source.internalPath;\n    }\n    return null;\n  }\n\n  /** Finishes parsing. */\n  finish(): void {\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\n    this.backlog = [];\n    this.seenlog.clear();\n    this.donelog.clear();\n    this.dependees.clear();\n  }\n\n  // types\n\n  /** Parses a type name. */\n  parseTypeName(\n    tn: Tokenizer\n  ): TypeName | null {\n\n    // at: Identifier ('.' Identifier)*\n\n    var first = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n    var current = first;\n    while (tn.skip(Token.DOT)) {\n      if (tn.skip(Token.IDENTIFIER)) {\n        let next = Node.createSimpleTypeName(tn.readIdentifier(), tn.range());\n        current.next = next;\n        current = next;\n      } else {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range(tn.pos)\n        );\n        return null;\n      }\n    }\n    return first;\n  }\n\n  /** Parses a type. */\n  parseType(\n    tn: Tokenizer,\n    acceptParenthesized: bool = true,\n    suppressErrors: bool = false\n  ): TypeNode | null {\n\n    // before: Type\n\n    // NOTE: this parses our limited subset\n    var token = tn.next();\n    var startPos = tn.tokenPos;\n\n    var type: TypeNode;\n\n    // '(' ...\n    if (token == Token.OPENPAREN) {\n\n      // '(' FunctionSignature ')' '|' 'null'?\n      let isNullableSignature = tn.skip(Token.OPENPAREN);\n      // FunctionSignature?\n      let signature = this.tryParseFunctionType(tn);\n      if (signature) {\n        if (isNullableSignature) {\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \")\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.BAR)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"|\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.NULL)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          signature.isNullable = true;\n        }\n        return signature;\n      } else if (isNullableSignature || this.tryParseSignatureIsSignature) {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n      // Type (',' Type)* ')'\n      if (acceptParenthesized) {\n        let innerType = this.parseType(tn, false, suppressErrors);\n        if (!innerType) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \")\"\n            );\n          }\n          return null;\n        }\n        type = innerType;\n        type.range.start = startPos;\n        type.range.end = tn.pos;\n      } else {\n        this.error(\n          DiagnosticCode.Unexpected_token,\n          tn.range()\n        );\n        return null;\n      }\n\n    // 'void'\n    } else if (token == Token.VOID) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'this'\n    } else if (token == Token.THIS) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"this\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'true'\n    } else if (token == Token.TRUE || token == Token.FALSE) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // 'null'\n    } else if (token == Token.NULL) {\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"null\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // StringLiteral\n    } else if (token == Token.STRINGLITERAL) {\n      tn.readString();\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\n      );\n\n    // Identifier\n    } else if (token == Token.IDENTIFIER) {\n      let name = this.parseTypeName(tn);\n      if (!name) return null;\n      let parameters: TypeNode[] | null = null;\n\n      // Name<T>\n      if (tn.skip(Token.LESSTHAN)) {\n        do {\n          let parameter = this.parseType(tn, true, suppressErrors);\n          if (!parameter) return null;\n          if (!parameters) parameters = [ parameter ];\n          else parameters.push(parameter);\n        } while (tn.skip(Token.COMMA));\n        if (!tn.skip(Token.GREATERTHAN)) {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(tn.pos), \">\"\n            );\n          }\n          return null;\n        }\n      }\n      if (!parameters) parameters = [];\n      type = Node.createNamedType(name, parameters, false, tn.range(startPos, tn.pos));\n    } else {\n      if (!suppressErrors) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        );\n      }\n      return null;\n    }\n    // ... | null\n    while (tn.skip(Token.BAR)) {\n      if (tn.skip(Token.NULL)) {\n        type.isNullable = true;\n      } else {\n        let notNullStart = tn.pos;\n        let notNull = this.parseType(tn, false, true);\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            notNull ? notNull.range : tn.range(notNullStart), \"null\"\n          );\n        }\n        return null;\n      }\n    }\n    // ... [][]\n    while (tn.skip(Token.OPENBRACKET)) {\n      let bracketStart = tn.tokenPos;\n      if (!tn.skip(Token.CLOSEBRACKET)) {\n        if (!suppressErrors) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"]\"\n          );\n        }\n        return null;\n      }\n      let bracketRange = tn.range(bracketStart, tn.pos);\n\n      // ...[] | null\n      let nullable = false;\n      if (tn.skip(Token.BAR)) {\n        if (tn.skip(Token.NULL)) {\n          nullable = true;\n        } else {\n          if (!suppressErrors) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"null\"\n            );\n          }\n          return null;\n        }\n      }\n      type = Node.createNamedType(\n        Node.createSimpleTypeName(\"Array\", bracketRange),\n        [ type ],\n        nullable,\n        tn.range(startPos, tn.pos)\n      );\n      if (nullable) break;\n    }\n\n    return type;\n  }\n\n  // Indicates whether tryParseSignature determined that it is handling a Signature\n  private tryParseSignatureIsSignature: bool = false;\n\n  /** Parses a function type, as used in type declarations. */\n  tryParseFunctionType(\n    tn: Tokenizer\n  ): FunctionTypeNode | null {\n\n    // at '(': ('...'? Identifier '?'? ':' Type (','  '...'? Identifier '?'? ':' Type)* )? ')' '=>' Type\n\n    var state = tn.mark();\n    var startPos = tn.tokenPos;\n    var parameters: ParameterNode[] | null = null;\n    var thisType: NamedTypeNode | null = null;\n    var isSignature: bool = false;\n    var firstParamNameNoType: IdentifierExpression | null = null;\n    var firstParamKind: ParameterKind = ParameterKind.DEFAULT;\n\n    if (tn.skip(Token.CLOSEPAREN)) {\n      isSignature = true;\n      tn.discard(state);\n      parameters = [];\n\n    } else {\n      isSignature = false; // not yet known\n      do {\n        let paramStart = -1;\n        let kind = ParameterKind.DEFAULT;\n        if (tn.skip(Token.DOT_DOT_DOT)) {\n          paramStart = tn.tokenPos;\n          isSignature = true;\n          tn.discard(state);\n          kind = ParameterKind.REST;\n        }\n        if (tn.skip(Token.THIS)) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn, false);\n            if (!type) return null;\n            if (type.kind != NodeKind.NAMEDTYPE) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                type.range\n              );\n              this.tryParseSignatureIsSignature = true;\n              return null;\n            }\n            thisType = <NamedTypeNode>type;\n          } else {\n            tn.reset(state);\n            this.tryParseSignatureIsSignature = false;\n            return null;\n          }\n        } else if (tn.skipIdentifier()) {\n          if (paramStart < 0) paramStart = tn.tokenPos;\n          let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range(tn.tokenPos, tn.pos));\n          if (tn.skip(Token.QUESTION)) {\n            isSignature = true;\n            tn.discard(state);\n            if (kind == ParameterKind.REST) {\n              this.error(\n                DiagnosticCode.A_rest_parameter_cannot_be_optional,\n                tn.range()\n              ); // recoverable\n            } else {\n              kind = ParameterKind.OPTIONAL;\n            }\n          }\n          if (tn.skip(Token.COLON)) {\n            isSignature = true;\n            tn.discard(state);\n            let type = this.parseType(tn); // not suppressing errors because known\n            if (!type) {\n              this.tryParseSignatureIsSignature = isSignature;\n              return null;\n            }\n            let param = Node.createParameter(kind, name, type, null, tn.range(paramStart, tn.pos));\n            if (!parameters) parameters = [ param ];\n            else parameters.push(param);\n          } else {\n            if (!isSignature) {\n              if (tn.peek() == Token.COMMA) {\n                isSignature = true;\n                tn.discard(state);\n              }\n            }\n            if (isSignature) {\n              let param = Node.createParameter(kind, name, Node.createOmittedType(tn.range(tn.pos)), null, tn.range(paramStart, tn.pos));\n              if (!parameters) parameters = [ param ];\n              else parameters.push(param);\n              this.error(\n                DiagnosticCode.Type_expected,\n                param.type.range\n              ); // recoverable\n            } else if (!parameters) {\n              // on '(' Identifier ^',' we don't yet know whether this is a\n              // parenthesized or a function type, hence we have to delay the\n              // respective diagnostic until we know for sure.\n              firstParamNameNoType = name;\n              firstParamKind = kind;\n            }\n          }\n        } else {\n          if (isSignature) {\n            this.error(\n              DiagnosticCode.Identifier_expected,\n              tn.range()\n            );\n          } else {\n            tn.reset(state);\n          }\n          this.tryParseSignatureIsSignature = isSignature;\n          return null;\n        }\n      } while (tn.skip(Token.COMMA));\n      if (!tn.skip(Token.CLOSEPAREN)) {\n        if (isSignature) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        } else {\n          tn.reset(state);\n        }\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    }\n\n    var returnType: TypeNode | null;\n    if (tn.skip(Token.EQUALS_GREATERTHAN)) {\n      if (!isSignature) {\n        isSignature = true;\n        tn.discard(state);\n        if (firstParamNameNoType) { // now we know\n          let param = Node.createParameter(\n            firstParamKind,\n            firstParamNameNoType,\n            Node.createOmittedType(firstParamNameNoType.range.atEnd),\n            null,\n            firstParamNameNoType.range\n          );\n          if (!parameters) parameters = [ param ];\n          else parameters.push(param);\n          this.error(\n            DiagnosticCode.Type_expected,\n            param.type.range\n          ); // recoverable\n        }\n      }\n      returnType = this.parseType(tn);\n      if (!returnType) {\n        this.tryParseSignatureIsSignature = isSignature;\n        return null;\n      }\n    } else {\n      if (isSignature) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=>\"\n        );\n      } else {\n        tn.reset(state);\n      }\n      this.tryParseSignatureIsSignature = isSignature;\n      return null;\n    }\n    this.tryParseSignatureIsSignature = true;\n    if (!parameters) parameters = [];\n    return Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  // statements\n\n  parseDecorator(\n    tn: Tokenizer\n  ): DecoratorNode | null {\n\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\n\n    var startPos = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let name = tn.readIdentifier();\n      let expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\n      while (tn.skip(Token.DOT)) {\n        if (tn.skipIdentifier(IdentifierHandling.PREFER)) {\n          name = tn.readIdentifier();\n          expression = Node.createPropertyAccessExpression(\n            expression,\n            Node.createIdentifierExpression(name, tn.range()),\n            tn.range(startPos, tn.pos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let args: Expression[] | null;\n      if (tn.skip(Token.OPENPAREN)) {\n        args = this.parseArguments(tn);\n        if (args) {\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\n        }\n      } else {\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVariable(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32,\n    isFor: bool = false\n  ): VariableStatement | null {\n\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\n\n    var declarations = new Array<VariableDeclaration>();\n    do {\n      let declaration = this.parseVariableDeclaration(tn, flags, decorators, isFor);\n      if (!declaration) return null;\n      declarations.push(declaration);\n    } while (tn.skip(Token.COMMA));\n\n    var ret = Node.createVariableStatement(decorators, declarations, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseVariableDeclaration(\n    tn: Tokenizer,\n    parentFlags: CommonFlags,\n    parentDecorators: DecoratorNode[] | null,\n    isFor: bool = false\n  ): VariableDeclaration | null {\n\n    // before: Identifier (':' Type)? ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (isIllegalVariableIdentifier(identifier.text)) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        identifier.range\n      );\n    }\n    var flags = parentFlags;\n    if (tn.skip(Token.EXCLAMATION)) {\n      flags |= CommonFlags.DEFINITELY_ASSIGNED;\n    }\n\n    var type: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      type = this.parseType(tn, true);\n    }\n\n    var initializer: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n      initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!initializer) return null;\n    } else if (!isFor) {\n      if (flags & CommonFlags.CONST) {\n        if (!(flags & CommonFlags.AMBIENT)) {\n          this.error(\n            DiagnosticCode._const_declarations_must_be_initialized,\n            identifier.range\n          ); // recoverable\n        }\n      } else if (!type) { // neither type nor initializer\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range(tn.pos)\n        ); // recoverable\n      }\n    }\n    var range = Range.join(identifier.range, tn.range());\n    if (initializer !== null && (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0) {\n      this.error(\n        DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n        range\n      );\n    }\n    return Node.createVariableDeclaration(\n      identifier,\n      parentDecorators,\n      flags,\n      type,\n      initializer,\n      range\n    );\n  }\n\n  parseEnum(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): EnumDeclaration | null {\n\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\n\n    if (tn.next() != Token.IDENTIFIER) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    if (tn.next() != Token.OPENBRACE) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n    var members = new Array<EnumValueDeclaration>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let member = this.parseEnumValue(tn, CommonFlags.NONE);\n      if (!member) return null;\n      members.push(member);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEBRACE)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          return null;\n        }\n      }\n    }\n    var ret = Node.createEnumDeclaration(\n      identifier,\n      decorators,\n      flags,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseEnumValue(\n    tn: Tokenizer,\n    parentFlags: CommonFlags\n  ): EnumValueDeclaration | null {\n\n    // before: Identifier ('=' Expression)?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var value: Expression | null = null;\n    if (tn.skip(Token.EQUALS)) {\n      value = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!value) return null;\n    }\n    return Node.createEnumValueDeclaration(\n      identifier,\n      parentFlags,\n      value,\n      Range.join(identifier.range, tn.range())\n    );\n  }\n\n  parseReturn(\n    tn: Tokenizer\n  ): ReturnStatement | null {\n\n    // at 'return': Expression | (';' | '}' | ...'\\n')\n\n    var startPos = tn.tokenPos;\n    var expr: Expression | null = null;\n    if (\n      tn.peek(true) != Token.SEMICOLON &&\n      tn.nextToken != Token.CLOSEBRACE &&\n      !tn.nextTokenOnNewLine\n    ) {\n      if (!(expr = this.parseExpression(tn))) return null;\n    }\n\n    var ret = Node.createReturnStatement(expr, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTypeParameters(\n    tn: Tokenizer\n  ): TypeParameterNode[] | null {\n\n    // at '<': TypeParameter (',' TypeParameter)* '>'\n\n    var typeParameters = new Array<TypeParameterNode>();\n    var seenOptional = false;\n    var start = tn.tokenPos;\n    while (!tn.skip(Token.GREATERTHAN)) {\n      let typeParameter = this.parseTypeParameter(tn);\n      if (!typeParameter) return null;\n      if (typeParameter.defaultType !== null) {\n        seenOptional = true;\n      } else if (seenOptional) {\n        this.error(\n          DiagnosticCode.Required_type_parameters_may_not_follow_optional_type_parameters,\n          typeParameter.range\n        );\n        typeParameter.defaultType = null;\n      }\n      typeParameters.push(typeParameter);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.GREATERTHAN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n      }\n    }\n    if (!typeParameters.length) {\n      this.error(\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\n        tn.range(start, tn.pos)\n      ); // recoverable\n    }\n    return typeParameters;\n  }\n\n  parseTypeParameter(\n    tn: Tokenizer\n  ): TypeParameterNode | null {\n\n    // before: Identifier ('extends' Type)? ('=' Type)?\n\n    if (tn.next() == Token.IDENTIFIER) {\n      let identifier = Node.createIdentifierExpression(\n        tn.readIdentifier(),\n        tn.range()\n      );\n      let extendsType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EXTENDS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        extendsType = <NamedTypeNode>type;\n      }\n      let defaultType: NamedTypeNode | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        defaultType = <NamedTypeNode>type;\n      }\n      return Node.createTypeParameter(\n        identifier,\n        extendsType,\n        defaultType,\n        Range.join(identifier.range, tn.range())\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  private parseParametersThis: NamedTypeNode | null = null;\n\n  parseParameters(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode[] | null {\n\n    // at '(': (Parameter (',' Parameter)*)? ')'\n\n    var parameters = new Array<ParameterNode>();\n    var seenRest: ParameterNode | null = null;\n    var seenOptional = false;\n    var reportedRest = false;\n    var thisType: TypeNode | null = null;\n\n    // check if there is a leading `this` parameter\n    this.parseParametersThis = null;\n    if (tn.skip(Token.THIS)) {\n      if (tn.skip(Token.COLON)) {\n        thisType = this.parseType(tn); // reports\n        if (!thisType) return null;\n        if (thisType.kind == NodeKind.NAMEDTYPE) {\n          this.parseParametersThis = <NamedTypeNode>thisType;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            thisType.range\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n        return null;\n      }\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          return parameters;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let param = this.parseParameter(tn, isConstructor); // reports\n      if (!param) return null;\n      if (seenRest !== null && !reportedRest) {\n        this.error(\n          DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\n          seenRest.name.range\n        );\n        reportedRest = true;\n      }\n      switch (param.parameterKind) {\n        default: {\n          if (seenOptional) {\n            this.error(\n              DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\n              param.name.range\n            );\n          }\n          break;\n        }\n        case ParameterKind.OPTIONAL: {\n          seenOptional = true;\n          break;\n        }\n        case ParameterKind.REST: {\n          seenRest = param;\n          break;\n        }\n      }\n      parameters.push(param);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return parameters;\n  }\n\n  parseParameter(\n    tn: Tokenizer,\n    isConstructor: bool = false\n  ): ParameterNode | null {\n\n    // before: ('public' | 'private' | 'protected' | '...')? Identifier '?'? (':' Type)? ('=' Expression)?\n\n    var isRest = false;\n    var isOptional = false;\n    var startRange: Range | null = null;\n    var accessFlags: CommonFlags = CommonFlags.NONE;\n    if (isConstructor) {\n      if (tn.skip(Token.PUBLIC)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PUBLIC;\n      } else if (tn.skip(Token.PROTECTED)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PROTECTED;\n      } else if (tn.skip(Token.PRIVATE)) {\n        startRange = tn.range();\n        accessFlags |= CommonFlags.PRIVATE;\n      }\n      if (tn.peek() == Token.READONLY) {\n        let state = tn.mark();\n        tn.next();\n        if (tn.peek() != Token.COLON) { // modifier\n          tn.discard(state);\n          if (!startRange) startRange = tn.range();\n          accessFlags |= CommonFlags.READONLY;\n        } else { // identifier\n          tn.reset(state);\n        }\n      }\n    }\n    if (tn.skip(Token.DOT_DOT_DOT)) {\n      if (accessFlags) {\n        this.error(\n          DiagnosticCode.A_parameter_property_cannot_be_declared_using_a_rest_parameter,\n          tn.range()\n        );\n      } else {\n        startRange = tn.range();\n      }\n      isRest = true;\n    }\n    if (tn.skipIdentifier()) {\n      if (!isRest) startRange = tn.range();\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let type: TypeNode | null = null;\n      if (isOptional = tn.skip(Token.QUESTION)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\n            identifier.range\n          );\n        }\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        type = Node.createOmittedType(tn.range(tn.pos));\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        if (isRest) {\n          this.error(\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\n            identifier.range\n          );\n        }\n        if (isOptional) {\n          this.error(\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\n            identifier.range\n          );\n        } else {\n          isOptional = true;\n        }\n        initializer = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (!initializer) return null;\n      }\n      let param = Node.createParameter(\n        isRest\n          ? ParameterKind.REST\n          : isOptional\n            ? ParameterKind.OPTIONAL\n            : ParameterKind.DEFAULT,\n        identifier,\n        type,\n        initializer,\n        Range.join(assert(startRange), tn.range())\n      );\n      param.flags |= accessFlags;\n      return param;\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseFunction(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): FunctionDeclaration | null {\n\n    // at 'function':\n    //  Identifier\n    //  ('<' TypeParameters)?\n    //  '(' Parameters (':' Type)?\n    //  '{' Statement* '}'\n    //  ';'?\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range(tn.pos)\n      );\n      return null;\n    }\n\n    var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    var signatureStart = -1;\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      signatureStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    if (!tn.skip(Token.OPENPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"(\"\n      );\n      return null;\n    }\n\n    if (signatureStart < 0) {\n      signatureStart = tn.tokenPos;\n    }\n\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n    var thisType = this.parseParametersThis;\n\n    var isSetter = (flags & CommonFlags.SET) != 0;\n    if (isSetter) {\n      if (parameters.length != 1) {\n        this.error(\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n          name.range\n        ); // recoverable\n      }\n      if (parameters.length > 0 && parameters[0].initializer !== null) {\n        this.error(\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    if (flags & CommonFlags.GET) {\n      if (parameters.length) {\n        this.error(\n          DiagnosticCode.A_get_accessor_cannot_have_parameters,\n          name.range\n        ); // recoverable\n      }\n    }\n\n    var returnType: TypeNode | null = null;\n    if (tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn, true, isSetter);\n      if (!returnType) return null;\n    }\n\n    if (!returnType) {\n      returnType = Node.createOmittedType(\n        tn.range(tn.pos)\n      );\n      if (!isSetter) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnType.range\n        ); // recoverable\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      thisType,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (tn.skip(Token.OPENBRACE)) {\n      if (flags & CommonFlags.AMBIENT) {\n        this.error(\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n          tn.range()\n        ); // recoverable\n      }\n\n      body = this.parseBlockStatement(tn, false);\n      if (!body) return null;\n    } else if (!(flags & CommonFlags.AMBIENT)) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        tn.range(tn.pos)\n      );\n    }\n\n    var ret = Node.createFunctionDeclaration(\n      name,\n      decorators,\n      flags,\n      typeParameters,\n      signature,\n      body,\n      ArrowKind.NONE,\n      tn.range(startPos, tn.pos)\n    );\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n    var arrowKind = ArrowKind.NONE;\n\n    // either at 'function':\n    //  Identifier?\n    //  '(' Parameters (':' Type)?\n    //  Statement\n\n    if (tn.token == Token.FUNCTION) {\n      if (tn.skipIdentifier()) {\n        name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      } else { // empty name\n        name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n      }\n      if (!tn.skip(Token.OPENPAREN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"(\"\n        );\n        return null;\n      }\n\n      // or at '(' of arrow function:\n      //  Parameters (':' Type)?\n      //  Statement\n\n    } else {\n      arrowKind = ArrowKind.ARROW_PARENTHESIZED;\n      assert(tn.token == Token.OPENPAREN);\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.tokenPos));\n    }\n\n    // TODO: type parameters? doesn't seem worth it.\n\n    var signatureStart = tn.pos;\n    var parameters = this.parseParameters(tn);\n    if (!parameters) return null;\n\n    return this.parseFunctionExpressionCommon(tn, name, parameters, this.parseParametersThis, arrowKind, startPos, signatureStart);\n  }\n\n  private parseFunctionExpressionCommon(\n    tn: Tokenizer,\n    name: IdentifierExpression,\n    parameters: ParameterNode[],\n    explicitThis: NamedTypeNode | null,\n    arrowKind: ArrowKind,\n    startPos: i32 = -1,\n    signatureStart: i32 = -1\n  ): FunctionExpression | null {\n    if (startPos < 0) startPos = name.range.start;\n    if (signatureStart < 0) signatureStart = startPos;\n\n    var returnType: TypeNode | null = null;\n    if (arrowKind != ArrowKind.ARROW_SINGLE && tn.skip(Token.COLON)) {\n      returnType = this.parseType(tn);\n      if (!returnType) return null;\n    } else {\n      returnType = Node.createOmittedType(tn.range(tn.pos));\n    }\n\n    if (arrowKind) {\n      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"=>\"\n        );\n        return null;\n      }\n    }\n\n    var signature = Node.createFunctionType(\n      parameters,\n      returnType,\n      explicitThis,\n      false,\n      tn.range(signatureStart, tn.pos)\n    );\n\n    var body: Statement | null = null;\n    if (arrowKind) {\n      if (tn.skip(Token.OPENBRACE)) {\n        body = this.parseBlockStatement(tn, false);\n      } else {\n        let bodyExpression = this.parseExpression(tn, Precedence.COMMA + 1);\n        if (bodyExpression) body = Node.createExpressionStatement(bodyExpression);\n      }\n    } else {\n      if (!tn.skip(Token.OPENBRACE)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(tn.pos), \"{\"\n        );\n        return null;\n      }\n      body = this.parseBlockStatement(tn, false);\n    }\n    if (!body) return null;\n\n    var declaration = Node.createFunctionDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      signature,\n      body,\n      arrowKind,\n      tn.range(startPos, tn.pos)\n    );\n    return Node.createFunctionExpression(declaration);\n  }\n\n  parseClassOrInterface(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): ClassDeclaration | null {\n\n    // at ('class' | 'interface'):\n    //   Identifier\n    //   ('<' TypeParameters)?\n    //   ('extends' Type)?\n    //   ('implements' Type (',' Type)*)?\n    //   '{' ClassMember* '}'\n\n    var isInterface = tn.token == Token.INTERFACE;\n\n    if (!tn.skipIdentifier()) {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n      return null;\n    }\n\n    var identifier = Node.createIdentifierExpression(\n      tn.readIdentifier(),\n      tn.range()\n    );\n\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      flags |= CommonFlags.GENERIC;\n    }\n\n    var extendsType: NamedTypeNode | null = null;\n    if (tn.skip(Token.EXTENDS)) {\n      let type = this.parseType(tn);\n      if (!type) return null;\n      if (type.kind != NodeKind.NAMEDTYPE) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          type.range\n        );\n        return null;\n      }\n      extendsType = <NamedTypeNode>type;\n    }\n\n    var implementsTypes: NamedTypeNode[] | null = null;\n    if (tn.skip(Token.IMPLEMENTS)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode.Interface_declaration_cannot_have_implements_clause,\n          tn.range()\n        ); // recoverable\n      }\n      do {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        if (type.kind != NodeKind.NAMEDTYPE) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            type.range\n          );\n          return null;\n        }\n        if (!isInterface) {\n          if (!implementsTypes) implementsTypes = [];\n          implementsTypes.push(<NamedTypeNode>type);\n        }\n      } while (tn.skip(Token.COMMA));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration: ClassDeclaration;\n    if (isInterface) {\n      assert(!implementsTypes);\n      declaration = Node.createInterfaceDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        null,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    } else {\n      declaration = Node.createClassDeclaration(\n        identifier,\n        decorators,\n        flags,\n        typeParameters,\n        extendsType,\n        implementsTypes,\n        members,\n        tn.range(startPos, tn.pos)\n      );\n    }\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(member instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return declaration;\n  }\n\n  parseClassExpression(tn: Tokenizer): ClassExpression | null {\n\n    // at 'class': Identifier? '{' ... '}'\n\n    var startPos = tn.tokenPos;\n    var name: IdentifierExpression;\n\n    if (tn.skipIdentifier()) {\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    } else {\n      name = Node.createEmptyIdentifierExpression(tn.range(tn.pos));\n    }\n\n    if (!tn.skip(Token.OPENBRACE)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(tn.pos), \"{\"\n      );\n      return null;\n    }\n\n    var members = new Array<DeclarationStatement>();\n    var declaration = Node.createClassDeclaration(\n      name,\n      null,\n      CommonFlags.NONE,\n      null,\n      null,\n      null,\n      members,\n      tn.range(startPos, tn.pos)\n    );\n    if (!tn.skip(Token.CLOSEBRACE)) {\n      do {\n        let member = this.parseClassMember(tn, declaration);\n        if (member) {\n          if (member.kind == NodeKind.INDEXSIGNATURE) {\n            declaration.indexSignature = <IndexSignatureNode>member;\n          } else {\n            assert(declaration instanceof DeclarationStatement);\n            members.push(<DeclarationStatement>member);\n          }\n        } else {\n          this.skipStatement(tn);\n          if (tn.skip(Token.ENDOFFILE)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      } while (!tn.skip(Token.CLOSEBRACE));\n    }\n    declaration.range.end = tn.pos;\n    return Node.createClassExpression(declaration);\n  }\n\n  parseClassMember(\n    tn: Tokenizer,\n    parent: ClassDeclaration\n  ): Node | null {\n\n    // before:\n    //   ('public' | 'private' | 'protected')?\n    //   ('static' | 'abstract')?\n    //   'readonly'?\n    //   ('get' | 'set')?\n    //   Identifier ...\n\n    var isInterface = parent.kind == NodeKind.INTERFACEDECLARATION;\n    var startPos = 0;\n    var decorators: DecoratorNode[] | null = null;\n    if (tn.skip(Token.AT)) {\n      startPos = tn.tokenPos;\n      do {\n        let decorator = this.parseDecorator(tn);\n        if (!decorator) break;\n        if (!decorators) decorators = new Array();\n        decorators.push(decorator);\n      } while (tn.skip(Token.AT));\n      if (isInterface && decorators !== null) {\n        this.error(\n          DiagnosticCode.Decorators_are_not_valid_here,\n          Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n        );\n      }\n    }\n\n    // inherit ambient status\n    var flags = parent.flags & CommonFlags.AMBIENT;\n\n    // implemented methods are virtual\n    if (isInterface) flags |= CommonFlags.VIRTUAL;\n\n    var accessStart = 0;\n    var accessEnd = 0;\n    if (tn.skip(Token.PUBLIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"public\"\n        );\n      } else {\n        flags |= CommonFlags.PUBLIC;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PRIVATE)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"private\"\n        );\n      } else {\n        flags |= CommonFlags.PRIVATE;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else if (tn.skip(Token.PROTECTED)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"protected\"\n        );\n      } else {\n        flags |= CommonFlags.PROTECTED;\n        accessStart = tn.tokenPos;\n        accessEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    }\n\n    var staticStart = 0;\n    var staticEnd = 0;\n    var abstractStart = 0;\n    var abstractEnd = 0;\n    if (tn.skip(Token.STATIC)) {\n      if (isInterface) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(), \"static\"\n        );\n      } else {\n        flags |= CommonFlags.STATIC;\n        staticStart = tn.tokenPos;\n        staticEnd = tn.pos;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n    } else {\n      flags |= CommonFlags.INSTANCE;\n      if (tn.skip(Token.ABSTRACT)) {\n        if (isInterface || !parent.is(CommonFlags.ABSTRACT)) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(), \"abstract\"\n          );\n        } else {\n          flags |= CommonFlags.ABSTRACT;\n          abstractStart = tn.tokenPos;\n          abstractEnd = tn.pos;\n        }\n        if (!startPos) startPos = tn.tokenPos;\n      }\n      if (parent.flags & CommonFlags.GENERIC) flags |= CommonFlags.GENERIC_CONTEXT;\n    }\n\n    var readonlyStart = 0;\n    var readonlyEnd = 0;\n    if (tn.peek() == Token.READONLY) {\n      let state = tn.mark();\n      tn.next();\n      if (tn.peek() != Token.COLON) { // modifier\n        tn.discard(state);\n        flags |= CommonFlags.READONLY;\n        readonlyStart = tn.tokenPos;\n        readonlyEnd = tn.pos;\n        if (!startPos) startPos = readonlyStart;\n      } else { // identifier\n        tn.reset(state);\n      }\n    }\n\n    // check if accessor: ('get' | 'set') ^\\n Identifier\n    var state = tn.mark();\n    var isConstructor = false;\n    var isGetter = false;\n    var getStart = 0;\n    var getEnd = 0;\n    var isSetter = false;\n    var setStart = 0;\n    var setEnd = 0;\n    if (!isInterface) {\n      if (tn.skip(Token.GET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.GET;\n          isGetter = true;\n          getStart = tn.tokenPos;\n          getEnd = tn.pos;\n          if (!startPos) startPos = getStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.SET)) {\n        if (tn.peek(true, IdentifierHandling.PREFER) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n          flags |= CommonFlags.SET;\n          isSetter = true;\n          setStart = tn.tokenPos;\n          setEnd = tn.pos;\n          if (!startPos) startPos = setStart;\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n        } else {\n          tn.reset(state);\n        }\n      } else if (tn.skip(Token.CONSTRUCTOR)) {\n        flags |= CommonFlags.CONSTRUCTOR;\n        isConstructor = true;\n        if (!startPos) startPos = tn.tokenPos;\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.READONLY) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(readonlyStart, readonlyEnd), \"readonly\"\n          ); // recoverable\n        }\n      }\n    }\n\n    var isGetterOrSetter = isGetter || isSetter;\n    var name: IdentifierExpression;\n    if (isConstructor) {\n      name = Node.createConstructorExpression(tn.range());\n    } else {\n      if (!isGetterOrSetter && tn.skip(Token.OPENBRACKET)) {\n        if (!startPos) startPos = tn.tokenPos;\n        // TODO: also handle symbols, which might have some of these modifiers\n        if (flags & CommonFlags.PUBLIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"public\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PROTECTED) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        } else if (flags & CommonFlags.PRIVATE) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(accessStart, accessEnd), \"protected\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.STATIC) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(staticStart, staticEnd), \"static\"\n          ); // recoverable\n        }\n        if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode._0_modifier_cannot_be_used_here,\n            tn.range(abstractStart, abstractEnd), \"abstract\"\n          ); // recoverable\n        }\n        let retIndex = this.parseIndexSignature(tn, flags, decorators);\n        if (!retIndex) {\n          if (flags & CommonFlags.READONLY) {\n            this.error(\n              DiagnosticCode._0_modifier_cannot_be_used_here,\n              tn.range(readonlyStart, readonlyEnd), \"readonly\"\n            ); // recoverable\n          }\n          return null;\n        }\n        tn.skip(Token.SEMICOLON);\n        return retIndex;\n      }\n      if (!tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          tn.range()\n        );\n        return null;\n      }\n      if (!startPos) startPos = tn.tokenPos;\n      name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var typeParameters: TypeParameterNode[] | null = null;\n    if (tn.skip(Token.LESSTHAN)) {\n      let typeParametersStart = tn.tokenPos;\n      typeParameters = this.parseTypeParameters(tn);\n      if (!typeParameters) return null;\n      if (isConstructor) {\n        this.error(\n          DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else if (isGetterOrSetter) {\n        this.error(\n          DiagnosticCode.An_accessor_cannot_have_type_parameters,\n          tn.range(typeParametersStart, tn.pos)\n        ); // recoverable\n      } else {\n        flags |= CommonFlags.GENERIC;\n      }\n    }\n\n    // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\n    if (tn.skip(Token.OPENPAREN)) {\n      let signatureStart = tn.tokenPos;\n      let parameters = this.parseParameters(tn, isConstructor);\n      if (!parameters) return null;\n      let thisType = this.parseParametersThis;\n      if (isConstructor) {\n        for (let i = 0, k = parameters.length; i < k; ++i) {\n          let parameter = parameters[i];\n          if (parameter.isAny(\n            CommonFlags.PUBLIC |\n            CommonFlags.PROTECTED |\n            CommonFlags.PRIVATE |\n            CommonFlags.READONLY\n          )) {\n            let implicitFieldDeclaration = Node.createFieldDeclaration(\n              parameter.name,\n              null,\n              parameter.flags | CommonFlags.INSTANCE,\n              parameter.type,\n              null, // initialized via parameter\n              parameter.range\n            );\n            implicitFieldDeclaration.parameterIndex = i;\n            parameter.implicitFieldDeclaration = implicitFieldDeclaration;\n            parent.members.push(implicitFieldDeclaration);\n          }\n        }\n      } else if (isGetter) {\n        if (parameters.length) {\n          this.error(\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\n            name.range\n          );\n        }\n      } else if (isSetter) {\n        if (parameters.length != 1) {\n          this.error(\n            DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\n            name.range\n          );\n        }\n        if (parameters.length > 0 && parameters[0].initializer !== null) {\n          this.error(\n            DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\n            name.range\n          );\n        }\n      } else if (name.text == \"constructor\") {\n        this.error(\n          DiagnosticCode._0_keyword_cannot_be_used_here,\n          name.range, \"constructor\"\n        );\n      }\n\n      let returnType: TypeNode | null = null;\n      if (tn.skip(Token.COLON)) {\n        if (name.kind == NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\n            tn.range()\n          );\n        } else if (isSetter) {\n          this.error(\n            DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\n            tn.range()\n          );\n        }\n        returnType = this.parseType(tn, isSetter || name.kind == NodeKind.CONSTRUCTOR);\n        if (!returnType) return null;\n      } else {\n        returnType = Node.createOmittedType(tn.range(tn.pos));\n        if (!isSetter && name.kind != NodeKind.CONSTRUCTOR) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            returnType.range\n          ); // recoverable\n        }\n      }\n\n      let signature = Node.createFunctionType(\n        parameters,\n        returnType,\n        thisType,\n        false,\n        tn.range(signatureStart, tn.pos)\n      );\n\n      let body: Statement | null = null;\n      if (tn.skip(Token.OPENBRACE)) {\n        if (flags & CommonFlags.AMBIENT) {\n          this.error(\n            DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\n            tn.range()\n          ); // recoverable\n        } else if (flags & CommonFlags.ABSTRACT) {\n          this.error(\n            DiagnosticCode.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract,\n            tn.range(), name.text\n          ); // recoverable\n        } else if (isInterface) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          ); // recoverable\n        }\n        body = this.parseBlockStatement(tn, false);\n        if (!body) return null;\n      } else if (!isInterface && !(flags & (CommonFlags.AMBIENT | CommonFlags.ABSTRACT))) {\n        this.error(\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n          tn.range()\n        ); // recoverable\n      }\n\n      let retMethod = Node.createMethodDeclaration(\n        name,\n        decorators,\n        flags,\n        typeParameters,\n        signature,\n        body,\n        tn.range(startPos, tn.pos)\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retMethod;\n\n    } else if (isConstructor) {\n      this.error(\n        DiagnosticCode.Constructor_implementation_is_missing,\n        name.range\n      );\n\n    } else if (isGetterOrSetter) {\n      this.error(\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\n        name.range\n      );\n\n    // field: (':' Type)? ('=' Expression)? ';'?\n    } else {\n      if (flags & CommonFlags.ABSTRACT) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(abstractStart, abstractEnd), \"abstract\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.GET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(getStart, getEnd), \"get\"\n        ); // recoverable\n      }\n\n      if (flags & CommonFlags.SET) {\n        this.error(\n          DiagnosticCode._0_modifier_cannot_be_used_here,\n          tn.range(setStart, setEnd), \"set\"\n        ); // recoverable\n      }\n\n      let type: TypeNode | null = null;\n      if (tn.skip(Token.QUESTION)) {\n        this.error(\n          DiagnosticCode.Optional_properties_are_not_supported,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      if (tn.skip(Token.EXCLAMATION)) {\n        flags |= CommonFlags.DEFINITELY_ASSIGNED;\n      }\n      if (tn.skip(Token.COLON)) {\n        type = this.parseType(tn);\n        if (!type) return null;\n      } else {\n        this.error(\n          DiagnosticCode.Type_expected,\n          tn.range()\n        ); // recoverable\n      }\n      let initializer: Expression | null = null;\n      if (tn.skip(Token.EQUALS)) {\n        initializer = this.parseExpression(tn);\n        if (!initializer) return null;\n      }\n      let range = tn.range(startPos, tn.pos);\n      if (\n        (flags & CommonFlags.DEFINITELY_ASSIGNED) != 0 &&\n        (isInterface || initializer !== null || (flags & CommonFlags.STATIC) != 0)\n      ) {\n        this.error(\n          DiagnosticCode.A_definite_assignment_assertion_is_not_permitted_in_this_context,\n          range\n        );\n      }\n      let retField = Node.createFieldDeclaration(\n        name,\n        decorators,\n        flags,\n        type,\n        initializer,\n        range\n      );\n      if (!(isInterface && tn.skip(Token.COMMA))) {\n        tn.skip(Token.SEMICOLON);\n      }\n      return retField;\n    }\n    return null;\n  }\n\n  parseIndexSignature(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n  ): IndexSignatureNode | null {\n\n    // at: '[': 'key' ':' Type ']' ':' Type\n\n    if (decorators !== null && decorators.length > 0) {\n      this.error(\n        DiagnosticCode.Decorators_are_not_valid_here,\n        Range.join(decorators[0].range, decorators[decorators.length - 1].range)\n      ); // recoverable\n    }\n\n    var start = tn.tokenPos;\n    if (tn.skipIdentifier()) {\n      let id = tn.readIdentifier();\n      if (id == \"key\") {\n        if (tn.skip(Token.COLON)) {\n          let keyType = this.parseType(tn);\n          if (!keyType) return null;\n          if (keyType.kind != NodeKind.NAMEDTYPE) {\n            this.error(\n              DiagnosticCode.Type_expected,\n              tn.range()\n            );\n            return null;\n          }\n          if (tn.skip(Token.CLOSEBRACKET)) {\n            if (tn.skip(Token.COLON)) {\n              let valueType = this.parseType(tn);\n              if (!valueType) return null;\n              if (valueType.kind != NodeKind.NAMEDTYPE) {\n                this.error(\n                  DiagnosticCode.Identifier_expected,\n                  valueType.range\n                );\n                return null;\n              }\n              return Node.createIndexSignature(<NamedTypeNode>keyType, valueType, flags, tn.range(start, tn.pos));\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \":\"\n              );\n            }\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n          }\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \":\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"key\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseNamespace(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): NamespaceDeclaration | null {\n\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\n\n    if (tn.skipIdentifier()) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.OPENBRACE)) {\n        let members = new Array<Statement>();\n        let declaration = Node.createNamespaceDeclaration(\n          identifier,\n          decorators,\n          flags,\n          members,\n          tn.range(startPos, tn.pos)\n        );\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          let member = this.parseTopLevelStatement(tn, declaration);\n          if (member) members.push(member);\n          else {\n            this.skipStatement(tn);\n            if (tn.skip(Token.ENDOFFILE)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        declaration.range.end = tn.pos;\n        tn.skip(Token.SEMICOLON);\n        return declaration;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"{\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExport(\n    tn: Tokenizer,\n    startPos: i32,\n    isDeclare: bool\n  ): ExportStatement | null {\n\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\n\n    var path: StringLiteralExpression | null = null;\n    var currentSource = assert(this.currentSource);\n    if (tn.skip(Token.OPENBRACE)) {\n      let members = new Array<ExportMember>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseExportMember(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      let ret = Node.createExportStatement(members, path, isDeclare, tn.range(startPos, tn.pos));\n      if (path !== null) {\n        let internalPath = assert(ret.internalPath);\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(currentSource, path));\n          this.backlog.push(internalPath);\n          this.seenlog.add(internalPath);\n        }\n      }\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else if (tn.skip(Token.ASTERISK)) {\n      if (tn.skip(Token.FROM)) {\n        if (tn.skip(Token.STRINGLITERAL)) {\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n          let ret = Node.createExportStatement(null, path, isDeclare, tn.range(startPos, tn.pos));\n          let internalPath = assert(ret.internalPath);\n          let source = tn.source;\n          let exportPaths = source.exportPaths;\n          if (!exportPaths) source.exportPaths = [ internalPath ];\n          else if (!exportPaths.includes(internalPath)) exportPaths.push(internalPath);\n          if (!this.seenlog.has(internalPath)) {\n            this.dependees.set(internalPath, new Dependee(currentSource, path));\n            this.backlog.push(internalPath);\n          }\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.String_literal_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"from\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseExportMember(\n    tn: Tokenizer\n  ): ExportMember | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createExportMember(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createExportMember(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportDefaultAlias(\n    tn: Tokenizer,\n    startPos: i32,\n    defaultStart: i32,\n    defaultEnd: i32\n  ): ExportStatement {\n\n    // at 'export' 'default': [Known-To-Be-]Identifier\n\n    var name = tn.readIdentifier();\n    var range = tn.range();\n    var ret = Node.createExportStatement([\n      Node.createExportMember(\n        Node.createIdentifierExpression(name, range),\n        Node.createIdentifierExpression(\"default\", tn.range(defaultStart, defaultEnd)),\n        range\n      )\n    ], null, false, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseImport(\n    tn: Tokenizer\n  ): ImportStatement | null {\n\n    // at 'import':\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\n    //  'from' StringLiteral ';'?\n\n    var startPos = tn.tokenPos;\n    var members: ImportDeclaration[] | null = null;\n    var namespaceName: IdentifierExpression | null = null;\n    var skipFrom = false;\n    if (tn.skip(Token.OPENBRACE)) { // import { ... } from \"file\"\n      members = new Array();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        let member = this.parseImportDeclaration(tn);\n        if (!member) return null;\n        members.push(member);\n        if (!tn.skip(Token.COMMA)) {\n          if (tn.skip(Token.CLOSEBRACE)) {\n            break;\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"}\"\n            );\n            return null;\n          }\n        }\n      }\n    } else if (tn.skip(Token.ASTERISK)) { // import * from \"file\"\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"as\"\n        );\n        return null;\n      }\n    } else if (tn.skip(Token.IDENTIFIER, IdentifierHandling.PREFER)) { // import Name from \"file\"\n      let name = tn.readIdentifier();\n      let range = tn.range();\n      members = [\n        Node.createImportDeclaration(\n          Node.createIdentifierExpression(\"default\", range),\n          Node.createIdentifierExpression(name, range),\n          range\n        )\n      ];\n      if (tn.skip(Token.COMMA)) {\n        // TODO: default + star, default + members\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          tn.range(),\n          \"Mixed default and named imports\"\n        );\n        return null;\n      }\n    } else { // import \"file\"\n      skipFrom = true;\n    }\n\n    if (skipFrom || tn.skip(Token.FROM)) {\n      if (tn.skip(Token.STRINGLITERAL)) {\n        let path = Node.createStringLiteralExpression(tn.readString(), tn.range());\n        let ret: ImportStatement;\n        if (namespaceName) {\n          assert(!members);\n          ret = Node.createWildcardImportStatement(namespaceName, path, tn.range(startPos, tn.pos));\n        } else {\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\n        }\n        let internalPath = ret.internalPath;\n        if (!this.seenlog.has(internalPath)) {\n          this.dependees.set(internalPath, new Dependee(assert(this.currentSource), path));\n          this.backlog.push(internalPath);\n        }\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode.String_literal_expected,\n          tn.range()\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"from\"\n      );\n    }\n    return null;\n  }\n\n  parseImportDeclaration(\n    tn: Tokenizer\n  ): ImportDeclaration | null {\n\n    // before: Identifier ('as' Identifier)?\n\n    if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) {\n      let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let asIdentifier: IdentifierExpression | null = null;\n      if (tn.skip(Token.AS)) {\n        if (tn.skipIdentifier()) {\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n      }\n      if (asIdentifier) {\n        return Node.createImportDeclaration(\n          identifier,\n          asIdentifier,\n          Range.join(identifier.range, asIdentifier.range)\n        );\n      }\n      return Node.createImportDeclaration(\n        identifier,\n        null,\n        identifier.range\n      );\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseExportImport(\n    tn: Tokenizer,\n    startPos: i32\n  ): ExportImportStatement | null {\n\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\n\n    if (tn.skipIdentifier()) {\n      let asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      if (tn.skip(Token.EQUALS)) {\n        if (tn.skipIdentifier()) {\n          let identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          let ret = Node.createExportImportStatement(identifier, asIdentifier, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseStatement(\n    tn: Tokenizer,\n    topLevel: bool = false\n  ): Statement | null {\n\n    // at previous token\n\n    var state = tn.mark();\n    var token = tn.next();\n    var statement: Statement | null = null;\n    switch (token) {\n      case Token.BREAK: {\n        statement = this.parseBreak(tn);\n        break;\n      }\n      case Token.CONST: {\n        statement = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos);\n        break;\n      }\n      case Token.CONTINUE: {\n        statement = this.parseContinue(tn);\n        break;\n      }\n      case Token.DO: {\n        statement = this.parseDoStatement(tn);\n        break;\n      }\n      case Token.FOR: {\n        statement = this.parseForStatement(tn);\n        break;\n      }\n      case Token.IF: {\n        statement = this.parseIfStatement(tn);\n        break;\n      }\n      case Token.LET: {\n        statement = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos);\n        break;\n      }\n      case Token.VAR: {\n        statement = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos);\n        break;\n      }\n      case Token.OPENBRACE: {\n        statement = this.parseBlockStatement(tn, topLevel);\n        break;\n      }\n      case Token.RETURN: {\n        if (topLevel) {\n          this.error(\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\n            tn.range()\n          ); // recoverable\n        }\n        statement = this.parseReturn(tn);\n        break;\n      }\n      case Token.SEMICOLON: {\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\n      }\n      case Token.SWITCH: {\n        statement = this.parseSwitchStatement(tn);\n        break;\n      }\n      case Token.THROW: {\n        statement = this.parseThrowStatement(tn);\n        break;\n      }\n      case Token.TRY: {\n        statement = this.parseTryStatement(tn);\n        break;\n      }\n      case Token.VOID: {\n        statement = this.parseVoidStatement(tn);\n        break;\n      }\n      case Token.WHILE: {\n        statement = this.parseWhileStatement(tn);\n        break;\n      }\n      case Token.TYPE: { // also identifier\n        if (tn.peek(false, IdentifierHandling.PREFER) == Token.IDENTIFIER) {\n          statement = this.parseTypeDeclaration(tn, CommonFlags.NONE, null, tn.tokenPos);\n          break;\n        }\n        // fall-through\n      }\n      default: {\n        tn.reset(state);\n        statement = this.parseExpressionStatement(tn);\n        break;\n      }\n    }\n    if (!statement) { // has been reported\n      tn.reset(state);\n      this.skipStatement(tn);\n    } else {\n      tn.discard(state);\n    }\n    return statement;\n  }\n\n  parseBlockStatement(\n    tn: Tokenizer,\n    topLevel: bool\n  ): BlockStatement | null {\n\n    // at '{': Statement* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    var statements = new Array<Statement>();\n    while (!tn.skip(Token.CLOSEBRACE)) {\n      let state = tn.mark();\n      let statement = this.parseStatement(tn, topLevel);\n      if (!statement) {\n        if (tn.token == Token.ENDOFFILE) return null;\n        tn.reset(state);\n        this.skipStatement(tn);\n      } else {\n        tn.discard(state);\n        statements.push(statement);\n      }\n    }\n    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseBreak(\n    tn: Tokenizer\n  ): BreakStatement | null {\n\n    // at 'break': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createBreakStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseContinue(\n    tn: Tokenizer\n  ): ContinueStatement | null {\n\n    // at 'continue': Identifier? ';'?\n\n    var identifier: IdentifierExpression | null = null;\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\n      tn.next(IdentifierHandling.PREFER);\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n    }\n    var ret = Node.createContinueStatement(identifier, tn.range());\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseDoStatement(\n    tn: Tokenizer\n  ): DoStatement | null {\n\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\n\n    var startPos = tn.tokenPos;\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    if (tn.skip(Token.WHILE)) {\n\n      if (tn.skip(Token.OPENPAREN)) {\n        let condition = this.parseExpression(tn);\n        if (!condition) return null;\n\n        if (tn.skip(Token.CLOSEPAREN)) {\n          let ret = Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"(\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"while\"\n      );\n    }\n    return null;\n  }\n\n  parseExpressionStatement(\n    tn: Tokenizer\n  ): ExpressionStatement | null {\n\n    // at previous token\n\n    var expr = this.parseExpression(tn);\n    if (!expr) return null;\n\n    var ret = Node.createExpressionStatement(expr);\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseForStatement(\n    tn: Tokenizer\n  ): Statement | null {\n\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\n\n    var startPos = tn.tokenPos;\n\n    if (tn.skip(Token.OPENPAREN)) {\n      let initializer: Statement | null = null;\n\n      if (tn.skip(Token.CONST)) {\n        initializer = this.parseVariable(tn, CommonFlags.CONST, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.LET)) {\n        initializer = this.parseVariable(tn, CommonFlags.LET, null, tn.tokenPos, true);\n      } else if (tn.skip(Token.VAR)) {\n        initializer = this.parseVariable(tn, CommonFlags.NONE, null, tn.tokenPos, true);\n\n      } else if (!tn.skip(Token.SEMICOLON)) {\n        initializer = this.parseExpressionStatement(tn);\n        if (!initializer) return null;\n      }\n\n      if (initializer) {\n        if (tn.skip(Token.OF)) {\n          // TODO: for (let [key, val] of ...)\n          if (initializer.kind == NodeKind.EXPRESSION) {\n            if ((<ExpressionStatement>initializer).expression.kind != NodeKind.IDENTIFIER) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                initializer.range\n              );\n              return null;\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          if (initializer.kind == NodeKind.VARIABLE) {\n            let declarations = (<VariableStatement>initializer).declarations;\n            for (let i = 0, k = declarations.length; i < k; ++i) {\n              let declaration = declarations[i];\n              let initializer = declaration.initializer;\n              if (initializer) {\n                this.error(\n                  DiagnosticCode.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer,\n                  initializer.range\n                ); // recoverable\n              }\n            }\n            return this.parseForOfStatement(tn, startPos, initializer);\n          }\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            initializer.range\n          );\n          return null;\n        }\n        // non-for..of needs type or initializer\n        if (initializer.kind == NodeKind.VARIABLE) {\n          let declarations = (<VariableStatement>initializer).declarations;\n          for (let i = 0, k = declarations.length; i < k; ++i) {\n            let declaration = declarations[i];\n            if (!declaration.initializer) {\n              if (declaration.flags & CommonFlags.CONST) {\n                this.error(\n                  DiagnosticCode._const_declarations_must_be_initialized,\n                  declaration.name.range\n                );\n              } else if (!declaration.type) {\n                this.error(\n                  DiagnosticCode.Type_expected,\n                  declaration.name.range.atEnd\n                );\n              }\n            }\n          }\n        }\n      }\n\n      if (tn.token == Token.SEMICOLON) {\n        let condition: ExpressionStatement | null = null;\n        if (!tn.skip(Token.SEMICOLON)) {\n          condition = this.parseExpressionStatement(tn);\n          if (!condition) return null;\n        }\n\n        if (tn.token == Token.SEMICOLON) {\n          let incrementor: Expression | null = null;\n          if (!tn.skip(Token.CLOSEPAREN)) {\n            incrementor = this.parseExpression(tn);\n            if (!incrementor) return null;\n\n            if (!tn.skip(Token.CLOSEPAREN)) {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \")\"\n              );\n              return null;\n            }\n          }\n\n          let statement = this.parseStatement(tn);\n          if (!statement) return null;\n\n          return Node.createForStatement(\n            initializer,\n            condition\n              ? condition.expression\n              : null,\n            incrementor,\n            statement,\n            tn.range(startPos, tn.pos)\n          );\n\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \";\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \";\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseForOfStatement(\n    tn: Tokenizer,\n    startPos: i32,\n    variable: Statement,\n  ): ForOfStatement | null {\n\n    // at 'of': Expression ')' Statement\n\n    var iterable = this.parseExpression(tn);\n    if (!iterable) return null;\n\n    if (!tn.skip(Token.CLOSEPAREN)) {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \")\"\n      );\n      return null;\n    }\n\n    var statement = this.parseStatement(tn);\n    if (!statement) return null;\n\n    return Node.createForOfStatement(\n      variable,\n      iterable,\n      statement,\n      tn.range(startPos, tn.pos)\n    );\n  }\n\n  parseIfStatement(\n    tn: Tokenizer\n  ): IfStatement | null {\n\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let elseStatement: Statement | null = null;\n        if (tn.skip(Token.ELSE)) {\n          elseStatement = this.parseStatement(tn);\n          if (!elseStatement) return null;\n        }\n        return Node.createIfStatement(\n          condition,\n          statement,\n          elseStatement,\n          tn.range(startPos, tn.pos)\n        );\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchStatement(\n    tn: Tokenizer\n  ): SwitchStatement | null {\n\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let condition = this.parseExpression(tn);\n      if (!condition) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        if (tn.skip(Token.OPENBRACE)) {\n          let switchCases = new Array<SwitchCase>();\n          while (!tn.skip(Token.CLOSEBRACE)) {\n            let switchCase = this.parseSwitchCase(tn);\n            if (!switchCase) return null;\n            switchCases.push(switchCase);\n          }\n          let ret = Node.createSwitchStatement(condition, switchCases, tn.range(startPos, tn.pos));\n          tn.skip(Token.SEMICOLON);\n          return ret;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n        }\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  parseSwitchCase(\n    tn: Tokenizer\n  ): SwitchCase | null {\n\n    var startPos = tn.tokenPos;\n    var statements: Statement[],\n        statement: Statement | null;\n\n    // 'case' Expression ':' Statement*\n\n    if (tn.skip(Token.CASE)) {\n      let label = this.parseExpression(tn);\n      if (!label) return null;\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n\n      // 'default' ':' Statement*\n\n    } else if (tn.skip(Token.DEFAULT)) {\n      if (tn.skip(Token.COLON)) {\n        statements = new Array<Statement>();\n        while (\n          tn.peek() != Token.CASE &&\n          tn.nextToken != Token.DEFAULT &&\n          tn.nextToken != Token.CLOSEBRACE\n        ) {\n          statement = this.parseStatement(tn);\n          if (!statement) return null;\n          statements.push(statement);\n        }\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \":\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._case_or_default_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseThrowStatement(\n    tn: Tokenizer\n  ): ThrowStatement | null {\n\n    // at 'throw': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn);\n    if (!expression) return null;\n    var ret = Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseTryStatement(\n    tn: Tokenizer\n  ): TryStatement | null {\n\n    // at 'try':\n    //   '{' Statement* '}'\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\n    //   ('finally' '{' Statement* '}'? ';'?\n\n    var startPos = tn.tokenPos;\n    var stmt: Statement | null;\n    if (tn.skip(Token.OPENBRACE)) {\n      let statements = new Array<Statement>();\n      while (!tn.skip(Token.CLOSEBRACE)) {\n        stmt = this.parseStatement(tn);\n        if (!stmt) return null;\n        statements.push(stmt);\n      }\n      let catchVariable: IdentifierExpression | null = null;\n      let catchStatements: Statement[] | null = null;\n      let finallyStatements: Statement[] | null = null;\n      if (tn.skip(Token.CATCH)) {\n        if (!tn.skip(Token.OPENPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"(\"\n          );\n          return null;\n        }\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        catchStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          catchStatements.push(stmt);\n        }\n      }\n      if (tn.skip(Token.FINALLY)) {\n        if (!tn.skip(Token.OPENBRACE)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"{\"\n          );\n          return null;\n        }\n        finallyStatements = [];\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          stmt = this.parseStatement(tn);\n          if (!stmt) return null;\n          finallyStatements.push(stmt);\n        }\n      }\n      if (!(catchStatements || finallyStatements)) {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"catch\"\n        );\n        return null;\n      }\n      let ret = Node.createTryStatement(\n        statements,\n        catchVariable,\n        catchStatements,\n        finallyStatements,\n        tn.range(startPos, tn.pos)\n      );\n      tn.skip(Token.SEMICOLON);\n      return ret;\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"{\"\n      );\n    }\n    return null;\n  }\n\n  parseTypeDeclaration(\n    tn: Tokenizer,\n    flags: CommonFlags,\n    decorators: DecoratorNode[] | null,\n    startPos: i32\n  ): TypeDeclaration | null {\n\n    // at 'type': Identifier ('<' TypeParameters '>')? '=' Type ';'?\n\n    if (tn.skipIdentifier()) {\n      let name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n      let typeParameters: TypeParameterNode[] | null = null;\n      if (tn.skip(Token.LESSTHAN)) {\n        typeParameters = this.parseTypeParameters(tn);\n        if (!typeParameters) return null;\n        flags |= CommonFlags.GENERIC;\n      }\n      if (tn.skip(Token.EQUALS)) {\n        let type = this.parseType(tn);\n        if (!type) return null;\n        let ret = Node.createTypeDeclaration(\n          name,\n          decorators,\n          flags,\n          typeParameters,\n          type,\n          tn.range(startPos, tn.pos)\n        );\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \"=\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode.Identifier_expected,\n        tn.range()\n      );\n    }\n    return null;\n  }\n\n  parseVoidStatement(\n    tn: Tokenizer\n  ): VoidStatement | null {\n\n    // at 'void': Expression ';'?\n\n    var startPos = tn.tokenPos;\n    var expression = this.parseExpression(tn, Precedence.GROUPING);\n    if (!expression) return null;\n    var ret = Node.createVoidStatement(expression, tn.range(startPos, tn.pos));\n    tn.skip(Token.SEMICOLON);\n    return ret;\n  }\n\n  parseWhileStatement(\n    tn: Tokenizer\n  ): WhileStatement | null {\n\n    // at 'while': '(' Expression ')' Statement ';'?\n\n    var startPos = tn.tokenPos;\n    if (tn.skip(Token.OPENPAREN)) {\n      let expression = this.parseExpression(tn);\n      if (!expression) return null;\n      if (tn.skip(Token.CLOSEPAREN)) {\n        let statement = this.parseStatement(tn);\n        if (!statement) return null;\n        let ret = Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\n        tn.skip(Token.SEMICOLON);\n        return ret;\n      } else {\n        this.error(\n          DiagnosticCode._0_expected,\n          tn.range(), \")\"\n        );\n      }\n    } else {\n      this.error(\n        DiagnosticCode._0_expected,\n        tn.range(), \"(\"\n      );\n    }\n    return null;\n  }\n\n  // expressions\n\n  parseExpressionStart(\n    tn: Tokenizer\n  ): Expression | null {\n    var token = tn.next(IdentifierHandling.PREFER);\n    var startPos = tn.tokenPos;\n    switch (token) {\n\n      // TODO: SpreadExpression, YieldExpression\n      case Token.DOT_DOT_DOT:\n      case Token.YIELD: // fallthrough to unsupported UnaryPrefixExpression\n\n      // UnaryPrefixExpression\n      case Token.EXCLAMATION:\n      case Token.TILDE:\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.DELETE: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let operand = this.parseExpression(tn, Precedence.UNARY_PREFIX);\n        if (!operand) return null;\n        switch (operand.kind) {\n          case NodeKind.IDENTIFIER:\n          case NodeKind.ELEMENTACCESS:\n          case NodeKind.PROPERTYACCESS: break;\n          default: {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              operand.range\n            );\n          }\n        }\n        return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\n      }\n\n      // NewExpression\n      case Token.NEW: {\n        if (!tn.skipIdentifier()) {\n          this.error(\n            DiagnosticCode.Identifier_expected,\n            tn.range()\n          );\n          return null;\n        }\n        let typeName = this.parseTypeName(tn);\n        if (!typeName) return null;\n        let typeArguments: TypeNode[] | null = null;\n        let arguments_: Expression[] | null = null;\n        if (\n          tn.skip(Token.OPENPAREN) ||\n          (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n        ) {\n          arguments_ = this.parseArguments(tn);\n          if (!arguments_) return null;\n        } else {\n          arguments_ = []; // new Type;\n        }\n        return Node.createNewExpression(\n          typeName,\n          typeArguments,\n          arguments_,\n          tn.range(startPos, tn.pos)\n        );\n      }\n\n      // Special IdentifierExpression\n      case Token.NULL: return Node.createNullExpression(tn.range());\n      case Token.TRUE: return Node.createTrueExpression(tn.range());\n      case Token.FALSE: return Node.createFalseExpression(tn.range());\n      case Token.THIS: return Node.createThisExpression(tn.range());\n      case Token.CONSTRUCTOR: return Node.createConstructorExpression(tn.range());\n\n      // ParenthesizedExpression or FunctionExpression\n      case Token.OPENPAREN: {\n\n        // determine whether this is a function expression\n        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [],\n            null,\n            ArrowKind.ARROW_PARENTHESIZED\n          );\n        }\n        let state = tn.mark();\n        let again = true;\n        do {\n          switch (tn.next(IdentifierHandling.PREFER)) {\n\n            // function expression\n            case Token.DOT_DOT_DOT: {\n              tn.reset(state);\n              return this.parseFunctionExpression(tn);\n            }\n            // can be both\n            case Token.IDENTIFIER: {\n              tn.readIdentifier();\n              switch (tn.next()) {\n\n                // if we got here, check for arrow\n                case Token.CLOSEPAREN: {\n                  if (\n                    !tn.skip(Token.COLON) &&\n                    !tn.skip(Token.EQUALS_GREATERTHAN)\n                  ) {\n                    again = false;\n                    break;\n                  }\n                  // fall-through\n                }\n                // function expression\n                case Token.COLON: {    // type annotation\n                  tn.reset(state);\n                  return this.parseFunctionExpression(tn);\n                }\n                // optional parameter or parenthesized\n                case Token.QUESTION: {\n                  if (\n                    tn.skip(Token.COLON) ||   // optional parameter with type\n                    tn.skip(Token.COMMA) ||   // optional parameter without type\n                    tn.skip(Token.CLOSEPAREN) // last optional parameter without type\n                  ) {\n                    tn.reset(state);\n                    return this.parseFunctionExpression(tn);\n                  }\n                  again = false; // parenthesized\n                  break;\n                }\n                case Token.COMMA: {\n                  break; // continue\n                }\n                // parenthesized expression\n                // case Token.EQUALS:  // missing type annotation for simplicity\n                default: {\n                  again = false;\n                  break;\n                }\n              }\n              break;\n            }\n            // parenthesized expression\n            default: {\n              again = false;\n              break;\n            }\n          }\n        } while (again);\n        tn.reset(state);\n\n        // parse parenthesized\n        let inner = this.parseExpression(tn);\n        if (!inner) return null;\n        if (!tn.skip(Token.CLOSEPAREN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n        inner = Node.createParenthesizedExpression(inner, tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, inner);\n      }\n      // ArrayLiteralExpression\n      case Token.OPENBRACKET: {\n        let elementExpressions = new Array<Expression>();\n        while (!tn.skip(Token.CLOSEBRACKET)) {\n          let expr: Expression | null;\n          if (tn.peek() == Token.COMMA) {\n            expr = Node.createOmittedExpression(tn.range(tn.pos));\n          } else {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n          }\n          elementExpressions.push(expr);\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACKET)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"]\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\n      }\n      // ObjectLiteralExpression\n      case Token.OPENBRACE: {\n        let startPos = tn.tokenPos;\n        let names = new Array<IdentifierExpression>();\n        let values = new Array<Expression>();\n        let name: IdentifierExpression;\n        while (!tn.skip(Token.CLOSEBRACE)) {\n          if (!tn.skipIdentifier()) {\n            if (!tn.skip(Token.STRINGLITERAL)) {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                tn.range(),\n              );\n              return null;\n            }\n            name = Node.createIdentifierExpression(tn.readString(), tn.range());\n            name.isQuoted = true;\n          } else {\n            name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n          }\n          names.push(name);\n          if (tn.skip(Token.COLON)) {\n            let value = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!value) return null;\n            values.push(value);\n          } else if (!name.isQuoted) {\n            values.push(name);\n          } else {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          if (!tn.skip(Token.COMMA)) {\n            if (tn.skip(Token.CLOSEBRACE)) {\n              break;\n            } else {\n              this.error(\n                DiagnosticCode._0_expected,\n                tn.range(), \"}\"\n              );\n              return null;\n            }\n          }\n        }\n        return Node.createObjectLiteralExpression(names, values, tn.range(startPos, tn.pos));\n      }\n      // AssertionExpression (unary prefix)\n      case Token.LESSTHAN: {\n        let toType = this.parseType(tn);\n        if (!toType) return null;\n        if (!tn.skip(Token.GREATERTHAN)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \">\"\n          );\n          return null;\n        }\n        let expr = this.parseExpression(tn, Precedence.CALL);\n        if (!expr) return null;\n        return Node.createAssertionExpression(\n          AssertionKind.PREFIX,\n          expr,\n          toType,\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.IDENTIFIER: {\n        let identifierText = tn.readIdentifier();\n        if (identifierText == \"null\") return Node.createNullExpression(tn.range()); // special\n        let identifier = Node.createIdentifierExpression(identifierText, tn.range(startPos, tn.pos));\n        if (tn.peek(true) == Token.EQUALS_GREATERTHAN && !tn.nextTokenOnNewLine) {\n          return this.parseFunctionExpressionCommon(\n            tn,\n            Node.createEmptyIdentifierExpression(tn.range(startPos)),\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                identifier,\n                Node.createOmittedType(identifier.range.atEnd),\n                null,\n                identifier.range\n              )\n            ],\n            null,\n            ArrowKind.ARROW_SINGLE,\n            startPos\n          );\n        }\n        return this.maybeParseCallExpression(tn, identifier, true);\n      }\n      case Token.SUPER: {\n        if (tn.peek() != Token.DOT && tn.nextToken != Token.OPENPAREN) {\n          this.error(\n            DiagnosticCode._super_must_be_followed_by_an_argument_list_or_member_access,\n            tn.range()\n          );\n        }\n        let expr = Node.createSuperExpression(tn.range(startPos, tn.pos));\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.STRINGLITERAL: {\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\n      }\n      case Token.INTEGERLITERAL: {\n        return Node.createIntegerLiteralExpression(tn.readInteger(), tn.range(startPos, tn.pos));\n      }\n      case Token.FLOATLITERAL: {\n        return Node.createFloatLiteralExpression(tn.readFloat(), tn.range(startPos, tn.pos));\n      }\n      // RegexpLiteralExpression\n      // note that this also continues on invalid ones so the surrounding AST remains intact\n      case Token.SLASH: {\n        let regexpPattern = tn.readRegexpPattern(); // also reports\n        if (!tn.skip(Token.SLASH)) {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"/\"\n          );\n          return null;\n        }\n        return Node.createRegexpLiteralExpression(\n          regexpPattern,\n          tn.readRegexpFlags(), // also reports\n          tn.range(startPos, tn.pos)\n        );\n      }\n      case Token.FUNCTION: {\n        let expr = this.parseFunctionExpression(tn);\n        if (!expr) return null;\n        return this.maybeParseCallExpression(tn, expr);\n      }\n      case Token.CLASS: {\n        return this.parseClassExpression(tn);\n      }\n      default: {\n        if (token == Token.ENDOFFILE) {\n          this.error(\n            DiagnosticCode.Unexpected_end_of_text,\n            tn.range(startPos)\n          );\n        } else {\n          this.error(\n            DiagnosticCode.Expression_expected,\n            tn.range()\n          );\n        }\n        return null;\n      }\n    }\n  }\n\n  tryParseTypeArgumentsBeforeArguments(\n    tn: Tokenizer\n  ): TypeNode[] | null {\n\n    // at '<': Type (',' Type)* '>' '('\n\n    var state = tn.mark();\n    if (!tn.skip(Token.LESSTHAN)) return null;\n    var start = tn.tokenPos;\n    var typeArguments: TypeNode[] | null = null;\n    do {\n      if (tn.peek() === Token.GREATERTHAN) {\n        break;\n      }\n      let type = this.parseType(tn, true, true);\n      if (!type) {\n        tn.reset(state);\n        return null;\n      }\n      if (!typeArguments) typeArguments = [ type ];\n      else typeArguments.push(type);\n    } while (tn.skip(Token.COMMA));\n    if (tn.skip(Token.GREATERTHAN)) {\n      let end = tn.pos;\n      if (tn.skip(Token.OPENPAREN)) {\n        if (!typeArguments) {\n          this.error(\n            DiagnosticCode.Type_argument_list_cannot_be_empty,\n            tn.range(start, end)\n          );\n        }\n        return typeArguments;\n      }\n    }\n    tn.reset(state);\n    return null;\n  }\n\n  parseArguments(\n    tn: Tokenizer\n  ): Expression[] | null {\n\n    // at '(': (Expression (',' Expression)*)? ')'\n\n    var args = new Array<Expression>();\n    while (!tn.skip(Token.CLOSEPAREN)) {\n      let expr = this.parseExpression(tn, Precedence.COMMA + 1);\n      if (!expr) return null;\n      args.push(expr);\n      if (!tn.skip(Token.COMMA)) {\n        if (tn.skip(Token.CLOSEPAREN)) {\n          break;\n        } else {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \")\"\n          );\n          return null;\n        }\n      }\n    }\n    return args;\n  }\n\n  parseExpression(\n    tn: Tokenizer,\n    precedence: Precedence = Precedence.COMMA\n  ): Expression | null {\n    assert(precedence != Precedence.NONE);\n    var expr = this.parseExpressionStart(tn);\n    if (!expr) return null;\n    var startPos = expr.range.start;\n\n    // precedence climbing\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\n    var nextPrecedence: Precedence;\n    while (\n      (nextPrecedence = determinePrecedence(tn.peek())) >= precedence\n    ) {\n      let token = tn.next();\n      switch (token) {\n\n        // AssertionExpression\n        case Token.AS: {\n          if (tn.skip(Token.CONST)) {\n            expr = Node.createAssertionExpression(\n              AssertionKind.CONST,\n              expr,\n              null,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let toType = this.parseType(tn); // reports\n            if (!toType) return null;\n            expr = Node.createAssertionExpression(\n              AssertionKind.AS,\n              expr,\n              toType,\n              tn.range(startPos, tn.pos)\n            );\n          }\n          break;\n        }\n        case Token.EXCLAMATION: {\n          expr = Node.createAssertionExpression(\n            AssertionKind.NONNULL,\n            expr,\n            null,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // InstanceOfExpression\n        case Token.INSTANCEOF: {\n          let isType = this.parseType(tn); // reports\n          if (!isType) return null;\n          expr = Node.createInstanceOfExpression(\n            expr,\n            isType,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // ElementAccessExpression\n        case Token.OPENBRACKET: {\n          let next = this.parseExpression(tn); // reports\n          if (!next) return null;\n          if (!tn.skip(Token.CLOSEBRACKET)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \"]\"\n            );\n            return null;\n          }\n          expr = Node.createElementAccessExpression(\n            expr,\n            next,\n            tn.range(startPos, tn.pos)\n          );\n          expr = this.maybeParseCallExpression(tn, expr);\n          break;\n        }\n        // UnaryPostfixExpression\n        case Token.PLUS_PLUS:\n        case Token.MINUS_MINUS: {\n          if (\n            expr.kind != NodeKind.IDENTIFIER &&\n            expr.kind != NodeKind.ELEMENTACCESS &&\n            expr.kind != NodeKind.PROPERTYACCESS\n          ) {\n            this.error(\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\n              expr.range\n            );\n          }\n          expr = Node.createUnaryPostfixExpression(\n            token,\n            expr,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // TernaryExpression\n        case Token.QUESTION: {\n          let ifThen = this.parseExpression(tn);\n          if (!ifThen) return null;\n          if (!tn.skip(Token.COLON)) {\n            this.error(\n              DiagnosticCode._0_expected,\n              tn.range(), \":\"\n            );\n            return null;\n          }\n          let ifElse = this.parseExpression(tn, precedence > Precedence.COMMA\n            ? Precedence.COMMA + 1\n            : Precedence.COMMA\n          );\n          if (!ifElse) return null;\n          expr = Node.createTernaryExpression(\n            expr,\n            ifThen,\n            ifElse,\n            tn.range(startPos, tn.pos)\n          );\n          break;\n        }\n        // CommaExpression\n        case Token.COMMA: {\n          let commaExprs: Expression[] = [ expr ];\n          do {\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\n            if (!expr) return null;\n            commaExprs.push(expr);\n          } while (tn.skip(Token.COMMA));\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\n          break;\n        }\n        // PropertyAccessExpression\n        case Token.DOT: {\n          if (tn.skipIdentifier(IdentifierHandling.ALWAYS)) { // expr '.' Identifier\n            let next = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\n            expr = Node.createPropertyAccessExpression(\n              expr,\n              next,\n              tn.range(startPos, tn.pos)\n            );\n          } else {\n            let next = this.parseExpression(tn, nextPrecedence + 1);\n            if (!next) return null;\n            if (next.kind == NodeKind.CALL) { // expr '.' CallExpression\n              expr = this.joinPropertyCall(tn, startPos, expr, <CallExpression>next);\n              if (!expr) return null;\n            } else {\n              this.error(\n                DiagnosticCode.Identifier_expected,\n                next.range\n              );\n              return null;\n            }\n          }\n          expr = this.maybeParseCallExpression(tn, expr, true);\n          break;\n        }\n        // BinaryExpression (right associative)\n        case Token.EQUALS:\n        case Token.PLUS_EQUALS:\n        case Token.MINUS_EQUALS:\n        case Token.ASTERISK_ASTERISK_EQUALS:\n        case Token.ASTERISK_EQUALS:\n        case Token.SLASH_EQUALS:\n        case Token.PERCENT_EQUALS:\n        case Token.LESSTHAN_LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n        case Token.AMPERSAND_EQUALS:\n        case Token.CARET_EQUALS:\n        case Token.BAR_EQUALS:\n        case Token.ASTERISK_ASTERISK: {\n          let next = this.parseExpression(tn, nextPrecedence);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        // BinaryExpression\n        case Token.LESSTHAN:\n        case Token.GREATERTHAN:\n        case Token.LESSTHAN_EQUALS:\n        case Token.GREATERTHAN_EQUALS:\n        case Token.EQUALS_EQUALS:\n        case Token.EQUALS_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS_EQUALS:\n        case Token.EXCLAMATION_EQUALS:\n        case Token.PLUS:\n        case Token.MINUS:\n        case Token.ASTERISK:\n        case Token.SLASH:\n        case Token.PERCENT:\n        case Token.LESSTHAN_LESSTHAN:\n        case Token.GREATERTHAN_GREATERTHAN:\n        case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n        case Token.AMPERSAND:\n        case Token.BAR:\n        case Token.CARET:\n        case Token.AMPERSAND_AMPERSAND:\n        case Token.BAR_BAR: {\n          let next = this.parseExpression(tn, nextPrecedence + 1);\n          if (!next) return null;\n          expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\n          break;\n        }\n        default: assert(false); // filtered by determinePrecedence\n      }\n    }\n    return expr;\n  }\n\n  private joinPropertyCall(\n    tn: Tokenizer,\n    startPos: i32,\n    expr: Expression,\n    call: CallExpression\n  ): Expression | null {\n    var callee = call.expression;\n    switch (callee.kind) {\n      case NodeKind.IDENTIFIER: { // join property access and use as call target\n        call.expression = Node.createPropertyAccessExpression(\n          expr,\n          <IdentifierExpression>callee,\n          tn.range(startPos, tn.pos)\n        );\n        break;\n      }\n      case NodeKind.CALL: { // join call target und wrap the original call around it\n        let inner = this.joinPropertyCall(tn, startPos, expr, <CallExpression>callee);\n        if (!inner) return null;\n        call.expression = inner;\n        call.range = tn.range(startPos, tn.pos);\n        break;\n      }\n      default: {\n        this.error(\n          DiagnosticCode.Identifier_expected,\n          call.range\n        );\n        return null;\n      }\n    }\n    return call;\n  }\n\n  private maybeParseCallExpression(\n    tn: Tokenizer,\n    expr: Expression,\n    potentiallyGeneric: bool = false\n  ): Expression {\n    var typeArguments: TypeNode[] | null = null;\n    while (\n      tn.skip(Token.OPENPAREN) ||\n      potentiallyGeneric &&\n      (typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn)) !== null\n    ) {\n      let args = this.parseArguments(tn);\n      if (!args) break;\n      expr = Node.createCallExpression( // is again callable\n        expr,\n        typeArguments,\n        args,\n        tn.range(expr.range.start, tn.pos)\n      );\n      potentiallyGeneric = false;\n    }\n    return expr;\n  }\n\n  /** Skips over a statement on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipStatement(tn: Tokenizer): void {\n    tn.peek(true);\n    if (tn.nextTokenOnNewLine) tn.next(); // if reset() to the previous line\n    do {\n      let nextToken = tn.peek(true);\n      if (\n        nextToken == Token.ENDOFFILE ||   // next step should handle this\n        nextToken == Token.SEMICOLON      // end of the statement for sure\n      ) {\n        tn.next();\n        break;\n      }\n      if (tn.nextTokenOnNewLine) break;   // end of the statement maybe\n      switch (tn.next()) {\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL: {\n          tn.readString();\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          break;\n        }\n        case Token.OPENBRACE: {\n          this.skipBlock(tn);\n          break;\n        }\n      }\n    } while (true);\n  }\n\n  /** Skips over a block on errors in an attempt to reduce unnecessary diagnostic noise. */\n  skipBlock(tn: Tokenizer): void {\n    // at '{': ... '}'\n    var depth = 1;\n    var again = true;\n    do {\n      switch (tn.next()) {\n        case Token.ENDOFFILE: {\n          this.error(\n            DiagnosticCode._0_expected,\n            tn.range(), \"}\"\n          );\n          again = false;\n          break;\n        }\n        case Token.OPENBRACE: {\n          ++depth;\n          break;\n        }\n        case Token.CLOSEBRACE: {\n          --depth;\n          if (!depth) again = false;\n          break;\n        }\n        case Token.IDENTIFIER: {\n          tn.readIdentifier();\n          break;\n        }\n        case Token.STRINGLITERAL: {\n          tn.readString();\n          break;\n        }\n        case Token.INTEGERLITERAL: {\n          tn.readInteger();\n          break;\n        }\n        case Token.FLOATLITERAL: {\n          tn.readFloat();\n          break;\n        }\n      }\n    } while (again);\n  }\n}\n\n/** Operator precedence from least to largest. */\nexport const enum Precedence {\n  NONE,\n  COMMA,\n  SPREAD,\n  YIELD,\n  ASSIGNMENT,\n  CONDITIONAL,\n  LOGICAL_OR,\n  LOGICAL_AND,\n  BITWISE_OR,\n  BITWISE_XOR,\n  BITWISE_AND,\n  EQUALITY,\n  RELATIONAL,\n  SHIFT,\n  ADDITIVE,\n  MULTIPLICATIVE,\n  EXPONENTIATED,\n  UNARY_PREFIX,\n  UNARY_POSTFIX,\n  CALL,\n  MEMBERACCESS,\n  GROUPING\n}\n\n/** Determines the precende of a non-starting token. */\nfunction determinePrecedence(kind: Token): Precedence {\n  switch (kind) {\n    case Token.COMMA: return Precedence.COMMA;\n    case Token.EQUALS:\n    case Token.PLUS_EQUALS:\n    case Token.MINUS_EQUALS:\n    case Token.ASTERISK_ASTERISK_EQUALS:\n    case Token.ASTERISK_EQUALS:\n    case Token.SLASH_EQUALS:\n    case Token.PERCENT_EQUALS:\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n    case Token.AMPERSAND_EQUALS:\n    case Token.CARET_EQUALS:\n    case Token.BAR_EQUALS: return Precedence.ASSIGNMENT;\n    case Token.QUESTION: return Precedence.CONDITIONAL;\n    case Token.BAR_BAR: return Precedence.LOGICAL_OR;\n    case Token.AMPERSAND_AMPERSAND: return Precedence.LOGICAL_AND;\n    case Token.BAR: return Precedence.BITWISE_OR;\n    case Token.CARET: return Precedence.BITWISE_XOR;\n    case Token.AMPERSAND: return Precedence.BITWISE_AND;\n    case Token.EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS:\n    case Token.EQUALS_EQUALS_EQUALS:\n    case Token.EXCLAMATION_EQUALS_EQUALS: return Precedence.EQUALITY;\n    case Token.AS:\n    case Token.IN:\n    case Token.INSTANCEOF:\n    case Token.LESSTHAN:\n    case Token.GREATERTHAN:\n    case Token.LESSTHAN_EQUALS:\n    case Token.GREATERTHAN_EQUALS: return Precedence.RELATIONAL;\n    case Token.LESSTHAN_LESSTHAN:\n    case Token.GREATERTHAN_GREATERTHAN:\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return Precedence.SHIFT;\n    case Token.PLUS:\n    case Token.MINUS: return Precedence.ADDITIVE;\n    case Token.ASTERISK:\n    case Token.SLASH:\n    case Token.PERCENT: return Precedence.MULTIPLICATIVE;\n    case Token.ASTERISK_ASTERISK: return Precedence.EXPONENTIATED;\n    case Token.PLUS_PLUS:\n    case Token.MINUS_MINUS: return Precedence.UNARY_POSTFIX;\n    case Token.DOT:\n    case Token.NEW:\n    case Token.OPENBRACKET:\n    case Token.EXCLAMATION: return Precedence.MEMBERACCESS;\n  }\n  return Precedence.NONE;\n}\n","/**\n * @fileoverview AssemblyScript's intermediate representation.\n *\n * The compiler uses Binaryen IR, which is fairly low level, as its\n * primary intermediate representation, with the following structures\n * holding any higher level information that cannot be represented by\n * Binaryen IR alone, for example higher level types.\n *\n * Similar to the AST being composed of `Node`s in `Source`s, the IR is\n * composed of `Element`s in a `Program`. Each class or function is\n * represented by a \"prototype\" holding all the relevant information,\n * including each's concrete instances. If a class or function is not\n * generic, there is exactly one instance, otherwise there is one for\n * each concrete set of type arguments.\n *\n * @license Apache-2.0\n */\n\n// Element                    Base class of all elements\n// DeclaredElement          Base class of elements with a declaration\n//  TypedElement           Base class of elements resolving to a type\n//   TypeDefinition       Type alias declaration\n//   VariableLikeElement  Base class of all variable-like elements\n//    EnumValue          Enum value\n//    Global             File global\n//    Local              Function local\n//    Field              Class field (instance only)\n//    Property           Class property\n//   IndexSignature       Class index signature\n//   Function             Concrete function instance\n//   Class                Concrete class instance\n//  Namespace              Namespace with static members\n//  FunctionPrototype      Prototype of concrete function instances\n//  FieldPrototype         Prototype of concrete field instances\n//  PropertyPrototype      Prototype of concrete property instances\n//  ClassPrototype         Prototype of concrete classe instances\n// File                     File, analogous to Source in the AST\n\nimport {\n  CommonFlags,\n  PATH_DELIMITER,\n  STATIC_DELIMITER,\n  INSTANCE_DELIMITER,\n  GETTER_PREFIX,\n  SETTER_PREFIX,\n  INNER_DELIMITER,\n  LIBRARY_SUBST,\n  INDEX_SUFFIX,\n  STUB_DELIMITER,\n  CommonNames,\n  Feature,\n  Target\n} from \"./common\";\n\nimport {\n  Options\n} from \"./compiler\";\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Type,\n  TypeKind,\n  Signature,\n  TypeFlags\n} from \"./types\";\n\nimport {\n  Token,\n  Range\n} from \"./tokenizer\";\n\nimport {\n  Node,\n  NodeKind,\n  Source,\n  SourceKind,\n  DecoratorNode,\n  DecoratorKind,\n  TypeParameterNode,\n  TypeNode,\n  NamedTypeNode,\n  FunctionTypeNode,\n  ArrowKind,\n\n  Expression,\n  IdentifierExpression,\n  LiteralKind,\n  StringLiteralExpression,\n\n  Statement,\n  ClassDeclaration,\n  DeclarationStatement,\n  EnumDeclaration,\n  EnumValueDeclaration,\n  ExportMember,\n  ExportDefaultStatement,\n  ExportStatement,\n  FieldDeclaration,\n  FunctionDeclaration,\n  ImportDeclaration,\n  ImportStatement,\n  InterfaceDeclaration,\n  MethodDeclaration,\n  NamespaceDeclaration,\n  TypeDeclaration,\n  VariableDeclaration,\n  VariableLikeDeclarationStatement,\n  VariableStatement,\n  ParameterKind\n} from \"./ast\";\n\nimport {\n  Module,\n  FunctionRef,\n  MemorySegment\n} from \"./module\";\n\nimport {\n  CharCode,\n  writeI8,\n  writeI16,\n  writeI32,\n  writeF32,\n  writeF64,\n  writeI64,\n  writeI32AsI64,\n  writeI64AsI32\n} from \"./util\";\n\nimport {\n  Resolver\n} from \"./resolver\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Parser\n} from \"./parser\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Represents a yet unresolved `import`. */\nclass QueuedImport {\n  constructor(\n    /** File being imported into. */\n    public localFile: File,\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. Is an `import *` if not set. */\n    public foreignIdentifier: IdentifierExpression | null,\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string\n  ) {}\n}\n\n/** Represents a yet unresolved `export`. */\nclass QueuedExport {\n  constructor(\n    /** Identifier within the local file. */\n    public localIdentifier: IdentifierExpression,\n    /** Identifier within the other file. */\n    public foreignIdentifier: IdentifierExpression,\n    /** Path to the other file if a re-export. */\n    public foreignPath: string | null,\n    /** Alternative path to the other file if a re-export. */\n    public foreignPathAlt: string | null\n  ) {}\n}\n\n/** Represents a yet unresolved `export *`. */\nclass QueuedExportStar {\n  // stored in a map with localFile as the key\n  constructor(\n    /** Path to the other file. */\n    public foreignPath: string,\n    /** Alternative path to the other file. */\n    public foreignPathAlt: string,\n    /** Reference to the path literal for reporting. */\n    public pathLiteral: StringLiteralExpression\n  ) {}\n}\n\n/** Represents the kind of an operator overload. */\nexport enum OperatorKind {\n  INVALID,\n\n  // indexed access\n  INDEXED_GET,            // a[]\n  INDEXED_SET,            // a[]=b\n  UNCHECKED_INDEXED_GET,  // unchecked(a[])\n  UNCHECKED_INDEXED_SET,  // unchecked(a[]=b)\n\n  // binary\n  ADD,                    // a + b\n  SUB,                    // a - b\n  MUL,                    // a * b\n  DIV,                    // a / b\n  REM,                    // a % b\n  POW,                    // a ** b\n  BITWISE_AND,            // a & b\n  BITWISE_OR,             // a | b\n  BITWISE_XOR,            // a ^ b\n  BITWISE_SHL,            // a << b\n  BITWISE_SHR,            // a >> b\n  BITWISE_SHR_U,          // a >>> b\n  EQ,                     // a == b\n  NE,                     // a != b\n  GT,                     // a > b\n  GE,                     // a >= b\n  LT,                     // a < b\n  LE,                     // a <= b\n\n  // unary prefix\n  PLUS,                   // +a\n  MINUS,                  // -a\n  NOT,                    // !a\n  BITWISE_NOT,            // ~a\n  PREFIX_INC,             // ++a\n  PREFIX_DEC,             // --a\n\n  // unary postfix\n  POSTFIX_INC,            // a++\n  POSTFIX_DEC             // a--\n\n  // not overridable:\n  // IDENTITY             // a === b\n  // LOGICAL_AND          // a && b\n  // LOGICAL_OR           // a || b\n}\n\nexport namespace OperatorKind {\n\n  /** Returns the operator kind represented by the specified decorator and string argument. */\n  export function fromDecorator(decoratorKind: DecoratorKind, arg: string): OperatorKind {\n    assert(arg.length);\n    switch (decoratorKind) {\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.OPENBRACKET: {\n            if (arg == \"[]\") return OperatorKind.INDEXED_GET;\n            if (arg == \"[]=\") return OperatorKind.INDEXED_SET;\n            break;\n          }\n          case CharCode.OPENBRACE: {\n            if (arg == \"{}\") return OperatorKind.UNCHECKED_INDEXED_GET;\n            if (arg == \"{}=\") return OperatorKind.UNCHECKED_INDEXED_SET;\n            break;\n          }\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.ADD;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.SUB;\n            break;\n          }\n          case CharCode.ASTERISK: {\n            if (arg == \"*\") return OperatorKind.MUL;\n            if (arg == \"**\") return OperatorKind.POW;\n            break;\n          }\n          case CharCode.SLASH: {\n            if (arg == \"/\") return OperatorKind.DIV;\n            break;\n          }\n          case CharCode.PERCENT: {\n            if (arg == \"%\") return OperatorKind.REM;\n            break;\n          }\n          case CharCode.AMPERSAND: {\n            if (arg == \"&\") return OperatorKind.BITWISE_AND;\n            break;\n          }\n          case CharCode.BAR: {\n            if (arg == \"|\") return OperatorKind.BITWISE_OR;\n            break;\n          }\n          case CharCode.CARET: {\n            if (arg == \"^\") return OperatorKind.BITWISE_XOR;\n            break;\n          }\n          case CharCode.EQUALS: {\n            if (arg == \"==\") return OperatorKind.EQ;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!=\") return OperatorKind.NE;\n            break;\n          }\n          case CharCode.GREATERTHAN: {\n            if (arg == \">\") return OperatorKind.GT;\n            if (arg == \">=\") return OperatorKind.GE;\n            if (arg == \">>\") return OperatorKind.BITWISE_SHR;\n            if (arg == \">>>\") return OperatorKind.BITWISE_SHR_U;\n            break;\n          }\n          case CharCode.LESSTHAN: {\n            if (arg == \"<\") return OperatorKind.LT;\n            if (arg == \"<=\") return OperatorKind.LE;\n            if (arg == \"<<\") return OperatorKind.BITWISE_SHL;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_PREFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"+\") return OperatorKind.PLUS;\n            if (arg == \"++\") return OperatorKind.PREFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"-\") return OperatorKind.MINUS;\n            if (arg == \"--\") return OperatorKind.PREFIX_DEC;\n            break;\n          }\n          case CharCode.EXCLAMATION: {\n            if (arg == \"!\") return OperatorKind.NOT;\n            break;\n          }\n          case CharCode.TILDE: {\n            if (arg == \"~\") return OperatorKind.BITWISE_NOT;\n            break;\n          }\n        }\n        break;\n      }\n      case DecoratorKind.OPERATOR_POSTFIX: {\n        switch (arg.charCodeAt(0)) {\n          case CharCode.PLUS: {\n            if (arg == \"++\") return OperatorKind.POSTFIX_INC;\n            break;\n          }\n          case CharCode.MINUS: {\n            if (arg == \"--\") return OperatorKind.POSTFIX_DEC;\n            break;\n          }\n        }\n        break;\n      }\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a binary operator token to the respective operator kind. */\n  export function fromBinaryToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS:\n      case Token.PLUS_EQUALS: return OperatorKind.ADD;\n      case Token.MINUS:\n      case Token.MINUS_EQUALS: return OperatorKind.SUB;\n      case Token.ASTERISK:\n      case Token.ASTERISK_EQUALS: return OperatorKind.MUL;\n      case Token.SLASH:\n      case Token.SLASH_EQUALS: return OperatorKind.DIV;\n      case Token.PERCENT:\n      case Token.PERCENT_EQUALS: return OperatorKind.REM;\n      case Token.ASTERISK_ASTERISK:\n      case Token.ASTERISK_ASTERISK_EQUALS: return OperatorKind.POW;\n      case Token.AMPERSAND:\n      case Token.AMPERSAND_EQUALS: return OperatorKind.BITWISE_AND;\n      case Token.BAR:\n      case Token.BAR_EQUALS: return OperatorKind.BITWISE_OR;\n      case Token.CARET:\n      case Token.CARET_EQUALS: return OperatorKind.BITWISE_XOR;\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.LESSTHAN_LESSTHAN_EQUALS: return OperatorKind.BITWISE_SHL;\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR;\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return OperatorKind.BITWISE_SHR_U;\n      case Token.EQUALS_EQUALS: return OperatorKind.EQ;\n      case Token.EXCLAMATION_EQUALS: return OperatorKind.NE;\n      case Token.GREATERTHAN: return OperatorKind.GT;\n      case Token.GREATERTHAN_EQUALS: return OperatorKind.GE;\n      case Token.LESSTHAN: return OperatorKind.LT;\n      case Token.LESSTHAN_EQUALS: return OperatorKind.LE;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary prefix operator token to the respective operator kind. */\n  export function fromUnaryPrefixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS: return OperatorKind.PLUS;\n      case Token.MINUS: return OperatorKind.MINUS;\n      case Token.EXCLAMATION: return OperatorKind.NOT;\n      case Token.TILDE: return OperatorKind.BITWISE_NOT;\n      case Token.PLUS_PLUS: return OperatorKind.PREFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.PREFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n\n  /** Converts a unary postfix operator token to the respective operator kind. */\n  export function fromUnaryPostfixToken(token: Token): OperatorKind {\n    switch (token) {\n      case Token.PLUS_PLUS: return OperatorKind.POSTFIX_INC;\n      case Token.MINUS_MINUS: return OperatorKind.POSTFIX_DEC;\n    }\n    return OperatorKind.INVALID;\n  }\n}\n\n/** Represents an AssemblyScript program. */\nexport class Program extends DiagnosticEmitter {\n\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\n  constructor(\n    /** Compiler options. */\n    public options: Options,\n    /** Shared array of diagnostic messages (emitted so far). */\n    diagnostics: DiagnosticMessage[] | null = null\n  ) {\n    super(diagnostics);\n    var nativeSource = new Source(SourceKind.LIBRARY_ENTRY, LIBRARY_SUBST + \".wasm\", \"[native code]\");\n    this.nativeSource = nativeSource;\n    this.parser = new Parser(this.diagnostics, this.sources);\n    this.resolver = new Resolver(this);\n    var nativeFile = new File(this, nativeSource);\n    this.nativeFile = nativeFile;\n    this.filesByName.set(nativeFile.internalName, nativeFile);\n  }\n\n  /** Parser instance. */\n  parser: Parser;\n  /** Resolver instance. */\n  resolver!: Resolver;\n  /** Array of sources. */\n  sources: Source[] = [];\n  /** Diagnostic offset used where successively obtaining the next diagnostic. */\n  diagnosticsOffset: i32 = 0;\n  /** Special native code source. */\n  nativeSource: Source;\n  /** Special native code file. */\n  nativeFile!: File;\n  /** Next class id. */\n  nextClassId: u32 = 0;\n  /** Next signature id. */\n  nextSignatureId: i32 = 0;\n  /** An indicator if the program has been initialized. */\n  initialized: bool = false;\n\n  // Lookup maps\n\n  /** Files by unique internal name. */\n  filesByName: Map<string,File> = new Map();\n  /** Elements by unique internal name in element space. */\n  elementsByName: Map<string,Element> = new Map();\n  /** Elements by declaration. */\n  elementsByDeclaration: Map<DeclarationStatement,DeclaredElement> = new Map();\n  /** Element instances by unique internal name. */\n  instancesByName: Map<string,Element> = new Map();\n  /** Classes wrapping basic types like `i32`. */\n  wrapperClasses: Map<Type,Class> = new Map();\n  /** Managed classes contained in the program, by id. */\n  managedClasses: Map<i32,Class> = new Map();\n  /** A set of unique function signatures contained in the program, by id. */\n  uniqueSignatures: Signature[] = new Array<Signature>(0);\n\n  // Standard library\n\n  /** Gets the standard `ArrayBufferView` instance. */\n  get arrayBufferViewInstance(): Class {\n    var cached = this._arrayBufferViewInstance;\n    if (!cached) this._arrayBufferViewInstance = cached = this.requireClass(CommonNames.ArrayBufferView);\n    return cached;\n  }\n  private _arrayBufferViewInstance: Class | null = null;\n\n  /** Gets the standard `ArrayBuffer` instance. */\n  get arrayBufferInstance(): Class {\n    var cached = this._arrayBufferInstance;\n    if (!cached) this._arrayBufferInstance = cached = this.requireClass(CommonNames.ArrayBuffer);\n    return cached;\n  }\n  private _arrayBufferInstance: Class | null = null;\n\n  /** Gets the standard `Array` prototype. */\n  get arrayPrototype(): ClassPrototype {\n    var cached = this._arrayPrototype;\n    if (!cached) this._arrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _arrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `StaticArray` prototype. */\n  get staticArrayPrototype(): ClassPrototype {\n    var cached = this._staticArrayPrototype;\n    if (!cached) this._staticArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.StaticArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _staticArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Set` prototype. */\n  get setPrototype(): ClassPrototype {\n    var cached = this._setPrototype;\n    if (!cached) this._setPrototype = cached = <ClassPrototype>this.require(CommonNames.Set, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _setPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Map` prototype. */\n  get mapPrototype(): ClassPrototype {\n    var cached = this._mapPrototype;\n    if (!cached) this._mapPrototype = cached = <ClassPrototype>this.require(CommonNames.Map, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _mapPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Function` prototype. */\n  get functionPrototype(): ClassPrototype {\n    var cached = this._functionPrototype;\n    if (!cached) this._functionPrototype = cached = <ClassPrototype>this.require(CommonNames.Function, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _functionPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int8Array` prototype. */\n  get int8ArrayPrototype(): ClassPrototype {\n    var cached = this._int8ArrayPrototype;\n    if (!cached) this._int8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int16Array` prototype. */\n  get int16ArrayPrototype(): ClassPrototype {\n    var cached = this._int16ArrayPrototype;\n    if (!cached) this._int16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int32Array` prototype. */\n  get int32ArrayPrototype(): ClassPrototype {\n    var cached = this._int32ArrayPrototype;\n    if (!cached) this._int32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Int64Array` prototype. */\n  get int64ArrayPrototype(): ClassPrototype {\n    var cached = this._int64ArrayPrototype;\n    if (!cached) this._int64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Int64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _int64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8Array` prototype. */\n  get uint8ArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ArrayPrototype;\n    if (!cached) this._uint8ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint8ClampedArray` prototype. */\n  get uint8ClampedArrayPrototype(): ClassPrototype {\n    var cached = this._uint8ClampedArrayPrototype;\n    if (!cached) this._uint8ClampedArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint8ClampedArray, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint8ClampedArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint16Array` prototype. */\n  get uint16ArrayPrototype(): ClassPrototype {\n    var cached = this._uint16ArrayPrototype;\n    if (!cached) this._uint16ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint16Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint16ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint32Array` prototype. */\n  get uint32ArrayPrototype(): ClassPrototype {\n    var cached = this._uint32ArrayPrototype;\n    if (!cached) this._uint32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Uint64Array` prototype. */\n  get uint64ArrayPrototype(): ClassPrototype {\n    var cached = this._uint64ArrayPrototype;\n    if (!cached) this._uint64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Uint64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _uint64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float32Array` prototype. */\n  get float32ArrayPrototype(): ClassPrototype {\n    var cached = this._float32ArrayPrototype;\n    if (!cached) this._float32ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float32Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float32ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `Float64Array` prototype. */\n  get float64ArrayPrototype(): ClassPrototype {\n    var cached = this._float64ArrayPrototype;\n    if (!cached) this._float64ArrayPrototype = cached = <ClassPrototype>this.require(CommonNames.Float64Array, ElementKind.CLASS_PROTOTYPE);\n    return cached;\n  }\n  private _float64ArrayPrototype: ClassPrototype | null = null;\n\n  /** Gets the standard `String` instance. */\n  get stringInstance(): Class {\n    var cached = this._stringInstance;\n    if (!cached) this._stringInstance = cached = this.requireClass(CommonNames.String);\n    return cached;\n  }\n  private _stringInstance: Class | null = null;\n\n  /** Gets the standard `abort` instance, if not explicitly disabled. */\n  get abortInstance(): Function | null {\n    return this.lookupFunction(CommonNames.abort);\n  }\n\n  // Runtime interface\n\n  /** Gets the runtime `__alloc(size: usize): usize` instance. */\n  get allocInstance(): Function {\n    var cached = this._allocInstance;\n    if (!cached) this._allocInstance = cached = this.requireFunction(CommonNames.alloc);\n    return cached;\n  }\n  private _allocInstance: Function | null = null;\n\n  /** Gets the runtime `__realloc(ptr: usize, newSize: usize): usize` instance. */\n  get reallocInstance(): Function {\n    var cached = this._reallocInstance;\n    if (!cached) this._reallocInstance = cached = this.requireFunction(CommonNames.realloc);\n    return cached;\n  }\n  private _reallocInstance: Function | null = null;\n\n  /** Gets the runtime `__free(ptr: usize): void` instance. */\n  get freeInstance(): Function {\n    var cached = this._freeInstance;\n    if (!cached) this._freeInstance = cached = this.requireFunction(CommonNames.free);\n    return cached;\n  }\n  private _freeInstance: Function | null = null;\n\n  /** Gets the runtime `__new(size: usize, id: u32): usize` instance. */\n  get newInstance(): Function {\n    var cached = this._newInstance;\n    if (!cached) this._newInstance = cached = this.requireFunction(CommonNames.new_);\n    return cached;\n  }\n  private _newInstance: Function | null = null;\n\n  /** Gets the runtime `__renew(ptr: usize, size: usize): usize` instance. */\n  get renewInstance(): Function {\n    var cached = this._renewInstance;\n    if (!cached) this._renewInstance = cached = this.requireFunction(CommonNames.renew);\n    return cached;\n  }\n  private _renewInstance: Function | null = null;\n\n  /** Gets the runtime `__retain(ptr: usize): usize` instance. */\n  get retainInstance(): Function {\n    var cached = this._retainInstance;\n    if (!cached) this._retainInstance = cached = this.requireFunction(CommonNames.retain);\n    return cached;\n  }\n  private _retainInstance: Function | null = null;\n\n  /** Gets the runtime `__release(ptr: usize): void` instance. */\n  get releaseInstance(): Function {\n    var cached = this._releaseInstance;\n    if (!cached) this._releaseInstance = cached = this.requireFunction(CommonNames.release);\n    return cached;\n  }\n  private _releaseInstance: Function | null = null;\n\n  /** Gets the runtime `__collect(): void` instance. */\n  get collectInstance(): Function {\n    var cached = this._collectInstance;\n    if (!cached) this._collectInstance = cached = this.requireFunction(CommonNames.collect);\n    return cached;\n  }\n  private _collectInstance: Function | null = null;\n\n  /** Gets the runtime `__visit(ptr: usize, cookie: u32): void` instance. */\n  get visitInstance(): Function {\n    var cached = this._visitInstance;\n    if (!cached) this._visitInstance = cached = this.requireFunction(CommonNames.visit);\n    return cached;\n  }\n  private _visitInstance: Function | null = null;\n\n  /** Gets the runtime `__typeinfo(id: u32): RTTIFlags` instance. */\n  get typeinfoInstance(): Function {\n    var cached = this._typeinfoInstance;\n    if (!cached) this._typeinfoInstance = cached = this.requireFunction(CommonNames.typeinfo);\n    return cached;\n  }\n  private _typeinfoInstance: Function | null = null;\n\n  /** Gets the runtime `__instanceof(ptr: usize, superId: u32): bool` instance. */\n  get instanceofInstance(): Function {\n    var cached = this._instanceofInstance;\n    if (!cached) this._instanceofInstance = cached = this.requireFunction(CommonNames.instanceof_);\n    return cached;\n  }\n  private _instanceofInstance: Function | null = null;\n\n  /** Gets the runtime `__newBuffer(size: usize, id: u32, data: usize = 0): usize` instance. */\n  get newBufferInstance(): Function {\n    var cached = this._newBufferInstance;\n    if (!cached) this._newBufferInstance = cached = this.requireFunction(CommonNames.newBuffer);\n    return cached;\n  }\n  private _newBufferInstance: Function | null = null;\n\n  /** Gets the runtime `__newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize` instance. */\n  get newArrayInstance(): Function {\n    var cached = this._newArrayInstance;\n    if (!cached) this._newArrayInstance = cached = this.requireFunction(CommonNames.newArray);\n    return cached;\n  }\n  private _newArrayInstance: Function | null = null;\n\n  /** Gets the runtime's internal `BLOCK` instance. */\n  get BLOCKInstance(): Class {\n    var cached = this._BLOCKInstance;\n    if (!cached) this._BLOCKInstance = cached = this.requireClass(CommonNames.BLOCK);\n    return cached;\n  }\n  private _BLOCKInstance: Class | null = null;\n\n  /** Gets the runtime's internal `OBJECT` instance. */\n  get OBJECTInstance(): Class {\n    var cached = this._OBJECTInstance;\n    if (!cached) this._OBJECTInstance = cached = this.requireClass(CommonNames.OBJECT);\n    return cached;\n  }\n  private _OBJECTInstance: Class | null = null;\n\n  // Utility\n\n  /** Tests whether this is a WASI program. */\n  get isWasi(): bool {\n    return this.elementsByName.has(CommonNames.ASC_WASI);\n  }\n\n  /** Obtains the source matching the specified internal path. */\n  getSource(internalPath: string): string | null {\n    var sources = this.sources;\n    for (let i = 0; i < sources.length; ++i) {\n      let source = sources[i];\n      if (source.internalPath == internalPath) return source.text;\n    }\n    return null;\n  }\n\n  /** Gets the size of a runtime header. */\n  get runtimeHeaderSize(): i32 {\n    var cached = this._runtimeHeaderSize;\n    if (!cached) {\n      // see: rt/common.ts\n      var blockOverhead = this.BLOCKInstance.nextMemoryOffset;\n      var totalOverhead = this.OBJECTInstance.nextMemoryOffset;\n      const AL_SIZE = 16;\n      const AL_MASK = AL_SIZE - 1;\n      var objectOverhead = (totalOverhead - blockOverhead + AL_MASK) & ~AL_MASK;\n      var headerSize = blockOverhead + objectOverhead;\n      assert(headerSize == 20);\n      this._runtimeHeaderSize = cached = headerSize;\n    }\n    return cached;\n  }\n  private _runtimeHeaderSize: u32 = 0;\n\n  /** Creates a native variable declaration. */\n  makeNativeVariableDeclaration(\n    /** The simple name of the variable */\n    name: string,\n    /** Flags indicating specific traits, e.g. `CONST`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): VariableDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createVariableDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, null, range\n    );\n  }\n\n  /** Creates a native type declaration. */\n  makeNativeTypeDeclaration(\n    /** The simple name of the type. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): TypeDeclaration {\n    var range = this.nativeSource.range;\n    var identifier = Node.createIdentifierExpression(name, range);\n    return Node.createTypeDeclaration(\n      identifier,\n      null, flags, null,\n      Node.createOmittedType(range),\n      range\n    );\n  }\n\n  // a dummy signature for programmatically generated native functions\n  private nativeDummySignature: FunctionTypeNode | null = null;\n\n  /** Creates a native function declaration. */\n  makeNativeFunctionDeclaration(\n    /** The simple name of the function. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `DECLARE`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): FunctionDeclaration {\n    var range = this.nativeSource.range;\n    var signature = this.nativeDummySignature;\n    if (!signature) {\n      this.nativeDummySignature = signature = Node.createFunctionType([],\n        Node.createNamedType( // ^ AST signature doesn't really matter, is overridden anyway\n          Node.createSimpleTypeName(CommonNames.void_, range),\n          null, false, range\n        ),\n        null, false, range\n      );\n    }\n    return Node.createFunctionDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, null, signature, null, ArrowKind.NONE, range\n    );\n  }\n\n  /** Creates a native namespace declaration. */\n  makeNativeNamespaceDeclaration(\n    /** The simple name of the namespace. */\n    name: string,\n    /** Flags indicating specific traits, e.g. `EXPORT`. */\n    flags: CommonFlags = CommonFlags.NONE\n  ): NamespaceDeclaration {\n    var range = this.nativeSource.range;\n    return Node.createNamespaceDeclaration(\n      Node.createIdentifierExpression(name, range),\n      null, flags, [], range\n    );\n  }\n\n  /** Creates a native function. */\n  makeNativeFunction(\n    /** The simple name of the function. */\n    name: string,\n    /** Concrete function signature. */\n    signature: Signature,\n    /** Parent element, usually a file, class or namespace. */\n    parent: Element = this.nativeFile,\n    /** Flags indicating specific traits, e.g. `GENERIC`. */\n    flags: CommonFlags = CommonFlags.NONE,\n    /** Decorator flags representing built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ): Function {\n    return new Function(\n      name,\n      new FunctionPrototype(\n        name,\n        parent,\n        this.makeNativeFunctionDeclaration(name, flags),\n        decoratorFlags\n      ),\n      null,\n      signature\n    );\n  }\n\n  /** Gets the (possibly merged) program element linked to the specified declaration. */\n  getElementByDeclaration(declaration: DeclarationStatement): DeclaredElement | null {\n    var elementsByDeclaration = this.elementsByDeclaration;\n    return elementsByDeclaration.has(declaration)\n      ? assert(elementsByDeclaration.get(declaration))\n      : null;\n  }\n\n  /** Initializes the program and its elements prior to compilation. */\n  initialize(): void {\n    if (this.initialized) return;\n    this.initialized = true;\n\n    var options = this.options;\n\n    // register native types\n    this.registerNativeType(CommonNames.i8, Type.i8);\n    this.registerNativeType(CommonNames.i16, Type.i16);\n    this.registerNativeType(CommonNames.i32, Type.i32);\n    this.registerNativeType(CommonNames.i64, Type.i64);\n    this.registerNativeType(CommonNames.isize, options.isizeType);\n    this.registerNativeType(CommonNames.u8, Type.u8);\n    this.registerNativeType(CommonNames.u16, Type.u16);\n    this.registerNativeType(CommonNames.u32, Type.u32);\n    this.registerNativeType(CommonNames.u64, Type.u64);\n    this.registerNativeType(CommonNames.usize, options.usizeType);\n    this.registerNativeType(CommonNames.bool, Type.bool);\n    this.registerNativeType(CommonNames.f32, Type.f32);\n    this.registerNativeType(CommonNames.f64, Type.f64);\n    this.registerNativeType(CommonNames.void_, Type.void);\n    this.registerNativeType(CommonNames.number, Type.f64); // alias\n    this.registerNativeType(CommonNames.boolean, Type.bool); // alias\n    this.nativeFile.add(CommonNames.native, new TypeDefinition(\n      CommonNames.native,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.native, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.indexof, new TypeDefinition(\n      CommonNames.indexof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.indexof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.valueof, new TypeDefinition(\n      CommonNames.valueof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.valueof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n    this.nativeFile.add(CommonNames.returnof, new TypeDefinition(\n      CommonNames.returnof,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(CommonNames.returnof, CommonFlags.EXPORT | CommonFlags.GENERIC),\n      DecoratorFlags.BUILTIN\n    ));\n\n    // The following types might not be enabled by compiler options, so the\n    // compiler needs to check this condition whenever such a value is created\n    // respectively stored or loaded.\n    this.registerNativeType(CommonNames.v128, Type.v128);\n    this.registerNativeType(CommonNames.funcref, Type.funcref);\n    this.registerNativeType(CommonNames.externref, Type.externref);\n    this.registerNativeType(CommonNames.exnref, Type.exnref);\n    this.registerNativeType(CommonNames.anyref, Type.anyref);\n\n    // register compiler hints\n    this.registerConstantInteger(CommonNames.ASC_TARGET, Type.i32,\n      i64_new(options.isWasm64 ? Target.WASM64 : Target.WASM32));\n    this.registerConstantInteger(CommonNames.ASC_NO_ASSERT, Type.bool,\n      i64_new(options.noAssert ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_MEMORY_BASE, Type.i32,\n      i64_new(options.memoryBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_TABLE_BASE, Type.i32,\n      i64_new(options.tableBase, 0));\n    this.registerConstantInteger(CommonNames.ASC_OPTIMIZE_LEVEL, Type.i32,\n      i64_new(options.optimizeLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_SHRINK_LEVEL, Type.i32,\n      i64_new(options.shrinkLevelHint, 0));\n    this.registerConstantInteger(CommonNames.ASC_LOW_MEMORY_LIMIT, Type.i32,\n      i64_new(options.lowMemoryLimit, 0));\n\n    // register feature hints\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIGN_EXTENSION, Type.bool,\n      i64_new(options.hasFeature(Feature.SIGN_EXTENSION) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MUTABLE_GLOBALS, Type.bool,\n      i64_new(options.hasFeature(Feature.MUTABLE_GLOBALS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_NONTRAPPING_F2I, Type.bool,\n      i64_new(options.hasFeature(Feature.NONTRAPPING_F2I) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_BULK_MEMORY, Type.bool,\n      i64_new(options.hasFeature(Feature.BULK_MEMORY) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_SIMD, Type.bool,\n      i64_new(options.hasFeature(Feature.SIMD) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_THREADS, Type.bool,\n      i64_new(options.hasFeature(Feature.THREADS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_EXCEPTION_HANDLING, Type.bool,\n      i64_new(options.hasFeature(Feature.EXCEPTION_HANDLING) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_TAIL_CALLS, Type.bool,\n      i64_new(options.hasFeature(Feature.TAIL_CALLS) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_REFERENCE_TYPES, Type.bool,\n      i64_new(options.hasFeature(Feature.REFERENCE_TYPES) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MULTI_VALUE, Type.bool,\n      i64_new(options.hasFeature(Feature.MULTI_VALUE) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_GC, Type.bool,\n      i64_new(options.hasFeature(Feature.GC) ? 1 : 0, 0));\n    this.registerConstantInteger(CommonNames.ASC_FEATURE_MEMORY64, Type.bool,\n      i64_new(options.hasFeature(Feature.MEMORY64) ? 1 : 0, 0));\n\n    // remember deferred elements\n    var queuedImports = new Array<QueuedImport>();\n    var queuedExports = new Map<File,Map<string,QueuedExport>>();\n    var queuedExportsStar = new Map<File,QueuedExportStar[]>();\n    var queuedExtends = new Array<ClassPrototype>();\n    var queuedImplements = new Array<ClassPrototype>();\n\n    // initialize relevant declaration-like statements of the entire program\n    for (let i = 0, k = this.sources.length; i < k; ++i) {\n      let source = this.sources[i];\n      let file = new File(this, source);\n      this.filesByName.set(file.internalName, file);\n      let statements = source.statements;\n      for (let j = 0, l = statements.length; j < l; ++j) {\n        let statement = statements[j];\n        switch (statement.kind) {\n          case NodeKind.EXPORT: {\n            this.initializeExports(<ExportStatement>statement, file, queuedExports, queuedExportsStar);\n            break;\n          }\n          case NodeKind.EXPORTDEFAULT: {\n            this.initializeExportDefault(<ExportDefaultStatement>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.IMPORT: {\n            this.initializeImports(<ImportStatement>statement, file, queuedImports, queuedExports);\n            break;\n          }\n          case NodeKind.VARIABLE: {\n            this.initializeVariables(<VariableStatement>statement, file);\n            break;\n          }\n          case NodeKind.CLASSDECLARATION: {\n            this.initializeClass(<ClassDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.ENUMDECLARATION: {\n            this.initializeEnum(<EnumDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.FUNCTIONDECLARATION: {\n            this.initializeFunction(<FunctionDeclaration>statement, file);\n            break;\n          }\n          case NodeKind.INTERFACEDECLARATION: {\n            this.initializeInterface(<InterfaceDeclaration>statement, file, queuedExtends);\n            break;\n          }\n          case NodeKind.NAMESPACEDECLARATION: {\n            this.initializeNamespace(<NamespaceDeclaration>statement, file, queuedExtends, queuedImplements);\n            break;\n          }\n          case NodeKind.TYPEDECLARATION: {\n            this.initializeTypeDefinition(<TypeDeclaration>statement, file);\n            break;\n          }\n        }\n      }\n    }\n\n    // queued exports * should be linkable now that all files have been processed\n    // TODO: for (let [file, starExports] of queuedExportsStar) {\n    for (let _keys = Map_keys(queuedExportsStar), i = 0, k = _keys.length; i < k; ++i) {\n      let file = _keys[i];\n      let starExports = assert(queuedExportsStar.get(file));\n      for (let j = 0, l = starExports.length; j < l; ++j) {\n        let exportStar = unchecked(starExports[j]);\n        let foreignFile = this.lookupForeignFile(exportStar.foreignPath, exportStar.foreignPathAlt);\n        if (!foreignFile) {\n          this.error(\n            DiagnosticCode.File_0_not_found,\n            exportStar.pathLiteral.range, exportStar.pathLiteral.value\n          );\n          continue;\n        }\n        file.ensureExportStar(foreignFile);\n      }\n    }\n\n    // queued imports should be resolvable now through traversing exports and queued exports.\n    // note that imports may depend upon imports, so repeat until there's no more progress.\n    do {\n      let i = 0, madeProgress = false;\n      while (i < queuedImports.length) {\n        let queuedImport = queuedImports[i];\n        let localIdentifier = queuedImport.localIdentifier;\n        let foreignIdentifier = queuedImport.foreignIdentifier;\n        if (foreignIdentifier) { // i.e. import { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            foreignIdentifier.text,\n            queuedImport.foreignPath,\n            queuedImport.foreignPathAlt,\n            queuedExports\n          );\n          if (element) {\n            queuedImport.localFile.add(\n              localIdentifier.text,\n              element,\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n          }\n        } else { // i.e. import * as bar from \"./bar\"\n          let foreignFile = this.lookupForeignFile(queuedImport.foreignPath, queuedImport.foreignPathAlt);\n          if (foreignFile) {\n            let localFile = queuedImport.localFile;\n            let localName = localIdentifier.text;\n            localFile.add(\n              localName,\n              foreignFile.asAliasNamespace(\n                localName,\n                localFile,\n                localIdentifier\n              ),\n              localIdentifier // isImport\n            );\n            queuedImports.splice(i, 1);\n            madeProgress = true;\n          } else {\n            ++i;\n            assert(false); // already reported by the parser not finding the file\n          }\n        }\n      }\n      if (!madeProgress) {\n        // report queued imports we were unable to resolve\n        for (let j = 0, l = queuedImports.length; j < l; ++j) {\n          let queuedImport = queuedImports[j];\n          let foreignIdentifier = queuedImport.foreignIdentifier;\n          if (foreignIdentifier) {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              foreignIdentifier.range, queuedImport.foreignPath, foreignIdentifier.text\n            );\n          }\n        }\n        break;\n      }\n    } while (true);\n\n    // queued exports should be resolvable now that imports are finalized\n    // TODO: for (let [file, exports] of queuedExports) {\n    for (let _keys = Map_keys(queuedExports), i = 0, k = _keys.length; i < k; ++i) {\n      let file = unchecked(_keys[i]);\n      let exports = assert(queuedExports.get(file));\n      // TODO: for (let [exportName, queuedExport] of exports) {\n      for (let exportNames = Map_keys(exports), j = 0, l = exportNames.length; j < l; ++j) {\n        let exportName = unchecked(exportNames[j]);\n        let queuedExport = assert(exports.get(exportName));\n        let localName = queuedExport.localIdentifier.text;\n        let foreignPath = queuedExport.foreignPath;\n        if (foreignPath) { // i.e. export { foo [as bar] } from \"./baz\"\n          let element = this.lookupForeign(\n            localName,\n            foreignPath,\n            assert(queuedExport.foreignPathAlt), // must be set if foreignPath is\n            queuedExports\n          );\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            this.error(\n              DiagnosticCode.Module_0_has_no_exported_member_1,\n              queuedExport.localIdentifier.range,\n              foreignPath, localName\n            );\n          }\n        } else { // i.e. export { foo [as bar] }\n          let element = file.lookupInSelf(localName);\n          if (element) {\n            file.ensureExport(exportName, element);\n          } else {\n            let globalElement = this.lookupGlobal(localName);\n            if (globalElement !== null && isDeclaredElement(globalElement.kind)) { // export { memory }\n              file.ensureExport(exportName, <DeclaredElement>globalElement);\n            } else {\n              this.error(\n                DiagnosticCode.Module_0_has_no_exported_member_1,\n                queuedExport.foreignIdentifier.range,\n                file.internalName, queuedExport.foreignIdentifier.text\n              );\n            }\n          }\n        }\n      }\n    }\n\n    // register ArrayBuffer (id=0), String (id=1), ArrayBufferView (id=2)\n    assert(this.arrayBufferInstance.id == 0);\n    assert(this.stringInstance.id == 1);\n    assert(this.arrayBufferViewInstance.id == 2);\n\n    // register classes backing basic types\n    this.registerWrapperClass(Type.i8, CommonNames.I8);\n    this.registerWrapperClass(Type.i16, CommonNames.I16);\n    this.registerWrapperClass(Type.i32, CommonNames.I32);\n    this.registerWrapperClass(Type.i64, CommonNames.I64);\n    this.registerWrapperClass(options.isizeType, CommonNames.Isize);\n    this.registerWrapperClass(Type.u8, CommonNames.U8);\n    this.registerWrapperClass(Type.u16, CommonNames.U16);\n    this.registerWrapperClass(Type.u32, CommonNames.U32);\n    this.registerWrapperClass(Type.u64, CommonNames.U64);\n    this.registerWrapperClass(options.usizeType, CommonNames.Usize);\n    this.registerWrapperClass(Type.bool, CommonNames.Bool);\n    this.registerWrapperClass(Type.f32, CommonNames.F32);\n    this.registerWrapperClass(Type.f64, CommonNames.F64);\n    if (options.hasFeature(Feature.SIMD)) this.registerWrapperClass(Type.v128, CommonNames.V128);\n    if (options.hasFeature(Feature.REFERENCE_TYPES)) {\n      this.registerWrapperClass(Type.funcref, CommonNames.Funcref);\n      this.registerWrapperClass(Type.externref, CommonNames.Externref);\n      if (options.hasFeature(Feature.EXCEPTION_HANDLING)) {\n        this.registerWrapperClass(Type.exnref, CommonNames.Exnref);\n      }\n      if (options.hasFeature(Feature.GC)) {\n        this.registerWrapperClass(Type.anyref, CommonNames.Anyref);\n      }\n    }\n\n    // resolve prototypes of extended classes or interfaces\n    var resolver = this.resolver;\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let extendsNode = assert(thisPrototype.extendsNode); // must be present if in queuedExtends\n      let baseElement = resolver.resolveTypeName(extendsNode.name, thisPrototype.parent);\n      if (!baseElement) continue;\n      if (thisPrototype.kind == ElementKind.CLASS_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.CLASS_PROTOTYPE) {\n          let basePrototype = <ClassPrototype>baseElement;\n          if (basePrototype.hasDecorator(DecoratorFlags.FINAL)) {\n            this.error(\n              DiagnosticCode.Class_0_is_final_and_cannot_be_extended,\n              extendsNode.range, basePrototype.identifierNode.text\n            );\n          }\n          if (\n            basePrototype.hasDecorator(DecoratorFlags.UNMANAGED) !=\n            thisPrototype.hasDecorator(DecoratorFlags.UNMANAGED)\n          ) {\n            this.error(\n              DiagnosticCode.Unmanaged_classes_cannot_extend_managed_classes_and_vice_versa,\n              Range.join(thisPrototype.identifierNode.range, extendsNode.range)\n            );\n          }\n          thisPrototype.basePrototype = basePrototype;\n        } else {\n          this.error(\n            DiagnosticCode.A_class_may_only_extend_another_class,\n            extendsNode.range\n          );\n        }\n      } else if (thisPrototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n        if (baseElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          thisPrototype.basePrototype = <InterfacePrototype>baseElement;\n        } else {\n          this.error(\n            DiagnosticCode.An_interface_can_only_extend_an_interface,\n            extendsNode.range\n          );\n        }\n      }\n    }\n\n    // resolve prototypes of implemented interfaces\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let implementsNodes = assert(thisPrototype.implementsNodes); // must be present if in queuedImplements\n      for (let j = 0, l = implementsNodes.length; j < l; ++j) {\n        let implementsNode = implementsNodes[j];\n        let interfaceElement = resolver.resolveTypeName(implementsNode.name, thisPrototype.parent);\n        if (!interfaceElement) continue;\n        if (interfaceElement.kind == ElementKind.INTERFACE_PROTOTYPE) {\n          let interfacePrototype = <InterfacePrototype>interfaceElement;\n          let interfacePrototypes = thisPrototype.interfacePrototypes;\n          if (!interfacePrototypes) thisPrototype.interfacePrototypes = interfacePrototypes = new Array();\n          interfacePrototypes.push(interfacePrototype);\n        } else {\n          this.error(\n            DiagnosticCode.A_class_can_only_implement_an_interface,\n            implementsNode.range\n          );\n        }\n      }\n    }\n\n    // check for virtual overloads in extended classes and implemented interfaces\n    for (let i = 0, k = queuedExtends.length; i < k; ++i) {\n      let thisPrototype = queuedExtends[i];\n      let basePrototype = thisPrototype.basePrototype;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n    }\n    for (let i = 0, k = queuedImplements.length; i < k; ++i) {\n      let thisPrototype = queuedImplements[i];\n      let basePrototype = thisPrototype.basePrototype;\n      let interfacePrototypes = thisPrototype.interfacePrototypes;\n      if (basePrototype) {\n        this.markVirtuals(thisPrototype, basePrototype);\n      }\n      if (interfacePrototypes) {\n        for (let j = 0, l = interfacePrototypes.length; j < l; ++j) {\n          this.markVirtuals(thisPrototype, interfacePrototypes[j]);\n        }\n      }\n    }\n\n    // set up global aliases\n    {\n      let globalAliases = options.globalAliases;\n      if (!globalAliases) globalAliases = new Map();\n      let isWasi = this.isWasi;\n      if (!globalAliases.has(CommonNames.abort)) {\n        globalAliases.set(CommonNames.abort,\n          isWasi\n            ? BuiltinNames.wasiAbort\n            : BuiltinNames.abort\n        );\n      }\n      if (!globalAliases.has(CommonNames.trace)) {\n        globalAliases.set(CommonNames.trace,\n          isWasi\n            ? BuiltinNames.wasiTrace\n            : BuiltinNames.trace\n        );\n      }\n      if (!globalAliases.has(CommonNames.seed)) {\n        globalAliases.set(CommonNames.seed,\n          isWasi\n            ? BuiltinNames.wasiSeed\n            : BuiltinNames.seed\n        );\n      }\n      if (!globalAliases.has(CommonNames.Math)) {\n        globalAliases.set(CommonNames.Math, CommonNames.NativeMath);\n      }\n      if (!globalAliases.has(CommonNames.Mathf)) {\n        globalAliases.set(CommonNames.Mathf, CommonNames.NativeMathf);\n      }\n      // TODO: for (let [alias, name] of globalAliases) {\n      for (let _keys = Map_keys(globalAliases), i = 0, k = _keys.length; i < k; ++i) {\n        let alias = unchecked(_keys[i]);\n        let name = changetype<string>(globalAliases.get(alias));\n        assert(name != null);\n        if (!name.length) {\n          this.elementsByName.delete(alias);\n          continue;\n        }\n        let firstChar = name.charCodeAt(0);\n        if (firstChar >= CharCode._0 && firstChar <= CharCode._9) {\n          this.registerConstantInteger(alias, Type.i32, i64_new(<i32>parseInt(name, 10)));\n        } else {\n          let elementsByName = this.elementsByName;\n          if (elementsByName.has(name)) {\n            elementsByName.set(alias, assert(elementsByName.get(name)));\n          } else {\n            throw new Error(\"no such global element: \" + name);\n          }\n        }\n      }\n    }\n\n    // mark module exports, i.e. to apply proper wrapping behavior on the boundaries\n    // TODO: for (let file of this.filesByName.values()) {\n    for (let _values = Map_values(this.filesByName), i = 0, k = _values.length; i < k; ++i) {\n      let file = unchecked(_values[i]);\n      if (file.source.sourceKind == SourceKind.USER_ENTRY) {\n        this.markModuleExports(file);\n      }\n    }\n  }\n\n  /** Marks virtual members in a base class overloaded in this class. */\n  private markVirtuals(thisPrototype: ClassPrototype, basePrototype: ClassPrototype): void {\n    // TODO: make this work with interfaaces as well\n    var thisInstanceMembers = thisPrototype.instanceMembers;\n    if (thisInstanceMembers) {\n      do {\n        let baseInstanceMembers = basePrototype.instanceMembers;\n        if (baseInstanceMembers) {\n          for (let _values = Map_values(thisInstanceMembers), j = 0, l = _values.length; j < l; ++j) {\n            let thisMember = _values[j];\n            if (\n              !thisMember.isAny(CommonFlags.CONSTRUCTOR | CommonFlags.PRIVATE) &&\n              baseInstanceMembers.has(thisMember.name)\n            ) {\n              let baseMember = assert(baseInstanceMembers.get(thisMember.name));\n              if (\n                thisMember.kind == ElementKind.FUNCTION_PROTOTYPE &&\n                baseMember.kind == ElementKind.FUNCTION_PROTOTYPE\n              ) {\n                let thisMethod = <FunctionPrototype>thisMember;\n                let baseMethod = <FunctionPrototype>baseMember;\n                if (!thisMethod.visibilityEquals(baseMethod)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisMethod.identifierNode.range, baseMethod.identifierNode.range\n                  );\n                }\n                baseMember.set(CommonFlags.VIRTUAL);\n                let overloads = baseMethod.overloads;\n                if (!overloads) baseMethod.overloads = overloads = new Set();\n                overloads.add(<FunctionPrototype>thisMember);\n                let baseMethodInstances = baseMethod.instances;\n                if (baseMethodInstances) {\n                  for (let _values = Map_values(baseMethodInstances), a = 0, b = _values.length; a < b; ++a) {\n                    let baseMethodInstance = _values[a];\n                    baseMethodInstance.set(CommonFlags.VIRTUAL);\n                  }\n                }\n              } else if (\n                thisMember.kind == ElementKind.PROPERTY_PROTOTYPE &&\n                baseMember.kind == ElementKind.PROPERTY_PROTOTYPE\n              ) {\n                let thisProperty = <PropertyPrototype>thisMember;\n                let baseProperty = <PropertyPrototype>baseMember;\n                if (!thisProperty.visibilityEquals(baseProperty)) {\n                  this.errorRelated(\n                    DiagnosticCode.Overload_signatures_must_all_be_public_private_or_protected,\n                    thisProperty.identifierNode.range, baseProperty.identifierNode.range\n                  );\n                }\n                baseProperty.set(CommonFlags.VIRTUAL);\n                let baseGetter = baseProperty.getterPrototype;\n                if (baseGetter) {\n                  baseGetter.set(CommonFlags.VIRTUAL);\n                  let thisGetter = thisProperty.getterPrototype;\n                  if (thisGetter) {\n                    let overloads = baseGetter.overloads;\n                    if (!overloads) baseGetter.overloads = overloads = new Set();\n                    overloads.add(thisGetter);\n                  }\n                  let baseGetterInstances = baseGetter.instances;\n                  if (baseGetterInstances) {\n                    for (let _values = Map_values(baseGetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseGetterInstance = _values[a];\n                      baseGetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n                let baseSetter = baseProperty.setterPrototype;\n                if (baseSetter !== null && thisProperty.setterPrototype !== null) {\n                  baseSetter.set(CommonFlags.VIRTUAL);\n                  let thisSetter = thisProperty.setterPrototype;\n                  if (thisSetter) {\n                    let overloads = baseSetter.overloads;\n                    if (!overloads) baseSetter.overloads = overloads = new Set();\n                    overloads.add(thisSetter);\n                  }\n                  let baseSetterInstances = baseSetter.instances;\n                  if (baseSetterInstances) {\n                    for (let _values = Map_values(baseSetterInstances), a = 0, b = _values.length; a < b; ++a) {\n                      let baseSetterInstance = _values[a];\n                      baseSetterInstance.set(CommonFlags.VIRTUAL);\n                    }\n                  }\n                }\n              } else {\n                this.errorRelated(\n                  DiagnosticCode.Duplicate_identifier_0,\n                  thisMember.identifierNode.range,\n                  baseMember.identifierNode.range\n                );\n              }\n            }\n          }\n        }\n        let nextPrototype = basePrototype.basePrototype;\n        if (!nextPrototype) break;\n        basePrototype = nextPrototype;\n      } while (true);\n    }\n  }\n\n  /** Requires that a global library element of the specified kind is present and returns it. */\n  private require(name: string, kind: ElementKind): Element {\n    var element = this.lookupGlobal(name);\n    if (!element) throw new Error(\"Missing standard library component: \" + name);\n    if (element.kind != kind) throw Error(\"Invalid standard library component: \" + name);\n    return element;\n  }\n\n  /** Requires that a non-generic global class is present and returns it. */\n  private requireClass(name: string): Class {\n    var prototype = this.require(name, ElementKind.CLASS_PROTOTYPE);\n    var resolved = this.resolver.resolveClass(<ClassPrototype>prototype, null);\n    if (!resolved) throw new Error(\"Invalid standard library class: \" + name);\n    return resolved;\n  }\n\n  /** Obtains a non-generic global function and returns it. Returns `null` if it does not exist. */\n  private lookupFunction(name: string): Function | null {\n    var prototype = this.lookupGlobal(name);\n    if (!prototype || prototype.kind != ElementKind.FUNCTION_PROTOTYPE) return null;\n    return this.resolver.resolveFunction(<FunctionPrototype>prototype, null);\n  }\n\n  /** Requires that a global function is present and returns it. */\n  private requireFunction(name: string, typeArguments: Type[] | null = null): Function {\n    var prototype = <FunctionPrototype>this.require(name, ElementKind.FUNCTION_PROTOTYPE);\n    var resolved = this.resolver.resolveFunction(prototype, typeArguments);\n    if (!resolved) throw new Error(\"Invalid standard library function: \" + name);\n    return resolved;\n  }\n\n  /** Marks all exports of the specified file as module exports. */\n  private markModuleExports(file: File): void {\n    var exports = file.exports;\n    if (exports) {\n      // TODO: for (let element of exports.values()) {\n      for (let _values = Map_values(exports), j = 0, l = _values.length; j < l; ++j) {\n        let element = unchecked(_values[j]);\n        this.markModuleExport(element);\n      }\n    }\n    var exportsStar = file.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        this.markModuleExports(exportsStar[i]);\n      }\n    }\n  }\n\n  /** Marks an element and its children as a module export. */\n  private markModuleExport(element: Element): void {\n    element.set(CommonFlags.MODULE_EXPORT);\n    switch (element.kind) {\n      case ElementKind.CLASS_PROTOTYPE: {\n        let instanceMembers = (<ClassPrototype>element).instanceMembers;\n        if (instanceMembers) {\n          // TODO: for (let member of instanceMembers.values()) {\n          for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n            let member = unchecked(_values[i]);\n            this.markModuleExport(member);\n          }\n        }\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: {\n        let propertyPrototype = <PropertyPrototype>element;\n        let getterPrototype = propertyPrototype.getterPrototype;\n        if (getterPrototype) this.markModuleExport(getterPrototype);\n        let setterPrototype = propertyPrototype.setterPrototype;\n        if (setterPrototype) this.markModuleExport(setterPrototype);\n        break;\n      }\n      case ElementKind.PROPERTY:\n      case ElementKind.FUNCTION:\n      case ElementKind.FIELD:\n      case ElementKind.CLASS: assert(false); // assumes that there are no instances yet\n    }\n    var staticMembers = element.members;\n    if (staticMembers) {\n      // TODO: for (let member of staticMembers.values()) {\n      for (let _values = Map_values(staticMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        this.markModuleExport(member);\n      }\n    }\n  }\n\n  /** Registers a native type with the program. */\n  private registerNativeType(name: string, type: Type): void {\n    var element = new TypeDefinition(\n      name,\n      this.nativeFile,\n      this.makeNativeTypeDeclaration(name, CommonFlags.EXPORT),\n      DecoratorFlags.BUILTIN\n    );\n    element.setType(type);\n    this.nativeFile.add(name, element);\n  }\n\n  /** Registers the wrapper class of a non-class type. */\n  private registerWrapperClass(type: Type, className: string): void {\n    var wrapperClasses = this.wrapperClasses;\n    assert(!type.isInternalReference && !wrapperClasses.has(type));\n    var element = assert(this.lookupGlobal(className));\n    assert(element.kind == ElementKind.CLASS_PROTOTYPE);\n    var classElement = assert(this.resolver.resolveClass(<ClassPrototype>element, null));\n    classElement.wrappedType = type;\n    wrapperClasses.set(type, classElement);\n  }\n\n  /** Registers a constant integer value within the global scope. */\n  registerConstantInteger(name: string, type: Type, value: i64): void {\n    assert(type.isIntegerInclReference);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantIntegerValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Registers a constant float value within the global scope. */\n  private registerConstantFloat(name: string, type: Type, value: f64): void {\n    assert(type.isFloatValue);\n    var global = new Global(\n      name,\n      this.nativeFile,\n      DecoratorFlags.NONE,\n      this.makeNativeVariableDeclaration(name, CommonFlags.CONST | CommonFlags.EXPORT)\n    );\n    global.setConstantFloatValue(value, type);\n    this.nativeFile.add(name, global);\n  }\n\n  /** Ensures that the given global element exists. Attempts to merge duplicates. */\n  ensureGlobal(name: string, element: DeclaredElement): DeclaredElement {\n    var elementsByName = this.elementsByName;\n    if (elementsByName.has(name)) {\n      let existing = assert(elementsByName.get(name));\n      // NOTE: this is effectively only performed when merging native types with\n      // their respective namespaces in std/builtins, but can also trigger when a\n      // user has multiple global elements of the same name in different files,\n      // which might result in unexpected shared symbols accross files. considering\n      // this a wonky feature for now that we might want to revisit later.\n      if (existing !== element) {\n        let merged = tryMerge(existing, element);\n        if (!merged) {\n          if (isDeclaredElement(existing.kind)) {\n            this.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range,\n              (<DeclaredElement>existing).declaration.name.range,\n              name\n            );\n          } else {\n            this.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              element.identifierNode.range, name\n            );\n          }\n          return element;\n        }\n        element = merged;\n      }\n    }\n    elementsByName.set(name, element);\n    return element;\n  }\n\n  /** Looks up the element of the specified name in the global scope. */\n  lookupGlobal(name: string): Element | null {\n    var elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    return null;\n  }\n\n  /** Looks up the element of the specified name in the global scope. Errors if not present. */\n  requireGlobal(name: string): Element {\n    var elements = this.elementsByName;\n    if (elements.has(name)) return assert(elements.get(name));\n    throw new Error(\"missing global\");\n  }\n\n  /** Tries to locate a foreign file given its normalized path. */\n  private lookupForeignFile(\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string\n  ): File | null {\n    var filesByName = this.filesByName;\n    return filesByName.has(foreignPath)\n      ? assert(filesByName.get(foreignPath))\n      : filesByName.has(foreignPathAlt)\n        ? assert(filesByName.get(foreignPathAlt))\n        : null;\n  }\n\n  /** Tries to locate a foreign element by traversing exports and queued exports. */\n  private lookupForeign(\n    /** Identifier within the other file. */\n    foreignName: string,\n    /** Normalized path to the other file. */\n    foreignPath: string,\n    /** Alternative normalized path to the other file. */\n    foreignPathAlt: string,\n    /** So far queued exports. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): DeclaredElement | null {\n    do {\n      let foreignFile = this.lookupForeignFile(foreignPath, foreignPathAlt);\n      if (!foreignFile) return null; // no such file\n\n      // search already resolved exports\n      let element = foreignFile.lookupExport(foreignName);\n      if (element) return element;\n\n      // otherwise traverse queued exports\n      if (queuedExports.has(foreignFile)) {\n        let fileQueuedExports = assert(queuedExports.get(foreignFile));\n        if (fileQueuedExports.has(foreignName)) {\n          let queuedExport = assert(fileQueuedExports.get(foreignName));\n          let queuedExportForeignPath = queuedExport.foreignPath;\n          if (queuedExportForeignPath) { // imported from another file\n            foreignName = queuedExport.localIdentifier.text;\n            foreignPath = queuedExportForeignPath;\n            foreignPathAlt = assert(queuedExport.foreignPathAlt);\n            continue;\n          } else { // local element of this file\n            element = foreignFile.lookupInSelf(queuedExport.localIdentifier.text);\n            if (element) return element;\n          }\n        }\n      }\n      break;\n    } while (true);\n    return null;\n  }\n\n  /** Validates that only supported decorators are present. */\n  private checkDecorators(\n    /** Decorators present on an element. */\n    decorators: DecoratorNode[] | null,\n    /** Accepted decorator flags. Emits diagnostics if any other decorators are present. */\n    acceptedFlags: DecoratorFlags\n  ): DecoratorFlags {\n    var flags = DecoratorFlags.NONE;\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator = decorators[i];\n        let kind = DecoratorKind.fromNode(decorator.name);\n        let flag = DecoratorFlags.fromKind(kind);\n        if (flag) {\n          if (flag == DecoratorFlags.BUILTIN) {\n            if (!(acceptedFlags & flag) && !decorator.range.source.isLibrary) {\n              this.error(\n                DiagnosticCode.Decorator_0_is_not_valid_here,\n                decorator.range, decorator.name.range.toString()\n              );\n            } else {\n              flags |= flag;\n            }\n          } else if (!(acceptedFlags & flag)) {\n            this.error(\n              DiagnosticCode.Decorator_0_is_not_valid_here,\n              decorator.range, decorator.name.range.toString()\n            );\n          } else if (flags & flag) {\n            this.error(\n              DiagnosticCode.Duplicate_decorator,\n              decorator.range\n            );\n          } else {\n            flags |= flag;\n          }\n        }\n      }\n    }\n    // if (flags) throw new Error();\n    return flags;\n  }\n\n  /** Initializes a class declaration. */\n  private initializeClass(\n    /** The declaration to initialize. */\n    declaration: ClassDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): ClassPrototype | null {\n    var name = declaration.name.text;\n    var element = new ClassPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.FINAL |\n        DecoratorFlags.UNMANAGED |\n        DecoratorFlags.STORAGE |\n        DecoratorFlags.CONTRACT\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember classes that implement interfaces\n    var implementsTypes = declaration.implementsTypes;\n    if (implementsTypes) {\n      let numImplementsTypes = implementsTypes.length;\n      if (numImplementsTypes) {\n        // cannot implement interfaces when unmanaged\n        if (element.hasDecorator(DecoratorFlags.UNMANAGED)) {\n          this.error(\n            DiagnosticCode.Unmanaged_classes_cannot_implement_interfaces,\n            Range.join(\n              declaration.name.range,\n              implementsTypes[numImplementsTypes - 1].range\n            )\n          );\n        } else {\n          queuedImplements.push(element);\n        }\n      }\n    }\n\n    // remember classes that extend another class\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    // initialize members\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeField(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            let method = this.initializeMethod(methodDeclaration, element);\n            if (method !== null && methodDeclaration.name.kind == NodeKind.CONSTRUCTOR) {\n              element.constructorPrototype = method;\n            }\n          }\n          break;\n        }\n        case NodeKind.INDEXSIGNATURE: break; // ignored for now\n        default: assert(false); // class member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of a class or interface. */\n  private initializeField(\n    /** The declaration to initialize. */\n    declaration: FieldDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var name = declaration.name.text;\n    var decorators = declaration.decorators;\n    var element: DeclaredElement;\n    var acceptedFlags: DecoratorFlags = DecoratorFlags.UNSAFE;\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    if (declaration.is(CommonFlags.STATIC)) { // global variable\n      assert(parent.kind != ElementKind.INTERFACE_PROTOTYPE);\n      acceptedFlags |= DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.READONLY)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      element = new Global(\n        name,\n        parent,\n        this.checkDecorators(decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) return;\n    } else { // actual instance field\n      assert(!declaration.isAny(CommonFlags.ABSTRACT | CommonFlags.GET | CommonFlags.SET));\n      element = new FieldPrototype(\n        name,\n        parent,\n        declaration,\n        this.checkDecorators(decorators, acceptedFlags)\n      );\n      if (!parent.addInstance(name, element)) return;\n    }\n  }\n\n  /** Initializes a method of a class or interface. */\n  private initializeMethod(\n    /** The declaration to initialize. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    var isStatic = declaration.is(CommonFlags.STATIC);\n    // Extension add\n    var acceptedFlags = DecoratorFlags.INLINE | DecoratorFlags.UNSAFE | DecoratorFlags.DEPLOYER;\n    if (!declaration.is(CommonFlags.GENERIC)) {\n      acceptedFlags |= DecoratorFlags.OPERATOR_BINARY\n                    |  DecoratorFlags.OPERATOR_PREFIX\n                    |  DecoratorFlags.OPERATOR_POSTFIX;\n    }\n    if (parent.is(CommonFlags.AMBIENT)) {\n      acceptedFlags |= DecoratorFlags.EXTERNAL;\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, acceptedFlags)\n    );\n    if (isStatic) { // global function\n      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);\n      if (!parent.add(name, element)) return null;\n    } else { // actual instance method\n      if (!parent.addInstance(name, element)) return null;\n    }\n    this.checkOperatorOverloads(declaration.decorators, element, parent);\n    return element;\n  }\n\n  /** Checks that operator overloads are generally valid, if present. */\n  private checkOperatorOverloads(\n    /** Decorators to check. */\n    decorators: DecoratorNode[] | null,\n    /** Decorated method. */\n    prototype: FunctionPrototype,\n    /** Parent class. */\n    classPrototype: ClassPrototype\n  ): void {\n    if (decorators) {\n      for (let i = 0, k = decorators.length; i < k; ++i) {\n        let decorator: DecoratorNode = decorators[i]; // FIXME: why does tsc want a type here?\n        switch (decorator.decoratorKind) {\n          case DecoratorKind.OPERATOR:\n          case DecoratorKind.OPERATOR_BINARY:\n          case DecoratorKind.OPERATOR_PREFIX:\n          case DecoratorKind.OPERATOR_POSTFIX: {\n            let args = decorator.args;\n            let numArgs = args ? args.length : 0;\n            if (numArgs == 1) {\n              let firstArg = (<Expression[]>decorator.args)[0];\n              if (firstArg.isLiteralKind(LiteralKind.STRING)) {\n                let text = (<StringLiteralExpression>firstArg).value;\n                let kind = OperatorKind.fromDecorator(decorator.decoratorKind, text);\n                if (kind == OperatorKind.INVALID) {\n                  this.error(\n                    DiagnosticCode._0_is_not_a_valid_operator,\n                    firstArg.range, text\n                  );\n                } else {\n                  let overloads = classPrototype.overloadPrototypes;\n                  if (overloads.has(kind)) {\n                    this.error(\n                      DiagnosticCode.Duplicate_function_implementation,\n                      firstArg.range\n                    );\n                  } else {\n                    prototype.operatorKind = kind;\n                    overloads.set(kind, prototype);\n                  }\n                }\n              } else {\n                this.error(\n                  DiagnosticCode.String_literal_expected,\n                  firstArg.range\n                );\n              }\n            } else {\n              this.error(\n                DiagnosticCode.Expected_0_arguments_but_got_1,\n                decorator.range, \"1\", numArgs.toString()\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /** Ensures that the property introduced by the specified getter or setter exists.*/\n  private ensureProperty(\n    /** The declaration of the getter or setter introducing the property. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): PropertyPrototype | null {\n    var name = declaration.name.text;\n    if (declaration.is(CommonFlags.STATIC)) {\n      let parentMembers = parent.members;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.add(name, element)) return null;\n        return element;\n      }\n    } else {\n      let parentMembers = parent.instanceMembers;\n      if (parentMembers !== null && parentMembers.has(name)) {\n        let element = assert(parentMembers.get(name));\n        if (element.kind == ElementKind.PROPERTY_PROTOTYPE) return <PropertyPrototype>element;\n      } else {\n        let element = new PropertyPrototype(name, parent, declaration);\n        if (!parent.addInstance(name, element)) return null;\n        return element;\n      }\n    }\n    this.error(\n      DiagnosticCode.Duplicate_property_0,\n      declaration.name.range, name\n    );\n    return null;\n  }\n\n  /** Initializes a property of a class. */\n  private initializeProperty(\n    /** The declaration of the getter or setter. */\n    declaration: MethodDeclaration,\n    /** Parent class. */\n    parent: ClassPrototype\n  ): void {\n    var property = this.ensureProperty(declaration, parent);\n    if (!property) return;\n    var name = declaration.name.text;\n    var isGetter = declaration.is(CommonFlags.GET);\n    if (isGetter) {\n      if (property.getterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    } else {\n      if (property.setterPrototype) {\n        this.error(\n          DiagnosticCode.Duplicate_property_0,\n          declaration.name.range, name\n        );\n        return;\n      }\n    }\n    var element = new FunctionPrototype(\n      (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + name,\n      property,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.INLINE | DecoratorFlags.UNSAFE\n      )\n    );\n    if (isGetter) {\n      property.getterPrototype = element;\n    } else {\n      property.setterPrototype = element;\n    }\n  }\n\n  /** Initializes an enum. */\n  private initializeEnum(\n    /** The declaration to initialize. */\n    declaration: EnumDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): Enum | null {\n    var name = declaration.name.text;\n    var element = new Enum(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL |\n        DecoratorFlags.INLINE |\n        DecoratorFlags.LAZY\n      )\n    );\n    if (!parent.add(name, element)) return null;\n    var values = declaration.values;\n    for (let i = 0, k = values.length; i < k; ++i) {\n      this.initializeEnumValue(values[i], element);\n    }\n    return element;\n  }\n\n  /** Initializes an enum value. */\n  private initializeEnumValue(\n    /** The declaration to initialize. */\n    declaration: EnumValueDeclaration,\n    /** Parent enum. */\n    parent: Enum\n  ): void {\n    var name = declaration.name.text;\n    var element = new EnumValue(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.NONE\n      )\n    );\n    if (!parent.add(name, element)) return;\n  }\n\n  /** Initializes an `export` statement. */\n  private initializeExports(\n    /** The statement to initialize. */\n    statement: ExportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>,\n    /** So far queued `export *`s. */\n    queuedExportsStar: Map<File,QueuedExportStar[]>\n  ): void {\n    var members = statement.members;\n    if (members) { // export { foo, bar } [from \"./baz\"]\n      for (let i = 0, k = members.length; i < k; ++i) {\n        this.initializeExport(members[i], parent, statement.internalPath, queuedExports);\n      }\n    } else { // export * from \"./baz\"\n      let queued: QueuedExportStar[];\n      if (queuedExportsStar.has(parent)) queued = assert(queuedExportsStar.get(parent));\n      else queuedExportsStar.set(parent, queued = []);\n      let foreignPath = statement.internalPath!; // must be set for export *\n      queued.push(new QueuedExportStar(\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX,\n        assert(statement.path)\n      ));\n    }\n  }\n\n  /** Initializes a single `export` member. Does not handle `export *`. */\n  private initializeExport(\n    /** The member to initialize. */\n    member: ExportMember,\n    /** Local file. */\n    localFile: File,\n    /** Path to the other file, if present. */\n    foreignPath: string | null,\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var localName = member.localName.text;\n    var foreignName = member.exportedName.text;\n\n    // check for duplicates\n    var element = localFile.lookupExport(foreignName);\n    if (element) {\n      this.error(\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\n        member.exportedName.range, foreignName\n      );\n      return;\n    }\n    // local element, i.e. export { foo [as bar] }\n    if (foreignPath === null) {\n\n      // resolve right away if the local element already exists\n      if (element = localFile.lookupInSelf(localName)) {\n        localFile.ensureExport(foreignName, element);\n\n      // otherwise queue it\n      } else {\n        let queued: Map<string,QueuedExport>;\n        if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n        else queuedExports.set(localFile, queued = new Map());\n        queued.set(foreignName, new QueuedExport(\n          member.localName,\n          member.exportedName,\n          null, null\n        ));\n      }\n\n    // foreign element, i.e. export { foo } from \"./bar\"\n    } else {\n      let queued: Map<string,QueuedExport>;\n      if (queuedExports.has(localFile)) queued = assert(queuedExports.get(localFile));\n      else queuedExports.set(localFile, queued = new Map());\n      queued.set(foreignName, new QueuedExport(\n        member.localName,\n        member.exportedName,\n        foreignPath,\n        foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n          ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n          : foreignPath + INDEX_SUFFIX\n      ));\n    }\n  }\n\n  private initializeExportDefault(\n    /** The statement to initialize. */\n    statement: ExportDefaultStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `extends` clauses. */\n    queuedExtends: Array<ClassPrototype>,\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): void {\n    var declaration = statement.declaration;\n    var element: DeclaredElement | null = null;\n    switch (declaration.kind) {\n      case NodeKind.ENUMDECLARATION: {\n        element = this.initializeEnum(<EnumDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.FUNCTIONDECLARATION: {\n        element = this.initializeFunction(<FunctionDeclaration>declaration, parent);\n        break;\n      }\n      case NodeKind.CLASSDECLARATION: {\n        element = this.initializeClass(<ClassDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      case NodeKind.INTERFACEDECLARATION: {\n        element = this.initializeInterface(<InterfaceDeclaration>declaration, parent, queuedExtends);\n        break;\n      }\n      case NodeKind.NAMESPACEDECLARATION: {\n        element = this.initializeNamespace(<NamespaceDeclaration>declaration, parent, queuedExtends, queuedImplements);\n        break;\n      }\n      default: assert(false);\n    }\n    if (element) {\n      let exports = parent.exports;\n      if (!exports) parent.exports = exports = new Map();\n      else {\n        if (exports.has(\"default\")) {\n          let existing = assert(exports.get(\"default\"));\n          this.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            declaration.name.range,\n            existing.declaration.name.range,\n            \"default\"\n          );\n          return;\n        }\n      }\n      exports.set(\"default\", element);\n    }\n  }\n\n  /** Initializes an `import` statement. */\n  private initializeImports(\n    /** The statement to initialize. */\n    statement: ImportStatement,\n    /** Parent file. */\n    parent: File,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var declarations = statement.declarations;\n    if (declarations) { // import { foo [as bar] } from \"./baz\"\n      for (let i = 0, k = declarations.length; i < k; ++i) {\n        this.initializeImport(\n          declarations[i],\n          parent,\n          statement.internalPath,\n          queuedImports,\n          queuedExports\n        );\n      }\n    } else {\n      let namespaceName = statement.namespaceName;\n      if (namespaceName) { // import * as foo from \"./bar\"\n        queuedImports.push(new QueuedImport(\n          parent,\n          namespaceName,\n          null, // indicates import *\n          statement.internalPath,\n          statement.internalPath + INDEX_SUFFIX\n        ));\n      } else {\n        // import \"./foo\"\n      }\n    }\n  }\n\n  /** Initializes a single `import` declaration. Does not handle `import *`. */\n  private initializeImport( // { foo [as bar] }\n    /** The declaration to initialize. */\n    declaration: ImportDeclaration,\n    /** Parent file. */\n    parent: File,\n    /** Path to the other file. */\n    foreignPath: string,\n    /** So far queued `import`s. */\n    queuedImports: QueuedImport[],\n    /** So far queued `export`s. */\n    queuedExports: Map<File,Map<string,QueuedExport>>\n  ): void {\n    var foreignPathAlt = foreignPath.endsWith(INDEX_SUFFIX) // strip or add index depending on what's already present\n      ? foreignPath.substring(0, foreignPath.length - INDEX_SUFFIX.length)\n      : foreignPath + INDEX_SUFFIX;\n\n    // resolve right away if the element exists\n    var element = this.lookupForeign(declaration.foreignName.text, foreignPath, foreignPathAlt, queuedExports);\n    if (element) {\n      parent.add(declaration.name.text, element, declaration.name /* isImport */);\n      return;\n    }\n\n    // otherwise queue it\n    queuedImports.push(new QueuedImport(\n      parent,\n      declaration.name,\n      declaration.foreignName,\n      foreignPath,\n      foreignPathAlt\n    ));\n  }\n\n  /** Initializes a function. Does not handle methods. */\n  private initializeFunction(\n    /** The declaration to initialize. */\n    declaration: FunctionDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): FunctionPrototype | null {\n    var name = declaration.name.text;\n    // Extension Add\n    var validDecorators = DecoratorFlags.UNSAFE | DecoratorFlags.BUILTIN | DecoratorFlags.DEPLOYER;\n    if (declaration.is(CommonFlags.AMBIENT)) {\n      validDecorators |= DecoratorFlags.EXTERNAL;\n    } else {\n      validDecorators |= DecoratorFlags.INLINE;\n      if (declaration.range.source.isLibrary || declaration.is(CommonFlags.EXPORT)) {\n        validDecorators |= DecoratorFlags.LAZY;\n      }\n    }\n    if (!declaration.is(CommonFlags.INSTANCE)) {\n      if (parent.kind != ElementKind.CLASS_PROTOTYPE) {\n        validDecorators |= DecoratorFlags.GLOBAL;\n      }\n    }\n    var element = new FunctionPrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, validDecorators)\n    );\n    if (!parent.add(name, element)) return null;\n    return element;\n  }\n\n  /** Initializes an interface. */\n  private initializeInterface(\n    /** The declaration to initialize. */\n    declaration: InterfaceDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n  ): InterfacePrototype | null {\n    var name = declaration.name.text;\n    var element = new InterfacePrototype(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators,\n        DecoratorFlags.GLOBAL\n      )\n    );\n    if (!parent.add(name, element)) return null;\n\n    // remember interfaces that extend another interface\n    if (declaration.extendsType) queuedExtends.push(element);\n\n    var memberDeclarations = declaration.members;\n    for (let i = 0, k = memberDeclarations.length; i < k; ++i) {\n      let memberDeclaration = memberDeclarations[i];\n      switch (memberDeclaration.kind) {\n        case NodeKind.FIELDDECLARATION: {\n          this.initializeFieldAsProperty(<FieldDeclaration>memberDeclaration, element);\n          break;\n        }\n        case NodeKind.METHODDECLARATION: {\n          let methodDeclaration = <MethodDeclaration>memberDeclaration;\n          if (memberDeclaration.isAny(CommonFlags.GET | CommonFlags.SET)) {\n            this.initializeProperty(methodDeclaration, element);\n          } else {\n            this.initializeMethod(methodDeclaration, element);\n          }\n          break;\n        }\n        default: assert(false); // interface member expected\n      }\n    }\n    return element;\n  }\n\n  /** Initializes a field of an interface, as a property. */\n  private initializeFieldAsProperty(\n    /** Field declaration. */\n    declaration: FieldDeclaration,\n    /** Parent interface. */\n    parent: InterfacePrototype\n  ): void {\n    var typeNode = declaration.type;\n    if (!typeNode) typeNode = Node.createOmittedType(declaration.name.range.atEnd);\n    this.initializeProperty(\n      Node.createMethodDeclaration(\n        declaration.name,\n        declaration.decorators,\n        declaration.flags | CommonFlags.GET,\n        null,\n        Node.createFunctionType(\n          [],\n          typeNode,\n          null,\n          false,\n          declaration.range\n        ),\n        null,\n        declaration.range\n      ),\n      parent\n    );\n    if (!declaration.is(CommonFlags.READONLY)) {\n      this.initializeProperty(\n        Node.createMethodDeclaration(\n          declaration.name,\n          declaration.decorators,\n          declaration.flags | CommonFlags.SET,\n          null,\n          Node.createFunctionType(\n            [\n              Node.createParameter(\n                ParameterKind.DEFAULT,\n                declaration.name,\n                typeNode,\n                null,\n                declaration.name.range\n              )\n            ],\n            Node.createOmittedType(declaration.name.range.atEnd),\n            null,\n            false,\n            declaration.range\n          ),\n          null,\n          declaration.range\n        ),\n        parent\n      );\n    }\n  }\n\n  /** Initializes a namespace. */\n  private initializeNamespace(\n    /** The declaration to initialize. */\n    declaration: NamespaceDeclaration,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** So far queued `extends` clauses. */\n    queuedExtends: ClassPrototype[],\n    /** So far queued `implements` clauses. */\n    queuedImplements: ClassPrototype[]\n  ): DeclaredElement | null {\n    var name = declaration.name.text;\n    var original = new Namespace(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.GLOBAL)\n    );\n    if (!parent.add(name, original)) return null;\n    var element = assert(parent.lookupInSelf(name)); // possibly merged\n    var members = declaration.members;\n    for (let i = 0, k = members.length; i < k; ++i) {\n      let member = members[i];\n      switch (member.kind) {\n        case NodeKind.CLASSDECLARATION: {\n          this.initializeClass(<ClassDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.ENUMDECLARATION: {\n          this.initializeEnum(<EnumDeclaration>member, original);\n          break;\n        }\n        case NodeKind.FUNCTIONDECLARATION: {\n          this.initializeFunction(<FunctionDeclaration>member, original);\n          break;\n        }\n        case NodeKind.INTERFACEDECLARATION: {\n          this.initializeInterface(<InterfaceDeclaration>member, original, queuedExtends);\n          break;\n        }\n        case NodeKind.NAMESPACEDECLARATION: {\n          this.initializeNamespace(<NamespaceDeclaration>member, original, queuedExtends, queuedImplements);\n          break;\n        }\n        case NodeKind.TYPEDECLARATION: {\n          this.initializeTypeDefinition(<TypeDeclaration>member, original);\n          break;\n        }\n        case NodeKind.VARIABLE: {\n          this.initializeVariables(<VariableStatement>member, original);\n          break;\n        }\n        default: assert(false); // namespace member expected\n      }\n    }\n    if (original != element) copyMembers(original, element); // retain original parent\n    return element;\n  }\n\n  /** Initializes a `type` definition. */\n  private initializeTypeDefinition(\n    /** The declaration to initialize. */\n    declaration: TypeDeclaration,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var name = declaration.name.text;\n    var element = new TypeDefinition(\n      name,\n      parent,\n      declaration,\n      this.checkDecorators(declaration.decorators, DecoratorFlags.NONE)\n    );\n    parent.add(name, element); // reports\n  }\n\n  /** Initializes a variable statement. */\n  private initializeVariables(\n    /** The statement to initialize. */\n    statement: VariableStatement,\n    /** Parent element, usually a file or namespace. */\n    parent: Element\n  ): void {\n    var declarations = statement.declarations;\n    for (let i = 0, k = declarations.length; i < k; ++i) {\n      let declaration = declarations[i];\n      let name = declaration.name.text;\n      let acceptedFlags = DecoratorFlags.GLOBAL | DecoratorFlags.LAZY;\n      if (declaration.is(CommonFlags.DECLARE)) {\n        acceptedFlags |= DecoratorFlags.EXTERNAL;\n      }\n      if (declaration.is(CommonFlags.CONST)) {\n        acceptedFlags |= DecoratorFlags.INLINE;\n      }\n      let element = new Global(\n        name,\n        parent,\n        this.checkDecorators(declaration.decorators, acceptedFlags),\n        declaration\n      );\n      if (!parent.add(name, element)) continue; // reports\n    }\n  }\n\n  /** Determines the element type of a built-in array. */\n  // determineBuiltinArrayType(target: Class): Type | null {\n  //   switch (target.internalName) {\n  //     case BuiltinSymbols.Int8Array: return Type.i8;\n  //     case BuiltinSymbols.Uint8ClampedArray:\n  //     case BuiltinSymbols.Uint8Array: return Type.u8;\n  //     case BuiltinSymbols.Int16Array: return Type.i16;\n  //     case BuiltinSymbols.Uint16Array: return Type.u16;\n  //     case BuiltinSymbols.Int32Array: return Type.i32;\n  //     case BuiltinSymbols.Uint32Array: return Type.u32;\n  //     case BuiltinSymbols.Int64Array: return Type.i64;\n  //     case BuiltinSymbols.Uint64Array: return Type.u64;\n  //     case BuiltinSymbols.Float32Array: return Type.f32;\n  //     case BuiltinSymbols.Float64Array: return Type.f64;\n  //   }\n  //   var current: Class | null = target;\n  //   var arrayPrototype = this.arrayPrototype;\n  //   do {\n  //     if (current.prototype == arrayPrototype) { // Array<T>\n  //       let typeArguments = assert(current.typeArguments);\n  //       assert(typeArguments.length == 1);\n  //       return typeArguments[0];\n  //     }\n  //   } while (current = current.base);\n  //   return null;\n  // }\n\n  /** Finds all cyclic classes. */\n  findCyclicClasses(): Set<Class> {\n    var cyclics = new Set<Class>();\n    // TODO: for (let instance of this.managedClasses.values()) {\n    for (let _values = Map_values(this.managedClasses), i = 0, k = _values.length; i < k; ++i) {\n      let instance = unchecked(_values[i]);\n      if (!instance.isAcyclic) cyclics.add(instance);\n    }\n    return cyclics;\n  }\n}\n\n/** Indicates the specific kind of an {@link Element}. */\nexport enum ElementKind {\n  /** A {@link Global}. */\n  GLOBAL,\n  /** A {@link Local}. */\n  LOCAL,\n  /** An {@link Enum}. */\n  ENUM,\n  /** An {@link EnumValue}. */\n  ENUMVALUE,\n  /** A {@link FunctionPrototype}. */\n  FUNCTION_PROTOTYPE,\n  /** A {@link Function}. */\n  FUNCTION,\n  /** A {@link FunctionTarget}. */\n  FUNCTION_TARGET,\n  /** A {@link ClassPrototype}. */\n  CLASS_PROTOTYPE,\n  /** A {@link Class}. */\n  CLASS,\n  /** An {@link InterfacePrototype}. */\n  INTERFACE_PROTOTYPE,\n  /** An {@link Interface}. */\n  INTERFACE,\n  /** A {@link FieldPrototype}. */\n  FIELD_PROTOTYPE,\n  /** A {@link Field}. */\n  FIELD,\n  /** A {@link PropertyPrototype}.  */\n  PROPERTY_PROTOTYPE,\n  /** A {@link Property}. */\n  PROPERTY,\n  /** A {@link Namespace}. */\n  NAMESPACE,\n  /** A {@link File}. */\n  FILE,\n  /** A {@link TypeDefinition}.  */\n  TYPEDEFINITION,\n  /** An {@link IndexSignature}. */\n  INDEXSIGNATURE\n}\n\n/** Indicates built-in decorators that are present. */\nexport enum DecoratorFlags {\n  /** No flags set. */\n  NONE = 0,\n  /** Is a program global. */\n  GLOBAL = 1 << 0,\n  /** Is a binary operator overload. */\n  OPERATOR_BINARY = 1 << 1,\n  /** Is a unary prefix operator overload. */\n  OPERATOR_PREFIX = 1 << 2,\n  /** Is a unary postfix operator overload. */\n  OPERATOR_POSTFIX = 1 << 3,\n  /** Is an unmanaged class. */\n  UNMANAGED = 1 << 4,\n  /** Is a final class. */\n  FINAL = 1 << 5,\n  /** Is always inlined. */\n  INLINE = 1 << 6,\n  /** Is using a different external name. */\n  EXTERNAL = 1 << 7,\n  /** Is a builtin. */\n  BUILTIN = 1 << 8,\n  /** Is compiled lazily. */\n  LAZY = 1 << 9,\n  /** Is considered unsafe code. */\n  UNSAFE = 1 << 10,\n  /* Extension add START */\n  MESSAGE = 1 << 11,\n  STORAGE = 1 << 12,\n  DEPLOYER = 1 << 13,\n  CONTRACT = 1 << 14,\n  DATABASE = 1 << 15,\n  PRIMARYID = 1 << 16,\n  /* Extension add END */\n}\n\nexport namespace DecoratorFlags {\n\n  /** Translates a decorator kind to the respective decorator flag. */\n  export function fromKind(kind: DecoratorKind): DecoratorFlags {\n    switch (kind) {\n      case DecoratorKind.GLOBAL: return DecoratorFlags.GLOBAL;\n      case DecoratorKind.OPERATOR:\n      case DecoratorKind.OPERATOR_BINARY: return DecoratorFlags.OPERATOR_BINARY;\n      case DecoratorKind.OPERATOR_PREFIX: return DecoratorFlags.OPERATOR_PREFIX;\n      case DecoratorKind.OPERATOR_POSTFIX: return DecoratorFlags.OPERATOR_POSTFIX;\n      case DecoratorKind.UNMANAGED: return DecoratorFlags.UNMANAGED;\n      case DecoratorKind.FINAL: return DecoratorFlags.FINAL;\n      case DecoratorKind.INLINE: return DecoratorFlags.INLINE;\n      case DecoratorKind.EXTERNAL: return DecoratorFlags.EXTERNAL;\n      case DecoratorKind.BUILTIN: return DecoratorFlags.BUILTIN;\n      case DecoratorKind.LAZY: return DecoratorFlags.LAZY;\n      case DecoratorKind.UNSAFE: return DecoratorFlags.UNSAFE;\n      /* Extension add START */\n      case DecoratorKind.CONTRACT: return DecoratorFlags.CONTRACT;\n      case DecoratorKind.DEPLOYER: return DecoratorFlags.DEPLOYER;\n      case DecoratorKind.STORAGE: return DecoratorFlags.STORAGE;\n      /* Extension add END */\n      default: return DecoratorFlags.NONE;\n    }\n  }\n}\n\n/** Base class of all program elements. */\nexport abstract class Element {\n\n  /** Parent element. */\n  parent!: Element;\n  /** Common flags indicating specific traits. */\n  flags: CommonFlags = CommonFlags.NONE;\n  /** Decorator flags indicating annotated traits. */\n  decoratorFlags: DecoratorFlags = DecoratorFlags.NONE;\n  /** Member elements. */\n  members: Map<string,DeclaredElement> | null = null;\n  /** Shadowing type in type space, if any. */\n  shadowType: TypeDefinition | null = null;\n\n  /** Constructs a new program element. */\n  protected constructor(\n    /** Specific element kind. */\n    public kind: ElementKind,\n    /** Simple name. */\n    public name: string,\n    /** Internal name referring to this element. */\n    public internalName: string,\n    /** Containing {@link Program}. */\n    public program: Program,\n    /** Parent element. */\n    parent: Element | null\n  ) {\n    this.program = program;\n    this.name = name;\n    this.internalName = internalName;\n    if (parent) {\n      this.parent = parent;\n    } else {\n      assert(this.kind == ElementKind.FILE);\n      this.parent = this; // special case to keep this.parent non-nullable\n    }\n  }\n\n  /** Gets the enclosing file. */\n  get file(): File {\n    var current: Element = this;\n    do {\n      current = current.parent;\n      if (current.kind == ElementKind.FILE) return <File>current;\n    } while (true);\n  }\n\n  /** Tests if this element has a specific flag or flags. */\n  is(flag: CommonFlags): bool { return (this.flags & flag) == flag; }\n  /** Tests if this element has any of the specified flags. */\n  isAny(flags: CommonFlags): bool { return (this.flags & flags) != 0; }\n  /** Sets a specific flag or flags. */\n  set(flag: CommonFlags): void { this.flags |= flag; }\n  /** Unsets the specific flag or flags. */\n  unset(flag: CommonFlags): void {this.flags &= ~flag; }\n  /** Tests if this element has a specific decorator flag or flags. */\n  hasDecorator(flag: DecoratorFlags): bool { return (this.decoratorFlags & flag) == flag; }\n\n  /** Looks up the element with the specified name within this element. */\n  lookupInSelf(name: string): DeclaredElement | null {\n    var members = this.members;\n    if (members !== null && members.has(name)) return assert(members.get(name));\n    return null;\n  }\n\n  /** Looks up the element with the specified name relative to this element, like in JS. */\n  abstract lookup(name: string): Element | null;\n\n  /** Adds an element as a member of this one. Reports and returns `false` if a duplicate. */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    var originalDeclaration = element.declaration;\n    var members = this.members;\n    if (!members) this.members = members = new Map();\n    else if (members.has(name)) {\n      let existing = assert(members.get(name));\n      if (existing.parent !== this) {\n        // override non-own element\n      } else {\n        let merged = tryMerge(existing, element);\n        if (merged) {\n          element = merged; // use merged element\n        } else {\n          let reportedIdentifier = localIdentifierIfImport\n            ? localIdentifierIfImport\n            : element.identifierNode;\n          if (isDeclaredElement(existing.kind)) {\n            this.program.errorRelated(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range,\n              (<DeclaredElement>existing).identifierNode.range,\n              reportedIdentifier.text\n            );\n          } else {\n            this.program.error(\n              DiagnosticCode.Duplicate_identifier_0,\n              reportedIdentifier.range, reportedIdentifier.text\n            );\n          }\n          return false;\n        }\n      }\n    }\n    members.set(name, element);\n    var program = this.program;\n    if (element.kind != ElementKind.FUNCTION_PROTOTYPE || !(<FunctionPrototype>element).isBound) {\n      // prefer unbound prototypes in global lookup maps\n      program.elementsByName.set(element.internalName, element);\n      program.elementsByDeclaration.set(originalDeclaration, element);\n    }\n    return true;\n  }\n\n  /** Checks if this element is public, explicitly or implicitly. */\n  get isPublic(): bool {\n    return !this.isAny(CommonFlags.PRIVATE | CommonFlags.PROTECTED);\n  }\n\n  /** Checks if this element is implicitly public, i.e. not explicitly declared to be. */\n  get isImplicitlyPublic(): bool {\n    return this.isPublic && !this.is(CommonFlags.PUBLIC);\n  }\n\n  /** Checks if the visibility of this element equals the specified. */\n  visibilityEquals(other: Element): bool {\n    if (this.isPublic == other.isPublic) return true;\n    const vis = CommonFlags.PRIVATE | CommonFlags.PROTECTED;\n    return (this.flags & vis) == (other.flags & vis);\n  }\n\n  /** Returns a string representation of this element. */\n  toString(): string {\n    return this.internalName + \", kind=\" + this.kind.toString();\n  }\n}\n\n// Kinds of all declared elements\nvar declaredElements = new Set<ElementKind>();\n\n/** Tests if the specified element kind indicates a declared element. */\nexport function isDeclaredElement(kind: ElementKind): bool {\n  return declaredElements.has(kind);\n}\n\n/** Base class of elements with an associated declaration statement. */\nexport abstract class DeclaredElement extends Element {\n\n  /** Constructs a new declared program element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    public declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent);\n    declaredElements.add(kind);\n    // It is necessary to have access to identifiers of all members and exports\n    // for reporting purposes and this is the lowest common denominator. Comes\n    // at the expense of not having more specific type information in derived\n    // classes, though. Instead, derived classes implement getters for other\n    // important AST nodes directly through manual casting, allowing the resolver\n    // etc. to not worry about actual declarations.\n    this.declaration = declaration;\n    this.flags = declaration.flags; // inherit\n  }\n\n  /** Tests if this element is a library element. */\n  get isDeclaredInLibrary(): bool {\n    return this.declaration.range.source.isLibrary;\n  }\n\n  /** Gets the associated identifier node. */\n  get identifierNode(): IdentifierExpression {\n    return this.declaration.name;\n  }\n\n  /** Gets the signature node, if applicable, along the identifier node. */\n  get identifierAndSignatureRange(): Range {\n    var declaration = this.declaration;\n    var identifierNode = declaration.name;\n    if (declaration.kind == NodeKind.FUNCTIONDECLARATION || declaration.kind == NodeKind.METHODDECLARATION) {\n      let signatureNode = (<FunctionDeclaration>declaration).signature;\n      return Range.join(identifierNode.range, signatureNode.range);\n    }\n    return identifierNode.range;\n  }\n\n  /** Gets the assiciated decorator nodes. */\n  get decoratorNodes(): DecoratorNode[] | null {\n    return this.declaration.decorators;\n  }\n\n  /** Checks if this element is a compatible override of the specified. */\n  isCompatibleOverride(base: DeclaredElement): bool {\n    var self: DeclaredElement = this; // TS\n    var kind = self.kind;\n    if (kind == base.kind) {\n      switch (kind) {\n        case ElementKind.FUNCTION: {\n          return (<Function>self).signature.isAssignableTo((<Function>base).signature, /* sameSize */ true);\n        }\n        case ElementKind.PROPERTY: {\n          let selfProperty = <Property>self;\n          let baseProperty = <Property>base;\n          let selfGetter = selfProperty.getterInstance;\n          let baseGetter = baseProperty.getterInstance;\n          if (selfGetter) {\n            if (!baseGetter || !selfGetter.signature.isAssignableTo(baseGetter.signature, true)) {\n              return false;\n            }\n          } else if (baseGetter) {\n            return false;\n          }\n          let selfSetter = selfProperty.setterInstance;\n          let baseSetter = baseProperty.setterInstance;\n          if (selfSetter) {\n            if (!baseSetter || !selfSetter.signature.isAssignableTo(baseSetter.signature, true)) {\n              return false;\n            }\n          } else if (baseSetter) {\n            return false;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\n// Kinds of all typed elements\nvar typedElements = new Set<ElementKind>();\n\n/** Checks if the specified element kind indicates a typed element. */\nexport function isTypedElement(kind: ElementKind): bool {\n  return typedElements.has(kind);\n}\n\n/** Base class of elements that can be resolved to a concrete type. */\nexport abstract class TypedElement extends DeclaredElement {\n\n  /** Resolved type. Set once `is(RESOLVED)`, otherwise void. */\n  type: Type = Type.void;\n\n  constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Internal name referring to this element. */\n    internalName: string,\n    /** Containing {@link Program}. */\n    program: Program,\n    /** Parent element. */\n    parent: Element | null,\n    /** Declaration reference. */\n    declaration: DeclarationStatement\n  ) {\n    super(kind, name, internalName, program, parent, declaration);\n    typedElements.add(kind);\n  }\n\n  /** Sets the resolved type of this element. */\n  setType(type: Type): void {\n    assert(!this.is(CommonFlags.RESOLVED));\n    this.type = type;\n    this.set(CommonFlags.RESOLVED);\n  }\n}\n\n/** A file representing the implicit top-level namespace of a source. */\nexport class File extends Element {\n\n  /** File exports. */\n  exports: Map<string,DeclaredElement> | null = null;\n  /** File re-exports. */\n  exportsStar: File[] | null = null;\n  /** Top-level start function of this file. */\n  startFunction!: Function;\n  /** Array of `import * as X` alias namespaces of this file. */\n  aliasNamespaces: Array<Namespace> = new Array<Namespace>();\n\n  /** Constructs a new file. */\n  constructor(\n    /** Program this file belongs to. */\n    program: Program,\n    /** Source of this file. */\n    public source: Source\n  ) {\n    super(\n      ElementKind.FILE,\n      source.normalizedPath,\n      source.internalPath,\n      program,\n      null // special case for files\n    );\n    this.source = source;\n    assert(!program.filesByName.has(this.internalName));\n    program.filesByName.set(this.internalName, this);\n    var startFunction = this.program.makeNativeFunction(\n      \"start:\" + this.internalName,\n      new Signature(program, null, Type.void),\n      this\n    );\n    startFunction.internalName = startFunction.name;\n    this.startFunction = startFunction;\n  }\n\n  /* @override */\n  add(name: string, element: DeclaredElement, localIdentifierIfImport: IdentifierExpression | null = null): bool {\n    if (element.hasDecorator(DecoratorFlags.GLOBAL)) {\n      element = this.program.ensureGlobal(name, element); // possibly merged globally\n    }\n    if (!super.add(name, element, localIdentifierIfImport)) return false;\n    element = assert(this.lookupInSelf(name)); // possibly merged locally\n    if (element.is(CommonFlags.EXPORT) && !localIdentifierIfImport) {\n      this.ensureExport(\n        element.name,\n        element\n      );\n    }\n    return true;\n  }\n\n  /* @override */\n  lookupInSelf(name: string): DeclaredElement | null {\n    var element = super.lookupInSelf(name);\n    if (element) return element;\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        if (element = exportsStar[i].lookupInSelf(name)) return element;\n      }\n    }\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var element = this.lookupInSelf(name);\n    if (element) return element;\n    return this.program.lookupGlobal(name);\n  }\n\n  /** Ensures that an element is an export of this file. */\n  ensureExport(name: string, element: DeclaredElement): void {\n    var exports = this.exports;\n    if (!exports) this.exports = exports = new Map();\n    exports.set(name, element);\n    if (this.source.sourceKind == SourceKind.LIBRARY_ENTRY) this.program.ensureGlobal(name, element);\n\n    // Also, add to the namespaces that capture our exports\n    for(let i = 0; i < this.aliasNamespaces.length; i++) {\n      let ns = this.aliasNamespaces[i];\n      ns.add(name, element);\n    }\n  }\n\n  /** Ensures that another file is a re-export of this file. */\n  ensureExportStar(file: File): void {\n    var exportsStar = this.exportsStar;\n    if (!exportsStar) this.exportsStar = exportsStar = [];\n    else if (exportsStar.includes(file)) return;\n    exportsStar.push(file);\n  }\n\n  /** Looks up the export of the specified name. */\n  lookupExport(name: string): DeclaredElement | null {\n    var exports = this.exports;\n    if (exports !== null && exports.has(name)) return assert(exports.get(name));\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        let element = exportsStar[i].lookupExport(name);\n        if (element) return element;\n      }\n    }\n    return null;\n  }\n\n  /** Creates an imported namespace from this file. */\n  asAliasNamespace(\n    name: string, \n    parent: Element, \n    localIdentifier: IdentifierExpression\n  ): Namespace {\n    var declaration = this.program.makeNativeNamespaceDeclaration(name);\n    declaration.name = localIdentifier;\n    var ns = new Namespace(name, parent, declaration);\n    ns.set(CommonFlags.SCOPED);\n    this.copyExportsToNamespace(ns);\n    // NOTE: Some exports are still queued, and can't yet be added here,\n    // so we remember all the alias namespaces and add to them as well\n    // when adding an element to the file.\n    this.aliasNamespaces.push(ns);\n    return ns;\n  }\n\n  /** Recursively copies the exports of this file to the specified namespace. */\n  private copyExportsToNamespace(ns: Namespace): void {\n    var exports = this.exports;\n    if (exports) {\n      // TODO: for (let [memberName, member] of exports) {\n      for (let _keys = Map_keys(exports), i = 0, k = _keys.length; i < k; ++i) {\n        let memberName = unchecked(_keys[i]);\n        let member = assert(exports.get(memberName));\n        ns.add(memberName, member);\n      }\n    }\n    var exportsStar = this.exportsStar;\n    if (exportsStar) {\n      for (let i = 0, k = exportsStar.length; i < k; ++i) {\n        exportsStar[i].copyExportsToNamespace(ns);\n      }\n    }\n  }\n}\n\n/** A type definition. */\nexport class TypeDefinition extends TypedElement {\n\n  /** Constructs a new type definition. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: TypeDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.TYPEDEFINITION,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<TypeDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode {\n    return (<TypeDeclaration>this.declaration).type;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A namespace that differs from a file in being user-declared with a name. */\nexport class Namespace extends DeclaredElement {\n\n  /** Constructs a new namespace. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or another namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: NamespaceDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.NAMESPACE,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var inSelf = this.lookupInSelf(name);\n    if (inSelf) return inSelf;\n    return this.parent.lookup(name);\n  }\n}\n\n/** An enum. */\nexport class Enum extends TypedElement {\n\n  /** Constructs a new enum. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: EnumDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUM,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var inSelf = this.lookupInSelf(name);\n    if (inSelf) return inSelf;\n    return this.parent.lookup(name);\n  }\n}\n\n/** Indicates the kind of an inlined constant value. */\nexport const enum ConstantValueKind {\n  /** No constant value. */\n  NONE,\n  /** Constant integer value. */\n  INTEGER,\n  /** Constant float value. */\n  FLOAT\n}\n\n/** Base class of all variable-like program elements. */\nexport abstract class VariableLikeElement extends TypedElement {\n\n  /** Constant value kind. */\n  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;\n  /** Constant integer value, if applicable. */\n  constantIntegerValue: i64 = i64_zero;\n  /** Constant float value, if applicable. */\n  constantFloatValue: f64 = 0;\n\n  /** Constructs a new variable-like element. */\n  protected constructor(\n    /** Specific element kind. */\n    kind: ElementKind,\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or class. */\n    parent: Element,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      kind,\n      name,\n      mangleInternalName(name, parent, false),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.flags = declaration.flags;\n  }\n\n  /** Gets the associated type node.s */\n  get typeNode(): TypeNode | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<VariableLikeDeclarationStatement>this.declaration).initializer;\n  }\n\n  /** Applies a constant integer value to this element. */\n  setConstantIntegerValue(value: i64, type: Type): void {\n    assert(type.isIntegerInclReference);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.INTEGER;\n    this.constantIntegerValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n\n  /** Applies a constant float value to this element. */\n  setConstantFloatValue(value: f64, type: Type): void {\n    assert(type.isFloatValue);\n    this.type = type;\n    this.constantValueKind = ConstantValueKind.FLOAT;\n    this.constantFloatValue = value;\n    this.set(CommonFlags.CONST | CommonFlags.INLINED | CommonFlags.RESOLVED);\n  }\n\n  /** @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** An enum value. */\nexport class EnumValue extends VariableLikeElement {\n\n  /** Constructs a new enum value. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent enum. */\n    parent: Enum,\n    /** Declaration reference. */\n    declaration: EnumValueDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.ENUMVALUE,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n    this.setType(Type.i32);\n  }\n\n  /** Whether this enum value is immutable. */\n  isImmutable: bool = false;\n\n  /** Gets the associated value node. */\n  get valueNode(): Expression | null {\n    return (<EnumValueDeclaration>this.declaration).initializer;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A global variable. */\nexport class Global extends VariableLikeElement {\n\n  /** Constructs a new global variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file, namespace or static class. */\n    parent: Element,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags,\n    /** Declaration reference. Creates a native declaration if omitted. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.GLOBAL,\n      name,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n}\n\n/** A function parameter. */\nexport class Parameter {\n  /** Constructs a new function parameter. */\n  constructor(\n    /** Parameter name. */\n    public name: string,\n    /** Parameter type. */\n    public type: Type,\n    /** Parameter initializer, if present. */\n    public initializer: Expression | null = null\n  ) {}\n}\n\n/** A local variable. */\nexport class Local extends VariableLikeElement {\n\n  /** Original name of the (temporary) local. */\n  private originalName: string;\n\n  /** Constructs a new local variable. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Zero-based index within the enclosing function. `-1` indicates a virtual local. */\n    public index: i32,\n    /** Resolved type. */\n    type: Type,\n    /** Parent function. */\n    parent: Function,\n    /** Declaration reference. */\n    declaration: VariableLikeDeclarationStatement = parent.program.makeNativeVariableDeclaration(name)\n  ) {\n    super(\n      ElementKind.LOCAL,\n      name,\n      parent,\n      declaration\n    );\n    this.originalName = name;\n    this.index = index;\n    assert(type != Type.void);\n    this.setType(type);\n  }\n\n  /** Sets the temporary name of this local. */\n  setTemporaryName(name: string): void {\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n\n  /** Resets the temporary name of this local. */\n  resetTemporaryName(): void {\n    var name = this.originalName;\n    this.name = name;\n    this.internalName = mangleInternalName(name, this.parent, false);\n  }\n}\n\n/** A yet unresolved function prototype. */\nexport class FunctionPrototype extends DeclaredElement {\n\n  /** Operator kind, if an overload. */\n  operatorKind: OperatorKind = OperatorKind.INVALID;\n  /** Already resolved instances. */\n  instances: Map<string,Function> | null = null;\n  /** Methods overloading this one, if any. These are unbound. */\n  overloads: Set<FunctionPrototype> | null = null;\n\n  /** Clones of this prototype that are bounds to specific classes. */\n  private boundPrototypes: Map<Class,FunctionPrototype> | null = null;\n\n  /** Constructs a new function prototype. */\n  constructor(\n    /** Simple name */\n    name: string,\n    /** Parent element, usually a file, namespace or class (if a method). */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: FunctionDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FUNCTION_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<FunctionDeclaration>this.declaration).typeParameters;\n  }\n\n  /** Gets the associated function type node. */\n  get functionTypeNode(): FunctionTypeNode {\n    return (<FunctionDeclaration>this.declaration).signature;\n  }\n\n  /** Gets the associated body node. */\n  get bodyNode(): Statement | null {\n    return (<FunctionDeclaration>this.declaration).body;\n  }\n\n  /** Gets the arrow function kind. */\n  get arrowKind(): ArrowKind {\n    return (<FunctionDeclaration>this.declaration).arrowKind;\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    var parent = this.parent;\n    return parent.kind == ElementKind.CLASS ||\n           parent.kind == ElementKind.PROPERTY_PROTOTYPE && (\n             parent.parent.kind == ElementKind.CLASS ||\n             parent.parent.kind == ElementKind.INTERFACE\n           );\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): FunctionPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var declaration = this.declaration;\n    assert(declaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new FunctionPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>declaration,\n      this.decoratorFlags\n    );\n    bound.flags = this.flags;\n    bound.operatorKind = this.operatorKind;\n    bound.overloads = this.overloads;\n    // NOTE: this.instances holds instances per bound class / unbound\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Function | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return assert(instances.get(instanceKey));\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Function): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A resolved function. */\nexport class Function extends TypedElement {\n\n  /** Function prototype. */\n  prototype: FunctionPrototype;\n  /** Function signature. */\n  signature: Signature;\n  /** Map of locals by name. */\n  localsByName: Map<string,Local> = new Map();\n  /** Array of locals by index. */\n  localsByIndex: Local[] = [];\n  /** List of additional non-parameter locals. */\n  additionalLocals: Type[] = [];\n  /** Concrete type arguments. */\n  typeArguments: Type[] | null;\n  /** Contextual type arguments. */\n  contextualTypeArguments: Map<string,Type> | null;\n  /** Default control flow. */\n  flow!: Flow;\n  /** Remembered debug locations. */\n  debugLocations: Range[] = [];\n  /** Function reference, if compiled. */\n  ref: FunctionRef = 0;\n  /** Varargs stub for calling with omitted arguments. */\n  varargsStub: Function | null = null;\n  /** Virtual stub for calling overloads. */\n  virtualStub: Function | null = null;\n  /** Runtime memory segment, if created. */\n  memorySegment: MemorySegment | null = null;\n  /** Original function, if a stub. Otherwise `this`. */\n  original!: Function;\n\n  /** Counting id of inline operations involving this function. */\n  nextInlineId: i32 = 0;\n  /** Counting id of anonymous inner functions. */\n  nextAnonymousId: i32 = 0;\n  /** Counting id of autorelease variables. */\n  nextAutoreleaseId: i32 = 0;\n\n  /** Constructs a new concrete function. */\n  constructor(\n    /** Name incl. type parameters, i.e. `foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** Respective function prototype. */\n    prototype: FunctionPrototype,\n    /** Concrete type arguments. */\n    typeArguments: Type[] | null,\n    /** Concrete signature. */\n    signature: Signature, // pre-resolved\n    /** Contextual type arguments inherited from its parent class, if any. */\n    contextualTypeArguments: Map<string,Type> | null = null\n  ) {\n    super(\n      ElementKind.FUNCTION,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    this.prototype = prototype;\n    this.typeArguments = typeArguments;\n    this.signature = signature;\n    this.flags = prototype.flags | CommonFlags.RESOLVED;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.contextualTypeArguments = contextualTypeArguments;\n    this.original = this;\n    var program = prototype.program;\n    this.type = signature.type;\n    if (!prototype.is(CommonFlags.AMBIENT)) {\n      let localIndex = 0;\n      let thisType = signature.thisType;\n      if (thisType) {\n        let local = new Local(\n          CommonNames.this_,\n          localIndex++,\n          thisType,\n          this\n        );\n        this.localsByName.set(CommonNames.this_, local);\n        this.localsByIndex[local.index] = local;\n      }\n      let parameterTypes = signature.parameterTypes;\n      for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n        let parameterType = parameterTypes[i];\n        let parameterName = this.getParameterName(i);\n        let local = new Local(\n          parameterName,\n          localIndex++,\n          parameterType,\n          this\n        );\n        this.localsByName.set(parameterName, local);\n        this.localsByIndex[local.index] = local;\n      }\n    }\n    this.flow = Flow.createParent(this);\n    registerConcreteElement(program, this);\n  }\n\n  /** Gets the name of the parameter at the specified index. */\n  getParameterName(index: i32): string {\n    var parameters = (<FunctionDeclaration>this.declaration).signature.parameters;\n    return parameters.length > index\n      ? parameters[index].name.text\n      : getDefaultParameterName(index);\n  }\n\n  /** Creates a stub for use with this function, i.e. for varargs or virtual calls. */\n  newStub(postfix: string): Function {\n    var stub = new Function(\n      this.original.name + STUB_DELIMITER + postfix,\n      this.prototype,\n      this.typeArguments,\n      this.signature.clone(),\n      this.contextualTypeArguments\n    );\n    stub.original = this.original;\n    stub.set(this.flags & ~CommonFlags.COMPILED | CommonFlags.STUB);\n    return stub;\n  }\n\n  /** Adds a local of the specified type, with an optional name. */\n  addLocal(type: Type, name: string | null = null, declaration: VariableDeclaration | null = null): Local {\n    // if it has a name, check previously as this method will throw otherwise\n    var localIndex = this.signature.parameterTypes.length + this.additionalLocals.length;\n    if (this.is(CommonFlags.INSTANCE)) ++localIndex;\n    var localName = name !== null\n      ? name\n      : \"var$\" + localIndex.toString();\n    if (!declaration) declaration = this.program.makeNativeVariableDeclaration(localName);\n    var local = new Local(\n      localName,\n      localIndex,\n      type,\n      this,\n      declaration\n    );\n    if (name) {\n      if (this.localsByName.has(name)) throw new Error(\"duplicate local name\");\n      this.localsByName.set(name, local);\n    }\n    this.localsByIndex[local.index] = local;\n    this.additionalLocals.push(type);\n    return local;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    var locals = this.localsByName;\n    if (locals.has(name)) return assert(locals.get(name));\n    return this.parent.lookup(name);\n  }\n\n  // used by flows to keep track of temporary locals\n  tempI32s: Local[] | null = null;\n  tempI64s: Local[] | null = null;\n  tempF32s: Local[] | null = null;\n  tempF64s: Local[] | null = null;\n  tempV128s: Local[] | null = null;\n  tempFuncrefs: Local[] | null = null;\n  tempExternrefs: Local[] | null = null;\n  tempExnrefs: Local[] | null = null;\n  tempAnyrefs: Local[] | null = null;\n\n  // used by flows to keep track of break labels\n  nextBreakId: i32 = 0;\n  breakStack: i32[] | null = null;\n  breakLabel: string | null = null;\n\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\n  finalize(module: Module, ref: FunctionRef): void {\n    this.ref = ref;\n    var breakStack = this.breakStack;\n    assert(!breakStack || !breakStack.length); // internal error\n    this.breakStack = breakStack = null;\n    this.breakLabel = null;\n    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\n    if (this.program.options.sourceMap) {\n      let debugLocations = this.debugLocations;\n      for (let i = 0, k = debugLocations.length; i < k; ++i) {\n        let range = debugLocations[i];\n        let source = range.source;\n        module.setDebugLocation(\n          ref,\n          range.debugInfoRef,\n          source.debugInfoIndex,\n          source.lineAt(range.start),\n          source.columnAt() - 1 // source maps are 0-based\n        );\n      }\n    }\n  }\n}\n\n/** A yet unresolved instance field prototype. */\nexport class FieldPrototype extends DeclaredElement {\n\n  /** Constructs a new field prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent class. */\n    parent: ClassPrototype,\n    /** Declaration reference. */\n    declaration: FieldDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE\n  ) {\n    super(\n      ElementKind.FIELD_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, assert(declaration.is(CommonFlags.INSTANCE))),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type node. */\n  get typeNode(): TypeNode | null {\n    return (<FieldDeclaration>this.declaration).type;\n  }\n\n  /** Gets the associated initializer node. */\n  get initializerNode(): Expression | null {\n    return (<FieldDeclaration>this.declaration).initializer;\n  }\n\n  /** Gets the associated parameter index. Set if declared as a constructor parameter, otherwise `-1`. */\n  get parameterIndex(): i32 {\n    return (<FieldDeclaration>this.declaration).parameterIndex;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A resolved instance field. */\nexport class Field extends VariableLikeElement {\n\n  /** Field prototype reference. */\n  prototype: FieldPrototype;\n  /** Field memory offset, if an instance field. */\n  memoryOffset: i32 = -1;\n  /** Getter function reference, if compiled. */\n  getterRef: FunctionRef = 0;\n  /** Setter function reference, if compiled. */\n  setterRef: FunctionRef = 0;\n\n  /** Constructs a new field. */\n  constructor(\n    /** Respective field prototype. */\n    prototype: FieldPrototype,\n    /** Parent class. */\n    parent: Class,\n    /** Concrete type. */\n    type: Type\n  ) {\n    super(\n      ElementKind.FIELD,\n      prototype.name,\n      parent,\n      <VariableLikeDeclarationStatement>prototype.declaration\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    assert(type != Type.void);\n    this.setType(type);\n    registerConcreteElement(this.program, this);\n  }\n\n  /** Gets the internal name of the respective getter function. */\n  get internalGetterName(): string {\n    return this.parent.internalName + INSTANCE_DELIMITER + GETTER_PREFIX + this.name;\n  }\n\n  /** Gets the internal name of the respective setter function. */\n  get internalSetterName(): string {\n    return this.parent.internalName + INSTANCE_DELIMITER + SETTER_PREFIX + this.name;\n  }\n}\n\n/** A property comprised of a getter and a setter function. */\nexport class PropertyPrototype extends DeclaredElement {\n\n  /** Getter prototype. */\n  getterPrototype: FunctionPrototype | null = null;\n  /** Setter prototype. */\n  setterPrototype: FunctionPrototype | null = null;\n  /** Property instance, if resolved. */\n  instance: Property | null = null;\n\n  /** Clones of this prototype that are bound to specific classes. */\n  private boundPrototypes: Map<Class,PropertyPrototype> | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element. Either a class prototype or instance. */\n    parent: Element,\n    /** Declaration of the getter or setter introducing the property. */\n    firstDeclaration: FunctionDeclaration\n  ) {\n    super(\n      ElementKind.PROPERTY_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, firstDeclaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      firstDeclaration\n    );\n    this.flags &= ~(CommonFlags.GET | CommonFlags.SET);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n\n  /** Tests if this prototype is bound to a class. */\n  get isBound(): bool {\n    switch (this.parent.kind) {\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: return true;\n    }\n    return false;\n  }\n\n  /** Creates a clone of this prototype that is bound to a concrete class instead. */\n  toBound(classInstance: Class): PropertyPrototype {\n    assert(this.is(CommonFlags.INSTANCE));\n    assert(!this.isBound);\n    var boundPrototypes = this.boundPrototypes;\n    if (!boundPrototypes) this.boundPrototypes = boundPrototypes = new Map();\n    else if (boundPrototypes.has(classInstance)) return assert(boundPrototypes.get(classInstance));\n    var firstDeclaration = this.declaration;\n    assert(firstDeclaration.kind == NodeKind.METHODDECLARATION);\n    var bound = new PropertyPrototype(\n      this.name,\n      classInstance, // !\n      <MethodDeclaration>firstDeclaration\n    );\n    bound.flags = this.flags;\n    var getterPrototype = this.getterPrototype;\n    if (getterPrototype) {\n      bound.getterPrototype = getterPrototype.toBound(classInstance);\n    }\n    var setterPrototype = this.setterPrototype;\n    if (setterPrototype) {\n      bound.setterPrototype = setterPrototype.toBound(classInstance);\n    }\n    boundPrototypes.set(classInstance, bound);\n    return bound;\n  }\n}\n\n/** A resolved property. */\nexport class Property extends VariableLikeElement {\n\n  /** Prototype reference. */\n  prototype: PropertyPrototype;\n  /** Getter instance. */\n  getterInstance: Function | null = null;\n  /** Setter instance. */\n  setterInstance: Function | null = null;\n\n  /** Constructs a new property prototype. */\n  constructor(\n    /** Respective property prototype. */\n    prototype: PropertyPrototype,\n    /** Parent element, usually a static class prototype or class instance. */\n    parent: Element\n  ) {\n    super(\n      ElementKind.PROPERTY,\n      prototype.name,\n      parent,\n      Node.createVariableDeclaration(\n        prototype.identifierNode,\n        null,\n        prototype.is(CommonFlags.INSTANCE)\n          ? CommonFlags.INSTANCE\n          : CommonFlags.NONE,\n        null, null,\n        prototype.identifierNode.range\n      )\n    );\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    if (this.is(CommonFlags.INSTANCE)) {\n      registerConcreteElement(this.program, this);\n    }\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A resolved index signature. */\nexport class IndexSignature extends TypedElement {\n\n  /** Constructs a new index prototype. */\n  constructor(\n    /** Parent class. */\n    parent: Class\n  ) {\n    super(\n      ElementKind.INDEXSIGNATURE,\n      \"[]\",\n      parent.internalName + \"[]\",\n      parent.program,\n      parent,\n      parent.program.makeNativeVariableDeclaration(\"[]\") // is fine\n    );\n  }\n\n  /** Obtains the getter instance. */\n  getGetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_GET, isUnchecked);\n  }\n\n  /** Obtains the setter instance. */\n  getSetterInstance(isUnchecked: bool): Function | null {\n    return (<Class>this.parent).lookupOverload(OperatorKind.INDEXED_SET, isUnchecked);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\n/** A yet unresolved class prototype. */\nexport class ClassPrototype extends DeclaredElement {\n\n  /** Instance member prototypes. */\n  instanceMembers: Map<string,DeclaredElement> | null = null;\n  /** Base class prototype, if applicable. */\n  basePrototype: ClassPrototype | null = null;\n  /** Interface prototypes, if applicable. */\n  interfacePrototypes: InterfacePrototype[] | null = null;\n  /** Constructor prototype. */\n  constructorPrototype: FunctionPrototype | null = null;\n  /** Operator overload prototypes. */\n  overloadPrototypes: Map<OperatorKind, FunctionPrototype> = new Map();\n  /** Already resolved instances. */\n  instances: Map<string,Class> | null = null;\n  /** Classes extending this class. */\n  extendees: Set<ClassPrototype> = new Set();\n\n  constructor(\n    /** Simple name. */\n    name: string,\n    /** Parent element, usually a file or namespace. */\n    parent: Element,\n    /** Declaration reference. */\n    declaration: ClassDeclaration,\n    /** Pre-checked flags indicating built-in decorators. */\n    decoratorFlags: DecoratorFlags = DecoratorFlags.NONE,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE_PROTOTYPE : ElementKind.CLASS_PROTOTYPE,\n      name,\n      mangleInternalName(name, parent, declaration.is(CommonFlags.INSTANCE)),\n      parent.program,\n      parent,\n      declaration\n    );\n    this.decoratorFlags = decoratorFlags;\n  }\n\n  /** Gets the associated type parameter nodes. */\n  get typeParameterNodes(): TypeParameterNode[] | null {\n    return (<ClassDeclaration>this.declaration).typeParameters;\n  }\n  /** Gets the associated extends node. */\n  get extendsNode(): NamedTypeNode | null {\n    return (<ClassDeclaration>this.declaration).extendsType;\n  }\n  /** Gets the associated implements nodes. */\n  get implementsNodes(): NamedTypeNode[] | null {\n    return (<ClassDeclaration>this.declaration).implementsTypes;\n  }\n\n  /** Tests if this prototype is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    var arrayBufferViewInstance = this.program.arrayBufferViewInstance;\n    return arrayBufferViewInstance !== null\n        && this.extends(arrayBufferViewInstance.prototype);\n  }\n\n  /** Tests if this prototype extends the specified. */\n  extends(basePtototype: ClassPrototype | null): bool {\n    var current: ClassPrototype | null = this;\n    var seen = new Set<ClassPrototype>();\n    do {\n      // cannot directly or indirectly extend itself\n      if (seen.has(current)) break;\n      seen.add(current);\n      if (current === basePtototype) return true;\n      current = current.basePrototype;\n    } while (current);\n    return false;\n  }\n\n  /** Adds an element as an instance member of this one. Returns the previous element if a duplicate. */\n  addInstance(name: string, element: DeclaredElement): bool {\n    var originalDeclaration = element.declaration;\n    var instanceMembers = this.instanceMembers;\n    if (!instanceMembers) this.instanceMembers = instanceMembers = new Map();\n    else if (instanceMembers.has(name)) {\n      let existing = assert(instanceMembers.get(name));\n      let merged = tryMerge(existing, element);\n      if (!merged) {\n        if (isDeclaredElement(existing.kind)) {\n          this.program.errorRelated(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range,\n            (<DeclaredElement>existing).declaration.name.range,\n            element.identifierNode.text\n          );\n        } else {\n          this.program.error(\n            DiagnosticCode.Duplicate_identifier_0,\n            element.identifierNode.range, element.identifierNode.text\n          );\n        }\n        return false;\n      }\n      element = merged;\n    }\n    instanceMembers.set(name, element);\n    if (element.is(CommonFlags.EXPORT) && this.is(CommonFlags.MODULE_EXPORT)) {\n      element.set(CommonFlags.MODULE_EXPORT); // propagate\n    }\n    this.program.elementsByDeclaration.set(originalDeclaration, element);\n    return true;\n  }\n\n  /** Gets the resolved instance for the specified instance key, if already resolved. */\n  getResolvedInstance(instanceKey: string): Class | null {\n    var instances = this.instances;\n    if (instances !== null && instances.has(instanceKey)) return <Class>instances.get(instanceKey);\n    return null;\n  }\n\n  /** Sets the resolved instance for the specified instance key. */\n  setResolvedInstance(instanceKey: string, instance: Class): void {\n    var instances = this.instances;\n    if (!instances) this.instances = instances = new Map();\n    else assert(!instances.has(instanceKey));\n    instances.set(instanceKey, instance);\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n}\n\nconst enum AcyclicState {\n  UNKNOWN,\n  ACYCLIC,\n  NOT_ACYCLIC\n}\n\n/** A resolved class. */\nexport class Class extends TypedElement {\n\n  /** Class prototype. */\n  prototype: ClassPrototype;\n  /** Resolved type arguments. */\n  typeArguments: Type[] | null;\n  /** Base class, if applicable. */\n  base: Class | null = null;\n  /** Implemented interfaces, if applicable. */\n  interfaces: Set<Interface> | null = null;\n  /** Contextual type arguments for fields and methods. */\n  contextualTypeArguments: Map<string,Type> | null = null;\n  /** Current member memory offset. */\n  nextMemoryOffset: u32 = 0;\n  /** Constructor instance. */\n  constructorInstance: Function | null = null;\n  /** Operator overloads. */\n  overloads: Map<OperatorKind,Function> | null = null;\n  /** Index signature, if present. */\n  indexSignature: IndexSignature | null = null;\n  /** Unique class id. */\n  private _id: u32 = 0;\n  /** Remembers acyclic state. */\n  private _acyclic: AcyclicState = AcyclicState.UNKNOWN;\n  /** Runtime type information flags. */\n  rttiFlags: u32 = 0;\n  /** Wrapped type, if a wrapper for a basic type. */\n  wrappedType: Type | null = null;\n  /** Classes directly extending this class. */\n  extendees: Set<Class> | null = null;\n  /** Classes implementing this interface. */\n  implementers: Set<Class> | null = null;\n  /** Whether the field initialization check has already been performed. */\n  didCheckFieldInitialization: bool = false;\n  /** Runtime visitor function reference. */\n  visitRef: FunctionRef = 0;\n\n  /** Gets the unique runtime id of this class. */\n  get id(): u32 {\n    return this._id; // unmanaged remains 0 (=ArrayBuffer)\n  }\n\n  /** Tests if this class is of a builtin array type (Array/TypedArray). */\n  get isBuiltinArray(): bool {\n    return this.prototype.isBuiltinArray;\n  }\n\n  /** Tests if this class is array-like. */\n  get isArrayLike(): bool {\n    if (this.isBuiltinArray) return true;\n    var lengthField = this.lookupInSelf(\"length\");\n    return lengthField !== null && (\n      lengthField.kind == ElementKind.FIELD ||\n      (\n        lengthField.kind == ElementKind.PROPERTY_PROTOTYPE &&\n        (<PropertyPrototype>lengthField).getterPrototype !== null // TODO: resolve & check type?\n      )\n    ) && (\n      this.lookupOverload(OperatorKind.INDEXED_GET) !== null ||\n      this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET) !== null\n    );\n  }\n\n  /** Constructs a new class. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: ClassPrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n    _isInterface: bool = false // FIXME\n  ) {\n    super(\n      _isInterface ? ElementKind.INTERFACE : ElementKind.CLASS,\n      nameInclTypeParameters,\n      mangleInternalName(nameInclTypeParameters, prototype.parent, prototype.is(CommonFlags.INSTANCE)),\n      prototype.program,\n      prototype.parent,\n      prototype.declaration\n    );\n    var program = this.program;\n    this.prototype = prototype;\n    this.flags = prototype.flags;\n    this.decoratorFlags = prototype.decoratorFlags;\n    this.typeArguments = typeArguments;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    type.classReference = this;\n    this.setType(type);\n\n    if (!this.hasDecorator(DecoratorFlags.UNMANAGED)) {\n      let id = program.nextClassId++;\n      this._id = id;\n      program.managedClasses.set(id, this);\n    }\n\n    // apply pre-checked instance-specific contextual type arguments\n    var typeParameters = prototype.typeParameterNodes;\n    if (typeArguments) {\n      let numTypeArguments = typeArguments.length;\n      if (!typeParameters || numTypeArguments != typeParameters.length) {\n        throw new Error(\"type argument count mismatch\");\n      }\n      if (numTypeArguments) {\n        let contextualTypeArguments = this.contextualTypeArguments;\n        if (!contextualTypeArguments) this.contextualTypeArguments = contextualTypeArguments = new Map();\n        for (let i = 0; i < numTypeArguments; ++i) {\n          contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\n        }\n      }\n    } else if (typeParameters !== null && typeParameters.length > 0) {\n      throw new Error(\"type argument count mismatch\");\n    }\n    registerConcreteElement(program, this);\n  }\n\n  /** Sets the base class. */\n  setBase(base: Class): void {\n    assert(!this.base);\n    this.base = base;\n    var extendees = base.extendees;\n    if (!extendees) base.extendees = extendees = new Set();\n    extendees.add(this);\n\n    // Inherit contextual type arguments from base class\n    var inheritedTypeArguments = base.contextualTypeArguments;\n    if (inheritedTypeArguments) {\n      let contextualTypeArguments = this.contextualTypeArguments;\n      // TODO: for (let [baseName, baseType] of inheritedTypeArguments) {\n      for (let _keys = Map_keys(inheritedTypeArguments), i = 0, k = _keys.length; i < k; ++i) {\n        let baseName = unchecked(_keys[i]);\n        let baseType = assert(inheritedTypeArguments.get(baseName));\n        if (!contextualTypeArguments) {\n          this.contextualTypeArguments = contextualTypeArguments = new Map();\n          contextualTypeArguments.set(baseName, baseType);\n        } else if (!contextualTypeArguments.has(baseName)) {\n          contextualTypeArguments.set(baseName, baseType);\n        }\n      }\n    }\n  }\n\n  /** Adds an interface. */\n  addInterface(iface: Interface): void {\n    var interfaces = this.interfaces;\n    if (!interfaces) this.interfaces = interfaces = new Set();\n    interfaces.add(iface);\n    var implementers = iface.implementers;\n    if (!implementers) iface.implementers = implementers = new Set();\n    implementers.add(this);\n  }\n\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\n  isAssignableTo(target: Class): bool {\n    var current: Class | null = this;\n    do {\n      if (current == target) return true;\n      if (target.kind == ElementKind.INTERFACE) {\n        let interfaces = current.interfaces;\n        if (interfaces) {\n          for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n            let iface = _values[i];\n            if (iface.isAssignableTo(target)) return true;\n          }\n        }\n      }\n      current = current.base;\n    } while (current);\n    return false;\n  }\n\n  /** Looks up the operator overload of the specified kind. */\n  lookupOverload(kind: OperatorKind, unchecked: bool = false): Function | null {\n    if (unchecked) {\n      switch (kind) {\n        case OperatorKind.INDEXED_GET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_GET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        case OperatorKind.INDEXED_SET: {\n          let uncheckedOverload = this.lookupOverload(OperatorKind.UNCHECKED_INDEXED_SET);\n          if (uncheckedOverload) return uncheckedOverload;\n          break;\n        }\n        default: assert(false);\n      }\n    }\n    var instance: Class | null = this;\n    do {\n      let overloads = instance.overloads;\n      if (overloads != null && overloads.has(kind)) {\n        return assert(overloads.get(kind));\n      }\n      instance = instance.base;\n    } while (instance);\n    return null;\n  }\n\n  /* @override */\n  lookup(name: string): Element | null {\n    return this.parent.lookup(name);\n  }\n\n  /** Calculates the memory offset of the specified field. */\n  offsetof(fieldName: string): u32 {\n    var members = assert(this.members);\n    assert(members.has(fieldName));\n    var field = <Element>members.get(fieldName);\n    assert(field.kind == ElementKind.FIELD);\n    return (<Field>field).memoryOffset;\n  }\n\n  /** Creates a buffer suitable to hold a runtime instance of this class. */\n  createBuffer(overhead: i32 = 0): Uint8Array {\n    var size = this.nextMemoryOffset + overhead;\n    var buffer = new Uint8Array(this.program.runtimeHeaderSize + size);\n    assert(!this.program.options.isWasm64); // TODO: WASM64, mmInfo is usize\n    // see: std/assembly/rt/common.ts\n    assert(size < (1 << 28));      // 1 bit BUFFERED + 3 bits color\n    var OBJECT = this.program.OBJECTInstance;\n    OBJECT.writeField(\"mmInfo\", size, buffer, 0);\n    OBJECT.writeField(\"gcInfo\", 1, buffer, 0); // RC = 1\n    OBJECT.writeField(\"gcInfo2\", 0, buffer, 0);\n    OBJECT.writeField(\"rtId\", this.id, buffer, 0);\n    OBJECT.writeField(\"rtSize\", size, buffer, 0);\n    return buffer;\n  }\n\n  /** Writes a field value to a buffer and returns the number of bytes written. */\n  writeField<T>(name: string, value: T, buffer: Uint8Array, baseOffset: i32 = this.program.runtimeHeaderSize): i32 {\n    var element = this.lookupInSelf(name);\n    if (element !== null && element.kind == ElementKind.FIELD) {\n      let fieldInstance = <Field>element;\n      let offset = baseOffset + fieldInstance.memoryOffset;\n      let typeKind = fieldInstance.type.kind;\n      switch (typeKind) {\n        case TypeKind.I8:\n        case TypeKind.U8: {\n          assert(!i64_is(value));\n          writeI8(i32(value), buffer, offset);\n          return 1;\n        }\n        case TypeKind.I16:\n        case TypeKind.U16: {\n          assert(!i64_is(value));\n          writeI16(i32(value), buffer, offset);\n          return 2;\n        }\n        case TypeKind.I32:\n        case TypeKind.U32: {\n          assert(!i64_is(value));\n          writeI32(i32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.ISIZE:\n        case TypeKind.USIZE: {\n          if (this.program.options.isWasm64) {\n            if (i64_is(value)) {\n              writeI64(value, buffer, offset);\n            } else {\n              writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.USIZE);\n            }\n            return 8;\n          } else {\n            if (i64_is(value)) {\n              writeI64AsI32(value, buffer, offset, typeKind == TypeKind.USIZE);\n            } else {\n              writeI32(i32(value), buffer, offset);\n            }\n            return 4;\n          }\n        }\n        case TypeKind.I64:\n        case TypeKind.U64: {\n          if (i64_is(value)) {\n            writeI64(value, buffer, offset);\n          } else {\n            writeI32AsI64(i32(value), buffer, offset, typeKind == TypeKind.U64);\n          }\n          return 8;\n        }\n        case TypeKind.F32: {\n          assert(!i64_is(value));\n          writeF32(f32(value), buffer, offset);\n          return 4;\n        }\n        case TypeKind.F64: {\n          assert(!i64_is(value));\n          writeF64(f64(value), buffer, offset);\n          return 8;\n        }\n      }\n    }\n    assert(false);\n    return 0;\n  }\n\n  /** Tests if this class extends the specified prototype. */\n  extends(prototype: ClassPrototype): bool {\n    return this.prototype.extends(prototype);\n  }\n\n  /** Gets the concrete type arguments to the specified extendend prototype. */\n  getTypeArgumentsTo(extendedPrototype: ClassPrototype): Type[] | null {\n    var current: Class | null = this;\n    do {\n      if (current.prototype === extendedPrototype) return current.typeArguments;\n      current = current.base;\n    } while (current);\n    return null;\n  }\n\n  /** Gets the value type of an array. Must be an array. */\n  getArrayValueType(): Type {\n    var current: Class = this;\n    var program = this.program;\n    var arrayPrototype = program.arrayPrototype;\n    if (this.extends(arrayPrototype)) {\n      return this.getTypeArgumentsTo(arrayPrototype)![0];\n    }\n    var staticArrayPrototype = program.staticArrayPrototype;\n    if (this.extends(staticArrayPrototype)) {\n      return this.getTypeArgumentsTo(staticArrayPrototype)![0];\n    }\n    var abvInstance = program.arrayBufferViewInstance;\n    while (current.base !== abvInstance) {\n      current = assert(current.base);\n    }\n    var prototype = current.prototype;\n    switch (prototype.name.charCodeAt(0)) {\n      case CharCode.F: {\n        if (prototype == program.float32ArrayPrototype) return Type.f32;\n        if (prototype == program.float64ArrayPrototype) return Type.f64;\n        break;\n      }\n      case CharCode.I: {\n        if (prototype == program.int8ArrayPrototype) return Type.i8;\n        if (prototype == program.int16ArrayPrototype) return Type.i16;\n        if (prototype == program.int32ArrayPrototype) return Type.i32;\n        if (prototype == program.int64ArrayPrototype) return Type.i64;\n        break;\n      }\n      case CharCode.U: {\n        if (prototype == program.uint8ArrayPrototype) return Type.u8;\n        if (prototype == program.uint8ClampedArrayPrototype) return Type.u8;\n        if (prototype == program.uint16ArrayPrototype) return Type.u16;\n        if (prototype == program.uint32ArrayPrototype) return Type.u32;\n        if (prototype == program.uint64ArrayPrototype) return Type.u64;\n        break;\n      }\n    }\n    assert(false);\n    return Type.void;\n  }\n\n  /** Tests if this class is inherently acyclic. */\n  get isAcyclic(): bool {\n    var acyclic = this._acyclic;\n    if (acyclic == AcyclicState.UNKNOWN) {\n      let hasCycle = this.cyclesTo(this);\n      if (hasCycle) this._acyclic = acyclic = AcyclicState.NOT_ACYCLIC;\n      else this._acyclic = acyclic = AcyclicState.ACYCLIC;\n    }\n    return acyclic == AcyclicState.ACYCLIC;\n  }\n\n  /** Tests if this class potentially forms a reference cycle to another one. */\n  private cyclesTo(other: Class, except: Set<Class> = new Set()): bool {\n    // TODO: The pure RC paper describes acyclic data structures as classes that may contain\n    //\n    // - scalars\n    // - references to classes that are both acyclic and final (here: Java); and\n    // - arrays (in our case: also sets, maps) of either of the above\n    //\n    // Our implementation, however, treats all objects that do not reference themselves directly\n    // or indirectly as acylic, allowing them to contain inner cycles of other non-acyclic objects.\n    // This contradicts the second assumption and must be revisited when actually implementing RC.\n\n    if (except.has(this)) return false;\n    except.add(this); // don't recurse indefinitely\n\n    // Find out if any field references 'other' directly or indirectly\n    var current: Class | null;\n    var instanceMembers = this.members;\n    if (instanceMembers) {\n      // TODO: for (let member of instanceMembers.values()) {\n      for (let _values = Map_values(instanceMembers), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        if (member.kind == ElementKind.FIELD) {\n          let fieldType = (<Field>member).type;\n          if (fieldType.isReference) {\n            if ((current = fieldType.getClass()) !== null && (\n              current === other ||\n              current.cyclesTo(other, except)\n            )) return true;\n          }\n        }\n      }\n    }\n\n    // Do the same for non-field data\n    var basePrototype: ClassPrototype | null;\n\n    // Array<T->other?>\n    if ((basePrototype = this.program.arrayPrototype) !== null && this.prototype.extends(basePrototype)) {\n      let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));\n      assert(typeArguments.length == 1);\n      if (\n        (current = typeArguments[0].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n\n    // Set<K->other?>\n    } else if ((basePrototype = this.program.setPrototype) !== null && this.prototype.extends(basePrototype)) {\n      let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));\n      assert(typeArguments.length == 1);\n      if (\n        (current = typeArguments[0].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n\n    // Map<K->other?,V->other?>\n    } else if ((basePrototype = this.program.mapPrototype) !== null && this.prototype.extends(basePrototype)) {\n      let typeArguments = assert(this.getTypeArgumentsTo(basePrototype));\n      assert(typeArguments.length == 2);\n      if (\n        (current = typeArguments[0].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n      if (\n        (current = typeArguments[1].classReference) !== null &&\n        (\n          current === other ||\n          current.cyclesTo(other, except)\n        )\n      ) return true;\n    }\n    return false;\n  }\n\n  /** Gets all extendees of this class (that do not have the specified instance member). */\n  getAllExtendees(exceptIfMember: string | null = null, out: Set<Class> = new Set()): Set<Class> {\n    var extendees = this.extendees;\n    if (extendees) {\n      for (let _values = Set_values(extendees), i = 0, k = _values.length; i < k; ++i) {\n        let extendee = _values[i];\n        if (exceptIfMember) {\n          let instanceMembers = extendee.prototype.instanceMembers;\n          if (instanceMembers !== null && instanceMembers.has(exceptIfMember)) continue;\n        }\n        out.add(extendee);\n        extendee.getAllExtendees(exceptIfMember, out);\n      }\n    }\n    return out;\n  }\n}\n\n/** A yet unresolved interface. */\nexport class InterfacePrototype extends ClassPrototype {\n\n  /** Constructs a new interface prototype. */\n  constructor(\n    name: string,\n    parent: Element,\n    declaration: InterfaceDeclaration,\n    decoratorFlags: DecoratorFlags\n  ) {\n    super(\n      name,\n      parent,\n      declaration,\n      decoratorFlags,\n      true\n    );\n  }\n}\n\n/** A resolved interface. */\nexport class Interface extends Class { // FIXME\n\n  /** Constructs a new interface. */\n  constructor(\n    /** Name incl. type parameters, i.e. `Foo<i32>`. */\n    nameInclTypeParameters: string,\n    /** The respective class prototype. */\n    prototype: InterfacePrototype,\n    /** Concrete type arguments, if any. */\n    typeArguments: Type[] | null = null,\n  ) {\n    super(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      true\n    );\n  }\n}\n\n/** Registers a concrete element with a program. */\nfunction registerConcreteElement(program: Program, element: Element): void {\n  assert(!program.instancesByName.has(element.internalName));\n  program.instancesByName.set(element.internalName, element);\n}\n\n/** Attempts to merge two elements. Returns the merged element on success. */\nfunction tryMerge(older: Element, newer: Element): DeclaredElement | null {\n  // NOTE: some of the following cases are not supported by TS, not sure why exactly.\n  // suggesting to just merge what seems to be possible for now and revisit later.\n  assert(older.program === newer.program);\n  if (newer.members) return null;\n  var merged: DeclaredElement | null = null;\n  switch (older.kind) {\n    case ElementKind.FUNCTION_PROTOTYPE: {\n      switch (newer.kind) {\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.CLASS_PROTOTYPE:\n    case ElementKind.ENUM: {\n      if (newer.kind == ElementKind.NAMESPACE) {\n        copyMembers(newer, older);\n        merged = <DeclaredElement>older;\n        break;\n      }\n      break;\n    }\n    case ElementKind.NAMESPACE: {\n      switch (newer.kind) {\n        case ElementKind.ENUM:\n        case ElementKind.CLASS_PROTOTYPE:      // TS2434\n        case ElementKind.FUNCTION_PROTOTYPE: { // TS2434\n          copyMembers(older, newer);\n          merged = <DeclaredElement>newer;\n          break;\n        }\n        case ElementKind.NAMESPACE: {\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n          break;\n        }\n        case ElementKind.TYPEDEFINITION: {\n          if (!older.shadowType) {\n            older.shadowType = <TypeDefinition>newer;\n            copyMembers(newer, older);\n            merged = <DeclaredElement>older;\n          }\n          break;\n        }\n      }\n      break;\n    }\n    case ElementKind.GLOBAL: {\n      if (newer.kind == ElementKind.TYPEDEFINITION) {\n        if (!older.shadowType) {\n          older.shadowType = <TypeDefinition>newer;\n          copyMembers(newer, older);\n          merged = <DeclaredElement>older;\n        }\n      }\n      break;\n    }\n    case ElementKind.TYPEDEFINITION: {\n      switch (newer.kind) {\n        case ElementKind.GLOBAL:\n        case ElementKind.FUNCTION_PROTOTYPE:\n        case ElementKind.NAMESPACE: {\n          if (!newer.shadowType) {\n            newer.shadowType = <TypeDefinition>older;\n            copyMembers(older, newer);\n            merged = <DeclaredElement>newer;\n          }\n          break;\n        }\n      }\n      break;\n    }\n  }\n  if (merged) {\n    let olderIsExport = older.is(CommonFlags.EXPORT) || older.hasDecorator(DecoratorFlags.GLOBAL);\n    let newerIsExport = newer.is(CommonFlags.EXPORT) || newer.hasDecorator(DecoratorFlags.GLOBAL);\n    if (olderIsExport != newerIsExport) {\n      older.program.error(\n        DiagnosticCode.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local,\n        merged.identifierNode.range, merged.identifierNode.text\n      );\n    }\n  }\n  return merged;\n}\n\n/** Copies the members of `src` to `dest`. */\nfunction copyMembers(src: Element, dest: Element): void {\n  var srcMembers = src.members;\n  if (srcMembers) {\n    let destMembers = dest.members;\n    if (!destMembers) dest.members = destMembers = new Map();\n    // TODO: for (let [memberName, member] of srcMembers) {\n    for (let _keys = Map_keys(srcMembers), i = 0, k = _keys.length; i < k; ++i) {\n      let memberName = unchecked(_keys[i]);\n      let member = assert(srcMembers.get(memberName));\n      destMembers.set(memberName, member);\n    }\n  }\n}\n\n/** Mangles the internal name of an element with the specified name that is a child of the given parent. */\nexport function mangleInternalName(name: string, parent: Element, isInstance: bool, asGlobal: bool = false): string {\n  switch (parent.kind) {\n    case ElementKind.FILE: {\n      if (asGlobal) return name;\n      return parent.internalName + PATH_DELIMITER + name;\n    }\n    case ElementKind.FUNCTION: {\n      if (asGlobal) return name;\n      assert(!isInstance);\n      return parent.internalName + INNER_DELIMITER + name;\n    }\n    case ElementKind.PROPERTY_PROTOTYPE: // properties are just containers\n    case ElementKind.PROPERTY: {         //\n      parent = parent.parent;\n      // fall-through\n    }\n    default: {\n      return mangleInternalName(parent.name, parent.parent, parent.is(CommonFlags.INSTANCE), asGlobal)\n           + (isInstance ? INSTANCE_DELIMITER : STATIC_DELIMITER) + name;\n    }\n  }\n}\n\n// Cached default parameter names used where names are unknown.\nvar cachedDefaultParameterNames: string[] = [];\n\n/** Gets the cached default parameter name for the specified index. */\nexport function getDefaultParameterName(index: i32): string {\n  for (let i = cachedDefaultParameterNames.length; i <= index; ++i) {\n    cachedDefaultParameterNames.push(\"$\" + i.toString());\n  }\n  return cachedDefaultParameterNames[index];\n}\n","/**\n * @fileoverview Resolve infrastructure to obtain types and elements.\n *\n * Similar to the compiler making instructions of expressions, the resolver\n * obtains metadata of expressions. As such, for each `compileX` method in\n * the compiler there is one `lookupX` method in the resolver returning the\n * respective IR element, respectively one `resolveX` method returning the\n * respective type of an expression. It is also able to make new elements,\n * like instances of classes given its concrete type arguments.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticEmitter,\n  DiagnosticCode\n} from \"./diagnostics\";\n\nimport {\n  Program,\n  ElementKind,\n  OperatorKind,\n  Element,\n  Class,\n  ClassPrototype,\n  Interface,\n  Function,\n  FunctionPrototype,\n  VariableLikeElement,\n  Property,\n  PropertyPrototype,\n  Field,\n  FieldPrototype,\n  Global,\n  TypeDefinition,\n  TypedElement,\n  IndexSignature,\n  isTypedElement,\n  InterfacePrototype,\n  DeclaredElement\n} from \"./program\";\n\nimport {\n  Flow\n} from \"./flow\";\n\nimport {\n  Range\n} from \"./tokenizer\";\n\nimport {\n  FunctionTypeNode,\n  ParameterKind,\n  TypeNode,\n  NodeKind,\n  NamedTypeNode,\n  TypeName,\n  TypeParameterNode,\n  Node,\n  IdentifierExpression,\n  CallExpression,\n  ElementAccessExpression,\n  PropertyAccessExpression,\n  LiteralExpression,\n  LiteralKind,\n  ParenthesizedExpression,\n  AssertionExpression,\n  Expression,\n  IntegerLiteralExpression,\n  UnaryPrefixExpression,\n  UnaryPostfixExpression,\n  AssertionKind,\n  BinaryExpression,\n  ThisExpression,\n  SuperExpression,\n  CommaExpression,\n  InstanceOfExpression,\n  TernaryExpression,\n  isTypeOmitted,\n  FunctionExpression,\n  NewExpression,\n  ArrayLiteralExpression\n} from \"./ast\";\n\nimport {\n  Type,\n  Signature,\n  typesToString,\n  TypeKind\n} from \"./types\";\n\nimport {\n  CommonFlags,\n  CommonNames\n} from \"./common\";\n\nimport {\n  uniqueMap,\n  isPowerOf2\n} from \"./util\";\n\nimport {\n  Token,\n  operatorTokenToString\n} from \"./tokenizer\";\n\nimport {\n  BuiltinNames\n} from \"./builtins\";\n\n/** Indicates whether errors are reported or not. */\nexport enum ReportMode {\n  /** Report errors. */\n  REPORT,\n  /** Swallow errors. */\n  SWALLOW\n}\n\n/** Provides tools to resolve types and expressions. */\nexport class Resolver extends DiagnosticEmitter {\n\n  /** The program this resolver belongs to. */\n  program: Program;\n\n  /** Target expression of the previously resolved property or element access. */\n  currentThisExpression: Expression | null = null;\n  /** Element expression of the previously resolved element access. */\n  currentElementExpression : Expression | null = null;\n\n  /** Constructs the resolver for the specified program. */\n  constructor(\n    /** The program to construct a resolver for. */\n    program: Program\n  ) {\n    super(program.diagnostics);\n    this.program = program;\n  }\n\n  // ====================================================== Types ======================================================\n\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\n  resolveType(\n    /** The type to resolve. */\n    node: TypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.NAMEDTYPE: {\n        return this.resolveNamedType(\n          <NamedTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      case NodeKind.FUNCTIONTYPE: {\n        return this.resolveFunctionType(\n          <FunctionTypeNode>node,\n          ctxElement,\n          ctxTypes,\n          reportMode\n        );\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Resolves a {@link NamedTypeNode} to a concrete {@link Type}. */\n  private resolveNamedType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var nameNode = node.name;\n    var typeArgumentNodes = node.typeArguments;\n    var isSimpleType = !nameNode.next;\n\n    // Look up in contextual types if a simple type\n    if (isSimpleType) {\n      let simpleName = nameNode.identifier.text;\n      if (ctxTypes !== null && ctxTypes.has(simpleName)) {\n        let type = assert(ctxTypes.get(simpleName));\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, type.toString()\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, type.toString()\n            );\n          }\n        }\n        return type;\n      }\n    }\n\n    // Look up in context\n    var element = this.resolveTypeName(nameNode, ctxElement, reportMode);\n    if (!element) return null;\n\n    // Use shadow type if present (i.e. namespace sharing a type)\n    var shadowType = element.shadowType;\n    if (shadowType) {\n      element = shadowType;\n\n    } else {\n\n      // Handle enums (become i32)\n      if (element.kind == ElementKind.ENUM) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        if (node.isNullable) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              node.range, element.name + \"/i32\"\n            );\n          }\n        }\n        return Type.i32;\n      }\n\n      // Handle classes and interfaces\n      if (\n        element.kind == ElementKind.CLASS_PROTOTYPE ||\n        element.kind == ElementKind.INTERFACE_PROTOTYPE\n      ) {\n        let instance = this.resolveClassInclTypeArguments(\n          <ClassPrototype>element,\n          typeArgumentNodes,\n          ctxElement,\n          uniqueMap<string,Type>(ctxTypes), // don't inherit\n          node,\n          reportMode\n        );\n        if (!instance) return null;\n        return node.isNullable ? instance.type.asNullable() : instance.type;\n      }\n    }\n\n    // Handle type definitions\n    if (element.kind == ElementKind.TYPEDEFINITION) {\n      let typeDefinition = <TypeDefinition>element;\n\n      // Shortcut already resolved (mostly builtins)\n      if (element.is(CommonFlags.RESOLVED)) {\n        if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_is_not_generic,\n              node.range, element.internalName\n            );\n          }\n        }\n        let type = typeDefinition.type;\n        if (node.isNullable) {\n          if (type.isInternalReference) return type.asNullable();\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Type_0_cannot_be_nullable,\n              nameNode.range, nameNode.identifier.text\n            );\n          }\n        }\n        return type;\n      }\n\n      // Handle special built-in types\n      if (isSimpleType) {\n        let text = nameNode.identifier.text;\n        if (text == CommonNames.native) return this.resolveBuiltinNativeType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.indexof) return this.resolveBuiltinIndexofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.valueof) return this.resolveBuiltinValueofType(node, ctxElement, ctxTypes, reportMode);\n        if (text == CommonNames.returnof) return this.resolveBuiltinReturnTypeType(node, ctxElement, ctxTypes, reportMode);\n      }\n\n      // Resolve normally\n      let typeParameterNodes = typeDefinition.typeParameterNodes;\n      let typeArguments: Type[] | null = null;\n      if (typeParameterNodes) {\n        typeArguments = this.resolveTypeArguments(\n          typeParameterNodes,\n          typeArgumentNodes,\n          ctxElement,\n          ctxTypes = uniqueMap(ctxTypes), // inherit\n          node,\n          reportMode\n        );\n        if (!typeArguments) return null;\n      } else if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        this.error(\n          DiagnosticCode.Type_0_is_not_generic,\n          node.range, nameNode.identifier.text\n        );\n      }\n      let type = this.resolveType(\n        typeDefinition.typeNode,\n        element,\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      if (node.isNullable) {\n        if (type.isInternalReference) return type.asNullable();\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_cannot_be_nullable,\n            nameNode.range, nameNode.identifier.text\n          );\n        }\n      }\n      return type;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        nameNode.range, nameNode.identifier.text\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a {@link FunctionTypeNode} to a concrete {@link Type}. */\n  private resolveFunctionType(\n    /** The type to resolve. */\n    node: FunctionTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var explicitThisType = node.explicitThisType;\n    var thisType: Type | null = null;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n    }\n    var parameterNodes = node.parameters;\n    var numParameters = parameterNodes.length;\n    var parameterTypes = new Array<Type>(numParameters);\n    var requiredParameters = 0;\n    var hasRest = false;\n    for (let i = 0; i < numParameters; ++i) {\n      let parameterNode = parameterNodes[i];\n      switch (parameterNode.parameterKind) {\n        case ParameterKind.DEFAULT: {\n          requiredParameters = i + 1;\n          break;\n        }\n        case ParameterKind.REST: {\n          assert(i == numParameters);\n          hasRest = true;\n          break;\n        }\n      }\n      let parameterTypeNode = parameterNode.type;\n      if (isTypeOmitted(parameterTypeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            parameterTypeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        parameterTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      parameterTypes[i] = parameterType;\n    }\n    var returnTypeNode = node.returnType;\n    var returnType: Type | null;\n    if (isTypeOmitted(returnTypeNode)) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_expected,\n          returnTypeNode.range\n        );\n      }\n      returnType = Type.void;\n    } else {\n      returnType = this.resolveType(\n        returnTypeNode,\n        ctxElement,\n        ctxTypes,\n        reportMode\n      );\n      if (!returnType) return null;\n    }\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n    signature.hasRest = hasRest;\n    return node.isNullable ? signature.type.asNullable() : signature.type;\n  }\n\n  private resolveBuiltinNativeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        let numTypeArguments = 0;\n        if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    switch (typeArgument.kind) {\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.ISIZE: if (!this.program.options.isWasm64) return Type.i32;\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return Type.u32;\n      case TypeKind.USIZE: if (!this.program.options.isWasm64) return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.F32: return Type.f32;\n      case TypeKind.F64: return Type.f64;\n      case TypeKind.V128: return Type.v128;\n      case TypeKind.VOID: return Type.void;\n      default: assert(false);\n    }\n    return null;\n  }\n\n  private resolveBuiltinIndexofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        let numTypeArguments = 0;\n        if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.classReference;\n    if (!classReference) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Index_signature_is_missing_in_type_0,\n          typeArgumentNodes[0].range, typeArgument.toString()\n        );\n      }\n      return null;\n    }\n    var overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n    if (overload) {\n      if (overload.is(CommonFlags.STATIC)) {\n        assert(overload.signature.parameterTypes.length == 2);\n        return overload.signature.parameterTypes[1];\n      } else {\n        assert(overload.signature.parameterTypes.length == 1);\n        return overload.signature.parameterTypes[0];\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNodes[0].range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinValueofType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      let numTypeArguments = 0;\n      if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var classReference = typeArgument.getClassOrWrapper(this.program);\n    if (classReference) {\n      let overload = classReference.lookupOverload(OperatorKind.INDEXED_GET);\n      if (overload) return overload.signature.returnType;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        typeArgumentNodes[0].range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  private resolveBuiltinReturnTypeType(\n    /** The type to resolve. */\n    node: NamedTypeNode,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> | null = null,\n    /** How to proceed with eventualy diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var typeArgumentNodes = node.typeArguments;\n    if (!typeArgumentNodes || typeArgumentNodes.length != 1) {\n      if (reportMode == ReportMode.REPORT) {\n        let numTypeArguments = 0;\n        if (typeArgumentNodes) numTypeArguments = typeArgumentNodes.length;\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          node.range, \"1\", numTypeArguments.toString()\n        );\n      }\n      return null;\n    }\n    var typeArgument = this.resolveType(typeArgumentNodes[0], ctxElement, ctxTypes, reportMode);\n    if (!typeArgument) return null;\n    var signatureReference = typeArgument.getSignature();\n    if (signatureReference) return signatureReference.returnType;\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_has_no_call_signatures,\n        typeArgumentNodes[0].range, typeArgument.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a type name to the program element it refers to. */\n  resolveTypeName(\n    /** The type name to resolve. */\n    node: TypeName,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = ctxElement.lookup(node.identifier.text);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Cannot_find_name_0,\n          node.range, node.identifier.text\n        );\n      }\n      return null;\n    }\n    var prev = node;\n    var next = node.next;\n    while (next) {\n      if (!(element = element.lookupInSelf(next.identifier.text))) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\n            next.range, next.identifier.text, prev.identifier.text\n          );\n        }\n        return null;\n      }\n      prev = next;\n      next = next.next;\n    }\n    return element;\n  }\n\n  /** Resolves an array of type arguments to concrete types. */\n  resolveTypeArguments(\n    /** Type parameter nodes present. */\n    typeParameters: TypeParameterNode[],\n    /** Type argument nodes provided. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** Alternative report node in case of empty type arguments. */\n    alternativeReportNode: Node | null = null,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type[] | null {\n    var minParameterCount = 0;\n    var maxParameterCount = 0;\n    for (let i = 0, k = typeParameters.length; i < k; ++i) {\n      if (!typeParameters[i].defaultType) ++minParameterCount;\n      ++maxParameterCount;\n    }\n    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\n    if (argumentCount < minParameterCount || argumentCount > maxParameterCount) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\n          argumentCount\n            ? Range.join(\n                typeArgumentNodes![0].range,\n                typeArgumentNodes![argumentCount - 1].range\n              )\n            : alternativeReportNode!.range,\n          (argumentCount < minParameterCount ? minParameterCount : maxParameterCount).toString(),\n          argumentCount.toString()\n        );\n      }\n      return null;\n    }\n    var typeArguments = new Array<Type>(maxParameterCount);\n    for (let i = 0; i < maxParameterCount; ++i) {\n      let type = i < argumentCount\n        ? this.resolveType( // reports\n            typeArgumentNodes![i],\n            ctxElement,\n            ctxTypes,\n            reportMode\n          )\n        : this.resolveType( // reports\n            assert(typeParameters[i].defaultType),\n            ctxElement,\n            ctxTypes,\n            reportMode\n          );\n      if (!type) return null;\n      // TODO: check extendsType\n      ctxTypes.set(typeParameters[i].name.text, type);\n      typeArguments[i] = type;\n    }\n    return typeArguments;\n  }\n\n  /** Resolves respectively infers the concrete instance of a function by call context. */\n  maybeInferCall(\n    node: CallExpression,\n    prototype: FunctionPrototype,\n    ctxFlow: Flow,\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var typeArguments = node.typeArguments;\n\n    // resolve generic call if type arguments have been provided\n    if (typeArguments) {\n      if (!prototype.is(CommonFlags.GENERIC)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            node.expression.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n      return this.resolveFunctionInclTypeArguments(\n        prototype,\n        typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap(ctxFlow.contextualTypeArguments), // don't inherit\n        node,\n        reportMode\n      );\n    }\n\n    // infer generic call if type arguments have been omitted\n    if (prototype.is(CommonFlags.GENERIC)) {\n      let contextualTypeArguments = uniqueMap<string,Type>(ctxFlow.contextualTypeArguments);\n\n      // fill up contextual types with auto for each generic component\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let typeParameterNames = new Set<string>();\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        contextualTypeArguments.set(name, Type.auto);\n        typeParameterNames.add(name);\n      }\n\n      let parameterNodes = prototype.functionTypeNode.parameters;\n      let numParameters = parameterNodes.length;\n      let argumentNodes = node.args;\n      let numArguments = argumentNodes.length;\n\n      // infer types with generic components while updating contextual types\n      for (let i = 0; i < numParameters; ++i) {\n        let argumentExpression = i < numArguments ? argumentNodes[i] : parameterNodes[i].initializer;\n        if (!argumentExpression) { // missing initializer -> too few arguments\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expected_0_arguments_but_got_1,\n              node.range, numParameters.toString(), numArguments.toString()\n            );\n          }\n          return null;\n        }\n        let typeNode = parameterNodes[i].type;\n        if (typeNode.hasGenericComponent(typeParameterNodes)) {\n          let type = this.resolveExpression(argumentExpression, ctxFlow, Type.auto, ReportMode.SWALLOW);\n          if (type) this.propagateInferredGenericTypes(typeNode, type, ctxFlow, contextualTypeArguments, typeParameterNames);\n        }\n      }\n\n      // apply concrete types to the generic function signature\n      let resolvedTypeArguments = new Array<Type>(numTypeParameters);\n      for (let i = 0; i < numTypeParameters; ++i) {\n        let name = typeParameterNodes[i].name.text;\n        if (contextualTypeArguments.has(name)) {\n          let inferredType = assert(contextualTypeArguments.get(name));\n          if (inferredType != Type.auto) {\n            resolvedTypeArguments[i] = inferredType;\n            continue;\n          }\n        }\n        // unused template, e.g. `function test<T>(): void {...}` called as `test()`\n        // invalid because the type is effectively unknown inside the function body\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_argument_expected,\n            node.expression.range.atEnd\n          );\n        }\n        return null;\n      }\n      return this.resolveFunction(\n        prototype,\n        resolvedTypeArguments,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        reportMode\n      );\n    }\n\n    // otherwise resolve the non-generic call as usual\n    return this.resolveFunction(prototype, null, uniqueMap<string,Type>(), reportMode);\n  }\n\n  /** Updates contextual types with a possibly encapsulated inferred type. */\n  private propagateInferredGenericTypes(\n    /** The inferred type node. */\n    node: TypeNode,\n    /** The inferred type. */\n    type: Type,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual types, i.e. `T`, with unknown types initialized to `auto`. */\n    ctxTypes: Map<string,Type>,\n    /** The names of the type parameters being inferred. */\n    typeParameterNames: Set<string>\n  ): void {\n    if (node.kind == NodeKind.NAMEDTYPE) {\n      let namedTypeNode = <NamedTypeNode>node;\n      let typeArgumentNodes = namedTypeNode.typeArguments;\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) { // foo<T>(bar: Array<T>)\n        let classReference = type.classReference;\n        if (classReference) {\n          let classPrototype = this.resolveTypeName(namedTypeNode.name, ctxFlow.actualFunction);\n          if (!classPrototype || classPrototype.kind != ElementKind.CLASS_PROTOTYPE) return;\n          if (classReference.prototype == <ClassPrototype>classPrototype) {\n            let typeArguments = classReference.typeArguments;\n            if (typeArguments !== null && typeArguments.length == typeArgumentNodes.length) {\n              for (let i = 0, k = typeArguments.length; i < k; ++i) {\n                this.propagateInferredGenericTypes(typeArgumentNodes[i], typeArguments[i], ctxFlow, ctxTypes, typeParameterNames);\n              }\n              return;\n            }\n          }\n        }\n      } else { // foo<T>(bar: T)\n        let name = namedTypeNode.name.identifier.text;\n        if (ctxTypes.has(name)) {\n          let currentType = assert(ctxTypes.get(name));\n          if (currentType == Type.auto || (typeParameterNames.has(name) && currentType.isAssignableTo(type))) {\n            ctxTypes.set(name, type);\n          }\n        }\n      }\n    } else if (node.kind == NodeKind.FUNCTIONTYPE) { // foo<T>(bar: (baz: T) => i32))\n      let functionTypeNode = <FunctionTypeNode>node;\n      let parameterNodes = functionTypeNode.parameters;\n      if (parameterNodes !== null && parameterNodes.length > 0) {\n        let signatureReference = type.signatureReference;\n        if (signatureReference) {\n          let parameterTypes = signatureReference.parameterTypes;\n          let thisType = signatureReference.thisType;\n          if (parameterTypes.length == parameterNodes.length && !thisType == !functionTypeNode.explicitThisType) {\n            for (let i = 0, k = parameterTypes.length; i < k; ++i) {\n              this.propagateInferredGenericTypes(parameterNodes[i].type, parameterTypes[i], ctxFlow, ctxTypes, typeParameterNames);\n            }\n            this.propagateInferredGenericTypes(functionTypeNode.returnType, signatureReference.returnType, ctxFlow, ctxTypes, typeParameterNames);\n            if (thisType) this.propagateInferredGenericTypes(functionTypeNode.explicitThisType!, thisType, ctxFlow, ctxTypes, typeParameterNames);\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  /** Gets the concrete type of an element. */\n  getTypeOfElement(element: Element): Type | null {\n    var kind = element.kind;\n    if (kind == ElementKind.GLOBAL) {\n      if (!this.ensureResolvedLazyGlobal(<Global>element, ReportMode.SWALLOW)) return null;\n    }\n    if (isTypedElement(kind)) {\n      let type = (<TypedElement>element).type;\n      assert(type != Type.void);\n      let classReference = type.getClassOrWrapper(this.program);\n      if (classReference) {\n        let wrappedType = classReference.wrappedType;\n        if (wrappedType) type = wrappedType;\n      }\n      return type;\n    }\n    return null;\n  }\n\n  /** Gets the element of a concrete type. */\n  getElementOfType(type: Type): Element | null {\n    let classReference = type.getClassOrWrapper(this.program);\n    if (classReference) return classReference;\n    return null;\n  }\n\n  // =================================================== Expressions ===================================================\n\n  /** Looks up the program element the specified expression refers to. */\n  lookupExpression(\n    /** The expression to look up. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.lookupAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.lookupBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.lookupCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.lookupCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.lookupElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.lookupFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.lookupIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.lookupThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.lookupSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.lookupInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.lookupLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.lookupNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.lookupPropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.lookupTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.lookupUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.lookupUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an expression to its static type. */\n  resolveExpression(\n    /** The expression to resolve. */\n    node: Expression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    while (node.kind == NodeKind.PARENTHESIZED) { // skip\n      node = (<ParenthesizedExpression>node).expression;\n    }\n    switch (node.kind) {\n      case NodeKind.ASSERTION: {\n        return this.resolveAssertionExpression(\n          <AssertionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.BINARY: {\n        return this.resolveBinaryExpression(\n          <BinaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.CALL: {\n        return this.resolveCallExpression(\n          <CallExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.COMMA: {\n        return this.resolveCommaExpression(\n          <CommaExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.ELEMENTACCESS: {\n        return this.resolveElementAccessExpression(\n          <ElementAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.FUNCTION: {\n        return this.resolveFunctionExpression(\n          <FunctionExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.IDENTIFIER:\n      case NodeKind.FALSE:\n      case NodeKind.NULL:\n      case NodeKind.TRUE: {\n        return this.resolveIdentifierExpression(\n          <IdentifierExpression>node,\n          ctxFlow, ctxType, ctxFlow.actualFunction, reportMode\n        );\n      }\n      case NodeKind.THIS: {\n        return this.resolveThisExpression(\n          <ThisExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.SUPER: {\n        return this.resolveSuperExpression(\n          <SuperExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.INSTANCEOF: {\n        return this.resolveInstanceOfExpression(\n          <InstanceOfExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.LITERAL: {\n        return this.resolveLiteralExpression(\n          <LiteralExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.NEW: {\n        return this.resolveNewExpression(\n          <NewExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.PROPERTYACCESS: {\n        return this.resolvePropertyAccessExpression(\n          <PropertyAccessExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.TERNARY: {\n        return this.resolveTernaryExpression(\n          <TernaryExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPOSTFIX: {\n        return this.resolveUnaryPostfixExpression(\n          <UnaryPostfixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n      case NodeKind.UNARYPREFIX: {\n        return this.resolveUnaryPrefixExpression(\n          <UnaryPrefixExpression>node,\n          ctxFlow, ctxType, reportMode\n        );\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified identifier expression refers to. */\n  lookupIdentifierExpression(\n    /** The expression to look up. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE:\n      case NodeKind.NULL: {\n        let type = this.resolveIdentifierExpression(node, ctxFlow, Type.auto, ctxElement, reportMode);\n        return type ? this.getElementOfType(type) : null;\n      }\n    }\n    var name = node.text;\n    var element: Element | null;\n    if (element = ctxFlow.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = ctxElement.lookup(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (element = this.program.lookupGlobal(name)) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return element;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_find_name_0,\n        node.range, name\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an identifier to its static type. */\n  private resolveIdentifierExpression(\n    /** The expression to resolve. */\n    node: IdentifierExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** Element to search. */\n    ctxElement: Element = ctxFlow.actualFunction, // differs for enums and namespaces\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.kind) {\n      case NodeKind.TRUE:\n      case NodeKind.FALSE: return Type.bool;\n      case NodeKind.NULL: {\n        let classReference = ctxType.getClass();\n        if (classReference) {\n          return classReference.type.asNullable();\n        } else {\n          let signatureReference = ctxType.getSignature();\n          if (signatureReference) {\n            return signatureReference.type.asNullable();\n          } else if (ctxType.isExternalReference) {\n            return ctxType; // TODO: nullable?\n          }\n        }\n        return this.program.options.usizeType;\n      }\n    }\n    var element = this.lookupIdentifierExpression(node, ctxFlow, ctxElement, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.FUNCTION_PROTOTYPE) {\n      let instance = this.resolveFunction(<FunctionPrototype>element, null, uniqueMap<string,Type>(), reportMode);\n      if (!instance) return null;\n      element = instance;\n    }\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Resolves a lazily compiled global, i.e. a static class field or annotated `@lazy`. */\n  private ensureResolvedLazyGlobal(global: Global, reportMode: ReportMode = ReportMode.REPORT): bool {\n    if (global.is(CommonFlags.RESOLVED)) return true;\n    var type: Type | null;\n    var typeNode = global.typeNode;\n    if (typeNode) {\n      type = this.resolveType(typeNode, global.parent, null, reportMode);\n    } else {\n      type = this.resolveExpression(assert(global.initializerNode), global.file.startFunction.flow, Type.auto, reportMode);\n    }\n    if (!type) return false;\n    global.setType(type); // also sets resolved\n    return true;\n  }\n\n  /** Looks up the program element the specified property access expression refers to. */\n  private lookupPropertyAccessExpression(\n    /** The expression to look up. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetNode = node.expression;\n    var target = this.lookupExpression(targetNode, ctxFlow, ctxType, reportMode); // reports\n    if (!target) return null;\n    var propertyName = node.property.text;\n\n    // Resolve variable-likes to their class type first\n    switch (target.kind) {\n      case ElementKind.GLOBAL: if (!this.ensureResolvedLazyGlobal(<Global>target, reportMode)) return null;\n      case ElementKind.ENUMVALUE:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: { // someVar.prop\n        let variableLikeElement = <VariableLikeElement>target;\n        let type = variableLikeElement.type;\n        assert(type != Type.void);\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, variableLikeElement.type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.PROPERTY_PROTOTYPE: { // SomeClass.prop\n        let propertyInstance = this.resolveProperty(<PropertyPrototype>target, reportMode);\n        if (!propertyInstance) return null;\n        target = propertyInstance;\n        // fall-through\n      }\n      case ElementKind.PROPERTY: { // someInstance.prop\n        let propertyInstance = <Property>target;\n        let getterInstance = assert(propertyInstance.getterInstance); // must have a getter\n        let type = getterInstance.signature.returnType;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, type.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.INDEXSIGNATURE: { // someInstance[x].prop\n        let indexSignature = <IndexSignature>target;\n        let parent = indexSignature.parent;\n        assert(parent.kind == ElementKind.CLASS);\n        let classInstance = <Class>parent;\n        let elementExpression = assert(this.currentElementExpression);\n        let indexedGet = classInstance.lookupOverload(OperatorKind.INDEXED_GET);\n        if (!indexedGet) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Index_signature_is_missing_in_type_0,\n              elementExpression.range, parent.internalName\n            );\n          }\n          return null;\n        }\n        let returnType = indexedGet.signature.returnType;\n        let classReference = returnType.getClassOrWrapper(this.program);\n        if (!classReference) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Property_0_does_not_exist_on_type_1,\n              node.property.range, propertyName, returnType.toString()\n            );\n          }\n          return null;\n        }\n        target = classReference;\n        break;\n      }\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        // Function with shadow type, i.e. function Symbol() + type Symbol = _Symbol\n        let shadowType = target.shadowType;\n        if (shadowType) {\n          if (!shadowType.is(CommonFlags.RESOLVED)) {\n            let resolvedType = this.resolveType(shadowType.typeNode, shadowType.parent, null, reportMode);\n            if (resolvedType) shadowType.setType(resolvedType);\n          }\n          let classReference = shadowType.type.classReference;\n          if (classReference) target = classReference.prototype;\n          break;\n        } else if (!target.is(CommonFlags.GENERIC)) {\n          // Inherit from 'Function' if not overridden, i.e. fn.call\n          let members = target.members;\n          if (!members || !members.has(propertyName)) {\n            let functionInstance = this.resolveFunction(<FunctionPrototype>target, null, uniqueMap<string,Type>(), ReportMode.SWALLOW);\n            if (functionInstance) {\n              let wrapper = functionInstance.type.getClassOrWrapper(this.program);\n              if (wrapper) target = wrapper;\n            }\n          }\n        }\n        break;\n      }\n    }\n\n    // Look up the member within\n    switch (target.kind) {\n      case ElementKind.CLASS_PROTOTYPE:\n      case ElementKind.INTERFACE_PROTOTYPE:\n      case ElementKind.CLASS:\n      case ElementKind.INTERFACE: {\n        do {\n          let members = target.members;\n          if (members !== null && members.has(propertyName)) {\n            let member = assert(members.get(propertyName));\n            if (member.kind == ElementKind.PROPERTY_PROTOTYPE) {\n              let propertyInstance = this.resolveProperty(<PropertyPrototype>member, reportMode);\n              if (!propertyInstance) return null;\n              member = propertyInstance;\n              if (propertyInstance.is(CommonFlags.STATIC)) {\n                this.currentThisExpression = null;\n              } else {\n                this.currentThisExpression = targetNode;\n              }\n            } else {\n              this.currentThisExpression = targetNode;\n            }\n            this.currentElementExpression = null;\n            return member; // instance FIELD, static GLOBAL, FUNCTION_PROTOTYPE, PROPERTY...\n          }\n          // traverse inherited static members on the base prototype if target is a class prototype\n          if (\n            target.kind == ElementKind.CLASS_PROTOTYPE ||\n            target.kind == ElementKind.INTERFACE_PROTOTYPE\n          ) {\n            let classPrototype = <ClassPrototype>target;\n            let basePrototype = classPrototype.basePrototype;\n            if (basePrototype) {\n              target = basePrototype;\n            } else {\n              break;\n            }\n          // traverse inherited instance members on the base class if target is a class instance\n          } else if (\n            target.kind == ElementKind.CLASS ||\n            target.kind == ElementKind.INTERFACE\n          ) {\n            let classInstance = <Class>target;\n            let baseInstance = classInstance.base;\n            if (baseInstance) {\n              target = baseInstance;\n            } else {\n              break;\n            }\n          } else {\n            break;\n          }\n        } while (true);\n        break;\n      }\n      default: { // enums or other namespace-like elements\n        let members = target.members;\n        if (members !== null && members.has(propertyName)) {\n          this.currentThisExpression = targetNode;\n          this.currentElementExpression = null;\n          return assert(members.get(propertyName)); // static ENUMVALUE, static GLOBAL, static FUNCTION_PROTOTYPE...\n        }\n        break;\n      }\n    }\n\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Property_0_does_not_exist_on_type_1,\n        node.property.range, propertyName, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a property access expression to its static type. */\n  private resolvePropertyAccessExpression(\n    /** The expression to resolve. */\n    node: PropertyAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupPropertyAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified element access expression refers to. */\n  private lookupElementAccessExpression(\n    /** The expression to look up. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var targetExpression = node.expression;\n    var targetType = this.resolveExpression(targetExpression, ctxFlow, ctxType, reportMode);\n    if (!targetType) return null;\n    let classReference = targetType.getClassOrWrapper(this.program);\n    if (classReference) {\n      do {\n        let indexSignature = classReference.indexSignature;\n        if (indexSignature) {\n          this.currentThisExpression = targetExpression;\n          this.currentElementExpression = node.elementExpression;\n          return indexSignature;\n        }\n        classReference = classReference.base;\n      } while(classReference);\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Index_signature_is_missing_in_type_0,\n        targetExpression.range, targetType.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves an element access expression to its static type. */\n  private resolveElementAccessExpression(\n    /** The expression to resolve. */\n    node: ElementAccessExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupElementAccessExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Determines the final type of an integer literal given the specified contextual type. */\n  determineIntegerLiteralType(\n    /** Integer literal value. */\n    intValue: i64,\n    /** Contextual type. */\n    ctxType: Type\n  ): Type {\n    if (ctxType.isValue) {\n      // compile to contextual type if matching\n      switch (ctxType.kind) {\n        case TypeKind.I8: {\n          if (i64_is_i8(intValue)) return Type.i8;\n          break;\n        }\n        case TypeKind.U8: {\n          if (i64_is_u8(intValue)) return Type.u8;\n          break;\n        }\n        case TypeKind.I16: {\n          if (i64_is_i16(intValue)) return Type.i16;\n          break;\n        }\n        case TypeKind.U16: {\n          if (i64_is_u16(intValue)) return Type.u16;\n          break;\n        }\n        case TypeKind.I32: {\n          if (i64_is_i32(intValue)) return Type.i32;\n          break;\n        }\n        case TypeKind.U32: {\n          if (i64_is_u32(intValue)) return Type.u32;\n          break;\n        }\n        case TypeKind.BOOL: {\n          if (i64_is_bool(intValue)) return Type.bool;\n          break;\n        }\n        case TypeKind.ISIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_i32(intValue)) return Type.isize32;\n            break;\n          }\n          return Type.isize64;\n        }\n        case TypeKind.USIZE: {\n          if (!this.program.options.isWasm64) {\n            if (i64_is_u32(intValue)) return Type.usize32;\n            break;\n          }\n          return Type.usize64;\n        }\n        case TypeKind.I64: return Type.i64;\n        case TypeKind.U64: return Type.u64;\n        case TypeKind.F32: return Type.f32;\n        case TypeKind.F64: return Type.f64;\n      }\n    }\n    // otherwise compile to best fitting native type\n    if (i64_is_i32(intValue)) return Type.i32;\n    if (i64_is_u32(intValue)) return Type.u32;\n    return Type.i64; // TODO: u64 if positive and larger than i64?\n  }\n\n  /** Looks up the program element the specified assertion expression refers to. */\n  private lookupAssertionExpression(\n    /** The expression to look up. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        let type = this.resolveType(\n          assert(node.toType), // must be set if not NONNULL\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n        if (!type) return null;\n        let element = this.getElementOfType(type);\n        if (element) return element;\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_illegal_in_this_context,\n            node.range, type.toString()\n          );\n        }\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return null;\n      }\n      case AssertionKind.NONNULL: {\n        return this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n      }\n      case AssertionKind.CONST: {\n        // TODO: decide on the layout of ReadonlyArray first\n        // let element = this.lookupExpression(node.expression, ctxFlow, ctxType, reportMode);\n        // if (!element) return null;\n        // if (element.kind == ElementKind.CLASS && (<Class>element).extends(this.program.arrayPrototype)) {\n        //   let elementType = assert((<Class>element).getTypeArgumentsTo(this.program.arrayPrototype))[0];\n        //   return this.resolveClass(this.program.readonlyArrayPrototype, [ elementType ]);\n        // }\n        this.error(\n          DiagnosticCode.Not_implemented_0,\n          node.range,\n          \"Const assertion\"\n        );\n        return null;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves an assertion expression to its static type. */\n  private resolveAssertionExpression(\n    /** The expression to resolve. */\n    node: AssertionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    switch (node.assertionKind) {\n      case AssertionKind.AS:\n      case AssertionKind.PREFIX: {\n        return this.resolveType(\n          assert(node.toType),\n          ctxFlow.actualFunction,\n          ctxFlow.contextualTypeArguments,\n          reportMode\n        );\n      }\n      case AssertionKind.NONNULL: {\n        let type = this.resolveExpression(node.expression, ctxFlow, ctxType, reportMode);\n        return type ? type.nonNullableType : null;\n      }\n      case AssertionKind.CONST: {\n        let element = this.lookupExpression(node, ctxFlow, ctxType, reportMode);\n        if (!element) return null;\n        let type = this.getTypeOfElement(element);\n        if (!type) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n              node.range\n            );\n          }\n        }\n        return type;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary prefix expression refers to. */\n  private lookupUnaryPrefixExpression(\n    /** The expression to look up. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPrefixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary prefix expression to its static type. */\n  private resolveUnaryPrefixExpression(\n    /** The expression to resolve. */\n    node: UnaryPrefixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operand = node.operand;\n    var operator = node.operator;\n    switch (operator) {\n      case Token.MINUS: {\n        // implicitly negate if an integer literal to distinguish between i32/u32/i64\n        if (operand.isLiteralKind(LiteralKind.INTEGER)) {\n          return this.determineIntegerLiteralType(i64_sub(i64_zero, (<IntegerLiteralExpression>operand).value), ctxType);\n        }\n        // fall-through\n      }\n      case Token.PLUS:\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPrefixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n      case Token.EXCLAMATION: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool; // incl. references\n      }\n      case Token.TILDE: {\n        let type = this.resolveExpression(operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.BITWISE_NOT);\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, \"~\", type.toString()\n            );\n          }\n          return null;\n        }\n        return type.intType;\n      }\n      default: assert(false);\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified unary postfix expression refers to. */\n  private lookupUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveUnaryPostfixExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n          node.range, operatorTokenToString(node.operator), type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves an unary postfix expression to its static type. */\n  private resolveUnaryPostfixExpression(\n    /** The expression to resolve. */\n    node: UnaryPostfixExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var operator = node.operator;\n    switch (operator) {\n      case Token.PLUS_PLUS:\n      case Token.MINUS_MINUS: {\n        let type = this.resolveExpression(node.operand, ctxFlow, ctxType, reportMode);\n        if (!type) return null;\n        let classReference = type.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromUnaryPostfixToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!type.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), type.toString()\n            );\n          }\n          return null;\n        }\n        return type;\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified binary expression refers to. */\n  private lookupBinaryExpression(\n    /** The expression to look up. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveBinaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (element) return element; // otherwise void\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Type_0_is_illegal_in_this_context,\n        node.range, type.toString()\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a binary expression to its static type. */\n  private resolveBinaryExpression(\n    /** The expression to resolve. */\n    node: BinaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var left = node.left;\n    var right = node.right;\n    var operator = node.operator;\n\n    switch (operator) {\n\n      // assignment: result is the target's type\n\n      case Token.EQUALS:\n      case Token.PLUS_EQUALS:\n      case Token.MINUS_EQUALS:\n      case Token.ASTERISK_EQUALS:\n      case Token.ASTERISK_ASTERISK_EQUALS:\n      case Token.SLASH_EQUALS:\n      case Token.PERCENT_EQUALS:\n      case Token.LESSTHAN_LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\n      case Token.AMPERSAND_EQUALS:\n      case Token.BAR_EQUALS:\n      case Token.CARET_EQUALS: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n\n      // comparison: result is Bool, preferring overloads, integer/float only\n\n      case Token.LESSTHAN:\n      case Token.GREATERTHAN:\n      case Token.LESSTHAN_EQUALS:\n      case Token.GREATERTHAN_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isNumericValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return Type.bool;\n      }\n\n      // equality: result is Bool, preferring overloads, incl. references\n\n      case Token.EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        return Type.bool;\n      }\n\n      // identity: result is Bool, not supporting overloads\n\n      case Token.EQUALS_EQUALS_EQUALS:\n      case Token.EXCLAMATION_EQUALS_EQUALS: {\n        return Type.bool;\n      }\n\n      // arithmetics: result is common type of LHS and RHS, preferring overloads\n\n      case Token.PLUS:\n      case Token.MINUS:\n      case Token.ASTERISK:\n      case Token.SLASH:\n      case Token.PERCENT: { // mod has special logic, but also behaves like this\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // pow: result is common type of LHS and RHS, preferring overloads\n\n      case Token.ASTERISK_ASTERISK: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, leftType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // shift: result is LHS (RHS is converted to LHS), preferring overloads\n\n      case Token.LESSTHAN_LESSTHAN:\n      case Token.GREATERTHAN_GREATERTHAN:\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        if (!leftType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.The_0_operator_cannot_be_applied_to_type_1,\n              node.range, operatorTokenToString(operator), leftType.toString()\n            );\n          }\n          return null;\n        }\n        return leftType;\n      }\n\n      // bitwise: result is common type of LHS and RHS with floats not being supported, preferring overloads\n\n      case Token.AMPERSAND:\n      case Token.BAR:\n      case Token.CARET: {\n        let leftType = this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n        if (!leftType) return null;\n        let classReference = leftType.getClassOrWrapper(this.program);\n        if (classReference) {\n          let overload = classReference.lookupOverload(OperatorKind.fromBinaryToken(operator));\n          if (overload) return overload.signature.returnType;\n        }\n        let rightType = this.resolveExpression(right, ctxFlow, ctxType, reportMode);\n        if (!rightType) return null;\n        let commonType = Type.commonDenominator(leftType, rightType, false);\n        if (!commonType || !commonType.isIntegerValue) {\n          if (reportMode == ReportMode.REPORT) {\n            this.error(\n              DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n              node.range, operatorTokenToString(operator), leftType.toString(), rightType.toString()\n            );\n          }\n        }\n        return commonType;\n      }\n\n      // logical: result is LHS (RHS is converted to LHS), not supporting overloads\n\n      case Token.AMPERSAND_AMPERSAND:\n      case Token.BAR_BAR: {\n        return this.resolveExpression(left, ctxFlow, ctxType, reportMode);\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Looks up the program element the specified this expression refers to. */\n  private lookupThisExpression(\n    /** The expression to look up. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let thisLocal = ctxFlow.lookupLocal(CommonNames.this_);\n      if (thisLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return thisLocal;\n      }\n    }\n    var parent = ctxFlow.actualFunction.parent;\n    if (parent) {\n      this.currentThisExpression = null;\n      this.currentElementExpression = null;\n      return parent;\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._this_cannot_be_referenced_in_current_location,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a this expression to its static type. */\n  private resolveThisExpression(\n    /** The expression to resolve. */\n    node: ThisExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupThisExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified super expression refers to. */\n  private lookupSuperExpression(\n    /** The expression to look up. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    if (ctxFlow.isInline) {\n      let superLocal = ctxFlow.lookupLocal(CommonNames.super_);\n      if (superLocal) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return superLocal;\n      }\n    }\n    var parent: Element | null = ctxFlow.actualFunction.parent;\n    if (parent !== null && parent.kind == ElementKind.CLASS) {\n      let base = (<Class>parent).base;\n      if (base) {\n        this.currentThisExpression = null;\n        this.currentElementExpression = null;\n        return base;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a super expression to its static type. */\n  private resolveSuperExpression(\n    /** The expression to resolve. */\n    node: SuperExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupSuperExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified literal expression refers to. */\n  private lookupLiteralExpression(\n    /** The expression to look up. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    this.currentThisExpression = node;\n    this.currentElementExpression = null;\n    switch (node.literalKind) {\n      case LiteralKind.INTEGER: {\n        let intType = this.determineIntegerLiteralType(\n          (<IntegerLiteralExpression>node).value,\n          ctxType\n        );\n        return assert(intType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.FLOAT: {\n        let fltType = ctxType == Type.f32 ? Type.f32 : Type.f64;\n        return assert(fltType.getClassOrWrapper(this.program));\n      }\n      case LiteralKind.STRING: {\n        return this.program.stringInstance;\n      }\n      case LiteralKind.ARRAY: {\n        let classReference = ctxType.getClass();\n        if (classReference !== null && classReference.prototype == this.program.arrayPrototype) {\n          return this.getElementOfType(ctxType);\n        }\n        // otherwise infer, ignoring ctxType\n        let expressions = (<ArrayLiteralExpression>node).elementExpressions;\n        let length = expressions.length;\n        let elementType = Type.auto;\n        let numNullLiterals = 0;\n        for (let i = 0, k = length; i < k; ++i) {\n          let expression = expressions[i];\n          if (expression) {\n            if (expression.kind == NodeKind.NULL && length > 1) {\n              ++numNullLiterals;\n            } else {\n              let currentType = this.resolveExpression(expression, ctxFlow, elementType);\n              if (!currentType) return null;\n              if (elementType == Type.auto) elementType = currentType;\n              else if (currentType != elementType) {\n                let commonType = Type.commonDenominator(elementType, currentType, false);\n                if (commonType) elementType = commonType;\n                // otherwise triggers error on compilation\n              }\n            }\n          }\n        }\n        if (elementType /* still */ == Type.auto) {\n          if (numNullLiterals == length) { // all nulls infers as usize\n            elementType = this.program.options.usizeType;\n          } else {\n            this.error(\n              DiagnosticCode.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly,\n              node.range, \"T\"\n            );\n            return null;\n          }\n        }\n        if (\n          numNullLiterals > 0 &&\n          elementType.isInternalReference\n        ) {\n          elementType = elementType.asNullable();\n        }\n        return assert(this.resolveClass(this.program.arrayPrototype, [ elementType ]));\n      }\n    }\n    assert(false);\n    return null;\n  }\n\n  /** Resolves a literal expression to its static type. */\n  private resolveLiteralExpression(\n    /** The expression to resolve. */\n    node: LiteralExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupLiteralExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified call expression refers to. */\n  private lookupCallExpression(\n    /** The expression to look up. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveCallExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a call expression to its static type. */\n  private resolveCallExpression(\n    /** The expression to resolve. */\n    node: CallExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.void,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var targetExpression = node.expression;\n    var target = this.lookupExpression( // reports\n      targetExpression,\n      ctxFlow,\n      ctxType,\n      reportMode\n    );\n    if (!target) return null;\n    switch (target.kind) {\n      case ElementKind.FUNCTION_PROTOTYPE: {\n        let functionPrototype = <FunctionPrototype>target;\n        // `unchecked` behaves like parenthesized\n        if (\n          functionPrototype.internalName == BuiltinNames.unchecked &&\n          node.args.length > 0\n        ) {\n          return this.resolveExpression(node.args[0], ctxFlow, ctxType, reportMode);\n        }\n        let instance = this.maybeInferCall(node, functionPrototype, ctxFlow, reportMode);\n        if (!instance) return null;\n        return instance.signature.returnType;\n      }\n      case ElementKind.GLOBAL:\n      case ElementKind.LOCAL:\n      case ElementKind.FIELD: {\n        let varType = (<VariableLikeElement>target).type;\n        let varElement = this.getElementOfType(varType);\n        if (!varElement || varElement.kind != ElementKind.CLASS) {\n          break;\n        }\n        target = varElement;\n        // fall-through\n      }\n      case ElementKind.CLASS: {\n        let typeArguments = (<Class>target).getTypeArgumentsTo(this.program.functionPrototype);\n        if (typeArguments !== null && typeArguments.length > 0) {\n          let ftype = typeArguments[0];\n          let signatureReference = assert(ftype.signatureReference);\n          return signatureReference.returnType;\n        }\n        break;\n      }\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\n        targetExpression.range, target.internalName\n      );\n    }\n    return null;\n  }\n\n  /** Looks up the program element the specified comma expression refers to. */\n  private lookupCommaExpression(\n    /** The expression to look up. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var expressions = node.expressions;\n    return this.lookupExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Resolves a comma expression to its static type. */\n  private resolveCommaExpression(\n    /** The expression to resolve. */\n    node: CommaExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var expressions = node.expressions;\n    return this.resolveExpression(expressions[assert(expressions.length) - 1], ctxFlow, ctxType, reportMode);\n  }\n\n  /** Looks up the program element the specified instanceof expression refers to. */\n  private lookupInstanceOfExpression(\n    /** The expression to look up. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    return assert(Type.bool.getClassOrWrapper(this.program));\n  }\n\n  /** Resolves an instanceof expression to its static type. */\n  private resolveInstanceOfExpression(\n    /** The expression to resolve. */\n    node: InstanceOfExpression,\n    /** Flow to search for scoped locals. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type = Type.auto,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return Type.bool;\n  }\n\n  /** Looks up the program element the specified ternary expression refers to. */\n  private lookupTernaryExpression(\n    /** The expression to look up. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveTernaryExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a ternary expression to its static type. */\n  private resolveTernaryExpression(\n    /** The expression to resolve. */\n    node: TernaryExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var thenType = this.resolveExpression(node.ifThen, ctxFlow, ctxType, reportMode);\n    if (!thenType) return null;\n    var elseType = this.resolveExpression(node.ifElse, ctxFlow, thenType, reportMode);\n    if (!elseType) return null;\n    var commonType = Type.commonDenominator(thenType, elseType, false);\n    if (!commonType) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\n          node.range, \"?:\", thenType.toString(), elseType.toString()\n        );\n      }\n    }\n    return commonType;\n  }\n\n  /** Looks up the program element the specified new expression refers to. */\n  private lookupNewExpression(\n    /** The expression to look up. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var element = this.resolveTypeName(node.typeName, ctxFlow.actualFunction, reportMode);\n    if (!element) return null;\n    if (element.kind == ElementKind.CLASS_PROTOTYPE) {\n      return this.resolveClassInclTypeArguments(\n        <ClassPrototype>element,\n        node.typeArguments,\n        ctxFlow.actualFunction,\n        uniqueMap<string,Type>(ctxFlow.contextualTypeArguments),\n        node,\n        reportMode\n      );\n    }\n    if (reportMode == ReportMode.REPORT) {\n      this.error(\n        DiagnosticCode.This_expression_is_not_constructable,\n        node.range\n      );\n    }\n    return null;\n  }\n\n  /** Resolves a new expression to its static type. */\n  private resolveNewExpression(\n    /** The expression to resolve. */\n    node: NewExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    var element = this.lookupNewExpression(node, ctxFlow, ctxType, reportMode);\n    if (!element) return null;\n    var type = this.getTypeOfElement(element);\n    if (!type) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Expression_cannot_be_represented_by_a_type,\n          node.range\n        );\n      }\n    }\n    return type;\n  }\n\n  /** Looks up the program element the specified function expression refers to. */\n  private lookupFunctionExpression(\n    /** The expression to look up. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Element | null {\n    var type = this.resolveFunctionExpression(node, ctxFlow, ctxType, reportMode);\n    if (!type) return null;\n    var element = this.getElementOfType(type);\n    if (!element) {\n      if (reportMode == ReportMode.REPORT) {\n        this.error(\n          DiagnosticCode.Type_0_is_illegal_in_this_context,\n          node.range, type.toString()\n        );\n      }\n    }\n    return element;\n  }\n\n  /** Resolves a function expression to its static type. */\n  private resolveFunctionExpression(\n    /** The expression to resolve. */\n    node: FunctionExpression,\n    /** Contextual flow. */\n    ctxFlow: Flow,\n    /** Contextual type. */\n    ctxType: Type,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Type | null {\n    return this.resolveFunctionType(node.declaration.signature, ctxFlow.actualFunction, ctxFlow.contextualTypeArguments, reportMode);\n  }\n\n  // ==================================================== Elements =====================================================\n\n  /** Resolves a function prototype using the specified concrete type arguments. */\n  resolveFunction(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var classInstance: Class | null = null; // if an instance method\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Instance method prototypes are pre-bound to their concrete class as their parent\n    if (prototype.is(CommonFlags.INSTANCE)) {\n      assert(actualParent.kind == ElementKind.CLASS || actualParent.kind == ElementKind.INTERFACE);\n      classInstance = <Class>actualParent;\n\n      // check if this exact concrete class and function combination is known already\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n\n      // inherit class specific type arguments\n      let classTypeArguments = classInstance.typeArguments;\n      if (classTypeArguments) {\n        let classTypeParameters = assert(classInstance.prototype.typeParameterNodes);\n        let numClassTypeArguments = classTypeParameters.length;\n        assert(numClassTypeArguments == classTypeParameters.length);\n        for (let i = 0; i < numClassTypeArguments; ++i) {\n          let classTypeParameterName = classTypeParameters[i].name.text;\n          if (!ctxTypes.has(classTypeParameterName)) {\n            ctxTypes.set(\n              classTypeParameterName,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n    } else {\n      assert(actualParent.kind != ElementKind.CLASS); // must not be pre-bound\n      let resolvedInstance = prototype.getResolvedInstance(instanceKey);\n      if (resolvedInstance) return resolvedInstance;\n    }\n\n    // override whatever is contextual with actual function type arguments\n    var signatureNode = prototype.functionTypeNode;\n    var typeParameterNodes = prototype.typeParameterNodes;\n    var numFunctionTypeArguments: i32;\n    if (typeArguments !== null && (numFunctionTypeArguments = typeArguments.length) > 0) {\n      assert(typeParameterNodes !== null && numFunctionTypeArguments == typeParameterNodes.length);\n      for (let i = 0; i < numFunctionTypeArguments; ++i) {\n        ctxTypes.set(\n          (<TypeParameterNode[]>typeParameterNodes)[i].name.text,\n          typeArguments[i]\n        );\n      }\n    } else {\n      assert(!typeParameterNodes || typeParameterNodes.length == 0);\n    }\n\n    // resolve `this` type if applicable\n    var thisType: Type | null = null;\n    var explicitThisType = signatureNode.explicitThisType;\n    if (explicitThisType) {\n      thisType = this.resolveType(\n        explicitThisType,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!thisType) return null;\n      ctxTypes.set(CommonNames.this_, thisType);\n    } else if (classInstance) {\n      thisType = classInstance.type;\n      ctxTypes.set(CommonNames.this_, thisType);\n    }\n\n    // resolve parameter types\n    var signatureParameters = signatureNode.parameters;\n    var numSignatureParameters = signatureParameters.length;\n    var parameterTypes = new Array<Type>(numSignatureParameters);\n    var requiredParameters = 0;\n    for (let i = 0; i < numSignatureParameters; ++i) {\n      let parameterDeclaration = signatureParameters[i];\n      if (parameterDeclaration.parameterKind == ParameterKind.DEFAULT) {\n        requiredParameters = i + 1;\n      }\n      let typeNode = parameterDeclaration.type;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let parameterType = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!parameterType) return null;\n      if (parameterType == Type.void) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      parameterTypes[i] = parameterType;\n    }\n\n    // resolve return type\n    var returnType: Type;\n    if (prototype.is(CommonFlags.SET)) {\n      returnType = Type.void; // not annotated\n    } else if (prototype.is(CommonFlags.CONSTRUCTOR)) {\n      returnType = classInstance!.type; // not annotated\n    } else {\n      let typeNode = signatureNode.returnType;\n      if (isTypeOmitted(typeNode)) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_expected,\n            typeNode.range\n          );\n        }\n        return null;\n      }\n      let type = this.resolveType(\n        typeNode,\n        prototype.parent, // relative to function\n        ctxTypes,\n        reportMode\n      );\n      if (!type) return null;\n      returnType = type;\n    }\n\n    var signature = new Signature(this.program, parameterTypes, returnType, thisType);\n    signature.requiredParameters = requiredParameters;\n\n    var nameInclTypeParameters = prototype.name;\n    if (instanceKey.length) nameInclTypeParameters += \"<\" + instanceKey + \">\";\n    var instance = new Function(\n      nameInclTypeParameters,\n      prototype,\n      typeArguments,\n      signature,\n      ctxTypes\n    );\n    prototype.setResolvedInstance(instanceKey, instance);\n    return instance;\n  }\n\n  /** Resolves a function prototypeby first resolving the specified type arguments. */\n  resolveFunctionInclTypeArguments(\n    /** The prototype of the function. */\n    prototype: FunctionPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Function | null {\n    var actualParent = prototype.parent.kind == ElementKind.PROPERTY_PROTOTYPE\n      ? prototype.parent.parent\n      : prototype.parent;\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n\n      // If this is an instance method, first apply the class's type arguments\n      if (prototype.is(CommonFlags.INSTANCE)) {\n        assert(actualParent.kind == ElementKind.CLASS);\n        let classInstance = <Class>actualParent;\n        let classTypeArguments = classInstance.typeArguments;\n        if (classTypeArguments) {\n          let typeParameterNodes = assert(classInstance.prototype.typeParameterNodes);\n          let numClassTypeArguments = classTypeArguments.length;\n          assert(numClassTypeArguments == typeParameterNodes.length);\n          for (let i = 0; i < numClassTypeArguments; ++i) {\n            ctxTypes.set(\n              typeParameterNodes[i].name.text,\n              classTypeArguments[i]\n            );\n          }\n        }\n      }\n\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes),\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes,\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveFunction(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Currently resolving classes. */\n  private resolveClassPending: Set<Class> = new Set();\n\n  /** Resolves a class prototype using the specified concrete type arguments. */\n  resolveClass(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided. */\n    typeArguments: Type[] | null,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type> = uniqueMap<string,Type>(),\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\n\n    // Do not attempt to resolve the same class twice. This can return a class\n    // that isn't fully resolved yet, but only on deeper levels of recursion.\n    var instance = prototype.getResolvedInstance(instanceKey);\n    if (instance) return instance;\n\n    // Otherwise create\n    var nameInclTypeParamters = prototype.name;\n    if (instanceKey.length) nameInclTypeParamters += \"<\" + instanceKey + \">\";\n    if (prototype.kind == ElementKind.INTERFACE_PROTOTYPE) {\n      instance = new Interface(nameInclTypeParamters, <InterfacePrototype>prototype, typeArguments);\n    } else {\n      instance = new Class(nameInclTypeParamters, prototype, typeArguments);\n    }\n    prototype.setResolvedInstance(instanceKey, instance);\n    var pendingClasses = this.resolveClassPending;\n    pendingClasses.add(instance);\n\n    // Insert contextual type arguments for this operation. Internally, this method is always\n    // called with matching type parameter / argument counts.\n    if (typeArguments) {\n      let typeParameterNodes = assert(prototype.typeParameterNodes);\n      let numTypeParameters = typeParameterNodes.length;\n      let numTypeArguments = typeArguments.length;\n      assert(numTypeArguments == numTypeParameters);\n      for (let i = 0; i < numTypeArguments; ++i) {\n        ctxTypes.set(typeParameterNodes[i].name.text, typeArguments[i]);\n      }\n    } else {\n      let typeParameterNodes = prototype.typeParameterNodes;\n      assert(!(typeParameterNodes !== null && typeParameterNodes.length > 0));\n    }\n    instance.contextualTypeArguments = ctxTypes;\n\n    var anyPending = false;\n\n    // Resolve base class if applicable\n    var basePrototype = prototype.basePrototype;\n    if (basePrototype) {\n      let current: ClassPrototype | null = basePrototype;\n      do {\n        if (current == prototype) {\n          this.error(\n            DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n            prototype.identifierNode.range,\n            prototype.internalName\n          );\n          return null;\n        }\n        current = current.basePrototype;\n      } while (current);\n      let extendsNode = assert(prototype.extendsNode); // must be present if it has a base prototype\n      let base = this.resolveClassInclTypeArguments(\n        basePrototype,\n        extendsNode.typeArguments,\n        prototype.parent, // relative to derived class\n        uniqueMap(ctxTypes), // don't inherit\n        extendsNode,\n        reportMode\n      );\n      if (!base) return null;\n      instance.setBase(base);\n\n      // If the base class is still pending, yield here and instead resolve any\n      // derived classes once the base class's `finishResolveClass` is done.\n      // This is guaranteed to never happen at the entry of the recursion, i.e.\n      // where `resolveClass` is called from other code.\n      if (pendingClasses.has(base)) anyPending = true;\n    }\n\n    // Resolve interfaces if applicable\n    var interfacePrototypes = prototype.interfacePrototypes;\n    if (interfacePrototypes) {\n      for (let i = 0, k = interfacePrototypes.length; i < k; ++i) {\n        let interfacePrototype = interfacePrototypes[i];\n        let current: ClassPrototype | null = interfacePrototype;\n        do {\n          if (current == prototype) {\n            this.error(\n              DiagnosticCode._0_is_referenced_directly_or_indirectly_in_its_own_base_expression,\n              prototype.identifierNode.range,\n              prototype.internalName\n            );\n            return null;\n          }\n          current = current.basePrototype;\n        } while (current);\n        let implementsNode = assert(prototype.implementsNodes![i]);\n        let iface = this.resolveClassInclTypeArguments(\n          interfacePrototype,\n          implementsNode.typeArguments,\n          prototype.parent,\n          uniqueMap(ctxTypes),\n          implementsNode,\n          reportMode\n        );\n        if (!iface) return null;\n        assert(iface.kind == ElementKind.INTERFACE);\n        instance.addInterface(<Interface>iface);\n\n        // Like above, if any implemented interface is still pending, yield\n        if (pendingClasses.has(iface)) anyPending = true;\n      }\n    }\n    if (anyPending) return instance;\n\n    // We only get here if the base class has been fully resolved already.\n    this.finishResolveClass(instance, reportMode);\n    return instance;\n  }\n\n  /** Finishes resolving the specified class. */\n  private finishResolveClass(\n    /** Class to finish resolving. */\n    instance: Class,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode\n  ): void {\n    var members = instance.members;\n    if (!members) instance.members = members = new Map();\n\n    var pendingClasses = this.resolveClassPending;\n    var unimplemented = new Map<string,DeclaredElement>();\n\n    // Alias interface members\n    var interfaces = instance.interfaces;\n    if (interfaces) {\n      for (let _values = Set_values(interfaces), i = 0, k = _values.length; i < k; ++i) {\n        let iface = _values[i];\n        assert(!pendingClasses.has(iface));\n        let ifaceMembers = iface.members;\n        if (ifaceMembers) {\n          for (let _keys = Map_keys(ifaceMembers), i = 0, k = _keys.length; i < k; ++i) {\n            let memberName = unchecked(_keys[i]);\n            let member = assert(ifaceMembers.get(memberName));\n            if (members.has(memberName)) {\n              let existing = assert(members.get(memberName));\n              if (!member.isCompatibleOverride(existing)) {\n                this.errorRelated(\n                  DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                  member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n                );\n                continue;\n              }\n            }\n            members.set(memberName, member);\n            unimplemented.set(memberName, member);\n          }\n        }\n      }\n    }\n\n    // Alias base members\n    var memoryOffset: u32 = 0;\n    var base = instance.base;\n    if (base) {\n      assert(!pendingClasses.has(base));\n      let baseMembers = base.members;\n      if (baseMembers) {\n        // TODO: for (let [baseMemberName, baseMember] of baseMembers) {\n        for (let _keys = Map_keys(baseMembers), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = unchecked(_keys[i]);\n          let member = assert(baseMembers.get(memberName));\n          if (members.has(memberName)) {\n            let existing = assert(members.get(memberName));\n            if (!member.isCompatibleOverride(existing)) {\n              this.errorRelated(\n                DiagnosticCode.This_overload_signature_is_not_compatible_with_its_implementation_signature,\n                member.identifierAndSignatureRange, existing.identifierAndSignatureRange\n              );\n              continue;\n            }\n          }\n          members.set(memberName, member);\n          if (member.is(CommonFlags.ABSTRACT)) {\n            unimplemented.set(memberName, member);\n          } else {\n            unimplemented.delete(memberName);\n          }\n        }\n      }\n      memoryOffset = base.nextMemoryOffset;\n    }\n\n    // Resolve instance members\n    var prototype = instance.prototype;\n    var instanceMemberPrototypes = prototype.instanceMembers;\n    var properties = new Array<Property>();\n    if (instanceMemberPrototypes) {\n      // TODO: for (let member of instanceMemberPrototypes.values()) {\n      for (let _values = Map_values(instanceMemberPrototypes), i = 0, k = _values.length; i < k; ++i) {\n        let member = unchecked(_values[i]);\n        let memberName = member.name;\n        switch (member.kind) {\n\n          case ElementKind.FIELD_PROTOTYPE: {\n            let fieldPrototype = <FieldPrototype>member;\n            let fieldTypeNode = fieldPrototype.typeNode;\n            let fieldType: Type | null = null;\n            // TODO: handle duplicate non-private fields specifically?\n            if (!fieldTypeNode) {\n              if (base) {\n                let baseMembers = base.members;\n                if (baseMembers !== null && baseMembers.has(fieldPrototype.name)) {\n                  let baseField = assert(baseMembers.get(fieldPrototype.name));\n                  if (!baseField.is(CommonFlags.PRIVATE)) {\n                    assert(baseField.kind == ElementKind.FIELD);\n                    fieldType = (<Field>baseField).type;\n                  }\n                }\n              }\n              if (!fieldType) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldPrototype.identifierNode.range.atEnd\n                  );\n                }\n              }\n            } else {\n              fieldType = this.resolveType(\n                fieldTypeNode,\n                prototype.parent, // relative to class\n                instance.contextualTypeArguments,\n                reportMode\n              );\n              if (fieldType == Type.void) {\n                if (reportMode == ReportMode.REPORT) {\n                  this.error(\n                    DiagnosticCode.Type_expected,\n                    fieldTypeNode.range\n                  );\n                }\n                break;\n              }\n            }\n            if (!fieldType) break; // did report above\n            let fieldInstance = new Field(fieldPrototype, instance, fieldType);\n            assert(isPowerOf2(fieldType.byteSize));\n            let mask = fieldType.byteSize - 1;\n            if (memoryOffset & mask) memoryOffset = (memoryOffset | mask) + 1;\n            fieldInstance.memoryOffset = memoryOffset;\n            memoryOffset += fieldType.byteSize;\n            instance.add(memberName, fieldInstance); // reports\n            break;\n          }\n          case ElementKind.FUNCTION_PROTOTYPE: {\n            let boundPrototype = (<FunctionPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          case ElementKind.PROPERTY_PROTOTYPE: {\n            let boundPrototype = (<PropertyPrototype>member).toBound(instance);\n            instance.add(boundPrototype.name, boundPrototype); // reports\n            break;\n          }\n          default: assert(false);\n        }\n        if (!member.is(CommonFlags.ABSTRACT)) {\n          unimplemented.delete(memberName);\n        }\n      }\n    }\n\n    // Check that property getters and setters match\n    for (let i = 0, k = properties.length; i < k; ++i) {\n      let property = properties[i];\n      let propertyGetter = property.getterInstance;\n      if (!propertyGetter) {\n        this.error(\n          DiagnosticCode.Property_0_only_has_a_setter_and_is_missing_a_getter,\n          property.identifierNode.range, property.name\n        );\n      } else {\n        let propertySetter = property.setterInstance;\n        if (propertySetter !== null && !propertyGetter.visibilityEquals(propertySetter)) {\n          this.errorRelated(\n            DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility,\n            propertyGetter.identifierNode.range, propertySetter.identifierNode.range\n          );\n        }\n      }\n    }\n\n    if (instance.kind != ElementKind.INTERFACE) {\n\n      // Check that all required members are implemented\n      if (!instance.is(CommonFlags.ABSTRACT) && unimplemented.size > 0) {\n        for (let _keys = Map_keys(unimplemented), i = 0, k = _keys.length; i < k; ++i) {\n          let memberName = _keys[i];\n          let member = assert(unimplemented.get(memberName));\n          this.errorRelated(\n            DiagnosticCode.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_2,\n            instance.identifierNode.range, member.identifierNode.range,\n            instance.internalName, memberName, member.parent.internalName\n          );\n        }\n      }\n\n      // Finalize memory offset\n      instance.nextMemoryOffset = memoryOffset;\n\n      // Link _own_ constructor if present\n      {\n        let ctorPrototype = instance.lookupInSelf(CommonNames.constructor);\n        if (ctorPrototype !== null && ctorPrototype.parent === instance) {\n          assert(ctorPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\n          let ctorInstance = this.resolveFunction(\n            <FunctionPrototype>ctorPrototype,\n            null,\n            assert(instance.contextualTypeArguments),\n            reportMode\n          );\n          if (ctorInstance) instance.constructorInstance = <Function>ctorInstance;\n        }\n      }\n    }\n\n    // Fully resolve operator overloads (don't have type parameters on their own)\n    var overloadPrototypes = prototype.overloadPrototypes;\n    // TODO: for (let [overloadKind, overloadPrototype] of overloadPrototypes) {\n    for (let _keys = Map_keys(overloadPrototypes), i = 0, k = _keys.length; i < k; ++i) {\n      let overloadKind = unchecked(_keys[i]);\n      let overloadPrototype = assert(overloadPrototypes.get(overloadKind));\n      assert(overloadKind != OperatorKind.INVALID);\n      let operatorInstance: Function | null;\n      if (overloadPrototype.is(CommonFlags.INSTANCE)) {\n        let boundPrototype = overloadPrototype.toBound(instance);\n        operatorInstance = this.resolveFunction(\n          boundPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      } else {\n        operatorInstance = this.resolveFunction(\n          overloadPrototype,\n          null,\n          uniqueMap<string,Type>(),\n          reportMode\n        );\n      }\n      if (!operatorInstance) continue;\n      let overloads = instance.overloads;\n      if (!overloads) instance.overloads = overloads = new Map();\n      // inc/dec are special in that an instance overload attempts to re-assign\n      // the corresponding value, thus requiring a matching return type, while a\n      // static overload works like any other overload.\n      if (operatorInstance.is(CommonFlags.INSTANCE)) {\n        switch (overloadKind) {\n          case OperatorKind.PREFIX_INC:\n          case OperatorKind.PREFIX_DEC:\n          case OperatorKind.POSTFIX_INC:\n          case OperatorKind.POSTFIX_DEC: {\n            let returnType = operatorInstance.signature.returnType;\n            if (!returnType.isAssignableTo(instance.type)) {\n              if (reportMode == ReportMode.REPORT) {\n                this.error(\n                  DiagnosticCode.Type_0_is_not_assignable_to_type_1,\n                  overloadPrototype.functionTypeNode.returnType.range, returnType.toString(), instance.type.toString()\n                );\n              }\n            }\n          }\n        }\n      }\n      if (!overloads.has(overloadKind)) {\n        overloads.set(overloadKind, operatorInstance);\n        if (overloadKind == OperatorKind.INDEXED_GET || overloadKind == OperatorKind.INDEXED_SET) {\n          let index = instance.indexSignature;\n          if (!index) instance.indexSignature = index = new IndexSignature(instance);\n          if (overloadKind == OperatorKind.INDEXED_GET) {\n            index.setType(operatorInstance.signature.returnType);\n          }\n        }\n      } else {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Duplicate_decorator,\n            operatorInstance.declaration.range\n          );\n        }\n      }\n    }\n\n    // Remove this class from pending\n    assert(pendingClasses.has(instance)); // must be pending\n    pendingClasses.delete(instance);\n\n    // Finish derived classes that we postponed in `resolveClass` due to the\n    // base class still being pending, again triggering `finishResolveClass`\n    // of any classes derived from those classes, ultimately leading to all\n    // pending classes being resolved.\n    for (let _values = Set_values(pendingClasses), i = 0, k = _values.length; i < k; ++i) {\n      let pending = _values[i];\n      let dependsOnInstance = pending.base === instance;\n      let interfaces = pending.interfaces;\n      if (interfaces) {\n        let anyPending = false;\n        for (let _values2 = Set_values(interfaces), j = 0, l = _values2.length; j < l; ++j) {\n          let iface = _values2[j];\n          if (iface === instance) dependsOnInstance = true;\n          else if (pendingClasses.has(iface)) anyPending = true;\n        }\n        if (anyPending) continue;\n      }\n      if (dependsOnInstance) this.finishResolveClass(pending, reportMode);\n    }\n  }\n\n  /** Resolves a class prototype by first resolving the specified type arguments. */\n  resolveClassInclTypeArguments(\n    /** The prototype of the class. */\n    prototype: ClassPrototype,\n    /** Type arguments provided to be resolved. */\n    typeArgumentNodes: TypeNode[] | null,\n    /** Contextual element. */\n    ctxElement: Element,\n    /** Contextual types, i.e. `T`. */\n    ctxTypes: Map<string,Type>,\n    /** The node to use when reporting intermediate errors. */\n    reportNode: Node,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Class | null {\n    var resolvedTypeArguments: Type[] | null = null;\n\n    // Resolve type arguments if generic\n    if (prototype.is(CommonFlags.GENERIC)) {\n      resolvedTypeArguments = this.resolveTypeArguments( // reports\n        assert(prototype.typeParameterNodes), // must be present if generic\n        typeArgumentNodes,\n        ctxElement,\n        ctxTypes,\n        reportNode,\n        reportMode\n      );\n      if (!resolvedTypeArguments) return null;\n\n    // Otherwise make sure that no type arguments have been specified\n    } else {\n      if (typeArgumentNodes !== null && typeArgumentNodes.length > 0) {\n        if (reportMode == ReportMode.REPORT) {\n          this.error(\n            DiagnosticCode.Type_0_is_not_generic,\n            reportNode.range, prototype.internalName\n          );\n        }\n        return null;\n      }\n    }\n\n    // Continue with concrete types\n    return this.resolveClass(\n      prototype,\n      resolvedTypeArguments,\n      ctxTypes,\n      reportMode\n    );\n  }\n\n  /** Resolves a property prototype. */\n  resolveProperty(\n    /** The prototype of the property. */\n    prototype: PropertyPrototype,\n    /** How to proceed with eventual diagnostics. */\n    reportMode: ReportMode = ReportMode.REPORT\n  ): Property | null {\n    var instance = prototype.instance;\n    if (instance) return instance;\n    prototype.instance = instance = new Property(prototype, prototype);\n    var getterPrototype = prototype.getterPrototype;\n    if (getterPrototype) {\n      let getterInstance = this.resolveFunction(\n        getterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (getterInstance) {\n        instance.getterInstance = getterInstance;\n        instance.setType(getterInstance.signature.returnType);\n      }\n    }\n    var setterPrototype = prototype.setterPrototype;\n    if (setterPrototype) {\n      let setterInstance = this.resolveFunction(\n        setterPrototype,\n        null,\n        uniqueMap<string,Type>(),\n        reportMode\n      );\n      if (setterInstance) {\n        instance.setterInstance = setterInstance;\n        if (!instance.is(CommonFlags.RESOLVED)) {\n          assert(setterInstance.signature.parameterTypes.length == 1);\n          instance.setType(setterInstance.signature.parameterTypes[0]);\n        }\n      }\n    }\n    return instance;\n  }\n}\n","/**\n * @fileoverview A TypeScript tokenizer modified for AssemblyScript.\n *\n * The `Tokenizer` scans over a source file and returns one syntactic token\n * at a time that the parser will combine to an abstract syntax tree.\n *\n * It skips over trivia like comments and whitespace and provides a general\n * mark/reset mechanism for the parser to utilize on ambiguous tokens, with\n * one token of lookahead otherwise.\n *\n * @license Apache-2.0\n */\n\nimport {\n  DiagnosticCode,\n  DiagnosticMessage,\n  DiagnosticEmitter\n} from \"./diagnostics\";\n\nimport {\n  Source,\n  CommentKind\n} from \"./ast\";\n\nimport {\n  CharCode,\n  isLineBreak,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimalDigit,\n  isOctalDigit,\n  isKeywordCharacter\n} from \"./util\";\n\n/** Named token types. */\nexport enum Token {\n\n  // keywords\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\n\n  ABSTRACT,\n  AS,\n  ASYNC,\n  AWAIT,        // ES2017\n  BREAK,        // ES2017\n  CASE,         // ES2017\n  CATCH,        // ES2017\n  CLASS,        // ES2017\n  CONST,        // ES2017\n  CONTINUE,     // ES2017\n  CONSTRUCTOR,\n  DEBUGGER,     // ES2017\n  DECLARE,\n  DEFAULT,      // ES2017\n  DELETE,       // ES2017\n  DO,           // ES2017\n  ELSE,         // ES2017\n  ENUM,         // ES2017 future\n  EXPORT,       // ES2017\n  EXTENDS,      // ES2017\n  FALSE,        // ES\n  FINALLY,      // ES2017\n  FOR,          // ES2017\n  FROM,         // AS possible identifier\n  FUNCTION,     // ES2017\n  GET,\n  IF,           // ES2017\n  IMPLEMENTS,   // ES2017 non-lexical\n  IMPORT,       // ES2017\n  IN,           // ES2017\n  INSTANCEOF,   // ES2017\n  INTERFACE,    // ES2017 non-lexical\n  IS,\n  KEYOF,\n  LET,          // ES2017 non-lexical\n  MODULE,       // AS possible identifier\n  NAMESPACE,    // AS possible identifier\n  NEW,          // ES2017\n  NULL,         // ES\n  OF,\n  PACKAGE,      // ES2017 non-lexical\n  PRIVATE,      // ES2017 non-lexical\n  PROTECTED,    // ES2017 non-lexical\n  PUBLIC,       // ES2017 non-lexical\n  READONLY,\n  RETURN,       // ES2017\n  SET,\n  STATIC,       // ES2017 non-lexical\n  SUPER,        // ES2017\n  SWITCH,       // ES2017\n  THIS,         // ES2017\n  THROW,        // ES2017\n  TRUE,         // ES\n  TRY,          // ES2017\n  TYPE,         // AS possible identifier\n  TYPEOF,       // ES2017\n  VAR,          // ES2017\n  VOID,         // ES2017\n  WHILE,        // ES2017\n  WITH,         // ES2017\n  YIELD,        // ES2017\n\n  // punctuation\n\n  OPENBRACE,\n  CLOSEBRACE,\n  OPENPAREN,\n  CLOSEPAREN,\n  OPENBRACKET,\n  CLOSEBRACKET,\n  DOT,\n  DOT_DOT_DOT,\n  SEMICOLON,\n  COMMA,\n  LESSTHAN,\n  GREATERTHAN,\n  LESSTHAN_EQUALS,\n  GREATERTHAN_EQUALS,\n  EQUALS_EQUALS,\n  EXCLAMATION_EQUALS,\n  EQUALS_EQUALS_EQUALS,\n  EXCLAMATION_EQUALS_EQUALS,\n  EQUALS_GREATERTHAN,\n  PLUS,\n  MINUS,\n  ASTERISK_ASTERISK,\n  ASTERISK,\n  SLASH,\n  PERCENT,\n  PLUS_PLUS,\n  MINUS_MINUS,\n  LESSTHAN_LESSTHAN,\n  GREATERTHAN_GREATERTHAN,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN,\n  AMPERSAND,\n  BAR,\n  CARET,\n  EXCLAMATION,\n  TILDE,\n  AMPERSAND_AMPERSAND,\n  BAR_BAR,\n  QUESTION,\n  COLON,\n  EQUALS,\n  PLUS_EQUALS,\n  MINUS_EQUALS,\n  ASTERISK_EQUALS,\n  ASTERISK_ASTERISK_EQUALS,\n  SLASH_EQUALS,\n  PERCENT_EQUALS,\n  LESSTHAN_LESSTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_EQUALS,\n  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,\n  AMPERSAND_EQUALS,\n  BAR_EQUALS,\n  CARET_EQUALS,\n  AT,\n\n  // literals\n\n  IDENTIFIER,\n  STRINGLITERAL,\n  INTEGERLITERAL,\n  FLOATLITERAL,\n\n  // meta\n\n  INVALID,\n  ENDOFFILE\n}\n\nexport enum IdentifierHandling {\n  DEFAULT,\n  PREFER,\n  ALWAYS\n}\n\nexport function tokenFromKeyword(text: string): Token {\n  assert(text.length);\n  switch (text.charCodeAt(0)) {\n    case CharCode.a: {\n      if (text == \"abstract\") return Token.ABSTRACT;\n      if (text == \"as\") return Token.AS;\n      if (text == \"async\") return Token.ASYNC;\n      if (text == \"await\") return Token.AWAIT;\n      break;\n    }\n    case CharCode.b: {\n      if (text == \"break\") return Token.BREAK;\n      break;\n    }\n    case CharCode.c: {\n      if (text == \"case\") return Token.CASE;\n      if (text == \"catch\") return Token.CATCH;\n      if (text == \"class\") return Token.CLASS;\n      if (text == \"continue\") return Token.CONTINUE;\n      if (text == \"const\") return Token.CONST;\n      if (text == \"constructor\") return Token.CONSTRUCTOR;\n      break;\n    }\n    case CharCode.d: {\n      if (text == \"debugger\") return Token.DEBUGGER;\n      if (text == \"declare\") return Token.DECLARE;\n      if (text == \"default\") return Token.DEFAULT;\n      if (text == \"delete\") return Token.DELETE;\n      if (text == \"do\") return Token.DO;\n      break;\n    }\n    case CharCode.e: {\n      if (text == \"else\") return Token.ELSE;\n      if (text == \"enum\") return Token.ENUM;\n      if (text == \"export\") return Token.EXPORT;\n      if (text == \"extends\") return Token.EXTENDS;\n      break;\n    }\n    case CharCode.f: {\n      if (text == \"false\") return Token.FALSE;\n      if (text == \"finally\") return Token.FINALLY;\n      if (text == \"for\") return Token.FOR;\n      if (text == \"from\") return Token.FROM;\n      if (text == \"function\") return Token.FUNCTION;\n      break;\n    }\n    case CharCode.g: {\n      if (text == \"get\") return Token.GET;\n      break;\n    }\n    case CharCode.i: {\n      if (text == \"if\") return Token.IF;\n      if (text == \"implements\") return Token.IMPLEMENTS;\n      if (text == \"import\") return Token.IMPORT;\n      if (text == \"in\") return Token.IN;\n      if (text == \"instanceof\") return Token.INSTANCEOF;\n      if (text == \"interface\") return Token.INTERFACE;\n      if (text == \"is\") return Token.IS;\n      break;\n    }\n    case CharCode.k: {\n      if (text == \"keyof\") return Token.KEYOF;\n      break;\n    }\n    case CharCode.l: {\n      if (text == \"let\") return Token.LET;\n      break;\n    }\n    case CharCode.m: {\n      if (text == \"module\") return Token.MODULE;\n      break;\n    }\n    case CharCode.n: {\n      if (text == \"namespace\") return Token.NAMESPACE;\n      if (text == \"new\") return Token.NEW;\n      if (text == \"null\") return Token.NULL;\n      break;\n    }\n    case CharCode.o: {\n      if (text == \"of\") return Token.OF;\n      break;\n    }\n    case CharCode.p: {\n      if (text == \"package\") return Token.PACKAGE;\n      if (text == \"private\") return Token.PRIVATE;\n      if (text == \"protected\") return Token.PROTECTED;\n      if (text == \"public\") return Token.PUBLIC;\n      break;\n    }\n    case CharCode.r: {\n      if (text == \"readonly\") return Token.READONLY;\n      if (text == \"return\") return Token.RETURN;\n      break;\n    }\n    case CharCode.s: {\n      if (text == \"set\") return Token.SET;\n      if (text == \"static\") return Token.STATIC;\n      if (text == \"super\") return Token.SUPER;\n      if (text == \"switch\") return Token.SWITCH;\n      break;\n    }\n    case CharCode.t: {\n      if (text == \"this\") return Token.THIS;\n      if (text == \"throw\") return Token.THROW;\n      if (text == \"true\") return Token.TRUE;\n      if (text == \"try\") return Token.TRY;\n      if (text == \"type\") return Token.TYPE;\n      if (text == \"typeof\") return Token.TYPEOF;\n      break;\n    }\n    case CharCode.v: {\n      if (text == \"var\") return Token.VAR;\n      if (text == \"void\") return Token.VOID;\n      break;\n    }\n    case CharCode.w: {\n      if (text == \"while\") return Token.WHILE;\n      if (text == \"with\") return Token.WITH;\n      break;\n    }\n    case CharCode.y: {\n      if (text == \"yield\") return Token.YIELD;\n      break;\n    }\n  }\n  return Token.INVALID;\n}\n\nexport function tokenIsAlsoIdentifier(token: Token): bool {\n  switch (token) {\n    case Token.ABSTRACT:\n    case Token.AS:\n    case Token.CONSTRUCTOR:\n    case Token.DECLARE:\n    case Token.DELETE:\n    case Token.FROM:\n    case Token.FOR:\n    case Token.GET:\n    case Token.INSTANCEOF:\n    case Token.IS:\n    case Token.KEYOF:\n    case Token.MODULE:\n    case Token.NAMESPACE:\n    case Token.NULL:\n    case Token.READONLY:\n    case Token.SET:\n    case Token.TYPE:\n    case Token.VOID: return true;\n    default: return false;\n  }\n}\n\nexport function isIllegalVariableIdentifier(name: string): bool {\n  assert(name.length);\n  switch (name.charCodeAt(0)) {\n    case CharCode.d: return name == \"delete\";\n    case CharCode.f: return name == \"for\";\n    case CharCode.i: return name == \"instanceof\";\n    case CharCode.n: return name == \"null\";\n    case CharCode.v: return name == \"void\";\n  }\n  return false;\n}\n\nexport function operatorTokenToString(token: Token): string {\n  switch (token) {\n    case Token.DELETE: return \"delete\";\n    case Token.IN: return \"in\";\n    case Token.INSTANCEOF: return \"instanceof\";\n    case Token.NEW: return \"new\";\n    case Token.TYPEOF: return \"typeof\";\n    case Token.VOID: return \"void\";\n    case Token.YIELD: return \"yield\";\n    case Token.DOT_DOT_DOT: return \"...\";\n    case Token.COMMA: return \",\";\n    case Token.LESSTHAN: return \"<\";\n    case Token.GREATERTHAN: return \">\";\n    case Token.LESSTHAN_EQUALS: return \"<=\";\n    case Token.GREATERTHAN_EQUALS: return \">=\";\n    case Token.EQUALS_EQUALS: return \"==\";\n    case Token.EXCLAMATION_EQUALS: return \"!=\";\n    case Token.EQUALS_EQUALS_EQUALS: return \"===\";\n    case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\n    case Token.PLUS: return \"+\";\n    case Token.MINUS: return \"-\";\n    case Token.ASTERISK_ASTERISK: return \"**\";\n    case Token.ASTERISK: return \"*\";\n    case Token.SLASH: return \"/\";\n    case Token.PERCENT: return \"%\";\n    case Token.PLUS_PLUS: return \"++\";\n    case Token.MINUS_MINUS: return \"--\";\n    case Token.LESSTHAN_LESSTHAN: return \"<<\";\n    case Token.GREATERTHAN_GREATERTHAN: return \">>\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\n    case Token.AMPERSAND: return \"&\";\n    case Token.BAR: return \"|\";\n    case Token.CARET: return \"^\";\n    case Token.EXCLAMATION: return \"!\";\n    case Token.TILDE: return \"~\";\n    case Token.AMPERSAND_AMPERSAND: return \"&&\";\n    case Token.BAR_BAR: return \"||\";\n    case Token.EQUALS: return \"=\";\n    case Token.PLUS_EQUALS: return \"+=\";\n    case Token.MINUS_EQUALS: return \"-=\";\n    case Token.ASTERISK_EQUALS: return \"*=\";\n    case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\n    case Token.SLASH_EQUALS: return \"/=\";\n    case Token.PERCENT_EQUALS: return \"%=\";\n    case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\n    case Token.AMPERSAND_EQUALS: return \"&=\";\n    case Token.BAR_EQUALS: return \"|=\";\n    case Token.CARET_EQUALS: return \"^=\";\n    default: {\n      assert(false);\n      return \"\";\n    }\n  }\n}\n\nexport class Range {\n\n  start: i32;\n  end: i32;\n  source!: Source;\n  debugInfoRef: usize = 0;\n\n  constructor(start: i32, end: i32) {\n    this.start = start;\n    this.end = end;\n  }\n\n  static join(a: Range, b: Range): Range {\n    if (a.source != b.source) throw new Error(\"source mismatch\");\n    let range = new Range(\n      a.start < b.start ? a.start : b.start,\n      a.end > b.end ? a.end : b.end\n    );\n    range.source = a.source;\n    return range;\n  }\n\n  equals(other: Range): bool {\n    return this.source == other.source && this.start == other.start && this.end == other.end;\n  }\n\n  get atStart(): Range {\n    let range = new Range(this.start, this.start);\n    range.source = this.source;\n    return range;\n  }\n\n  get atEnd(): Range {\n    let range = new Range(this.end, this.end);\n    range.source = this.source;\n    return range;\n  }\n\n  toString(): string {\n    return this.source.text.substring(this.start, this.end);\n  }\n}\n\n/** Handler for intercepting comments while tokenizing. */\nexport type CommentHandler = (kind: CommentKind, text: string, range: Range) => void;\n\n/** Tokenizes a source to individual {@link Token}s. */\nexport class Tokenizer extends DiagnosticEmitter {\n\n  source: Source;\n  end: i32 = 0;\n\n  pos: i32 = 0;\n  token: Token = -1;\n  tokenPos: i32 = 0;\n\n  nextToken: Token = -1;\n  nextTokenPos: i32 = 0;\n  nextTokenOnNewLine: bool = false;\n\n  onComment: CommentHandler | null = null;\n\n  /** Constructs a new tokenizer. */\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\n    super(diagnostics);\n\n    if (!diagnostics) diagnostics = [];\n    this.diagnostics = diagnostics;\n    this.source = source;\n\n    var text = source.text;\n    var end = text.length;\n    var pos = 0;\n    // skip bom\n    if (\n      pos < end &&\n      text.charCodeAt(pos) == CharCode.BYTEORDERMARK\n    ) {\n      ++pos;\n    }\n\n    // skip shebang\n    if (\n      pos + 1 < end &&\n      text.charCodeAt(pos) == CharCode.HASH &&\n      text.charCodeAt(pos + 1) == CharCode.EXCLAMATION\n    ) {\n      pos += 2;\n      while (\n        pos < end &&\n        text.charCodeAt(pos) != CharCode.LINEFEED\n      ) {\n        ++pos;\n      }\n      // 'next' now starts at lf or eof\n    }\n    this.pos = pos;\n    this.end = end;\n  }\n\n  next(identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): Token {\n    this.nextToken = -1;\n    var token: Token;\n    do token = this.unsafeNext(identifierHandling);\n    while (token == Token.INVALID);\n    this.token = token;\n    return token;\n  }\n\n  private unsafeNext(\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxTokenLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    while (pos < end) {\n      this.tokenPos = pos;\n      let c = text.charCodeAt(pos);\n      switch (c) {\n        case CharCode.CARRIAGERETURN: {\n          if (!(\n            ++pos < end &&\n            text.charCodeAt(pos) == CharCode.LINEFEED\n          )) break;\n          // otherwise fall-through\n        }\n        case CharCode.LINEFEED:\n        case CharCode.TAB:\n        case CharCode.VERTICALTAB:\n        case CharCode.FORMFEED:\n        case CharCode.SPACE: {\n          ++pos;\n          break;\n        }\n        case CharCode.EXCLAMATION: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            ++pos;\n            if (\n              maxTokenLength > 2 && pos < end &&\n              text.charCodeAt(pos) == CharCode.EQUALS\n            ) {\n              this.pos = pos + 1;\n              return Token.EXCLAMATION_EQUALS_EQUALS;\n            }\n            this.pos = pos;\n            return Token.EXCLAMATION_EQUALS;\n          }\n          this.pos = pos;\n          return Token.EXCLAMATION;\n        }\n        case CharCode.DOUBLEQUOTE:\n        case CharCode.SINGLEQUOTE:\n        case CharCode.BACKTICK: { // TODO\n          this.pos = pos;\n          return Token.STRINGLITERAL; // expects a call to readString\n        }\n        case CharCode.PERCENT: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.PERCENT_EQUALS;\n          }\n          this.pos = pos;\n          return Token.PERCENT;\n        }\n        case CharCode.AMPERSAND: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.AMPERSAND) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_AMPERSAND;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.AMPERSAND_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.AMPERSAND;\n        }\n        case CharCode.OPENPAREN: {\n          this.pos = pos + 1;\n          return Token.OPENPAREN;\n        }\n        case CharCode.CLOSEPAREN: {\n          this.pos = pos + 1;\n          return Token.CLOSEPAREN;\n        }\n        case CharCode.ASTERISK: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.ASTERISK_EQUALS;\n            }\n            if (chr == CharCode.ASTERISK) {\n              ++pos;\n              if (\n                maxTokenLength > 2 && pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.ASTERISK_ASTERISK_EQUALS;\n              }\n              this.pos = pos;\n              return Token.ASTERISK_ASTERISK;\n            }\n          }\n          this.pos = pos;\n          return Token.ASTERISK;\n        }\n        case CharCode.PLUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.PLUS) {\n              this.pos = pos + 1;\n              return Token.PLUS_PLUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.PLUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.PLUS;\n        }\n        case CharCode.COMMA: {\n          this.pos = pos + 1;\n          return Token.COMMA;\n        }\n        case CharCode.MINUS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.MINUS) {\n              this.pos = pos + 1;\n              return Token.MINUS_MINUS;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.MINUS_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.MINUS;\n        }\n        case CharCode.DOT: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (isDecimalDigit(chr)) {\n              this.pos = pos - 1;\n              return Token.FLOATLITERAL; // expects a call to readFloat\n            }\n            if (\n              maxTokenLength > 2 && pos + 1 < end &&\n              chr == CharCode.DOT &&\n              text.charCodeAt(pos + 1) == CharCode.DOT\n            ) {\n              this.pos = pos + 2;\n              return Token.DOT_DOT_DOT;\n            }\n          }\n          this.pos = pos;\n          return Token.DOT;\n        }\n        case CharCode.SLASH: {\n          let commentStartPos = pos;\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.SLASH) { // single-line\n              let commentKind = CommentKind.LINE;\n              if (\n                pos + 1 < end &&\n                text.charCodeAt(pos + 1) == CharCode.SLASH\n              ) {\n                ++pos;\n                commentKind = CommentKind.TRIPLE;\n              }\n              while (++pos < end) {\n                if (text.charCodeAt(pos) == CharCode.LINEFEED) {\n                  ++pos;\n                  break;\n                }\n              }\n              if (this.onComment) {\n                this.onComment(\n                  commentKind,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.ASTERISK) { // multi-line\n              let closed = false;\n              while (++pos < end) {\n                c = text.charCodeAt(pos);\n                if (\n                  c == CharCode.ASTERISK &&\n                  pos + 1 < end &&\n                  text.charCodeAt(pos + 1) == CharCode.SLASH\n                ) {\n                  pos += 2;\n                  closed = true;\n                  break;\n                }\n              }\n              if (!closed) {\n                this.error(\n                  DiagnosticCode._0_expected,\n                  this.range(pos), \"*/\"\n                );\n              } else if (this.onComment) {\n                this.onComment(\n                  CommentKind.BLOCK,\n                  text.substring(commentStartPos, pos),\n                  this.range(commentStartPos, pos)\n                );\n              }\n              break;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.SLASH_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.SLASH;\n        }\n        case CharCode._0:\n        case CharCode._1:\n        case CharCode._2:\n        case CharCode._3:\n        case CharCode._4:\n        case CharCode._5:\n        case CharCode._6:\n        case CharCode._7:\n        case CharCode._8:\n        case CharCode._9: {\n          this.pos = pos;\n          return this.testInteger()\n            ? Token.INTEGERLITERAL // expects a call to readInteger\n            : Token.FLOATLITERAL;  // expects a call to readFloat\n        }\n        case CharCode.COLON: {\n          this.pos = pos + 1;\n          return Token.COLON;\n        }\n        case CharCode.SEMICOLON: {\n          this.pos = pos + 1;\n          return Token.SEMICOLON;\n        }\n        case CharCode.LESSTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.LESSTHAN) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.LESSTHAN_LESSTHAN_EQUALS;\n              }\n              this.pos = pos;\n              return Token.LESSTHAN_LESSTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.LESSTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.LESSTHAN;\n        }\n        case CharCode.EQUALS: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.EQUALS) {\n              ++pos;\n              if (\n                maxTokenLength > 2 &&\n                pos < end &&\n                text.charCodeAt(pos) == CharCode.EQUALS\n              ) {\n                this.pos = pos + 1;\n                return Token.EQUALS_EQUALS_EQUALS;\n              }\n              this.pos = pos;\n              return Token.EQUALS_EQUALS;\n            }\n            if (chr == CharCode.GREATERTHAN) {\n              this.pos = pos + 1;\n              return Token.EQUALS_GREATERTHAN;\n            }\n          }\n          this.pos = pos;\n          return Token.EQUALS;\n        }\n        case CharCode.GREATERTHAN: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.GREATERTHAN) {\n              ++pos;\n              if (maxTokenLength > 2 && pos < end) {\n                chr = text.charCodeAt(pos);\n                if (chr == CharCode.GREATERTHAN) {\n                  ++pos;\n                  if (\n                    maxTokenLength > 3 && pos < end &&\n                    text.charCodeAt(pos) == CharCode.EQUALS\n                  ) {\n                    this.pos = pos + 1;\n                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\n                  }\n                  this.pos = pos;\n                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\n                }\n                if (chr == CharCode.EQUALS) {\n                  this.pos = pos + 1;\n                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;\n                }\n              }\n              this.pos = pos;\n              return Token.GREATERTHAN_GREATERTHAN;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.GREATERTHAN_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.GREATERTHAN;\n        }\n        case CharCode.QUESTION: {\n          this.pos = pos + 1;\n          return Token.QUESTION;\n        }\n        case CharCode.OPENBRACKET: {\n          this.pos = pos + 1;\n          return Token.OPENBRACKET;\n        }\n        case CharCode.CLOSEBRACKET: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACKET;\n        }\n        case CharCode.CARET: {\n          ++pos;\n          if (\n            maxTokenLength > 1 && pos < end &&\n            text.charCodeAt(pos) == CharCode.EQUALS\n          ) {\n            this.pos = pos + 1;\n            return Token.CARET_EQUALS;\n          }\n          this.pos = pos;\n          return Token.CARET;\n        }\n        case CharCode.OPENBRACE: {\n          this.pos = pos + 1;\n          return Token.OPENBRACE;\n        }\n        case CharCode.BAR: {\n          ++pos;\n          if (maxTokenLength > 1 && pos < end) {\n            let chr = text.charCodeAt(pos);\n            if (chr == CharCode.BAR) {\n              this.pos = pos + 1;\n              return Token.BAR_BAR;\n            }\n            if (chr == CharCode.EQUALS) {\n              this.pos = pos + 1;\n              return Token.BAR_EQUALS;\n            }\n          }\n          this.pos = pos;\n          return Token.BAR;\n        }\n        case CharCode.CLOSEBRACE: {\n          this.pos = pos + 1;\n          return Token.CLOSEBRACE;\n        }\n        case CharCode.TILDE: {\n          this.pos = pos + 1;\n          return Token.TILDE;\n        }\n        case CharCode.AT: {\n          this.pos = pos + 1;\n          return Token.AT;\n        }\n        default: {\n          if (isIdentifierStart(c)) {\n            if (isKeywordCharacter(c)) {\n              let posBefore = pos;\n              while (\n                ++pos < end &&\n                isIdentifierPart(c = text.charCodeAt(pos))\n              ) {\n                if (!isKeywordCharacter(c)) {\n                  this.pos = posBefore;\n                  return Token.IDENTIFIER;\n                }\n              }\n              let keywordText = text.substring(posBefore, pos);\n              let keywordToken = tokenFromKeyword(keywordText);\n              if (\n                keywordToken !== Token.INVALID &&\n                identifierHandling !== IdentifierHandling.ALWAYS &&\n                !(\n                  identifierHandling === IdentifierHandling.PREFER &&\n                  tokenIsAlsoIdentifier(keywordToken)\n                )\n              ) {\n                this.pos = pos;\n                return keywordToken;\n              }\n              this.pos = pos = posBefore;\n            }\n            this.pos = pos;\n            return Token.IDENTIFIER; // expects a call to readIdentifier\n          } else if (isWhiteSpace(c)) {\n            ++pos;\n            break;\n          }\n          let start = pos++;\n          if ( // surrogate pair?\n            (c & 0xFC00) == 0xD800 && pos < end &&\n            ((text.charCodeAt(pos)) & 0xFC00) == 0xDC00\n          ) ++pos;\n          this.error(\n            DiagnosticCode.Invalid_character,\n            this.range(start, pos)\n          );\n          this.pos = pos;\n          return Token.INVALID;\n        }\n      }\n    }\n    this.pos = pos;\n    return Token.ENDOFFILE;\n  }\n\n  peek(\n    checkOnNewLine: bool = false,\n    identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT,\n    maxCompoundLength: i32 = i32.MAX_VALUE\n  ): Token {\n    var text = this.source.text;\n    if (this.nextToken < 0) {\n      let posBefore = this.pos;\n      let tokenBefore = this.token;\n      let tokenPosBefore = this.tokenPos;\n      let nextToken: Token;\n      do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n      while (nextToken == Token.INVALID);\n      this.nextToken = nextToken;\n      this.nextTokenPos = this.tokenPos;\n      if (checkOnNewLine) {\n        this.nextTokenOnNewLine = false;\n        for (let pos = posBefore, end = this.nextTokenPos; pos < end; ++pos) {\n          if (isLineBreak(text.charCodeAt(pos))) {\n            this.nextTokenOnNewLine = true;\n            break;\n          }\n        }\n      }\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n    }\n    return this.nextToken;\n  }\n\n  skipIdentifier(identifierHandling: IdentifierHandling = IdentifierHandling.PREFER): bool {\n    return this.skip(Token.IDENTIFIER, identifierHandling);\n  }\n\n  skip(token: Token, identifierHandling: IdentifierHandling = IdentifierHandling.DEFAULT): bool {\n    var posBefore = this.pos;\n    var tokenBefore = this.token;\n    var tokenPosBefore = this.tokenPos;\n    var maxCompoundLength = i32.MAX_VALUE;\n    if (token == Token.GREATERTHAN) {  // where parsing type arguments\n      maxCompoundLength = 1;\n    }\n    var nextToken: Token;\n    do nextToken = this.unsafeNext(identifierHandling, maxCompoundLength);\n    while (nextToken == Token.INVALID);\n    if (nextToken == token) {\n      this.token = token;\n      this.nextToken = -1;\n      return true;\n    } else {\n      this.pos = posBefore;\n      this.token = tokenBefore;\n      this.tokenPos = tokenPosBefore;\n      return false;\n    }\n  }\n\n  mark(): State {\n    var state = reusableState;\n    if (state) {\n      reusableState = null;\n      state.pos = this.pos;\n      state.token = this.token;\n      state.tokenPos = this.tokenPos;\n    } else {\n      state = new State(this.pos, this.token, this.tokenPos);\n    }\n    return state;\n  }\n\n  discard(state: State): void {\n    reusableState = state;\n  }\n\n  reset(state: State): void {\n    this.pos = state.pos;\n    this.token = state.token;\n    this.tokenPos = state.tokenPos;\n    this.nextToken = -1;\n  }\n\n  range(start: i32 = -1, end: i32 = -1): Range {\n    if (start < 0) {\n      start = this.tokenPos;\n      end = this.pos;\n    } else if (end < 0) {\n      end = start;\n    }\n    let range = new Range(start, end);\n    range.source = this.source;\n    return range;\n  }\n\n  readIdentifier(): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    var start = pos;\n    while (\n      ++pos < end &&\n      isIdentifierPart(text.charCodeAt(pos))\n    );\n    this.pos = pos;\n    return text.substring(start, pos);\n  }\n\n  readString(): string {\n    var text = this.source.text;\n    var end = this.end;\n    var pos = this.pos;\n    var quote = text.charCodeAt(pos++);\n    var start = pos;\n    var result = \"\";\n    while (true) {\n      if (pos >= end) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, end)\n        );\n        break;\n      }\n      let c = text.charCodeAt(pos);\n      if (c == quote) {\n        result += text.substring(start, pos++);\n        break;\n      }\n      if (c == CharCode.BACKSLASH) {\n        result += text.substring(start, pos);\n        this.pos = pos; // save\n        result += this.readEscapeSequence();\n        pos = this.pos; // restore\n        start = pos;\n        continue;\n      }\n      if (isLineBreak(c) && quote != CharCode.BACKTICK) {\n        result += text.substring(start, pos);\n        this.error(\n          DiagnosticCode.Unterminated_string_literal,\n          this.range(start - 1, pos)\n        );\n        break;\n      }\n      ++pos;\n    }\n    this.pos = pos;\n    return result;\n  }\n\n  readEscapeSequence(): string {\n    var end = this.end;\n    if (++this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(end)\n      );\n      return \"\";\n    }\n\n    var text = this.source.text;\n    var c = text.charCodeAt(this.pos++);\n    switch (c) {\n      case CharCode._0: return \"\\0\";\n      case CharCode.b: return \"\\b\";\n      case CharCode.t: return \"\\t\";\n      case CharCode.n: return \"\\n\";\n      case CharCode.v: return \"\\v\";\n      case CharCode.f: return \"\\f\";\n      case CharCode.r: return \"\\r\";\n      case CharCode.SINGLEQUOTE: return \"'\";\n      case CharCode.DOUBLEQUOTE: return \"\\\"\";\n      case CharCode.u: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.OPENBRACE\n        ) {\n          ++this.pos;\n          return this.readExtendedUnicodeEscape(); // \\u{DDDDDDDD}\n        }\n        return this.readUnicodeEscape(); // \\uDDDD\n      }\n      case CharCode.x: {\n        return this.readHexadecimalEscape(); // \\xDD\n      }\n      case CharCode.CARRIAGERETURN: {\n        if (\n          this.pos < end &&\n          text.charCodeAt(this.pos) == CharCode.LINEFEED\n        ) {\n          ++this.pos;\n        }\n        // fall through\n      }\n      case CharCode.LINEFEED:\n      case CharCode.LINESEPARATOR:\n      case CharCode.PARAGRAPHSEPARATOR: return \"\";\n      default: return String.fromCharCode(c);\n    }\n  }\n\n  readRegexpPattern(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var escaped = false;\n    while (true) {\n      if (this.pos >= end) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, end)\n        );\n        break;\n      }\n      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {\n        ++this.pos;\n        escaped = true;\n        continue;\n      }\n      let c = text.charCodeAt(this.pos);\n      if (!escaped && c == CharCode.SLASH) break;\n      if (isLineBreak(c)) {\n        this.error(\n          DiagnosticCode.Unterminated_regular_expression_literal,\n          this.range(start, this.pos)\n        );\n        break;\n      }\n      ++this.pos;\n      escaped = false;\n    }\n    return text.substring(start, this.pos);\n  }\n\n  readRegexpFlags(): string {\n    var text = this.source.text;\n    var start = this.pos;\n    var end = this.end;\n    var flags = 0;\n    while (this.pos < end) {\n      let c: i32 = text.charCodeAt(this.pos);\n      if (!isIdentifierPart(c)) break;\n      ++this.pos;\n\n      // make sure each supported flag is unique\n      switch (c) {\n        case CharCode.g: {\n          flags |= flags & 1 ? -1 : 1;\n          break;\n        }\n        case CharCode.i: {\n          flags |= flags & 2 ? -1 : 2;\n          break;\n        }\n        case CharCode.m: {\n          flags |= flags & 4 ? -1 : 4;\n          break;\n        }\n        default: {\n          flags = -1;\n          break;\n        }\n      }\n    }\n    if (flags == -1) {\n      this.error(\n        DiagnosticCode.Invalid_regular_expression_flags,\n        this.range(start, this.pos)\n      );\n    }\n    return text.substring(start, this.pos);\n  }\n\n  testInteger(): bool {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    if (pos + 1 < end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 2) | 32) {\n        case CharCode.x:\n        case CharCode.b:\n        case CharCode.o: return true;\n      }\n    }\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode.DOT || (c | 32) == CharCode.e) return false;\n      if (c != CharCode._ && (c < CharCode._0 || c > CharCode._9)) break;\n      // does not validate separator placement (this is done in readXYInteger)\n      pos++;\n    }\n    return true;\n  }\n\n  readInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    if (pos + 2 < this.end && text.charCodeAt(pos) == CharCode._0) {\n      switch (text.charCodeAt(pos + 1) | 32) {\n        case CharCode.x: {\n          this.pos = pos + 2;\n          return this.readHexInteger();\n        }\n        case CharCode.b: {\n          this.pos = pos + 2;\n          return this.readBinaryInteger();\n        }\n        case CharCode.o: {\n          this.pos = pos + 2;\n          return this.readOctalInteger();\n        }\n      }\n      if (isOctalDigit(text.charCodeAt(pos + 1))) {\n        let start = pos;\n        this.pos = pos + 1;\n        let value = this.readOctalInteger();\n        this.error(\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\n          this.range(start, this.pos)\n        );\n        return value;\n      }\n    }\n    return this.readDecimalInteger();\n  }\n\n  readHexInteger(): i64 {\n    var text = this.source.text;\n    let pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_4 = i64_new(4);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = (value << 4) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        // value = (value << 4) + 10 + c - CharCode.A;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.A)\n        );\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        // value = (value << 4) + 10 + c - CharCode.a;\n        value = i64_add(\n          i64_shl(value, i64_4),\n          i64_new(10 + c - CharCode.a)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Hexadecimal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readDecimalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_10 = i64_new(10);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        // value = value * 10 + c - CharCode._0;\n        value = i64_add(\n          i64_mul(value, i64_10),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readOctalInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_3 = i64_new(3);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c >= CharCode._0 && c <= CharCode._7) {\n        // value = (value << 3) + c - CharCode._0;\n        value = i64_add(\n          i64_shl(value, i64_3),\n          i64_new(c - CharCode._0)\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Octal_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readBinaryInteger(): i64 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    var start = pos;\n    var sepEnd = start;\n    var value = i64_new(0);\n    var i64_1 = i64_new(1);\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n      if (c == CharCode._0) {\n        // value = (value << 1);\n        value = i64_shl(value, i64_1);\n      } else if (c == CharCode._1) {\n        // value = (value << 1) + 1;\n        value = i64_add(\n          i64_shl(value, i64_1),\n          i64_1\n        );\n      } else if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n      } else {\n        break;\n      }\n      ++pos;\n    }\n    if (pos == start) {\n      this.error(\n        DiagnosticCode.Binary_digit_expected,\n        this.range(start)\n      );\n    } else if (sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n    this.pos = pos;\n    return value;\n  }\n\n  readFloat(): f64 {\n    // var text = this.source.text;\n    // if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\n    //   switch (text.charCodeAt(this.pos + 1)) {\n    //     case CharCode.X:\n    //     case CharCode.x: {\n    //       this.pos += 2;\n    //       return this.readHexFloat();\n    //     }\n    //   }\n    // }\n    return this.readDecimalFloat();\n  }\n\n  readDecimalFloat(): f64 {\n    var text = this.source.text;\n    var end = this.end;\n    var start = this.pos;\n    var sepCount = this.readDecimalFloatPartial(false);\n    if (this.pos < end && text.charCodeAt(this.pos) == CharCode.DOT) {\n      ++this.pos;\n      sepCount += this.readDecimalFloatPartial();\n    }\n    if (this.pos < end) {\n      let c = text.charCodeAt(this.pos);\n      if ((c | 32) == CharCode.e) {\n        if (\n          ++this.pos < end &&\n          (c = text.charCodeAt(this.pos)) == CharCode.MINUS || c == CharCode.PLUS &&\n          isDecimalDigit(text.charCodeAt(this.pos + 1))\n        ) {\n          ++this.pos;\n        }\n        sepCount += this.readDecimalFloatPartial();\n      }\n    }\n    let result = text.substring(start, this.pos);\n    if (sepCount) result = result.replaceAll(\"_\", \"\");\n    return parseFloat(result);\n  }\n\n  /** Reads past one section of a decimal float literal. Returns the number of separators encountered. */\n  private readDecimalFloatPartial(allowLeadingZeroSep: bool = true): u32 {\n    var text = this.source.text;\n    var pos = this.pos;\n    var start = pos;\n    var end = this.end;\n    var sepEnd = start;\n    var sepCount = 0;\n\n    while (pos < end) {\n      let c = text.charCodeAt(pos);\n\n      if (c == CharCode._) {\n        if (sepEnd == pos) {\n          this.error(\n            sepEnd == start\n              ? DiagnosticCode.Numeric_separators_are_not_allowed_here\n              : DiagnosticCode.Multiple_consecutive_numeric_separators_are_not_permitted,\n            this.range(pos)\n          );\n        } else if (!allowLeadingZeroSep && pos - 1 == start && text.charCodeAt(pos - 1) == CharCode._0) {\n          this.error(\n            DiagnosticCode.Numeric_separators_are_not_allowed_here,\n            this.range(pos)\n          );\n        }\n        sepEnd = pos + 1;\n        ++sepCount;\n      } else if (!isDecimalDigit(c)) {\n        break;\n      }\n      ++pos;\n    }\n\n    if (pos != start && sepEnd == pos) {\n      this.error(\n        DiagnosticCode.Numeric_separators_are_not_allowed_here,\n        this.range(sepEnd - 1)\n      );\n    }\n\n    this.pos = pos;\n    return sepCount;\n  }\n\n  readHexFloat(): f64 {\n    throw new Error(\"not implemented\"); // TBD\n  }\n\n  readHexadecimalEscape(remain: i32 = 2): string {\n    var value = 0;\n    var text = this.source.text;\n    var pos = this.pos;\n    var end = this.end;\n    while (pos < end) {\n      let c = text.charCodeAt(pos++);\n      if (c >= CharCode._0 && c <= CharCode._9) {\n        value = (value << 4) + c - CharCode._0;\n      } else if (c >= CharCode.A && c <= CharCode.F) {\n        value = (value << 4) + c + (10 - CharCode.A);\n      } else if (c >= CharCode.a && c <= CharCode.f) {\n        value = (value << 4) + c + (10 - CharCode.a);\n      } else {\n        this.error(\n          DiagnosticCode.Hexadecimal_digit_expected,\n          this.range(pos - 1, pos)\n        );\n        this.pos = pos;\n        return \"\";\n      }\n      if (--remain == 0) break;\n    }\n    if (remain) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(pos)\n      );\n      this.pos = pos;\n      return \"\";\n    }\n    this.pos = pos;\n    return String.fromCharCode(value);\n  }\n\n  readUnicodeEscape(): string {\n    return this.readHexadecimalEscape(4);\n  }\n\n  private readExtendedUnicodeEscape(): string {\n    var start = this.pos;\n    var value = this.readHexInteger();\n    var value32 = i64_low(value);\n    var invalid = false;\n\n    assert(!i64_high(value));\n    if (value32 > 0x10FFFF) {\n      this.error(\n        DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\n        this.range(start, this.pos)\n      );\n      invalid = true;\n    }\n\n    var end = this.end;\n    var text = this.source.text;\n    if (this.pos >= end) {\n      this.error(\n        DiagnosticCode.Unexpected_end_of_text,\n        this.range(start, end)\n      );\n      invalid = true;\n    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {\n      ++this.pos;\n    } else {\n      this.error(\n        DiagnosticCode.Unterminated_Unicode_escape_sequence,\n        this.range(start, this.pos)\n      );\n      invalid = true;\n    }\n\n    if (invalid) return \"\";\n    return value32 < 0x10000\n      ? String.fromCharCode(value32)\n      : String.fromCharCode(\n        ((value32 - 0x10000) >>> 10) | 0xD800,\n        ((value32 - 0x10000) & 1023) | 0xDC00\n      );\n  }\n}\n\n/** Tokenizer state as returned by {@link Tokenizer#mark} and consumed by {@link Tokenizer#reset}. */\nexport class State {\n  constructor(\n    /** Current position. */\n    public pos: i32,\n    /** Current token. */\n    public token: Token,\n    /** Current token's position. */\n    public tokenPos: i32\n  ) {}\n}\n\n// Reusable state object to reduce allocations\nvar reusableState: State | null = null;\n","/**\n * @fileoverview Mappings from AssemblyScript types to WebAssembly types.\n * @license Apache-2.0\n */\n\nimport {\n  Class,\n  Program,\n  DecoratorFlags\n} from \"./program\";\n\nimport {\n  NativeType,\n  createType\n} from \"./module\";\n\n/** Indicates the kind of a type. */\nexport const enum TypeKind {\n\n  // signed integers\n\n  /** An 8-bit signed integer. */\n  I8,\n  /** A 16-bit signed integer. */\n  I16,\n  /** A 32-bit signed integer. */\n  I32,\n  /** A 64-bit signed integer. */\n  I64,\n  /** A 32-bit/64-bit signed integer, depending on the target. */\n  ISIZE,\n\n  // unsigned integers\n\n  /** An 8-bit unsigned integer. */\n  U8,\n  /** A 16-bit unsigned integer. */\n  U16,\n  /** A 32-bit unsigned integer. Also the base of function types. */\n  U32,\n  /** A 64-bit unsigned integer. */\n  U64,\n  /** A 32-bit/64-bit unsigned integer, depending on the target. Also the base of class types. */\n  USIZE,\n  /** A 1-bit unsigned integer. */\n  BOOL, // sic\n\n  // floats\n\n  /** A 32-bit float. */\n  F32,\n  /** A 64-bit double. */\n  F64,\n\n  // vectors\n\n  /** A 128-bit vector. */\n  V128,\n\n  // references\n\n  /** Function reference. */\n  FUNCREF,\n  /** External reference. */\n  EXTERNREF,\n  /** Exception reference. */\n  EXNREF,\n  /** Any reference. */\n  ANYREF,\n\n  // other\n\n  /** No return type. */\n  VOID\n}\n\n/** Indicates capabilities of a type. */\nexport const enum TypeFlags {\n  NONE = 0,\n  /** Is a signed type that can represent negative values. */\n  SIGNED = 1 << 0,\n  /** Is an unsigned type that cannot represent negative values. */\n  UNSIGNED = 1 << 1,\n  /** Is an integer type. */\n  INTEGER = 1 << 2,\n  /** Is a floating point type. */\n  FLOAT = 1 << 3,\n  /** Is a varying (in size) type. */\n  VARYING = 1 << 4,\n  /** Is smaller than 32-bits. */\n  SHORT = 1 << 5,\n  /** Is larger than 32-bits. */\n  LONG = 1 << 6,\n  /** Is a value type. */\n  VALUE = 1 << 7,\n  /** Is a reference type (either a class or a function type). */\n  REFERENCE = 1 << 8,\n  /** Is a nullable type. */\n  NULLABLE = 1 << 9,\n  /** Is a vector type. */\n  VECTOR = 1 << 10,\n  /** Is an external type. */\n  EXTERNAL = 1 << 11,\n  /** Is a class. */\n  CLASS = 1 << 12,\n  /** Is a function. */\n  FUNCTION = 1 << 13\n}\n\n/** Represents a resolved type. */\nexport class Type {\n\n  /** Type kind. */\n  kind: TypeKind;\n  /** Type flags. */\n  flags: TypeFlags;\n  /** Size in bits. */\n  size: i32;\n  /** Size in bytes. */\n  byteSize: i32;\n  /** Underlying class reference, if a class type. */\n  classReference: Class | null;\n  /** Underlying signature reference, if a function type. */\n  signatureReference: Signature | null;\n  /** Respective non-nullable type, if nullable. */\n  private _nonNullableType: Type | null = null;\n  /** Respective nullable type, if non-nullable. */\n  private _nullableType: Type | null = null;\n\n  /** Constructs a new resolved type. */\n  constructor(kind: TypeKind, flags: TypeFlags, size: u32) {\n    this.kind = kind;\n    this.flags = flags;\n    this.size = size;\n    this.byteSize = <i32>ceil<f64>(<f64>size / 8);\n    this.classReference = null;\n    this.signatureReference = null;\n    if (!(flags & TypeFlags.NULLABLE)) {\n      this._nonNullableType = this;\n    } else {\n      this._nullableType = this;\n    }\n  }\n\n  /** Returns the closest int type representing this type. */\n  get intType(): Type {\n    if (this == Type.auto) return this; // keep auto as a hint\n    switch (this.kind) {\n      case TypeKind.I8: return Type.i8;\n      case TypeKind.I16: return Type.i16;\n      case TypeKind.F32:\n      case TypeKind.I32: return Type.i32;\n      case TypeKind.F64:\n      case TypeKind.I64: return Type.i64;\n      case TypeKind.ISIZE: return this.size == 64 ? Type.isize64 : Type.isize32;\n      case TypeKind.U8: return Type.u8;\n      case TypeKind.U16: return Type.u16;\n      case TypeKind.U32: return Type.u32;\n      case TypeKind.U64: return Type.u64;\n      case TypeKind.USIZE: return this.size == 64 ? Type.usize64 : Type.usize32;\n      case TypeKind.BOOL:\n      default: return Type.i32;\n    }\n  }\n\n  /** Substitutes this type with the auto type if this type is void. */\n  get exceptVoid(): Type {\n    if (this.kind == TypeKind.VOID) return Type.auto;\n    return this;\n  }\n\n  /** Gets this type's logarithmic alignment in memory. */\n  get alignLog2(): i32 {\n    return 31 - clz<i32>(this.byteSize);\n  }\n\n  /** Tests if this type represents a basic value. */\n  get isValue(): bool {\n    return this.is(TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer value. */\n  get isIntegerValue(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a small (< 32 bits) integer value. */\n  get isShortIntegerValue(): bool {\n    return this.is(TypeFlags.SHORT | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a long (> 32 bits) integer value. */\n  get isLongIntegerValue(): bool {\n    return this.is(TypeFlags.LONG | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a signed integer value. */\n  get isSignedIntegerValue(): bool {\n    return this.is(TypeFlags.SIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an unsigned integer value. */\n  get isUnsignedIntegerValue(): bool {\n    return this.is(TypeFlags.UNSIGNED | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents a varying (in size) integer value. */\n  get isVaryingIntegerValue(): bool {\n    return this.is(TypeFlags.VARYING | TypeFlags.INTEGER | TypeFlags.VALUE);\n  }\n\n  /** Tests if this type represents an integer, including references.  */\n  get isIntegerInclReference(): bool {\n    return this.is(TypeFlags.INTEGER);\n  }\n\n  /** Tests if this type represents a floating point value. */\n  get isFloatValue(): bool {\n    return this.is(TypeFlags.FLOAT | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents a numeric (integer or floating point) value. */\n  get isNumericValue(): bool {\n    return this.isIntegerValue || this.isFloatValue;\n  }\n\n  /** Tests if this type represents a boolean value. */\n  get isBooleanValue(): bool {\n    return this == Type.bool;\n  }\n\n  /** Tests if this type represents a vector value. */\n  get isVectorValue(): bool {\n    return this.is(TypeFlags.VECTOR | TypeFlags.VALUE);\n  }\n  \n  /** Tests if this type represents an internal or external reference. */\n  get isReference(): bool {\n    return this.is(TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a nullable internal or external reference. */\n  get isNullableReference(): bool {\n    return this.is(TypeFlags.NULLABLE | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an internal object. */\n  get isInternalReference(): bool {\n    return this.is(TypeFlags.INTEGER | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents an external object. */\n  get isExternalReference(): bool {\n    return this.is(TypeFlags.EXTERNAL | TypeFlags.REFERENCE);\n  }\n\n  /** Tests if this type represents a class. */\n  get isClass(): bool {\n    return this.isInternalReference\n      ? this.classReference !== null\n      : false;\n  }\n\n  /** Gets the underlying class of this type, if any. */\n  getClass(): Class | null {\n    return this.isInternalReference\n      ? this.classReference\n      : null;\n  }\n\n  /** Gets the underlying class or wrapper class of this type, if any. */\n  getClassOrWrapper(program: Program): Class | null {\n    let classReference = this.getClass();\n    if (classReference) {\n      // typical class\n      return classReference;\n    } else {\n      let signatureReference = this.getSignature();\n      if (signatureReference) {\n        // function wrapper\n        let type = signatureReference.type;\n        let wrapper = assert(program.resolver.resolveClass(program.functionPrototype, [ type ]));\n        wrapper.wrappedType = type;\n        return wrapper;\n      } else {\n        let wrapperClasses = program.wrapperClasses;\n        if (wrapperClasses.has(this)) {\n          // value wrapper\n          return assert(wrapperClasses.get(this));\n        }\n      }\n    }\n    return null;\n  }\n\n  /** Tests if this type represents a function. */\n  get isFunction(): bool {\n    return this.isInternalReference\n      ? this.signatureReference !== null\n      : false;\n  }\n\n  /** Gets the underlying function signature of this type, if any. */\n  getSignature(): Signature | null {\n    return this.isInternalReference\n      ? this.signatureReference\n      : null;\n  }\n\n  /** Tests if this is a managed type that needs GC hooks. */\n  get isManaged(): bool {\n    if (this.isInternalReference) {\n      let classReference = this.classReference;\n      if (classReference) return !classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n      return this.signatureReference !== null; // function references are managed\n    }\n    return false;\n  }\n\n  /** Tests if this is a class type explicitly annotated as unmanaged. */\n  get isUnmanaged(): bool {\n    var classReference = this.classReference;\n    return classReference !== null && classReference.hasDecorator(DecoratorFlags.UNMANAGED);\n  }\n\n  /** Gets the corresponding non-nullable type. */\n  get nonNullableType(): Type {\n    if (this.isExternalReference) {\n      return this; // TODO\n    }\n    return assert(this._nonNullableType); // set either in ctor or asNullable\n  }\n\n  /** Gets the corresponding nullable type, if applicable. */\n  get nullableType(): Type | null {\n    return this._nullableType; // set either in ctor or asNullable\n  }\n\n  /** Computes the sign-extending shift in the target type. */\n  computeSmallIntegerShift(targetType: Type): i32 {\n    return targetType.size - this.size;\n  }\n\n  /** Computes the truncating mask in the target type. */\n  computeSmallIntegerMask(targetType: Type): i32 {\n    var size = this.is(TypeFlags.UNSIGNED) ? this.size : this.size - 1;\n    return ~0 >>> (targetType.size - size);\n  }\n\n  /** Tests if this type has (all of) the specified flags. */\n  is(flags: TypeFlags): bool { return (this.flags & flags) == flags; }\n  /** Tests if this type has any of the specified flags. */\n  isAny(flags: TypeFlags): bool { return (this.flags & flags) != 0; }\n\n  /** Composes the respective nullable type of this type. */\n  asNullable(): Type {\n    assert(this.isInternalReference);\n    var nullableType = this._nullableType;\n    if (!nullableType) {\n      assert(!this.isNullableReference);\n      this._nullableType = nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);\n      nullableType.classReference = this.classReference;         // either a class reference\n      nullableType.signatureReference = this.signatureReference; // or a function reference\n      nullableType._nonNullableType = this;\n    }\n    return nullableType;\n  }\n\n  /** Tests if this type equals the specified. */\n  equals(other: Type): bool {\n    if (this.kind != other.kind) return false;\n    if (this.isReference) {\n      return (\n        this.classReference == other.classReference &&\n        this.signatureReference == other.signatureReference &&\n        this.isNullableReference == other.isNullableReference\n      );\n    }\n    return true;\n  }\n\n  /** Tests if a value of this type is assignable to the target type incl. implicit conversion. */\n  isAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    var currentClass: Class | null;\n    var targetClass: Class | null;\n    var currentFunction: Signature | null;\n    var targetFunction: Signature | null;\n    if (this.isReference) {\n      if (target.isReference) {\n        if (!this.isNullableReference || target.isNullableReference) {\n          if (currentClass = this.getClass()) {\n            if (targetClass = target.getClass()) {\n              return currentClass.isAssignableTo(targetClass);\n            }\n          } else if (currentFunction = this.getSignature()) {\n            if (targetFunction = target.getSignature()) {\n              return currentFunction.isAssignableTo(targetFunction);\n            }\n          } else if (this.isExternalReference && (this.kind == target.kind || target.kind == TypeKind.ANYREF)) {\n            return true;\n          }\n        }\n      }\n    } else if (!target.isReference) {\n      if (this.isIntegerValue) {\n        if (target.isIntegerValue) {\n          if (\n            !signednessIsRelevant ||\n            this.isBooleanValue || // a bool (0 or 1) can be safely assigned to all sorts of integers\n            this.isSignedIntegerValue == target.isSignedIntegerValue\n          ) {\n            return this.size <= target.size;\n          }\n        } else if (target.kind == TypeKind.F32) {\n          return this.size <= 23; // mantissa bits\n        } else if (target.kind == TypeKind.F64) {\n          return this.size <= 52; // ^\n        }\n      } else if (this.isFloatValue) {\n        if (target.isFloatValue) {\n          return this.size <= target.size;\n        }\n      } else if (this.isVectorValue) {\n        if (target.isVectorValue) {\n          return this.size == target.size;\n        }\n      }\n    }\n    return false;\n  }\n\n  /** Tests if a value of this type is assignable to the target type excl. implicit conversion. */\n  isStrictlyAssignableTo(target: Type, signednessIsRelevant: bool = false): bool {\n    if (this.isReference) return this.isAssignableTo(target);\n    else if (target.isReference) return false;\n    // not dealing with references from here on\n    if (this.isIntegerValue) {\n      return target.isIntegerValue && target.size == this.size && (\n        !signednessIsRelevant ||\n        this.isSignedIntegerValue == target.isSignedIntegerValue\n      );\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Tests if a value of this type can be changed to the target type using `changetype`. */\n  isChangeableTo(target: Type): bool {\n    // special in that it allows integer references as well\n    if (this.is(TypeFlags.INTEGER) && target.is(TypeFlags.INTEGER)) {\n      let size = this.size;\n      return size == target.size && (size >= 32 || this.is(TypeFlags.SIGNED) == target.is(TypeFlags.SIGNED));\n    }\n    return this.kind == target.kind;\n  }\n\n  /** Determines the common denominator type of two types, if there is any. */\n  static commonDenominator(left: Type, right: Type, signednessIsImportant: bool): Type | null {\n    if (right.isAssignableTo(left, signednessIsImportant)) return left;\n    else if (left.isAssignableTo(right, signednessIsImportant)) return right;\n    return null;\n  }\n\n  /** Converts this type to a string. */\n  toString(validWat: bool = false): string {\n    const nullablePostfix = validWat\n      ? \"|null\"\n      : \" | null\";\n    if (this.isReference) {\n      let classReference = this.getClass();\n      if (classReference) {\n        return this.isNullableReference\n          ? classReference.internalName + nullablePostfix\n          : classReference.internalName;\n      } else {\n        let signatureReference = this.getSignature();\n        if (signatureReference) {\n          return this.isNullableReference\n            ? \"(\" + signatureReference.toString(validWat) + \")\" + nullablePostfix\n            : signatureReference.toString(validWat);\n        }\n      }\n    }\n    switch (this.kind) {\n      case TypeKind.I8: return \"i8\";\n      case TypeKind.I16: return \"i16\";\n      case TypeKind.I32: return \"i32\";\n      case TypeKind.I64: return \"i64\";\n      case TypeKind.ISIZE: return \"isize\";\n      case TypeKind.U8: return \"u8\";\n      case TypeKind.U16: return \"u16\";\n      case TypeKind.U32: return \"u32\";\n      case TypeKind.U64: return \"u64\";\n      case TypeKind.USIZE: return \"usize\";\n      case TypeKind.BOOL: return \"bool\";\n      case TypeKind.F32: return \"f32\";\n      case TypeKind.F64: return \"f64\";\n      case TypeKind.V128: return \"v128\";\n      case TypeKind.FUNCREF: return \"funcref\";\n      case TypeKind.EXTERNREF: return \"externref\";\n      case TypeKind.EXNREF: return \"exnref\";\n      case TypeKind.ANYREF: return \"anyref\";\n      default: assert(false);\n      case TypeKind.VOID: return \"void\";\n    }\n  }\n\n  // Binaryen specific\n\n  /** Converts this type to its respective native type. */\n  toNativeType(): NativeType {\n    switch (this.kind) {\n      default: assert(false);\n      case TypeKind.I8:\n      case TypeKind.I16:\n      case TypeKind.I32:\n      case TypeKind.U8:\n      case TypeKind.U16:\n      case TypeKind.U32:\n      case TypeKind.BOOL: return NativeType.I32;\n      case TypeKind.ISIZE:\n      case TypeKind.USIZE: if (this.size != 64) return NativeType.I32;\n      case TypeKind.I64:\n      case TypeKind.U64: return NativeType.I64;\n      case TypeKind.F32: return NativeType.F32;\n      case TypeKind.F64: return NativeType.F64;\n      case TypeKind.V128: return NativeType.V128;\n      case TypeKind.FUNCREF: return NativeType.Funcref;\n      case TypeKind.EXTERNREF: return NativeType.Externref;\n      case TypeKind.EXNREF: return NativeType.Exnref;\n      case TypeKind.ANYREF: return NativeType.Anyref;\n      case TypeKind.VOID: return NativeType.None;\n    }\n  }\n\n  // Types\n\n  /** An 8-bit signed integer. */\n  static readonly i8: Type  = new Type(TypeKind.I8,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit signed integer. */\n  static readonly i16: Type = new Type(TypeKind.I16,\n    TypeFlags.SIGNED   |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit signed integer. */\n  static readonly i32: Type = new Type(TypeKind.I32,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed integer. */\n  static readonly i64: Type = new Type(TypeKind.I64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit signed size. WASM32 only. */\n  static readonly isize32: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit signed size. WASM64 only. */\n  static readonly isize64: Type = new Type(TypeKind.ISIZE,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** An 8-bit unsigned integer. */\n  static readonly u8: Type = new Type(TypeKind.U8,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   8\n  );\n\n  /** A 16-bit unsigned integer. */\n  static readonly u16: Type = new Type(TypeKind.U16,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  16\n  );\n\n  /** A 32-bit unsigned integer. */\n  static readonly u32: Type = new Type(TypeKind.U32,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned integer. */\n  static readonly u64: Type = new Type(TypeKind.U64,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 32-bit unsigned size. WASM32 only. */\n  static readonly usize32: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit unsigned size. WASM64 only. */\n  static readonly usize64: Type = new Type(TypeKind.USIZE,\n    TypeFlags.UNSIGNED |\n    TypeFlags.LONG     |\n    TypeFlags.INTEGER  |\n    TypeFlags.VARYING  |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 1-bit unsigned integer. */\n  static readonly bool: Type = new Type(TypeKind.BOOL,\n    TypeFlags.UNSIGNED |\n    TypeFlags.SHORT    |\n    TypeFlags.INTEGER  |\n    TypeFlags.VALUE,   1\n  );\n\n  /** A 32-bit float. */\n  static readonly f32: Type = new Type(TypeKind.F32,\n    TypeFlags.SIGNED   |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  32\n  );\n\n  /** A 64-bit float. */\n  static readonly f64: Type = new Type(TypeKind.F64,\n    TypeFlags.SIGNED   |\n    TypeFlags.LONG     |\n    TypeFlags.FLOAT    |\n    TypeFlags.VALUE,  64\n  );\n\n  /** A 128-bit vector. */\n  static readonly v128: Type = new Type(TypeKind.V128,\n    TypeFlags.VECTOR   |\n    TypeFlags.VALUE, 128\n  );\n\n  /** Function reference. */\n  static readonly funcref: Type = new Type(TypeKind.FUNCREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** External reference. */\n  static readonly externref: Type = new Type(TypeKind.EXTERNREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Exception reference. */\n  static readonly exnref: Type = new Type(TypeKind.EXNREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** Any reference. */\n  static readonly anyref: Type = new Type(TypeKind.ANYREF,\n    TypeFlags.EXTERNAL   |\n    TypeFlags.NULLABLE   |\n    TypeFlags.REFERENCE, 0\n  );\n\n  /** No return type. */\n  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);\n\n  /** Alias of i32 indicating type inference of locals and globals with just an initializer. */\n  static readonly auto: Type = new Type(Type.i32.kind, Type.i32.flags, Type.i32.size);\n}\n\n/** Converts an array of types to an array of native types. */\nexport function typesToNativeTypes(types: Type[]): NativeType[] {\n  var numTypes = types.length;\n  var ret = new Array<NativeType>(numTypes);\n  for (let i = 0; i < numTypes; ++i) ret[i] = types[i].toNativeType();\n  return ret;\n}\n\n/** Converts an array of types to its combined string representation. */\nexport function typesToString(types: Type[]): string {\n  var numTypes = types.length;\n  if (!numTypes) return \"\";\n  var sb = new Array<string>(numTypes);\n  for (let i = 0; i < numTypes; ++i) sb[i] = types[i].toString(true);\n  return sb.join(\",\");\n}\n\n/** Represents a fully resolved function signature. */\nexport class Signature {\n  /** Unique id representing this signature. */\n  id: u32 = 0;\n  /** Parameter types, if any, excluding `this`. */\n  parameterTypes: Type[];\n  /** Number of required parameters excluding `this`. Other parameters are considered optional. */\n  requiredParameters: i32;\n  /** Return type. */\n  returnType: Type;\n  /** This type, if an instance signature. */\n  thisType: Type | null;\n  /** Whether the last parameter is a rest parameter. */\n  hasRest: bool;\n  /** Respective function type. */\n  type: Type;\n  /** The program that created this signature. */\n  program: Program;\n\n  /** Constructs a new signature. */\n  constructor(\n    program: Program,\n    parameterTypes: Type[] | null = null,\n    returnType: Type | null = null,\n    thisType: Type | null = null\n  ) {\n    this.parameterTypes = parameterTypes ? parameterTypes : [];\n    this.requiredParameters = 0;\n    this.returnType = returnType ? returnType : Type.void;\n    this.thisType = thisType;\n    this.program = program;\n    this.hasRest = false;\n    var usizeType = program.options.usizeType;\n    var type = new Type(usizeType.kind, usizeType.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, usizeType.size);\n    this.type = type;\n    type.signatureReference = this;\n\n    var signatureTypes = program.uniqueSignatures;\n    var length = signatureTypes.length;\n    for (let i = 0; i < length; i++) {\n      let compare = signatureTypes[i];\n      if (this.equals(compare)) {\n        this.id = compare.id;\n        return this;\n      }\n    }\n    this.id = program.nextSignatureId++;\n    program.uniqueSignatures.push(this);\n  }\n\n  get nativeParams(): NativeType {\n    var thisType = this.thisType;\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    if (!numParameterTypes) {\n      if (!thisType) return NativeType.None;\n      return thisType.toNativeType();\n    }\n    if (thisType) {\n      let nativeTypes = new Array<NativeType>(1 + numParameterTypes);\n      nativeTypes[0] = thisType.toNativeType();\n      for (let i = 0; i < numParameterTypes; ++i) {\n        nativeTypes[i + 1] = parameterTypes[i].toNativeType();\n      }\n      return createType(nativeTypes);\n    }\n    return createType(typesToNativeTypes(parameterTypes));\n  }\n\n  get nativeResults(): NativeType {\n    return this.returnType.toNativeType();\n  }\n\n  /** Tests if this signature equals the specified. */\n  equals(other: Signature): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var otherThisType = other.thisType;\n    if (thisThisType !== null) {\n      if (otherThisType === null || !thisThisType.equals(otherThisType)) return false;\n    } else if (otherThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != other.hasRest) return false;\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var otherParameterTypes = other.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != otherParameterTypes.length) return false;\n    for (let i = 0; i < numParameters; ++i) {\n      if (!thisParameterTypes[i].equals(otherParameterTypes[i])) return false;\n    }\n\n    // check return type\n    return this.returnType.equals(other.returnType);\n  }\n\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\n  isAssignableTo(target: Signature, requireSameSize: bool = false): bool {\n\n    // check `this` type\n    var thisThisType = this.thisType;\n    var targetThisType = target.thisType;\n    if (thisThisType !== null) {\n      if (targetThisType === null || !thisThisType.isAssignableTo(targetThisType)) return false;\n    } else if (targetThisType) {\n      return false;\n    }\n\n    // check rest parameter\n    if (this.hasRest != target.hasRest) return false; // TODO\n\n    // check parameter types\n    var thisParameterTypes = this.parameterTypes;\n    var targetParameterTypes = target.parameterTypes;\n    var numParameters = thisParameterTypes.length;\n    if (numParameters != targetParameterTypes.length) return false; // TODO\n    for (let i = 0; i < numParameters; ++i) {\n      let thisParameterType = thisParameterTypes[i];\n      let targetParameterType = targetParameterTypes[i];\n      if (!thisParameterType.isAssignableTo(targetParameterType)) return false;\n    }\n\n    // check return type\n    var thisReturnType = this.returnType;\n    var targetReturnType = target.returnType;\n    return thisReturnType == targetReturnType || thisReturnType.isAssignableTo(targetReturnType);\n  }\n\n  /** Converts this signature to a string. */\n  toString(validWat: bool = false): string {\n    var sb = new Array<string>();\n    sb.push(validWat ? \"%28\" : \"(\");\n    var index = 0;\n    var thisType = this.thisType;\n    if (thisType) {\n      sb.push(validWat ? \"this:\" : \"this: \");\n      assert(!thisType.signatureReference);\n      sb.push(thisType.toString(validWat));\n      index = 1;\n    }\n    var parameters = this.parameterTypes;\n    var numParameters = parameters.length;\n    if (numParameters) {\n      let optionalStart = this.requiredParameters;\n      let restIndex = this.hasRest ? numParameters - 1 : -1;\n      for (let i = 0; i < numParameters; ++i, ++index) {\n        if (index) sb.push(validWat ? \"%2C\" : \", \");\n        if (i == restIndex) sb.push(\"...\");\n        sb.push(parameters[i].toString(validWat));\n        if (i >= optionalStart && i != restIndex) sb.push(\"?\");\n      }\n    }\n    sb.push(validWat ? \"%29=>\" : \") => \");\n    sb.push(this.returnType.toString(validWat));\n    return sb.join(\"\");\n  }\n\n  /** Creates a clone of this signature that is safe to modify. */\n  clone(): Signature {\n    var parameterTypes = this.parameterTypes;\n    var numParameterTypes = parameterTypes.length;\n    var cloneParameterTypes = new Array<Type>(numParameterTypes);\n    for (let i = 0; i < numParameterTypes; ++i) {\n      cloneParameterTypes[i] = parameterTypes[i];\n    }\n    return new Signature(this.program, cloneParameterTypes, this.returnType, this.thisType);\n  }\n}\n","/**\n * @fileoverview Various binary reading and writing utility.\n * @license Apache-2.0\n */\n\n/** Reads an 8-bit integer from the specified buffer. */\nexport function readI8(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset];\n}\n\n/** Writes an 8-bit integer to the specified buffer. */\nexport function writeI8(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset] = value;\n}\n\n/** Reads a 16-bit integer from the specified buffer. */\nexport function readI16(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset    ]\n       | buffer[offset + 1] << 8;\n}\n\n/** Writes a 16-bit integer to the specified buffer. */\nexport function writeI16(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n}\n\n/** Reads a 32-bit integer from the specified buffer. */\nexport function readI32(buffer: Uint8Array, offset: i32): i32 {\n  return buffer[offset    ]\n       | buffer[offset + 1] << 8\n       | buffer[offset + 2] << 16\n       | buffer[offset + 3] << 24;\n}\n\n/** Writes a 32-bit integer to the specified buffer. */\nexport function writeI32(value: i32, buffer: Uint8Array, offset: i32): void {\n  buffer[offset    ] = value;\n  buffer[offset + 1] = value >>> 8;\n  buffer[offset + 2] = value >>> 16;\n  buffer[offset + 3] = value >>> 24;\n}\n\n/** Writes a 32-bit integer as a 64-bit integer to the specified buffer. */\nexport function writeI32AsI64(value: i32, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  writeI32(value, buffer, offset);\n  writeI32(unsigned || value >= 0 ? 0 : -1, buffer, offset + 4);\n}\n\n/** Reads a 64-bit integer from the specified buffer. */\nexport function readI64(buffer: Uint8Array, offset: i32): i64 {\n  var lo = readI32(buffer, offset);\n  var hi = readI32(buffer, offset + 4);\n  return i64_new(lo, hi);\n}\n\n/** Writes a 64-bit integer to the specified buffer. */\nexport function writeI64(value: i64, buffer: Uint8Array, offset: i32): void {\n  writeI32(i64_low(value), buffer, offset);\n  writeI32(i64_high(value), buffer, offset + 4);\n}\n\n/** Writes a 64-bit integer as a 32-bit integer to the specified buffer. */\nexport function writeI64AsI32(value: i64, buffer: Uint8Array, offset: i32, unsigned: bool = false): void {\n  assert(unsigned ? i64_is_u32(value) : i64_is_i32(value));\n  writeI32(i64_low(value), buffer, offset);\n}\n\n/** Reads a 32-bit float from the specified buffer. */\nexport function readF32(buffer: Uint8Array, offset: i32): f32 {\n  return i32_as_f32(readI32(buffer, offset));\n}\n\n/** Writes a 32-bit float to the specified buffer. */\nexport function writeF32(value: f32, buffer: Uint8Array, offset: i32): void {\n  writeI32(f32_as_i32(value), buffer, offset);\n}\n\n/** Reads a 64-bit float from the specified buffer. */\nexport function readF64(buffer: Uint8Array, offset: i32): f64 {\n  return i64_as_f64(readI64(buffer, offset));\n}\n\n/** Writes a 64-bit float to the specified buffer. */\nexport function writeF64(value: f64, buffer: Uint8Array, offset: i32): void {\n  var valueI64 = f64_as_i64(value);\n  writeI32(i64_low(valueI64), buffer, offset);\n  writeI32(i64_high(valueI64), buffer, offset + 4);\n}\n","/**\n * @fileoverview Various collections utility.\n * @license Apache-2.0\n */\n\n/** Makes a unique map. Typically used to track contextual type arguemnts. */\nexport function uniqueMap<K,V>(original: Map<K,V> | null = null, overrides: Map<K,V> | null = null): Map<K,V> {\n  var cloned = new Map<K,V>();\n  if (original) {\n    // TODO: for (let [k, v] of original) {\n    for (let _keys = Map_keys(original), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(original.get(k));\n      cloned.set(k, v);\n    }\n  }\n  if (overrides) {\n    // TODO: for (let [k, v] of overrides) {\n    for (let _keys = Map_keys(overrides), i = 0, k = _keys.length; i < k; ++i) {\n      let k = unchecked(_keys[i]);\n      let v = assert(overrides.get(k));\n      cloned.set(k, v);\n    }\n  }\n  return cloned;\n}\n","/**\n * @fileoverview Various utility.\n * @license Apache-2.0\n */\n\nexport * from \"./binary\";\nexport * from \"./collections\";\nexport * from \"./math\";\nexport * from \"./path\";\nexport * from \"./text\";\nexport * from \"./vector\";\n","/**\n * @fileoverview Various math utility.\n * @license Apache-2.0\n */\n\n/** Tests if `x` is a power of two. */\nexport function isPowerOf2(x: i32): bool {\n  return x != 0 && (x & (x - 1)) == 0;\n}\n","/**\n * @fileoverview Various file path utility.\n * @license Apache-2.0\n */\n\nimport {\n  CharCode\n} from \"./text\";\n\nimport {\n  PATH_DELIMITER\n} from \"../common\";\n\nconst separator = CharCode.SLASH;\n\n/**\n * Normalizes the specified path, removing interior placeholders.\n * Expects a posix-compatible relative path (not Windows compatible).\n */\nexport function normalizePath(path: string): string {\n  var pos = 0;\n  var len = path.length;\n\n  // trim leading './'\n  while (pos + 1 < len &&\n    path.charCodeAt(pos) == CharCode.DOT &&\n    path.charCodeAt(pos + 1) == separator\n  ) {\n    pos += 2;\n  }\n\n  if (pos > 0 || len < path.length) {\n    path = path.substring(pos, len);\n    len -= pos;\n    pos = 0;\n  }\n\n  var atEnd: bool;\n  while (pos + 1 < len) {\n    atEnd = false;\n\n    // we are only interested in '/.' sequences ...\n    if (\n      path.charCodeAt(pos) == separator &&\n      path.charCodeAt(pos + 1) == CharCode.DOT\n    ) {\n      // '/.' ( '/' | $ )\n      atEnd = pos + 2 == len;\n      if (atEnd ||\n        pos + 2 < len &&\n        path.charCodeAt(pos + 2) == separator\n      ) {\n        path = atEnd\n          ? path.substring(0, pos)\n          : path.substring(0, pos) + path.substring(pos + 2);\n        len -= 2;\n        continue;\n      }\n\n      // '/.' ( './' | '.' $ )\n      atEnd = pos + 3 == len;\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||\n        pos + 3 < len &&\n        path.charCodeAt(pos + 2) == CharCode.DOT &&\n        path.charCodeAt(pos + 3) == separator\n      ) {\n        // find preceeding '/'\n        let ipos = pos;\n        while (--ipos >= 0) {\n          if (path.charCodeAt(ipos) == separator) {\n            if (pos - ipos != 3 ||\n              path.charCodeAt(ipos + 1) != CharCode.DOT ||\n              path.charCodeAt(ipos + 2) != CharCode.DOT\n            ) { // exclude '..' itself\n              path = atEnd\n                ? path.substring(0, ipos)\n                : path.substring(0, ipos) + path.substring(pos + 3);\n              len -= pos + 3 - ipos;\n              pos = ipos - 1; // incremented again at end of loop\n            }\n            break;\n          }\n        }\n\n        // if there's no preceeding '/', trim start if non-empty\n        if (ipos < 0 && pos > 0) {\n          if (pos != 2 ||\n            path.charCodeAt(0) != CharCode.DOT ||\n            path.charCodeAt(1) != CharCode.DOT\n          ) { // exclude '..' itself\n            path = path.substring(pos + 4);\n            len = path.length;\n            continue;\n          }\n        }\n      }\n    }\n    pos++;\n  }\n  return len > 0 ? path : \".\";\n}\n\n/** Resolves the specified path relative to the specified origin. */\nexport function resolvePath(normalizedPath: string, origin: string): string {\n  if (normalizedPath.startsWith(\"std/\")) {\n    return normalizedPath;\n  }\n  return normalizePath(\n    dirname(origin) + PATH_DELIMITER + normalizedPath\n  );\n}\n\n/** Obtains the directory portion of a normalized path. */\nexport function dirname(normalizedPath: string): string {\n  var pos = normalizedPath.length;\n  if (pos <= 1) {\n    if (pos == 0) return \".\";\n    if (normalizedPath.charCodeAt(0) == separator) {\n      return normalizedPath;\n    }\n  }\n  while (--pos > 0) {\n    if (normalizedPath.charCodeAt(pos) == separator) {\n      return normalizedPath.substring(0, pos);\n    }\n  }\n  return \".\";\n}\n","/**\n * @fileoverview Various character and text utility.\n * @license Apache-2.0\n */\n\n/** An enum of named character codes. */\nexport const enum CharCode {\n\n  NULL = 0,\n  LINEFEED = 0x0A,\n  CARRIAGERETURN = 0x0D,\n  LINESEPARATOR = 0x2028,\n  PARAGRAPHSEPARATOR = 0x2029,\n  NEXTLINE = 0x0085,\n\n  SPACE = 0x20,\n  NONBREAKINGSPACE = 0xA0,\n  ENQUAD = 0x2000,\n  EMQUAD = 0x2001,\n  ENSPACE = 0x2002,\n  EMSPACE = 0x2003,\n  THREEPEREMSPACE = 0x2004,\n  FOURPEREMSPACE = 0x2005,\n  SIXPEREMSPACE = 0x2006,\n  FIGURESPACE = 0x2007,\n  PUNCTUATIONSPACE = 0x2008,\n  THINSPACE = 0x2009,\n  HAIRSPACE = 0x200A,\n  ZEROWIDTHSPACE = 0x200B,\n  NARROWNOBREAKSPACE = 0x202F,\n  IDEOGRAPHICSPACE = 0x3000,\n  MATHEMATICALSPACE = 0x205F,\n  OGHAM = 0x1680,\n\n  _ = 0x5F,\n\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n\n  a = 0x61,\n  b = 0x62,\n  c = 0x63,\n  d = 0x64,\n  e = 0x65,\n  f = 0x66,\n  g = 0x67,\n  h = 0x68,\n  i = 0x69,\n  j = 0x6A,\n  k = 0x6B,\n  l = 0x6C,\n  m = 0x6D,\n  n = 0x6E,\n  o = 0x6F,\n  p = 0x70,\n  q = 0x71,\n  r = 0x72,\n  s = 0x73,\n  t = 0x74,\n  u = 0x75,\n  v = 0x76,\n  w = 0x77,\n  x = 0x78,\n  y = 0x79,\n  z = 0x7A,\n\n  A = 0x41,\n  B = 0x42,\n  C = 0x43,\n  D = 0x44,\n  E = 0x45,\n  F = 0x46,\n  G = 0x47,\n  H = 0x48,\n  I = 0x49,\n  J = 0x4A,\n  K = 0x4B,\n  L = 0x4C,\n  M = 0x4D,\n  N = 0x4E,\n  O = 0x4F,\n  P = 0x50,\n  Q = 0x51,\n  R = 0x52,\n  S = 0x53,\n  T = 0x54,\n  U = 0x55,\n  V = 0x56,\n  W = 0x57,\n  X = 0x58,\n  Y = 0x59,\n  Z = 0x5a,\n\n  AMPERSAND = 0x26,\n  ASTERISK = 0x2A,\n  AT = 0x40,\n  BACKSLASH = 0x5C,\n  BACKTICK = 0x60,\n  BAR = 0x7C,\n  CARET = 0x5E,\n  CLOSEBRACE = 0x7D,\n  CLOSEBRACKET = 0x5D,\n  CLOSEPAREN = 0x29,\n  COLON = 0x3A,\n  COMMA = 0x2C,\n  DOLLAR = 0x24,\n  DOT = 0x2E,\n  DOUBLEQUOTE = 0x22,\n  EQUALS = 0x3D,\n  EXCLAMATION = 0x21,\n  GREATERTHAN = 0x3E,\n  HASH = 0x23,\n  LESSTHAN = 0x3C,\n  MINUS = 0x2D,\n  OPENBRACE = 0x7B,\n  OPENBRACKET = 0x5B,\n  OPENPAREN = 0x28,\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  QUESTION = 0x3F,\n  SEMICOLON = 0x3B,\n  SINGLEQUOTE = 0x27,\n  SLASH = 0x2F,\n  TILDE = 0x7E,\n\n  BACKSPACE = 0x08,\n  FORMFEED = 0x0C,\n  BYTEORDERMARK = 0xFEFF,\n  TAB = 0x09,\n  VERTICALTAB = 0x0B\n}\n\n/** Tests if the specified character code is some sort of line break. */\nexport function isLineBreak(c: CharCode): bool {\n  switch (c) {\n    case CharCode.LINEFEED:\n    case CharCode.CARRIAGERETURN:\n    case CharCode.LINESEPARATOR:\n    case CharCode.PARAGRAPHSEPARATOR: {\n      return true;\n    }\n    default: {\n      return false;\n    }\n  }\n}\n\n/** Tests if the specified character code is some sort of white space. */\nexport function isWhiteSpace(c: i32): bool {\n  switch (c) {\n    case CharCode.SPACE:\n    case CharCode.TAB:\n    case CharCode.VERTICALTAB:\n    case CharCode.FORMFEED:\n    case CharCode.NONBREAKINGSPACE:\n    case CharCode.NEXTLINE:\n    case CharCode.OGHAM:\n    case CharCode.NARROWNOBREAKSPACE:\n    case CharCode.MATHEMATICALSPACE:\n    case CharCode.IDEOGRAPHICSPACE:\n    case CharCode.BYTEORDERMARK: {\n      return true;\n    }\n    default: {\n      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;\n    }\n  }\n}\n\n/** Tests if the specified character code is a valid decimal digit. */\nexport function isDecimalDigit(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid octal digit. */\nexport function isOctalDigit(c: i32): bool {\n  return c >= CharCode._0 && c <= CharCode._7;\n}\n\n/** Tests if the specified character code is trivially alphanumeric. */\nexport function isTrivialAlphanum(code: i32): bool {\n  return code >= CharCode.a && code <= CharCode.z\n      || code >= CharCode.A && code <= CharCode.Z\n      || code >= CharCode._0 && code <= CharCode._9;\n}\n\n/** Tests if the specified character code is a valid start of an identifier. */\nexport function isIdentifierStart(c: i32): bool {\n  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c > 0x7F && isUnicodeIdentifierStart(c);\n}\n\n/** Tests if the specified character code is a valid keyword character. */\nexport function isKeywordCharacter(c: i32): bool {\n  return c >= CharCode.a && c <= CharCode.z;\n}\n\n/** Tests if the specified character code is a valid part of an identifier. */\nexport function isIdentifierPart(c: i32): bool {\n  const c0 = c | 32; // unify uppercases and lowercases a|A - z|Z\n  return c0 >= CharCode.a && c0 <= CharCode.z\n      || c >= CharCode._0 && c <= CharCode._9\n      || c == CharCode._\n      || c == CharCode.DOLLAR\n      || c > 0x7F && isUnicodeIdentifierPart(c);\n}\n\n// storing as u16 to save memory\nconst unicodeIdentifierStart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\n  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\n  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\n  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\n  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\n  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\n  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\n  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\n  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\n  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\n  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\n  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\n  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\n  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\n  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\n  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\n  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\n  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\n  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\n  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\n  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\n  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\n  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\n  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\n  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\n  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\n  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\n  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\n  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\n  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\n  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\n  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\n  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\n  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\n  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\n  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\n  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\n  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\n  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\n  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\n  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\n  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\n  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\n  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\n  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\n  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\n  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\n  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\n  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\n  65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\nconst unicodeIdentifierPart: u16[] = [\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\n  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\n  908, 908, 910, 929, 931,\n  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\n  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\n  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\n  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\n  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\n  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\n  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\n  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\n  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\n  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\n  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\n  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\n  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\n  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\n  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\n  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\n  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\n  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\n  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\n  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\n  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\n  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\n  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\n  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\n  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\n  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\n  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\n  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\n  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\n  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\n  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\n  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\n  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\n  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\n  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\n  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\n  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\n  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\n  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\n  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\n  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\n  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\n  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\n  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\n  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\n  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\n  8521, 8526, 8526, 8544, 8584,\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\n  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\n  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\n  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\n  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\n  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\n  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\n  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\n  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\n  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\n  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\n  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\n  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\n  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\n  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\n  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\n  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\n  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\n  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\n  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\n];\n\nfunction lookupInUnicodeMap(code: u16, map: u16[]): bool {\n  if (code < map[0]) return false;\n\n  var lo = 0;\n  var hi = map.length;\n  var mid: i32;\n  var midVal: u16;\n\n  while (lo + 1 < hi) {\n    mid = lo + ((hi - lo) >> 1);\n    mid -= (mid & 1);\n    midVal = map[mid];\n    if (midVal <= code && code <= map[mid + 1]) {\n      return true;\n    }\n    if (code < midVal) {\n      hi = mid;\n    } else {\n      lo = mid + 2;\n    }\n  }\n  return false;\n}\n\nfunction isUnicodeIdentifierStart(code: i32): bool {\n  return code < 170 || code > 65500 ? false :\n         lookupInUnicodeMap(code as u16, unicodeIdentifierStart);\n}\n\nfunction isUnicodeIdentifierPart(code: i32): bool {\n  return code < 170 || code > 65500 ? false :\n         lookupInUnicodeMap(code as u16, unicodeIdentifierPart);\n}\n\nconst indentX1 = \"  \";\nconst indentX2 = \"    \";\nconst indentX4 = \"        \";\n\n/** Creates an indentation matching the number of specified levels. */\nexport function indent(sb: string[], level: i32): void {\n  while (level >= 4) {\n    sb.push(indentX4);\n    level -= 4;\n  }\n  if (level >= 2) {\n    sb.push(indentX2);\n    level -= 2;\n  }\n  if (level) {\n    sb.push(indentX1);\n  }\n}\n","/**\n * @fileoverview Various vector utility.\n * @license Apache-2.0\n */\n\n/** v128 zero constant. */\nexport const v128_zero = new Uint8Array(16);\n","// This file is shared with the compiler and must remain portable\n\n/** Indicates specific features to activate. */\nexport const enum Feature {\n  /** No additional features. */\n  NONE = 0,\n  /** Sign extension operations. */\n  SIGN_EXTENSION = 1 << 0, // see: https://github.com/WebAssembly/sign-extension-ops\n  /** Mutable global imports and exports. */\n  MUTABLE_GLOBALS = 1 << 1, // see: https://github.com/WebAssembly/mutable-global\n  /** Non-trapping float to integer operations. */\n  NONTRAPPING_F2I = 1 << 2, // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\n  /** Bulk memory operations. */\n  BULK_MEMORY = 1 << 3, // see: https://github.com/WebAssembly/bulk-memory-operations\n  /** SIMD types and operations. */\n  SIMD = 1 << 4, // see: https://github.com/WebAssembly/simd\n  /** Threading and atomic operations. */\n  THREADS = 1 << 5, // see: https://github.com/WebAssembly/threads\n  /** Exception handling operations. */\n  EXCEPTION_HANDLING = 1 << 6, // see: https://github.com/WebAssembly/exception-handling\n  /** Tail call operations. */\n  TAIL_CALLS = 1 << 7, // see: https://github.com/WebAssembly/tail-call\n  /** Reference types. */\n  REFERENCE_TYPES = 1 << 8, // see: https://github.com/WebAssembly/reference-types\n  /** Multi value types. */\n  MULTI_VALUE = 1 << 9, // see: https://github.com/WebAssembly/multi-value\n  /** Garbage collection. */\n  GC = 1 << 10, // see: https://github.com/WebAssembly/gc\n  /** Memory64. */\n  MEMORY64 = 1 << 11 // see: https://github.com/WebAssembly/memory64\n}\n\n/** Gets the name of the specified feature one would specify on the command line. */\nexport function featureToString(feature: Feature): string {\n  switch (feature) {\n    case Feature.SIGN_EXTENSION: return \"sign-extension\";\n    case Feature.MUTABLE_GLOBALS: return \"mutable-globals\";\n    case Feature.NONTRAPPING_F2I: return \"nontrapping-f2i\";\n    case Feature.BULK_MEMORY: return \"bulk-memory\";\n    case Feature.SIMD: return \"simd\";\n    case Feature.THREADS: return \"threads\";\n    case Feature.EXCEPTION_HANDLING: return \"exception-handling\";\n    case Feature.TAIL_CALLS: return \"tail-calls\";\n    case Feature.REFERENCE_TYPES: return \"reference-types\";\n    case Feature.MULTI_VALUE: return \"multi-value\";\n    case Feature.GC: return \"gc\";\n    case Feature.MEMORY64: return \"memory64\";\n  }\n  assert(false);\n  return \"\";\n}\n","// This file is shared with the compiler and must remain portable\n\n/** Compilation target. */\nexport enum Target {\n  /** Portable. */\n  JS = 0,\n  /** WebAssembly with 32-bit pointers. */\n  WASM32 = 1,\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\n  WASM64 = 2,\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","/**\n * @fileoverview Binaryen glue code for JavaScript.\n * @license Apache-2.0\n */\n\nconst binaryen = global.binaryen || (global.binaryen = require(\"binaryen\"));\n\nmodule.exports = binaryen;\n\nconst { Module } = require(\"../module\");\n\nModule.prototype.toText = function toText(watFormat = true) {\n  if (watFormat) {\n    // NOTE: Conversion to StackIR can yield conversion artifacts like sequences\n    // of unreachable statements not actually emitted by the compiler. Optimizing\n    // StackIR removes these again, but may also suppress useless code emitted by\n    // the compiler that's then no longer visible in tests. Both not ideal.\n    return binaryen.wrapModule(this.ref).emitStackIR(/* optimize-stack-ir */ true);\n  } else {\n    return binaryen.wrapModule(this.ref).emitText();\n  }\n};\n\nModule.prototype.toAsmjs = function toAsmjs() {\n  return binaryen.wrapModule(this.ref).emitAsmjs();\n};\n","/**\n * @fileoverview Collections glue code for JavaScript.\n * @license Apache-2.0\n */\n\nglobal.Map_keys = function Map_keys(map) {\n  return Array.from(map.keys());\n};\n\nglobal.Map_values = function Map_values(map) {\n  return Array.from(map.values());\n};\n\nglobal.Set_values = function Set_values(set) {\n  return Array.from(set.values());\n};\n","/**\n * @fileoverview Floating point glue code for JaavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst F64 = new Float64Array(1);\nconst F32 = new Float32Array(F64.buffer);\nconst I32 = new Int32Array(F64.buffer);\n\nglobal.f32_as_i32 = function f32_as_i32(value) {\n  F32[0] = value;\n  return I32[0];\n};\n\nglobal.i32_as_f32 = function i32_as_f32(value) {\n  I32[0] = value;\n  return F32[0];\n};\n\nglobal.f64_as_i64 = function f64_as_i64(value) {\n  F64[0] = value;\n  return i64_new(I32[0], I32[1]);\n};\n\nglobal.i64_as_f64 = function i64_as_f64(value) {\n  I32[0] = i64_low(value);\n  I32[1] = i64_high(value);\n  return F64[0];\n};\n","/**\n * @fileoverview 64-bit integer glue code for JavaScript.\n * @license Apache-2.0\n */\n\n/* eslint-disable no-undef */\n\nconst Long = global.Long || require(\"long\");\n\nglobal.i64_zero    = Long.ZERO;\nglobal.i64_one     = Long.ONE;\nglobal.i64_neg_one = Long.fromInt(-1);\n\nglobal.i64_is = function i64_is(value) {\n  return Long.isLong(value);\n};\n\nglobal.i64_new = function i64_new(lo, hi) {\n  return Long.fromBits(lo, hi);\n};\n\nglobal.i64_low = function i64_low(value) {\n  return value.low;\n};\n\nglobal.i64_high = function i64_high(value) {\n  return value.high;\n};\n\nglobal.i64_add = function i64_add(left, right) {\n  return left.add(right);\n};\n\nglobal.i64_sub = function i64_sub(left, right) {\n  return left.sub(right);\n};\n\nglobal.i64_mul = function i64_mul(left, right) {\n  return left.mul(right);\n};\n\nglobal.i64_pow = function i64_pow(left, right) {\n  var rightLo = right.low;\n  var rightHi = right.high;\n  if (rightHi <= 0) {\n    if (rightHi < 0) {\n      if (left.eq(global.i64_neg_one)) {\n        return rightLo & 1 ? left : Long.ONE;\n      }\n      return left.eq(Long.ONE) ? left : Long.ZERO;\n    }\n    if (rightLo == 0) return Long.ONE;\n    if (rightLo == 1) return left;\n    if (rightLo == 2) return left.mul(left);\n  }\n  var result = Long.ONE;\n  while (rightLo | rightHi) {\n    if (rightLo & 1) result = result.mul(left);\n    right = right.shru(1);\n    left  = left.mul(left);\n    rightLo = right.low;\n    rightHi = right.high;\n  }\n  return result;\n};\n\nglobal.i64_div = function i64_div(left, right) {\n  return left.div(right);\n};\n\nglobal.i64_div_u = function i64_div_u(left, right) {\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_rem = function i64_rem(left, right) {\n  return left.mod(right);\n};\n\nglobal.i64_rem_u = function i64_rem_u(left, right) {\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\n};\n\nglobal.i64_and = function i64_and(left, right) {\n  return left.and(right);\n};\n\nglobal.i64_or = function i64_or(left, right) {\n  return left.or(right);\n};\n\nglobal.i64_xor = function i64_xor(left, right) {\n  return left.xor(right);\n};\n\nglobal.i64_shl = function i64_shl(left, right) {\n  return left.shl(right);\n};\n\nglobal.i64_shr = function i64_shr(left, right) {\n  return left.shr(right);\n};\n\nglobal.i64_shr_u = function i64_shr_u(left, right) {\n  return left.shru(right);\n};\n\nglobal.i64_not = function i64_not(value) {\n  return value.not();\n};\n\nglobal.i64_eq = function i64_eq(left, right) {\n  return left.eq(right);\n};\n\nglobal.i64_ne = function i64_ne(left, right) {\n  return left.ne(right);\n};\n\nglobal.i64_gt = function i64_gt(left, right) {\n  return left.gt(right);\n};\n\nglobal.i64_align = function i64_align(value, alignment) {\n  assert(alignment && (alignment & (alignment - 1)) == 0);\n  var mask = Long.fromInt(alignment - 1);\n  return value.add(mask).and(mask.not());\n};\n\nglobal.i64_is_i8 = function i64_is_i8(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i16 = function i64_is_i16(value) {\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\n};\n\nglobal.i64_is_i32 = function i64_is_i32(value) {\n  return (value.high === 0 && value.low >= 0)\n      || (value.high === -1 && value.low < 0);\n};\n\nglobal.i64_is_u8 = function i64_is_u8(value) {\n  return value.high === 0 && (value.low >>> 0) <= u8.MAX_VALUE;\n};\n\nglobal.i64_is_u16 = function i64_is_u16(value) {\n  return value.high === 0 && (value.low >>> 0) <= u16.MAX_VALUE;\n};\n\nglobal.i64_is_u32 = function i64_is_u32(value) {\n  return value.high === 0;\n};\n\nglobal.i64_is_bool = function i64_is_bool(value) {\n  return (value.high | (value.low & ~1)) === 0;\n};\n\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f32 = function i64_is_f32(value) {\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\n};\n\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\n\nglobal.i64_is_f64 = function i64_is_f64(value) {\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\n};\n\nglobal.i64_to_f32 = function i64_to_f32(value) {\n  return global.Math.fround(value.toNumber());\n};\n\nglobal.i64_to_f64 = function i64_to_f64(value) {\n  return value.toNumber();\n};\n\nglobal.i64_to_string = function i64_to_string(value, unsigned) {\n  return unsigned ? value.toUnsigned().toString() : value.toString();\n};\n","/** @module std/portable *//***/\n\nvar globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\n\nglobalScope.ASC_TARGET = 0; // Target.JS\nglobalScope.ASC_NO_ASSERT = false;\nglobalScope.ASC_MEMORY_BASE = 0;\nglobalScope.ASC_OPTIMIZE_LEVEL = 3;\nglobalScope.ASC_SHRINK_LEVEL = 0;\nglobalScope.ASC_FEATURE_MUTABLE_GLOBAL = false;\nglobalScope.ASC_FEATURE_SIGN_EXTENSION = false;\nglobalScope.ASC_FEATURE_BULK_MEMORY = false;\nglobalScope.ASC_FEATURE_SIMD = false;\nglobalScope.ASC_FEATURE_THREADS = false;\n\nvar F64 = new Float64Array(1);\nvar U64 = new Uint32Array(F64.buffer);\n\nObject.defineProperties(\n  globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; },\n  {\n    \"MIN_VALUE\": { value: -128, writable: false },\n    \"MAX_VALUE\": { value:  127, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; },\n  {\n    \"MIN_VALUE\": { value: -32768, writable: false },\n    \"MAX_VALUE\": { value:  32767, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; },\n  {\n    \"MIN_VALUE\": { value: -2147483648, writable: false },\n    \"MAX_VALUE\": { value:  2147483647, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"u8\"] = function u8(value) { return value & 0xff; },\n  {\n    \"MIN_VALUE\": { value:   0, writable: false },\n    \"MAX_VALUE\": { value: 255, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"u16\"] = function u16(value) { return value & 0xffff; },\n  {\n    \"MIN_VALUE\": { value:     0, writable: false },\n    \"MAX_VALUE\": { value: 65535, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; },\n  {\n    \"MIN_VALUE\": { value:          0, writable: false },\n    \"MAX_VALUE\": { value: 4294967295, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"bool\"] = function bool(value) { return !!value; },\n  {\n    \"MIN_VALUE\": { value: false, writable: false },\n    \"MAX_VALUE\": { value: true,  writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"f32\"] = function f32(value) { return Math.fround(value); },\n  {\n    \"EPSILON\":   { value: 1.1920928955078125e-07, writable: false },\n    \"MIN_VALUE\": { value: 1.4012984643248170e-45, writable: false },\n    \"MAX_VALUE\": { value: 3.4028234663852886e+38, writable: false },\n    \"MIN_NORMAL_VALUE\":  { value:  1.1754943508222875e-38, writable: false },\n    \"MIN_SAFE_INTEGER\":  { value: -16777215, writable: false },\n    \"MAX_SAFE_INTEGER\":  { value:  16777215, writable: false },\n    \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\n    \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\n    \"NaN\": { value: NaN, writable: false }\n  }\n);\n\nObject.defineProperties(\n  globalScope[\"f64\"] = function f64(value) { return +value; },\n  {\n    \"EPSILON\":   { value: 2.2204460492503131e-016, writable: false },\n    \"MIN_VALUE\": { value:                  5e-324, writable: false },\n    \"MAX_VALUE\": { value: 1.7976931348623157e+308, writable: false },\n    \"MIN_NORMAL_VALUE\":  { value:  2.2250738585072014e-308, writable: false },\n    \"MIN_SAFE_INTEGER\":  { value: -9007199254740991, writable: false },\n    \"MAX_SAFE_INTEGER\":  { value:  9007199254740991, writable: false },\n    \"POSITIVE_INFINITY\": { value:  Infinity, writable: false },\n    \"NEGATIVE_INFINITY\": { value: -Infinity, writable: false },\n    \"NaN\": { value: NaN, writable: false }\n  }\n);\n\nglobalScope[\"clz\"] = Math.clz32;\n\nglobalScope[\"ctz\"] = function ctz(value) {\n  var c = Math.clz32(value & -value);\n  return value ? 31 - c : c;\n};\n\nglobalScope[\"popcnt\"] = function popcnt(value) {\n  value -= value >>> 1 & 0x55555555;\n  value = (value & 0x33333333) + (value >>> 2 & 0x33333333);\n  return (((value + (value >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;\n};\n\nglobalScope[\"rotl\"] = function rotl(value, shift) {\n  shift &= 31;\n  return (value << shift) | (value >>> (32 - shift));\n};\n\nglobalScope[\"rotr\"] = function rotr(value, shift) {\n  shift &= 31;\n  return (value >>> shift) | (value << (32 - shift));\n};\n\nglobalScope[\"abs\"] = Math.abs;\n\nglobalScope[\"max\"] = Math.max;\n\nglobalScope[\"min\"] = Math.min;\n\nglobalScope[\"ceil\"] = Math.ceil;\n\nglobalScope[\"floor\"] = Math.floor;\n\n// Adopt code from https://github.com/rfk/wasm-polyfill\nglobalScope[\"nearest\"] = function nearest(value) {\n  if (Math.abs(value - Math.trunc(value)) === 0.5) {\n    return 2.0 * Math.round(value * 0.5);\n  }\n  return Math.round(value);\n};\n\nglobalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\n  return condition ? ifTrue : ifFalse;\n};\n\nglobalScope[\"sqrt\"] = Math.sqrt;\n\nglobalScope[\"trunc\"] = Math.trunc;\n\nglobalScope[\"copysign\"] = function copysign(x, y) {\n  return Math.abs(x) * Math.sign(y);\n};\n\nglobalScope[\"bswap\"] = function bswap(value) {\n  var a = value >> 8 & 0x00FF00FF;\n  var b = (value & 0x00FF00FF) << 8;\n  value = a | b;\n  a = value >> 16 & 0x0000FFFF;\n  b = (value & 0x0000FFFF) << 16;\n  return a | b;\n};\n\nglobalScope[\"bswap16\"] = function bswap16(value) {\n  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\n};\n\nfunction UnreachableError() {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, UnreachableError);\n  } else {\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n  }\n}\nUnreachableError.prototype = Object.create(Error.prototype);\nUnreachableError.prototype.name = \"UnreachableError\";\nUnreachableError.prototype.message = \"unreachable\";\n\nglobalScope[\"unreachable\"] = function unreachable() {\n  throw new UnreachableError();\n};\n\nfunction AssertionError(message) {\n  this.message = message || \"assertion failed\";\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, AssertionError);\n  } else {\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\n  }\n}\nAssertionError.prototype = Object.create(Error.prototype);\nAssertionError.prototype.name = \"AssertionError\";\n\nglobalScope[\"assert\"] = function assert(isTrueish, message) {\n  if (isTrueish) return isTrueish;\n  throw new AssertionError(message);\n};\n\nglobalScope[\"changetype\"] = function changetype(value) {\n  return value;\n};\n\nString[\"fromCharCodes\"] = function fromCharCodes(arr) {\n  const CHUNKSIZE = 1 << 13;\n  const len = arr.length;\n  if (len <= CHUNKSIZE) {\n    return String.fromCharCode.apply(String, arr);\n  }\n  let index = 0;\n  let parts = '';\n  while (index < len) {\n    parts += String.fromCharCode.apply(\n      String,\n      arr.slice(index, Math.min(index + CHUNKSIZE, len))\n    );\n    index += CHUNKSIZE;\n  }\n  return parts;\n};\n\nString[\"fromCodePoints\"] = function fromCodePoints(arr) {\n  const CHUNKSIZE = 1 << 13;\n  const len = arr.length;\n  if (len <= CHUNKSIZE) {\n    return String.fromCodePoint.apply(String, arr);\n  }\n  let index = 0;\n  let parts = '';\n  while (index < len) {\n    parts += String.fromCodePoint.apply(\n      String,\n      arr.slice(index, Math.min(index + CHUNKSIZE, len))\n    );\n    index += CHUNKSIZE;\n  }\n  return parts;\n};\n\nif (!String.prototype.replaceAll) {\n  Object.defineProperty(String.prototype, \"replaceAll\", {\n    value: function replaceAll(search, replacment) {\n      var res = this.split(search).join(replacment);\n      if (!search.length) res = replacment + res + replacment;\n      return res;\n    }\n  });\n}\n\nfunction defaultComparator(a, b) {\n  if (a === b) {\n    if (a !== 0) return 0;\n    a = 1 / a, b = 1 / b;\n  } else {\n    var nanA = a != a, nanB = b != b;\n    if (nanA | nanB) return nanA - nanB;\n    if (a == null) a = String(a);\n    if (b == null) b = String(b);\n  }\n  return a > b ? 1 : -1;\n}\n\nconst arraySort = Array.prototype.sort;\nArray.prototype.sort = function sort(comparator) {\n  return arraySort.call(this, comparator || defaultComparator);\n};\n\nglobalScope[\"isInteger\"] = Number.isInteger;\n\nglobalScope[\"isFloat\"] = function isFloat(arg) {\n  return typeof arg === \"number\";\n};\n\nglobalScope[\"isNullable\"] = function isNullable(arg) {\n  return true;\n};\n\nglobalScope[\"isReference\"] = function isReference(arg) {\n  return typeof arg === \"object\" || typeof arg === \"string\";\n};\n\nglobalScope[\"isFunction\"] = function isFunction(arg) {\n  return typeof arg === \"function\";\n};\n\nglobalScope[\"isString\"] = function isString(arg) {\n  return typeof arg === \"string\" || arg instanceof String;\n};\n\nglobalScope[\"isArray\"] = Array.isArray;\nglobalScope[\"isArrayLike\"] = function isArrayLike(expr) {\n  return expr\n    && typeof expr === 'object'\n    && typeof expr.length === 'number'\n    && expr.length >= 0\n    && Math.trunc(expr.length) === expr.length;\n};\n\nglobalScope[\"isDefined\"] = function isDefined(expr) {\n  return typeof expr !== \"undefined\";\n};\n\nglobalScope[\"isConstant\"] = function isConstant(expr) {\n  return false;\n};\n\nglobalScope[\"unchecked\"] = function unchecked(expr) {\n  return expr;\n};\n\nglobalScope[\"fmod\"] = function fmod(x, y) {\n  return x % y;\n};\n\nglobalScope[\"fmodf\"] = function fmodf(x, y) {\n  return Math.fround(x % y);\n};\n\nglobalScope[\"JSMath\"] = Math;\n\nObject.defineProperties(globalScope[\"JSMath\"], {\n  sincos_sin: { value: 0.0, writable: true },\n  sincos_cos: { value: 0.0, writable: true },\n  signbit: {\n    value: function signbit(x) {\n      F64[0] = x; return Boolean(U64[1] >>> 31);\n    }\n  },\n  sincos: {\n    value: function sincos(x) {\n      this.sincos_sin = Math.sin(x);\n      this.sincos_cos = Math.cos(x);\n    }\n  },\n  exp2: {\n    value: function exp2(x) {\n      return Math.pow(2, x);\n    }\n  }\n});\n\nglobalScope[\"unmanaged\"] = function() { /* nop */ };\n\nglobalScope[\"trace\"] = function(message, n) {\n  if (n) message += Array.prototype.slice.call(arguments, 2, 2 + n);\n  console.error(\"trace: \" + message);\n};\n\nObject.defineProperty(Int8Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Int8Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint8Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint8Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint8ClampedArray, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint8ClampedArray(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Int16Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Int16Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint16Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint16Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Int32Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Int32Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Uint32Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Uint32Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Float32Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Float32Array(buffer, byteOffset, length);\n  }\n});\n\nObject.defineProperty(Float64Array, \"wrap\", {\n  value: function wrap(buffer, byteOffset, length) {\n    return new Float64Array(buffer, byteOffset, length);\n  }\n});\n","module.exports = __WEBPACK_EXTERNAL_MODULE__911__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\n__webpack_require__(308);\nreturn __webpack_require__(780);\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();"],"sourceRoot":""}